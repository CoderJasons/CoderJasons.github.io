<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="前文我们探索了iOS类的底层原理，简单了解了四个重要的属性。这篇文章主要探索第三个属性cache_t，对于这个属性，我们可以学习到苹果对于缓存的设计和理解。 探索cache_t从数据结构开始 cache_t的基本结构我们看一下源码： 12345678910111213141516171819struct cache_t &amp;#123;&#x2F;&#x2F;省略代码public:    &#x2F;&#x2F; The following">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS底层：cache_t">
<meta property="og:url" content="http://yujiusheng.com/2021/05/12/iOS%E5%BA%95%E5%B1%82%EF%BC%9Acache_t/index.html">
<meta property="og:site_name" content="Jason的博客">
<meta property="og:description" content="前文我们探索了iOS类的底层原理，简单了解了四个重要的属性。这篇文章主要探索第三个属性cache_t，对于这个属性，我们可以学习到苹果对于缓存的设计和理解。 探索cache_t从数据结构开始 cache_t的基本结构我们看一下源码： 12345678910111213141516171819struct cache_t &amp;#123;&#x2F;&#x2F;省略代码public:    &#x2F;&#x2F; The following">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-05-12T05:55:04.168Z">
<meta property="article:modified_time" content="2021-05-12T09:02:46.842Z">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yujiusheng.com/2021/05/12/iOS底层：cache_t/"/>





  <title>iOS底层：cache_t | Jason的博客</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jason的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/12/iOS%E5%BA%95%E5%B1%82%EF%BC%9Acache_t/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">iOS底层：cache_t</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-12T13:55:04+08:00">
                2021-05-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>前文我们探索了iOS类的底层原理，简单了解了四个重要的属性。这篇文章主要探索第三个属性<code>cache_t</code>，对于这个属性，我们可以学习到苹果对于缓存的设计和理解。</p>
<h3 id="探索cache-t"><a href="#探索cache-t" class="headerlink" title="探索cache_t"></a>探索<code>cache_t</code></h3><p>从数据结构开始</p>
<h4 id="cache-t的基本结构"><a href="#cache-t的基本结构" class="headerlink" title="cache_t的基本结构"></a><code>cache_t</code>的基本结构</h4><p>我们看一下源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line"><span class="comment">//省略代码</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// The following four fields are public for objcdt's use only.</span></span><br><span class="line">    <span class="comment">// objcdt reaches into fields while the process is suspended</span></span><br><span class="line">    <span class="comment">// hence doesn't care for locks and pesky little details like this</span></span><br><span class="line">    <span class="comment">// and can safely use these.</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">struct <span class="keyword">bucket_t</span> *<span class="title">buckets</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//重点</span></span><br><span class="line">    <span class="function">Class <span class="title">cls</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_USE_PREOPT_CACHES</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">preopt_cache_t</span> *<span class="title">preopt_cache</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">mask_t</span> <span class="title">occupied</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initializeToEmpty</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="comment">//省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现有一个<code>buckets()</code>成员，它是一个结构体<code>bucket_t</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// IMP-first is better for arm64e ptrauth and no worse for arm64.</span></span><br><span class="line">    <span class="comment">// SEL-first is better for armv7* and i386 and x86_64.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __arm64__</span></span><br><span class="line">    explicit_atomic&lt;<span class="keyword">uintptr_t</span>&gt; _imp;</span><br><span class="line">    explicit_atomic&lt;SEL&gt; _sel;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    explicit_atomic&lt;SEL&gt; _sel;</span><br><span class="line">    explicit_atomic&lt;<span class="keyword">uintptr_t</span>&gt; _imp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// Compute the ptrauth signing modifier from &amp;_imp, newSel, and cls.</span></span><br><span class="line">    <span class="function"><span class="keyword">uintptr_t</span> <span class="title">modifierForSEL</span><span class="params">(<span class="keyword">bucket_t</span> *base, SEL newSel, Class cls)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">uintptr_t</span>)base ^ (<span class="keyword">uintptr_t</span>)newSel ^ (<span class="keyword">uintptr_t</span>)cls;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Sign newImp, with &amp;_imp, newSel, and cls as modifiers.</span></span><br><span class="line">    <span class="function"><span class="keyword">uintptr_t</span> <span class="title">encodeImp</span><span class="params">(UNUSED_WITHOUT_PTRAUTH <span class="keyword">bucket_t</span> *base, IMP newImp, UNUSED_WITHOUT_PTRAUTH SEL newSel, Class cls)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!newImp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CACHE_IMP_ENCODING == CACHE_IMP_ENCODING_PTRAUTH</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">uintptr_t</span>)</span><br><span class="line">            ptrauth_auth_and_resign(newImp,</span><br><span class="line">                                    ptrauth_key_function_pointer, <span class="number">0</span>,</span><br><span class="line">                                    ptrauth_key_process_dependent_code,</span><br><span class="line">                                    modifierForSEL(base, newSel, cls));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> CACHE_IMP_ENCODING == CACHE_IMP_ENCODING_ISA_XOR</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">uintptr_t</span>)newImp ^ (<span class="keyword">uintptr_t</span>)cls;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> CACHE_IMP_ENCODING == CACHE_IMP_ENCODING_NONE</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">uintptr_t</span>)newImp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> Unknown method cache IMP encoding.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">offsetOfSel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> offsetof(<span class="keyword">bucket_t</span>, _sel); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> SEL <span class="title">sel</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _sel.load(memory_order_relaxed); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CACHE_IMP_ENCODING == CACHE_IMP_ENCODING_ISA_XOR</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAYBE_UNUSED_ISA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAYBE_UNUSED_ISA __attribute__((unused))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> IMP <span class="title">rawImp</span><span class="params">(MAYBE_UNUSED_ISA objc_class *cls)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">uintptr_t</span> imp = _imp.load(memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (!imp) <span class="keyword">return</span> nil;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CACHE_IMP_ENCODING == CACHE_IMP_ENCODING_PTRAUTH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> CACHE_IMP_ENCODING == CACHE_IMP_ENCODING_ISA_XOR</span></span><br><span class="line">        imp ^= (<span class="keyword">uintptr_t</span>)cls;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> CACHE_IMP_ENCODING == CACHE_IMP_ENCODING_NONE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> Unknown method cache IMP encoding.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span> (IMP)imp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> IMP <span class="title">imp</span><span class="params">(UNUSED_WITHOUT_PTRAUTH <span class="keyword">bucket_t</span> *base, Class cls)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">uintptr_t</span> imp = _imp.load(memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (!imp) <span class="keyword">return</span> nil;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CACHE_IMP_ENCODING == CACHE_IMP_ENCODING_PTRAUTH</span></span><br><span class="line">        SEL sel = _sel.load(memory_order_relaxed);</span><br><span class="line">        <span class="keyword">return</span> (IMP)</span><br><span class="line">            ptrauth_auth_and_resign((<span class="keyword">const</span> <span class="keyword">void</span> *)imp,</span><br><span class="line">                                    ptrauth_key_process_dependent_code,</span><br><span class="line">                                    modifierForSEL(base, sel, cls),</span><br><span class="line">                                    ptrauth_key_function_pointer, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> CACHE_IMP_ENCODING == CACHE_IMP_ENCODING_ISA_XOR</span></span><br><span class="line">        <span class="keyword">return</span> (IMP)(imp ^ (<span class="keyword">uintptr_t</span>)cls);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> CACHE_IMP_ENCODING == CACHE_IMP_ENCODING_NONE</span></span><br><span class="line">        <span class="keyword">return</span> (IMP)imp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> Unknown method cache IMP encoding.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;Atomicity, IMPEncoding&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">bucket_t</span> *base, SEL newSel, IMP newImp, Class cls)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从源码定义中不难看出，<code>bucket_t</code> 其实缓存的是方法实现 <code>IMP</code>。这里有一个注意点，就是 <code>IMP-first</code> 和 <code>SEL-first</code>。</p>
<blockquote>
<p>IMP-first is better for arm64e ptrauth and no worse for arm64.</p>
</blockquote>
<ul>
<li>IMP-first 对 arm64e 的效果更好，对 arm64 不会有坏的影响。</li>
</ul>
<blockquote>
<p>SEL-first is better for armv7* and i386 and x86_64.</p>
</blockquote>
<ul>
<li>SEL-first 适用于 armv7 * 和 i386 和 x86_64。</li>
</ul>
<p>通过上面的源码，我们大致了解了 bucket_t 类型的结构，那么现在问题来了，类中的 cache 是在什么时候以什么样的方式来进行缓存的呢？我们使用LLDB查看一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">lldb) x pClass</span><br><span class="line"><span class="number">0x100008220</span>: f8 <span class="number">81</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">40</span> <span class="number">71</span> <span class="number">35</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ........@q5.....</span><br><span class="line"><span class="number">0x100008230</span>: <span class="number">10</span> d4 <span class="number">22</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">24</span> <span class="number">80</span> <span class="number">01</span> <span class="number">00</span>  ..<span class="string">".........$...</span></span><br><span class="line"><span class="string">(lldb) p (cache_t *)0x100008230 //0x100008220 + 16字节（isa 8字节 + superclass 8字节）</span></span><br><span class="line"><span class="string">(cache_t *) $2 = 0x0000000100008230</span></span><br><span class="line"><span class="string">(lldb) p *$2</span></span><br><span class="line"><span class="string">(cache_t) $3 = &#123;</span></span><br><span class="line"><span class="string">  _bucketsAndMaybeMask = &#123;</span></span><br><span class="line"><span class="string">    std::__1::atomic&lt;unsigned long&gt; = &#123;</span></span><br><span class="line"><span class="string">      Value = 4314027024</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">   = &#123;</span></span><br><span class="line"><span class="string">     = &#123;</span></span><br><span class="line"><span class="string">      _maybeMask = &#123;</span></span><br><span class="line"><span class="string">        std::__1::atomic&lt;unsigned int&gt; = &#123;</span></span><br><span class="line"><span class="string">          Value = 3</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      _flags = 32804</span></span><br><span class="line"><span class="string">      _occupied = 1</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    _originalPreoptCache = &#123;</span></span><br><span class="line"><span class="string">      std::__1::atomic&lt;preopt_cache_t *&gt; = &#123;</span></span><br><span class="line"><span class="string">        Value = 0x0001802400000003</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">(lldb) p $3.buckets()</span></span><br><span class="line"><span class="string">(bucket_t *) $4 = 0x000000010122d410</span></span><br><span class="line"><span class="string">(lldb) p *$4</span></span><br><span class="line"><span class="string">(bucket_t) $5 = &#123;</span></span><br><span class="line"><span class="string">  _sel = &#123;</span></span><br><span class="line"><span class="string">    std::__1::atomic&lt;objc_selector *&gt; = "</span><span class="string">" &#123;</span></span><br><span class="line"><span class="string">      Value = "</span><span class="string">"</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  _imp = &#123;</span></span><br><span class="line"><span class="string">    std::__1::atomic&lt;unsigned long&gt; = &#123;</span></span><br><span class="line"><span class="string">      Value = 3365936</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>_occupied</code> 应该是表示当前已经占用了多少缓存（每调用一个实例方法会+1）。下面验证一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        Person *p &#x3D; [[Person alloc] init];</span><br><span class="line">      	Class pClass &#x3D; object_getClass(p);</span><br><span class="line">        [p sayHello];</span><br><span class="line">        [p sayOk];&#x2F;&#x2F;断点打在这</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x pClass</span><br><span class="line"><span class="number">0x100008240</span>: <span class="number">18</span> <span class="number">82</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">40</span> <span class="number">71</span> <span class="number">35</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ........@q5.....</span><br><span class="line"><span class="number">0x100008250</span>: <span class="number">00</span> dc <span class="number">74</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">24</span> <span class="number">80</span> <span class="number">02</span> <span class="number">00</span>  ..t.........$...</span><br><span class="line">(lldb) p (<span class="keyword">cache_t</span> *)<span class="number">0x100008250</span></span><br><span class="line">(<span class="keyword">cache_t</span> *) $<span class="number">1</span> = <span class="number">0x0000000100008250</span></span><br><span class="line">(lldb) p *$<span class="number">1</span></span><br><span class="line">(<span class="keyword">cache_t</span>) $<span class="number">2</span> = &#123;</span><br><span class="line">  _bucketsAndMaybeMask = &#123;</span><br><span class="line">    <span class="built_in">std</span>::__1::atomic&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span>&gt; = &#123;</span><br><span class="line">      Value = <span class="number">4302625792</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   = &#123;</span><br><span class="line">     = &#123;</span><br><span class="line">      _maybeMask = &#123;</span><br><span class="line">        <span class="built_in">std</span>::__1::atomic&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; = &#123;</span><br><span class="line">          Value = <span class="number">3</span><span class="comment">//注意</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      _flags = <span class="number">32804</span></span><br><span class="line">      _occupied = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    _originalPreoptCache = &#123;</span><br><span class="line">      <span class="built_in">std</span>::__1::atomic&lt;<span class="keyword">preopt_cache_t</span> *&gt; = &#123;</span><br><span class="line">        Value = <span class="number">0x0002802400000003</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>_occupied = 2</code>验证了我们的猜想，我们继续走断点发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        Person *p &#x3D; [[Person alloc] init];</span><br><span class="line">      	Class pClass &#x3D; object_getClass(p);</span><br><span class="line">        [p sayHello];</span><br><span class="line">        [p sayOk];</span><br><span class="line">        &#x2F;&#x2F;断点在最后一步</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(lldb) p *$1</span><br><span class="line">(cache_t) $3 &#x3D; &#123;</span><br><span class="line">  _bucketsAndMaybeMask &#x3D; &#123;</span><br><span class="line">    std::__1::atomic&lt;unsigned long&gt; &#x3D; &#123;</span><br><span class="line">      Value &#x3D; 4305857472</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   &#x3D; &#123;</span><br><span class="line">     &#x3D; &#123;</span><br><span class="line">      _maybeMask &#x3D; &#123;</span><br><span class="line">        std::__1::atomic&lt;unsigned int&gt; &#x3D; &#123;</span><br><span class="line">          Value &#x3D; 7&#x2F;&#x2F;注意</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      _flags &#x3D; 32804</span><br><span class="line">      _occupied &#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">    _originalPreoptCache &#x3D; &#123;</span><br><span class="line">      std::__1::atomic&lt;preopt_cache_t *&gt; &#x3D; &#123;</span><br><span class="line">        Value &#x3D; 0x0001802400000007</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现<code>_occupied=1</code>,<code>_maybeMask</code>的<code>Value=7</code>(上一步=3)，这是为什么</p>
<p>如果读者了解并掌握散列表这种数据结构的话，相信已经看出端倪了。是的，这里其实就是用到了 <strong>开放寻址法</strong> 来解决散列冲突（哈希冲突）。</p>
<blockquote>
<p>关于哈希冲突，可以借助鸽笼理论，即把 11 只鸽子放进 10 个抽屉里面，肯定会有一个抽屉里面有 2 只鸽子。是不是理解起来很简单? </p>
</blockquote>
<p>通过上面的测试，我们明确了方法缓存使用的是哈希表存储，并且为了解决无法避免的哈希冲突使用的是开放寻址法，而开放寻址法必然要在合适的时机进行扩容，这个时机肯定不是会在数据已经装满的时候，我们可以进源码探索一下，我们快速定位到 <code>cache_t</code> 的源码处:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_t::insert</span><span class="params">(SEL sel, IMP imp, id receiver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    <span class="comment">///省略代码</span></span><br><span class="line">    ASSERT(sel != <span class="number">0</span> &amp;&amp; cls()-&gt;isInitialized());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the cache as-is if until we exceed our expected fill ratio.</span></span><br><span class="line">    <span class="keyword">mask_t</span> newOccupied = occupied() + <span class="number">1</span>;</span><br><span class="line">  	<span class="comment">///取当前占用的空间大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> oldCapacity = capacity(), capacity = oldCapacity;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(isConstantEmptyCache())) &#123;</span><br><span class="line">        <span class="comment">// Cache is read-only. Replace it. </span></span><br><span class="line">        <span class="keyword">if</span> (!capacity) capacity = INIT_CACHE_SIZE;</span><br><span class="line">        reallocate(oldCapacity, capacity, <span class="comment">/* freeOld */</span><span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fastpath(newOccupied + CACHE_END_MARKER &lt;= cache_fill_ratio(capacity))) &#123;</span><br><span class="line">        <span class="comment">// Cache is less than 3/4 or 7/8 full. Use it as-is.</span></span><br><span class="line">    &#125;</span><br><span class="line">#<span class="keyword">if</span> CACHE_ALLOW_FULL_UTILIZATION</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (capacity &lt;= FULL_UTILIZATION_CACHE_SIZE &amp;&amp; newOccupied + CACHE_END_MARKER &lt;= capacity) &#123;</span><br><span class="line">        <span class="comment">// Allow 100% cache utilization for small buckets. Use it as-is.</span></span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        capacity = capacity ? capacity * <span class="number">2</span> : INIT_CACHE_SIZE;</span><br><span class="line">        <span class="keyword">if</span> (capacity &gt; MAX_CACHE_SIZE) &#123;</span><br><span class="line">            capacity = MAX_CACHE_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">///分配空间</span></span><br><span class="line">        reallocate(oldCapacity, capacity, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">///省略代码</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CACHE_END_MARKER || (__arm64__ &amp;&amp; !__LP64__)</span></span><br><span class="line">    <span class="comment">// When we have a cache end marker it fills a bucket slot, so having a</span></span><br><span class="line">    <span class="comment">// initial cache size of 2 buckets would not be efficient when one of the</span></span><br><span class="line">    <span class="comment">// slots is always filled with the end marker. So start with a cache size</span></span><br><span class="line">    <span class="comment">// 4 buckets.</span></span><br><span class="line">    INIT_CACHE_SIZE_LOG2 = <span class="number">2</span>,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">    <span class="comment">// Allow an initial bucket size of 2 buckets, since a large number of</span></span><br><span class="line">    <span class="comment">// classes, especially metaclasses, have very few imps, and we support</span></span><br><span class="line">    <span class="comment">// the ability to fill 100% of the cache before resizing.</span></span><br><span class="line">    INIT_CACHE_SIZE_LOG2 = <span class="number">1</span>,</span><br><span class="line">#endif</span><br><span class="line">    INIT_CACHE_SIZE      = (<span class="number">1</span> &lt;&lt; INIT_CACHE_SIZE_LOG2),</span><br></pre></td></tr></table></figure>

<p>看上面代码可以看出，换出的初始大小为4（metaclasses这种有很少imps为2），最后调用<code>reallocate</code>函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_t::reallocate</span><span class="params">(<span class="keyword">mask_t</span> oldCapacity, <span class="keyword">mask_t</span> newCapacity, <span class="keyword">bool</span> freeOld)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bucket_t</span> *oldBuckets = buckets();</span><br><span class="line">    <span class="keyword">bucket_t</span> *newBuckets = allocateBuckets(newCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache's old contents are not propagated. </span></span><br><span class="line">    <span class="comment">// This is thought to save cache memory at the cost of extra cache fills.</span></span><br><span class="line">    <span class="comment">// fixme re-measure this</span></span><br><span class="line"></span><br><span class="line">    ASSERT(newCapacity &gt; <span class="number">0</span>);</span><br><span class="line">    ASSERT((<span class="keyword">uintptr_t</span>)(<span class="keyword">mask_t</span>)(newCapacity<span class="number">-1</span>) == newCapacity<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    setBucketsAndMask(newBuckets, newCapacity - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (freeOld) &#123;</span><br><span class="line">        collect_free(oldBuckets, oldCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_OUTLINED</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_t::setBucketsAndMask</span><span class="params">(struct <span class="keyword">bucket_t</span> *newBuckets, <span class="keyword">mask_t</span> newMask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// objc_msgSend uses mask and buckets with no locks.</span></span><br><span class="line">    <span class="comment">// It is safe for objc_msgSend to see new buckets but old mask.</span></span><br><span class="line">    <span class="comment">// (It will get a cache miss but not overrun the buckets' bounds).</span></span><br><span class="line">    <span class="comment">// It is unsafe for objc_msgSend to see old buckets and new mask.</span></span><br><span class="line">    <span class="comment">// Therefore we write new buckets, wait a lot, then write new mask.</span></span><br><span class="line">    <span class="comment">// objc_msgSend reads mask first, then buckets.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __arm__</span></span><br><span class="line">    <span class="comment">// ensure other threads see buckets contents before buckets pointer</span></span><br><span class="line">    mega_barrier();</span><br><span class="line"></span><br><span class="line">    _bucketsAndMaybeMask.store((<span class="keyword">uintptr_t</span>)newBuckets, memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ensure other threads see new buckets before new mask</span></span><br><span class="line">    mega_barrier();</span><br><span class="line"></span><br><span class="line">    _maybeMask.store(newMask, memory_order_relaxed);</span><br><span class="line">    _occupied = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> __x86_64__ || i386</span></span><br><span class="line">    <span class="comment">// ensure other threads see buckets contents before buckets pointer</span></span><br><span class="line">    _bucketsAndMaybeMask.store((<span class="keyword">uintptr_t</span>)newBuckets, memory_order_release);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ensure other threads see new buckets before new mask</span></span><br><span class="line">    _maybeMask.store(newMask, memory_order_release);</span><br><span class="line">    _occupied = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">#error Don't know how to do setBucketsAndMask on this architecture.</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到_bucketsAndMaybeMask里的<code>newBuckets</code>为<code>newCapacity - 1</code>，我们看<code>capacity()</code>方法也能验证这一点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">cache_t::capacity</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mask() ? mask()+<span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继续探索cache-t"><a href="#继续探索cache-t" class="headerlink" title="继续探索cache_t"></a>继续探索<code>cache_t</code></h3><p>通过前面的探索，我们知道了 <code>cache_t</code> 实质上是缓存了我们类的实例方法，那么对于类方法来说，自然就是缓存在了元类上了。这一点我相信读者应该都能理解。</p>
<h3 id="方法缓存策略"><a href="#方法缓存策略" class="headerlink" title="方法缓存策略"></a>方法缓存策略</h3><p>直观的感受就是会在insert的时候缓存，我们继续看<code>insert</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_t::insert</span><span class="params">(SEL sel, IMP imp, id receiver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked();<span class="comment">//加锁</span></span><br><span class="line">    <span class="comment">// Never cache before +initialize is done</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!cls()-&gt;isInitialized())) &#123;<span class="comment">//initialize调用之后才会缓存</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isConstantOptimizedCache()) &#123;<span class="comment">//内联函数 return false 所以if里不会执行</span></span><br><span class="line">        _objc_fatal(<span class="string">"cache_t::insert() called with a preoptimized cache for %s"</span>,</span><br><span class="line">                    cls()-&gt;nameForLogging());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_TASK_THREADS</span></span><br><span class="line">    <span class="keyword">return</span> _collecting_in_critical();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_USE_CACHE_LOCK</span></span><br><span class="line">    <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(cacheUpdateLock)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    ASSERT(sel != <span class="number">0</span> &amp;&amp; cls()-&gt;isInitialized());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the cache as-is if until we exceed our expected fill ratio.</span></span><br><span class="line">    <span class="keyword">mask_t</span> newOccupied = occupied() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> oldCapacity = capacity(), capacity = oldCapacity;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(isConstantEmptyCache())) &#123;</span><br><span class="line">        <span class="comment">// Cache is read-only. Replace it.</span></span><br><span class="line">        <span class="keyword">if</span> (!capacity) capacity = INIT_CACHE_SIZE;</span><br><span class="line">        reallocate(oldCapacity, capacity, <span class="comment">/* freeOld */</span><span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fastpath(newOccupied + CACHE_END_MARKER &lt;= cache_fill_ratio(capacity))) &#123;</span><br><span class="line">        <span class="comment">// Cache is less than 3/4 or 7/8 full. Use it as-is.</span></span><br><span class="line">    &#125;</span><br><span class="line">#<span class="keyword">if</span> CACHE_ALLOW_FULL_UTILIZATION</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (capacity &lt;= FULL_UTILIZATION_CACHE_SIZE &amp;&amp; newOccupied + CACHE_END_MARKER &lt;= capacity) &#123;</span><br><span class="line">        <span class="comment">// Allow 100% cache utilization for small buckets. Use it as-is.</span></span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        capacity = capacity ? capacity * <span class="number">2</span> : INIT_CACHE_SIZE;</span><br><span class="line">        <span class="keyword">if</span> (capacity &gt; MAX_CACHE_SIZE) &#123;</span><br><span class="line">            capacity = MAX_CACHE_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        reallocate(oldCapacity, capacity, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bucket_t</span> *b = buckets();</span><br><span class="line">    <span class="keyword">mask_t</span> m = capacity - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">mask_t</span> <span class="built_in">begin</span> = cache_hash(sel, m);</span><br><span class="line">    <span class="keyword">mask_t</span> i = <span class="built_in">begin</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scan for the first unused slot and insert there.</span></span><br><span class="line">    <span class="comment">// There is guaranteed to be an empty slot.</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fastpath(b[i].sel() == <span class="number">0</span>)) &#123;</span><br><span class="line">            incrementOccupied();</span><br><span class="line">            b[i].<span class="built_in">set</span>&lt;Atomic, Encoded&gt;(b, sel, imp, cls());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b[i].sel() == sel) &#123;</span><br><span class="line">            <span class="comment">// The entry was added to the cache by some other thread</span></span><br><span class="line">            <span class="comment">// before we grabbed the cacheUpdateLock.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fastpath((i = cache_next(i, m)) != <span class="built_in">begin</span>));</span><br><span class="line"></span><br><span class="line">    bad_cache(receiver, (SEL)sel);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !DEBUG_TASK_THREADS</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法缓存是否有序"><a href="#方法缓存是否有序" class="headerlink" title="方法缓存是否有序"></a>方法缓存是否有序</h3><p>方法缓存是无序的，这是因为计算缓存下标是一个哈希算法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static inline mask_t cache_hash(cache_key_t key, mask_t mask) </span><br><span class="line">&#123;</span><br><span class="line">    return (mask_t)(key &amp; mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>cache_hash</code> 之后计算出来的下标并不是有序的，下标值取决于 <code>key</code> 和 <code>mask</code> 的值。</p>
<h3 id="bucket-与-mask-capacity-sel-imp-的关系"><a href="#bucket-与-mask-capacity-sel-imp-的关系" class="headerlink" title="bucket 与 mask, capacity, sel, imp 的关系"></a>bucket 与 mask, capacity, sel, imp 的关系</h3><p>一个类有一个属性 <code>cache_t</code>，而一个 <code>cache_t</code> 的 <code>buckets</code> 会有多个 <code>bucket</code>。一个 <code>bucket</code> 存储的是 <code>imp</code> 和 <code>cache_key_t</code> 。</p>
<p><code>mask</code> 的值对于 <code>bucket</code> 来说，主要是用来在缓存查找时的哈希算法。<br>而 <code>capacity</code> 则可以获取到 <code>cache_t</code> 中 <code>bucket</code> 的数量。</p>
<p><code>sel</code> 在缓存的时候是被强转成了 <code>cache_key_t</code> 的形式，更方便查询使用。<br><code>imp</code> 则是函数指针，也就是方法的具体实现，缓存的主要目的就是通过一系列策略让编译器更快的执行消息发送的逻辑。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>OC</code> 中实例方法缓存在类上面，类方法缓存在元类上面。</li>
<li><code>cache_t</code> 缓存会提前进行扩容防止溢出。</li>
<li>方法缓存是为了最大化的提高程序的执行效率。</li>
<li>苹果在方法缓存这里用的是<code>开放寻址法</code>来解决哈希冲突。</li>
<li>通过 <code>cache_t</code> 我们可以进一步延伸去探究 <code>objc_msgSend</code>，因为查找方法缓存是属于 <code>objc_msgSend</code> 查找方法实现的快速流程。</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/05/10/iOS%E5%BA%95%E5%B1%82%EF%BC%9A%E7%B1%BB/" rel="next" title="iOS底层：类">
                <i class="fa fa-chevron-left"></i> iOS底层：类
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/05/13/iOS%E5%BA%95%E5%B1%82%EF%BC%9A%E6%87%92%E5%8A%A0%E8%BD%BD%E7%B1%BB%E4%B8%8E%E9%9D%9E%E6%87%92%E5%8A%A0%E8%BD%BD%E7%B1%BB-realizeClass%E3%80%81methodizeClass/" rel="prev" title="iOS底层：懒加载类与非懒加载类 realizeClass、methodizeClass">
                iOS底层：懒加载类与非懒加载类 realizeClass、methodizeClass <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Jason</p>
              <p class="site-description motion-element" itemprop="description">个人技术博客</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#探索cache-t"><span class="nav-number">1.</span> <span class="nav-text">探索cache_t</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#cache-t的基本结构"><span class="nav-number">1.1.</span> <span class="nav-text">cache_t的基本结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继续探索cache-t"><span class="nav-number">2.</span> <span class="nav-text">继续探索cache_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法缓存策略"><span class="nav-number">3.</span> <span class="nav-text">方法缓存策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法缓存是否有序"><span class="nav-number">4.</span> <span class="nav-text">方法缓存是否有序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bucket-与-mask-capacity-sel-imp-的关系"><span class="nav-number">5.</span> <span class="nav-text">bucket 与 mask, capacity, sel, imp 的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
