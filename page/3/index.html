<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yujiusheng.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="个人技术博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Jason的博客">
<meta property="og:url" content="http://yujiusheng.com/page/3/index.html">
<meta property="og:site_name" content="Jason的博客">
<meta property="og:description" content="个人技术博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yujiusheng.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Jason的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jason的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/18/iOS-Runloop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/18/iOS-Runloop/" class="post-title-link" itemprop="url">iOS  - Runloop</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-18 15:33:42" itemprop="dateCreated datePublished" datetime="2021-05-18T15:33:42+08:00">2021-05-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/17/iOS-%E5%BA%95%E5%B1%82-%E7%B1%BB%E6%8B%93%E5%B1%95%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/17/iOS-%E5%BA%95%E5%B1%82-%E7%B1%BB%E6%8B%93%E5%B1%95%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">iOS 底层 - 类拓展和关联对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-17 13:39:24 / 修改时间：14:02:24" itemprop="dateCreated datePublished" datetime="2021-05-17T13:39:24+08:00">2021-05-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/17/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E5%88%86%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/17/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E5%88%86%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/" class="post-title-link" itemprop="url">iOS 底层探索 - 分类的加载</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-17 11:20:09 / 修改时间：13:38:57" itemprop="dateCreated datePublished" datetime="2021-05-17T11:20:09+08:00">2021-05-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="初探懒加载类"><a href="#初探懒加载类" class="headerlink" title="初探懒加载类"></a>初探懒加载类</h3><p>上一章我们探索了 <code>iOS</code> 中类的加载，让我们简单回顾一下大概的流程。</p>
<h4 id="类的加载回顾"><a href="#类的加载回顾" class="headerlink" title="类的加载回顾"></a>类的加载回顾</h4><ul>
<li><code>libObjc</code> 向 <code>dyld</code> 注册了回调 <code>_dyld_objc_notify_register</code>，当 <code>dyld</code> 把 <code>App</code> 以及 <code>App</code> 所依赖的一系列 <code>Mach-O</code> 镜像加载到当前 <code>App</code> 被分配的内存空间之后，<code>dyld</code> 会通过 <code>_dyld_objc_notify_mapped</code> 也就是 <code>map_images</code> 来通知 <code>libObjc</code> 来完成具体的加载工作，<code>map_images</code> 被调用之后会来到 <code>_read_images</code></li>
<li><code>_read_images</code><ul>
<li>主要会进行类的加载工作，会插入 <strong>所有的类</strong> 到 <code>gdb_objc_realized_classes</code> 哈希表中（插入方式为 类名为 <code>key</code>，类对象为<code>value</code>, 不包括通过 <em>共享缓存</em> 里面的类），同时还会把类插入到 <code>allocatedClasses</code> 这个集合里面，注意，<code>allocatedClasses</code> 的类型为 <code>NXHashTable</code>，可以类比为 <code>NSSet</code>，而 <code>gdb_objc_realized_classes</code> 的类型为 <code>NXMapTable</code>，可以类比为 <code>NSDictionary</code></li>
<li>对所有的类进行重映射</li>
<li>将所有的 <code>SEL</code> 插入到 <code>namedSelectors</code> 哈希表中(插入方式为：<code>SEL</code> 名称为 <code>key</code>，<code>SEL</code> 为<code>value</code>)</li>
<li>修复函数指针遗留</li>
<li>将所有的 <code>Protocol</code> 插入到 <code>readProtocol</code> 哈希表中(插入方式为：<code>Protocol</code> 名称为 <code>key</code>，<code>Protocol</code> 为 <code>value</code>)</li>
<li>对所有的 <code>Protocol</code> 做重映射</li>
<li>初始化所有的<strong>非懒加载类</strong>，包括 <code>rw</code> 和 <code>ro</code> 的初始化操作</li>
<li>处理所有的分类(包括类的分类和元类的分类)</li>
</ul>
</li>
</ul>
<h4 id="懒加载类的发现"><a href="#懒加载类的发现" class="headerlink" title="懒加载类的发现"></a>懒加载类的发现</h4><p>我们这个时候观察 <code>_read_images</code> 源码这部分的注释:</p>
<blockquote>
<p>Realize non-lazy classes (for +load methods and static instances)</p>
<p>实现<strong>非懒加载</strong>类(实现了 <code>+load</code> 方法和静态实例)</p>
</blockquote>
<p>什么意思呢，我们这里其实打印的都是所谓的<strong>非懒加载类</strong>，这里除了我们自己实现了 <code>+load</code> 方法的两个类之外，其他的内容都是系统内置的类，包括我们十分熟悉的 <code>NSObject</code> 类。通过这里其实反过来推论，我们没有实现 <code>+load</code> 方法就是所谓的懒加载类，这种类并不会在 <code>_read_images</code>环节被加载，那么应该是在哪里加载呢？我们稍微思考一下，我们一般第一次操作一个类是不是在初始化这个类的时候，而初始化类不就是发送<code>alloc</code>消息吗，而根据我们前面探索消息查找的知识，在第一次发送某个消息的时候，是没有缓存的，所以会来到一个非常重要的方法叫<code>lookUpImpOrForward</code>，我们在<code>main.m</code>中<code>LGPerson</code>类初始化的地方和<code>lookUpImpOrForward</code> 入口处打上断点:</p>
<p>Tips: 这里有个小技巧，我们先打开 <code>main.m</code> 文件中的断点，等断点来到了我们想要探索的 <code>LGPerson</code> 初始化的位置的时候，我们再打开 <code>lookUpImpOrForward</code> 处的断点，这样才能确保当前执行 <code>lookUpImpOrForward</code> 的是我们的研究对象 <code>LGPerson</code></p>
<p>因为我们断点的位置是 <code>LGPerson</code> 类发送 <code>alloc</code> 消息，而显然 <code>alloc</code> 作为类方法是存储在元类上的，也就是说 <code>lookUpImpOrForward</code> 的 <code>cls</code> 其实是 <code>LGPerson</code> 元类。那么 <code>inst</code> 就应该是真正的对象.</p>
<p>我们总结一下，如果类没有实现 <code>load</code> 方法，那么这个类就是<strong>懒加载类</strong>，反之、这个类如果实现了 <code>load</code> 方法，那么这个类就是<strong>非懒加载类</strong>。</p>
<h4 id="懒加载类的流程"><a href="#懒加载类的流程" class="headerlink" title="懒加载类的流程"></a>懒加载类的流程</h4><p>关于<strong>非懒加载类</strong>的加载流程我们已经很熟悉了，我们总结下<strong>懒加载类</strong>的流程：</p>
<ul>
<li>类第一次发送消息的时候是没有缓存的，所以会来到 <code>_class_lookupMethodAndLoadCache3</code> ，关于这个方法我们在前面的消息查找章节已经介绍过了，不熟悉的同学可以去查阅一下。</li>
<li><code>_class_lookupMethodAndLoadCache3</code> 会调用 <code>lookUpImpOrForward</code> ，这个方法的重要性在我们学习 <code>Runtime</code> 的过程中不言而喻</li>
<li><code>lookUpImpOrForward</code> 内部会进行一下判断，如果 <code>cls</code> 没有被实现，会调用 <code>realizeClassMaybeSwiftAndLeaveLocked</code> 方法</li>
<li><code>realizeClassMaybeSwiftAndLeaveLocked</code> 方法又会调用 <code>realizeClassMaybeSwiftMaybeRelock</code> 方法</li>
<li><code>realizeClassMaybeSwiftMaybeRelock</code> 方法内部会进行一下是否是 <code>Swift</code> 的判断，如果不是 <code>Swift</code> 环境的话，就会来到 <code>realizeClassWithoutSwift</code> ，也就是最终的类的加载的地方</li>
</ul>
<h3 id="分类的底层实现"><a href="#分类的底层实现" class="headerlink" title="分类的底层实现"></a>分类的底层实现</h3><p>分类作为 <code>Objective-C</code> 中常见的特性，相信大家都不会陌生，不过在底层它是怎么实现的呢？</p>
<h4 id="分类的定义"><a href="#分类的定义" class="headerlink" title="分类的定义"></a>分类的定义</h4><p>我们根据 <code>_category_t</code> 来到 <code>libObjc</code> 源码中进行查找，不过我们需要去掉一下 <code>_category_t</code> 的下划线，然后不难找到分类真正的定义所在：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">classref_t</span> cls;</span><br><span class="line">    WrappedPtr&lt;<span class="keyword">method_list_t</span>, PtrauthStrip&gt; instanceMethods;</span><br><span class="line">    WrappedPtr&lt;<span class="keyword">method_list_t</span>, PtrauthStrip&gt; classMethods;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span></span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *_<span class="title">classProperties</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">method_list_t</span> *<span class="title">methodsForMeta</span><span class="params">(<span class="keyword">bool</span> isMeta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">property_list_t</span> *<span class="title">propertiesForMeta</span><span class="params">(<span class="keyword">bool</span> isMeta, struct header_info *hi)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protocol_list_t</span> *<span class="title">protocolsForMeta</span><span class="params">(<span class="keyword">bool</span> isMeta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> protocols;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据刚才 <code>clang</code> 重写之后的内容，我们不难看出</p>
<ul>
<li><p><code>name</code> : 是分类所关联的类，也就是类的名字，而不是分类的名字</p>
</li>
<li><p><code>cls</code> : 我们在前面可以看到 <code>clang</code> 重写后这个值为 0，但是后面有注释为 <code>&amp;OBJC_CLASS_$_LGTeacher</code> ，也就是我们的类对象的定义，所以这里其实就是我们要扩展的类对象，只是在编译期这个值并不存在</p>
</li>
<li><p><code>instanceMethods</code> : 分类上存储的实例方法</p>
</li>
<li><p><code>classMethods</code> ：分类上存储的类方法</p>
</li>
<li><p><code>protocols</code> ：分类所实现的协议</p>
</li>
<li><p><code>instanceProperties</code> ：分类所定义的实例属性，不过我们一般在分类中添加属性都是通过关联对象来实现的</p>
</li>
<li><p><code>_classProperties</code>：分类所定义的类属性。这里有一行注释：</p>
<blockquote>
<p>Fields below this point are not always present on disk.<br>下面的内容并不是一直在磁盘上保存</p>
</blockquote>
</li>
</ul>
<p>也就是说 <code>_classProperties</code> 其实是一个私有属性，但并不是一直都存在的。</p>
<h3 id="分类的加载"><a href="#分类的加载" class="headerlink" title="分类的加载"></a>分类的加载</h3><p>我们现在知道了类分为了 <code>懒加载类</code> 和 <code>非懒加载类</code> ，它们的加载时机是不一样的，那么分类的加载又是怎么样的呢？我们还是同样的先分析没有实现 <code>load</code> 方法的分类的情况:</p>
<p>但是我们在分析前，还要搞清楚一点，分类必须依附于类而存在，如果只有分类，没有类，那么从逻辑上是说不通的，就算实现了，编译器也会忽略掉。而关于类是懒加载还是非懒加载的，所以这里我们还要再细分一次。</p>
<ul>
<li>懒加载分类与懒加载类</li>
<li>懒加载分类和非懒加载类</li>
</ul>
<h4 id="没有实现-load-的分类"><a href="#没有实现-load-的分类" class="headerlink" title="没有实现 load 的分类"></a>没有实现 load 的分类</h4><h5 id="与懒加载类配合加载"><a href="#与懒加载类配合加载" class="headerlink" title="与懒加载类配合加载"></a>与懒加载类配合加载</h5><p>我们先分析第一种情况，也就是类和分类都不实现 <code>load</code> 方法的情况。<br>首先，懒加载类的流程上面我们已经探索过了，在向类<strong>第一次发送消息</strong>的时候，懒加载类才会开始加载，而根据我们上一章类的加载探索内容，在 <code>realizeClassWithoutSwift</code> 方法的最后有一个 <code>methodizeClass</code> 方法，在这个方法里面会有一个 <code>Attach categories</code> 的地方：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Attach categories.</span></span><br><span class="line"><span class="keyword">if</span> (previously) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isMeta) &#123;</span><br><span class="line">        objc::unattachedCategories.attachToClass(cls, previously,</span><br><span class="line">                                                 ATTACH_METACLASS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// When a class relocates, categories with class methods</span></span><br><span class="line">        <span class="comment">// may be registered on the class itself rather than on</span></span><br><span class="line">        <span class="comment">// the metaclass. Tell attachToClass to look for those.</span></span><br><span class="line">        objc::unattachedCategories.attachToClass(cls, previously,</span><br><span class="line">                                                 ATTACH_CLASS_AND_METACLASS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">objc::unattachedCategories.attachToClass(cls, cls,</span><br><span class="line">                                         isMeta ? ATTACH_METACLASS : ATTACH_CLASS);</span><br></pre></td></tr></table></figure>

<p>我们进入<code>unattachedCategories</code>的<code>attachToClass</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachToClass</span><span class="params">(Class cls, Class previously, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    ASSERT((flags &amp; ATTACH_CLASS) ||</span><br><span class="line">           (flags &amp; ATTACH_METACLASS) ||</span><br><span class="line">           (flags &amp; ATTACH_CLASS_AND_METACLASS));</span><br><span class="line">    <span class="keyword">auto</span> &amp;<span class="built_in">map</span> = <span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">map</span>.<span class="built_in">find</span>(previously);</span><br><span class="line">    <span class="keyword">if</span> (it != <span class="built_in">map</span>.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        category_list &amp;<span class="built_in">list</span> = it-&gt;second;</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; ATTACH_CLASS_AND_METACLASS) &#123;</span><br><span class="line">            <span class="keyword">int</span> otherFlags = flags &amp; ~ATTACH_CLASS_AND_METACLASS;</span><br><span class="line">            attachCategories(cls, <span class="built_in">list</span>.<span class="built_in">array</span>(), <span class="built_in">list</span>.count(), otherFlags | ATTACH_CLASS);</span><br><span class="line">            attachCategories(cls-&gt;ISA(), <span class="built_in">list</span>.<span class="built_in">array</span>(), <span class="built_in">list</span>.count(), otherFlags | ATTACH_METACLASS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            attachCategories(cls, <span class="built_in">list</span>.<span class="built_in">array</span>(), <span class="built_in">list</span>.count(), flags);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>.erase(it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们断点之后发现这个时候通过 <code>unattachedCategoriesForClass</code> 方法并没有取到分类，我们此时不妨通过 <code>LLDB</code> 打印一下当前类里面是否已经把分类的内容附加上了。<br>前面的流程大家都很熟悉了，我们直接看 <code>cls</code> 的 <code>rw</code> 中的 <code>methods</code> 是否有内容：</p>
<p>这样进一步证明了，如果是懒加载类，并且分类也是懒加载，那么分类的加载并不会来到 <code>unattachedCategoriesForClass</code> ，而是直接在编译时加载到了类的 <code>ro</code> 里面，然后在运行时被拷贝到了类的 <code>rw</code> 里面。这一点可以通过下面的 <code>LLDB</code> 打印来证明。</p>
<h5 id="与非懒加载类配合加载"><a href="#与非懒加载类配合加载" class="headerlink" title="与非懒加载类配合加载"></a>与非懒加载类配合加载</h5><p>同样的道理，当类为非懒加载类的时候，走的是 <code>_read_images</code> 里面的流程，这个时候我们的懒加载分类是在哪加载的呢？</p>
<p>分类还是不在这，同时通过 <code>LLDB</code> 打印，发现分类的方法已经在类的 <code>ro</code> 里面了，所以说分类的加载其实跟类的懒加载与否并没有关系，也就是说懒加载的分类都是在编译时期被加载的。</p>
<h4 id="实现了-load-的分类"><a href="#实现了-load-的分类" class="headerlink" title="实现了 load 的分类"></a>实现了 load 的分类</h4><p>我们再接着分下下面两种情况：</p>
<ul>
<li>非懒加载分类与懒加载类</li>
<li>非懒加载分类和非懒加载类</li>
</ul>
<h5 id="与懒加载类配合加载-1"><a href="#与懒加载类配合加载-1" class="headerlink" title="与懒加载类配合加载"></a>与懒加载类配合加载</h5><p>其实懒加载和非懒加载的最大区别就是加载是否提前，而实现了 <code>+load</code> 方法的分类，面对的是懒加载的类，<br>而懒加载的类我们前面已经知道了，是在第一次发送消息的时候才会被加载的，那我们直接在<br><code>lookupImpOrForward</code> =&gt; <code>realizeClassMaybeSwiftAndLeaveLocked</code> =&gt; <code>realizeClassMaybeSwiftMaybeRelock</code> =&gt; <code>realizeClassWithoutSwift</code> =&gt; <code>methodizeClass</code> 流程中的 <code>methodizeClass</code> 打上断点，看下在这里分类会不会被加载：</p>
<p>这一次通过 <code>unattachedCategoriesForClass</code> 取出来值了，并且在这之前 <code>cls</code> 的 <code>ro</code> 中并没有分类的 <code>initialize</code> 方法：</p>
<p>为什么走的不是发送消息的流程，而走的是 <code>load_images</code> 里面的 <code>prepare_load_methods</code> 方法呢？我们来到 <code>prepare_load_methods</code> 方法处：</p>
<p>可以看到，其实是在这里调用了 <code>realizeClassWithoutSwift</code> 方法来加载类的。而上面的 <code>_getObjc2NonlazyCategoryList</code> 方法显示就是获取的所有的非懒加载分类，然后遍历这些非懒加载分类，然后去加载这些分类所依赖的类。这个逻辑很好理解，非懒加载分类让我们的懒加载类实现提前了，所以说懒加载类<strong>并不一定</strong>只会在第一次消息发送的时候加载，还要取决于有没有非懒加载的分类，如果有非懒加载的分类，那么就走的是 <code>load_images</code> 里面的 <code>prepare_load_methods</code> 的 <code>realizeClassWithoutSwift</code> 。</p>
<h5 id="与非懒加载类配合加载-1"><a href="#与非懒加载类配合加载-1" class="headerlink" title="与非懒加载类配合加载"></a>与非懒加载类配合加载</h5><p>非懒加载类的流程我们也十分熟悉了，在 <code>_read_images</code> 里面进行加载，而此时，分类也是非懒加载。我们还是在 <code>methodizeClass</code> 里面进行断点：</p>
<p>结果如上图所示，这次从 <code>unattachedCategoriesForClass</code> 方法取出来的是 <code>NULL</code> 值，显然分类不是在这个地方被加载的，我们回到 <code>_read_images</code> 方法，还记得那个 <code>Discover categories</code> 流程吗，我们打开里面的断点：</p>
<p>其实 <code>attachCategories</code> 这个方法只会在实现了 <code>load</code> 方法的分类下才会被调用，而来到 <code>attachCategories</code> 之前又取决于类是否为懒加载，如果是懒加载，那么就在 <code>load_images</code> 里面去处理，如果是非懒加载，那么就在 <code>map_images</code> 里面去处理。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们今天探索的内容可能会有点绕，不过其实探索下来，我们只需要保持研究重点就很简单。分类的加载其实可以笼统的分为实现 <code>load</code> 方法和没有实现 <code>load</code> 方法：</p>
<ul>
<li>没有实现 <code>load</code> 方法的分类由编译时确定</li>
<li>实现了 <code>load</code> 方法的分类由运行时去确定</li>
</ul>
<p>这也说明分类的加载和类的加载是不一样的，而结合着类的懒加载与否，我们有以下的结论：</p>
<ul>
<li>懒加载分类 + 懒加载类</li>
</ul>
<blockquote>
<p>类的加载在<strong>第一次消息发送</strong>的时候，而分类的加载则在<strong>编译时</strong></p>
</blockquote>
<ul>
<li>懒加载分类 + 非懒加载类</li>
</ul>
<blockquote>
<p>类的加载在 <code>_read_images</code> 处，分类的加载还是在<strong>编译时</strong></p>
</blockquote>
<ul>
<li>非懒加载分类 + 懒加载类</li>
</ul>
<blockquote>
<p>类的加载在 <code>load_images</code> 内部，分类的加载在类加载之后的 <code>methodizeClass</code></p>
</blockquote>
<ul>
<li>非懒加载分类 + 非懒加载类</li>
</ul>
<blockquote>
<p>类的加载在 <code>_read_images</code> 处，分类的加载在类加载之后的 <code>reMethodizeClass</code></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/15/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/15/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/" class="post-title-link" itemprop="url">iOS 底层探索 - 类的加载</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-15 16:19:03" itemprop="dateCreated datePublished" datetime="2021-05-15T16:19:03+08:00">2021-05-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-17 11:03:49" itemprop="dateModified" datetime="2021-05-17T11:03:49+08:00">2021-05-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="应用的加载回顾"><a href="#应用的加载回顾" class="headerlink" title="应用的加载回顾"></a>应用的加载回顾</h3><p>上一章我们对应用的加载有了初步的认识，我们知道了</p>
<ul>
<li>系统调用 <code>exec()</code> 会我们的应用<strong>映射</strong>到新的地址空间</li>
<li>然后通过 <code>dyld</code> 进行加载、链接、初始化主程序和主程序所依赖的各种动态库</li>
<li>最后在 <code>initializeMainExecutable</code> 方法中经过一系列初始化调用 <code>notifySingle</code> 函数，该函数会执行一个 <code>load_images</code> 的回调</li>
<li>然后在 <code>doModinitFuntions</code> 函数内部会调用 <code>__attribute__((constructor))</code> 的 <code>c</code> 函数</li>
<li>然后 <code>dyld</code> 返回主程序的入口函数，开始进入主程序的 <code>main</code> 函数 在 <code>main</code> 函数执行执行，其实 <code>dyld</code> 还会在流程中初始化 <code>libSystem</code>，而 <code>libSystem</code> 又会去初始化 <code>libDispatch</code>，在 <code>libDispatch</code> 初始化方法里面又会有一步 <code>_os_object_init</code>，在 <code>_os_object_init</code> 内部就会调起 <code>_objc_init</code>。而对于 <code>_objc_init</code> 我们还需要继续探索，因为这里面会进行类的加载等一系列重要的工作。</li>
</ul>
<h3 id="探索-objc-init"><a href="#探索-objc-init" class="headerlink" title="探索_objc_init"></a>探索<code>_objc_init</code></h3><p>首先来到 <code>libObjc</code> 源码的 <code>_objc_init</code> 方法处，你可以直接添加一个符号断点 <code>_objc_init</code> 或者全局搜索关键字来到这里：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* _objc_init</span></span><br><span class="line"><span class="comment">* Bootstrap initialization. Registers our image notifier with dyld.</span></span><br><span class="line"><span class="comment">* Called by libSystem BEFORE library initialization time</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">  	<span class="comment">//如果已经初始化直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    runtime_init();</span><br><span class="line">    exception_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    <span class="keyword">cache_t</span>::init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    _imp_implementationWithBlock_init();</span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    didCallDyldNotifyRegister = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="environ-init"><a href="#environ-init" class="headerlink" title="environ_init"></a><code>environ_init</code></h4><p>我们直接看调用的第一个方法<code>environ_init</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* environ_init</span></span><br><span class="line"><span class="comment">* Read environment variables that affect the runtime.</span></span><br><span class="line"><span class="comment">* Also print environment variable help, if requested.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">environ_init</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (issetugid()) &#123;</span><br><span class="line">        <span class="comment">// All environment variables are silently ignored when setuid or setgid</span></span><br><span class="line">        <span class="comment">// This includes OBJC_HELP and OBJC_PRINT_OPTIONS themselves.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// Turn off autorelease LRU coalescing by default for apps linked against</span></span><br><span class="line">    <span class="comment">// older SDKs. LRU coalescing can reorder releases and certain older apps</span></span><br><span class="line">    <span class="comment">// are accidentally relying on the ordering.</span></span><br><span class="line">    <span class="comment">// rdar://problem/63886091</span></span><br><span class="line"><span class="comment">//    if (!dyld_program_sdk_at_least(dyld_fall_2020_os_versions))</span></span><br><span class="line"><span class="comment">//        DisableAutoreleaseCoalescingLRU = true;</span></span><br><span class="line">    <span class="keyword">bool</span> PrintHelp = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> PrintOptions = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> maybeMallocDebugging = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// Scan environ[] directly instead of calling getenv() a lot.</span></span><br><span class="line">    <span class="comment">// This optimizes the case where none are set.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> **p = *_NSGetEnviron(); *p != nil; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strncmp</span>(*p, <span class="string">"Malloc"</span>, <span class="number">6</span>)  ||  <span class="number">0</span> == <span class="built_in">strncmp</span>(*p, <span class="string">"DYLD"</span>, <span class="number">4</span>)  ||  </span><br><span class="line">            <span class="number">0</span> == <span class="built_in">strncmp</span>(*p, <span class="string">"NSZombiesEnabled"</span>, <span class="number">16</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            maybeMallocDebugging = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != <span class="built_in">strncmp</span>(*p, <span class="string">"OBJC_"</span>, <span class="number">5</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strncmp</span>(*p, <span class="string">"OBJC_HELP="</span>, <span class="number">10</span>)) &#123;</span><br><span class="line">            PrintHelp = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strncmp</span>(*p, <span class="string">"OBJC_PRINT_OPTIONS="</span>, <span class="number">19</span>)) &#123;</span><br><span class="line">            PrintOptions = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strncmp</span>(*p, <span class="string">"OBJC_DEBUG_POOL_DEPTH="</span>, <span class="number">22</span>)) &#123;</span><br><span class="line">            SetPageCountWarning(*p + <span class="number">22</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *value = <span class="built_in">strchr</span>(*p, <span class="string">'='</span>);</span><br><span class="line">        <span class="keyword">if</span> (!*value) <span class="keyword">continue</span>;</span><br><span class="line">        value++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(Settings)/<span class="keyword">sizeof</span>(Settings[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">option_t</span> *opt = &amp;Settings[i];</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">size_t</span>)(value - *p) == <span class="number">1</span>+opt-&gt;envlen  &amp;&amp;  </span><br><span class="line">                <span class="number">0</span> == <span class="built_in">strncmp</span>(*p, opt-&gt;env, opt-&gt;envlen))</span><br><span class="line">            &#123;</span><br><span class="line">                *opt-&gt;var = (<span class="number">0</span> == <span class="built_in">strcmp</span>(value, <span class="string">"YES"</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Special case: enable some autorelease pool debugging</span></span><br><span class="line">    <span class="comment">// when some malloc debugging is enabled </span></span><br><span class="line">    <span class="comment">// and OBJC_DEBUG_POOL_ALLOCATION is not set to something other than NO.</span></span><br><span class="line">    <span class="keyword">if</span> (maybeMallocDebugging) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *insert = getenv(<span class="string">"DYLD_INSERT_LIBRARIES"</span>);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *zombie = getenv(<span class="string">"NSZombiesEnabled"</span>);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *pooldebug = getenv(<span class="string">"OBJC_DEBUG_POOL_ALLOCATION"</span>);</span><br><span class="line">        <span class="keyword">if</span> ((getenv(<span class="string">"MallocStackLogging"</span>)</span><br><span class="line">             || getenv(<span class="string">"MallocStackLoggingNoCompact"</span>)</span><br><span class="line">             || (zombie &amp;&amp; (*zombie == <span class="string">'Y'</span> || *zombie == <span class="string">'y'</span>))</span><br><span class="line">             || (insert &amp;&amp; <span class="built_in">strstr</span>(insert, <span class="string">"libgmalloc"</span>)))</span><br><span class="line">            &amp;&amp;</span><br><span class="line">            (!pooldebug || <span class="number">0</span> == <span class="built_in">strcmp</span>(pooldebug, <span class="string">"YES"</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            DebugPoolAllocation = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    if (!os_feature_enabled_simple(objc4, preoptimizedCaches, true)) &#123;</span></span><br><span class="line"><span class="comment">//        DisablePreoptCaches = true;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">// Print OBJC_HELP and OBJC_PRINT_OPTIONS output.</span></span><br><span class="line">    <span class="keyword">if</span> (PrintHelp  ||  PrintOptions) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintHelp) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"Objective-C runtime debugging. Set variable=YES to enable."</span>);</span><br><span class="line">            _objc_inform(<span class="string">"OBJC_HELP: describe available environment variables"</span>);</span><br><span class="line">            <span class="keyword">if</span> (PrintOptions) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"OBJC_HELP is set"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            _objc_inform(<span class="string">"OBJC_PRINT_OPTIONS: list which options are set"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (PrintOptions) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"OBJC_PRINT_OPTIONS is set"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(Settings)/<span class="keyword">sizeof</span>(Settings[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">option_t</span> *opt = &amp;Settings[i];            </span><br><span class="line">            <span class="keyword">if</span> (PrintHelp) _objc_inform(<span class="string">"%s: %s"</span>, opt-&gt;env, opt-&gt;help);</span><br><span class="line">            <span class="keyword">if</span> (PrintOptions &amp;&amp; *opt-&gt;var) _objc_inform(<span class="string">"%s is set"</span>, opt-&gt;env);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，这里主要是读取影响 <code>Runtime</code> 的一些环境变量，如果需要，还可以打印环境变量帮助提示。</p>
<p>我们可以在终端测试一下，直接输入<code>export OBJC-HELP=1</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">jason@<span class="number">192</span> ~ % <span class="keyword">export</span> OBJC_HELP=<span class="number">1</span></span><br><span class="line">jason@<span class="number">192</span> ~ % ls</span><br><span class="line">objc[<span class="number">6097</span>]: Objective-C runtime debugging. Set variable=YES to enable.</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_HELP: describe <span class="built_in">available</span> environment variables</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_OPTIONS: <span class="built_in">list</span> which options are <span class="built_in">set</span></span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_IMAGES: <span class="built_in">log</span> <span class="built_in">image</span> <span class="keyword">and</span> library names as they are loaded</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_IMAGE_TIMES: measure duration of <span class="built_in">image</span> loading steps</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_LOAD_METHODS: <span class="built_in">log</span> calls to class <span class="keyword">and</span> category +load methods</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_INITIALIZE_METHODS: <span class="built_in">log</span> calls to class +initialize methods</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_RESOLVED_METHODS: <span class="built_in">log</span> methods created by +resolveClassMethod: <span class="keyword">and</span> +resolveInstanceMethod:</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_CLASS_SETUP: <span class="built_in">log</span> progress of class <span class="keyword">and</span> category <span class="built_in">setup</span></span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_PROTOCOL_SETUP: <span class="built_in">log</span> progress of protocol <span class="built_in">setup</span></span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_IVAR_SETUP: <span class="built_in">log</span> processing of non-fragile ivars</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_VTABLE_SETUP: <span class="built_in">log</span> processing of class vtables</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_VTABLE_IMAGES: <span class="built_in">print</span> vtable images showing overridden methods</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_CACHE_SETUP: <span class="built_in">log</span> processing of method caches</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_FUTURE_CLASSES: <span class="built_in">log</span> use of <span class="built_in">future</span> classes <span class="keyword">for</span> toll-<span class="built_in">free</span> bridging</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_PREOPTIMIZATION: <span class="built_in">log</span> preoptimization courtesy of dyld shared cache</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_CXX_CTORS: <span class="built_in">log</span> calls to C++ ctors <span class="keyword">and</span> dtors <span class="keyword">for</span> instance variables</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_EXCEPTIONS: <span class="built_in">log</span> exception handling</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_EXCEPTION_THROW: <span class="built_in">log</span> backtrace of every objc_exception_throw()</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_ALT_HANDLERS: <span class="built_in">log</span> processing of exception alt handlers</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_REPLACED_METHODS: <span class="built_in">log</span> methods replaced by category implementations</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_DEPRECATION_WARNINGS: warn about calls to deprecated runtime functions</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_POOL_HIGHWATER: <span class="built_in">log</span> high-water marks <span class="keyword">for</span> autorelease pools</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_CUSTOM_CORE: <span class="built_in">log</span> classes with custom core methods</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_CUSTOM_RR: <span class="built_in">log</span> classes with custom retain/<span class="built_in">release</span> methods</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_CUSTOM_AWZ: <span class="built_in">log</span> classes with custom allocWithZone methods</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_RAW_ISA: <span class="built_in">log</span> classes that require raw pointer isa fields</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DEBUG_UNLOAD: warn about poorly-behaving bundles when unloaded</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DEBUG_FRAGILE_SUPERCLASSES: warn about subclasses that may have been broken by subsequent changes to superclasses</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DEBUG_NIL_SYNC: warn about @synchronized(nil), which does no synchronization</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DEBUG_NONFRAGILE_IVARS: capriciously rearrange non-fragile ivars</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DEBUG_ALT_HANDLERS: record more info about bad alt handler use</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DEBUG_MISSING_POOLS: warn about autorelease with no pool in place, which may be a leak</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DEBUG_POOL_ALLOCATION: halt when autorelease pools are popped out of order, <span class="keyword">and</span> allow heap debuggers to track autorelease pools</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DEBUG_DUPLICATE_CLASSES: halt when multiple classes with the same name are present</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DEBUG_DONT_CRASH: halt the <span class="built_in">process</span> by exiting instead of crashing</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DISABLE_VTABLES: disable vtable dispatch</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DISABLE_PREOPTIMIZATION: disable preoptimization courtesy of dyld shared cache</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DISABLE_TAGGED_POINTERS: disable tagged pointer optimization of NSNumber et al.</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DISABLE_TAG_OBFUSCATION: disable obfuscation of tagged pointers</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DISABLE_NONPOINTER_ISA: disable non-pointer isa fields</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DISABLE_INITIALIZE_FORK_SAFETY: disable safety checks <span class="keyword">for</span> +initialize after fork</span><br></pre></td></tr></table></figure>

<p>可以看到不同的环境变量对应的内容都被打印出来了。</p>
<h4 id="tls-init"><a href="#tls-init" class="headerlink" title="tls_init"></a><code>tls_init</code></h4><p>接着看<code>tls_init</code>方法内部：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tls_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line">    pthread_key_init_np(TLS_DIRECT_KEY, &amp;_objc_pthread_destroyspecific);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    _objc_pthread_key = tls_create(&amp;_objc_pthread_destroyspecific);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里执行的是关于线程 <code>key</code> 的绑定，比如每个线程数据的析构函数。</p>
<h4 id="static-init"><a href="#static-init" class="headerlink" title="static_init"></a><code>static_init</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* static_init</span></span><br><span class="line"><span class="comment">* Run C++ static constructor functions.</span></span><br><span class="line"><span class="comment">* libc calls _objc_init() before dyld would call our static constructors, </span></span><br><span class="line"><span class="comment">* so we have to do it ourselves.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">static_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    <span class="keyword">auto</span> inits = getLibobjcInitializers(&amp;_mh_dylib_header, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        inits[i]();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> offsets = getLibobjcInitializerOffsets(&amp;_mh_dylib_header, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="function">UnsignedInitializer <span class="title">init</span><span class="params">(offsets[i])</span></span>;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会运行 <code>C++</code> 的静态构造函数，在 <code>dyld</code> 调用我们的静态构造函数之前，<code>libc</code> 会调用 <code>_objc_init</code>，所以这里我们必须自己来做，并且这里只会初始化系统内置的 <code>C++</code> 静态构造函数，我们自己代码里面写的并不会在这里初始化。</p>
<h4 id="runtime-init"><a href="#runtime-init" class="headerlink" title="runtime_init"></a><code>runtime_init</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runtime_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    objc::unattachedCategories.init(<span class="number">32</span>);</span><br><span class="line">    objc::allocatedClasses.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Runtime环境初始化，unattachedCategories和allocatedClasses两张表的初始化工作</p>
<h4 id="exception-init"><a href="#exception-init" class="headerlink" title="exception_init"></a><code>exception_init</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* exception_init</span></span><br><span class="line"><span class="comment">* Initialize libobjc's exception handling system.</span></span><br><span class="line"><span class="comment">* Called by map_images().</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exception_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    old_terminate = <span class="built_in">std</span>::set_terminate(&amp;_objc_terminate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是初始化 <code>libobjc</code> 的异常处理系统，我们程序触发的异常都会来到：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* _objc_terminate</span></span><br><span class="line"><span class="comment">* Custom std::terminate handler.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* The uncaught exception callback is implemented as a std::terminate handler. </span></span><br><span class="line"><span class="comment">* 1. Check if there's an active exception</span></span><br><span class="line"><span class="comment">* 2. If so, check if it's an Objective-C exception</span></span><br><span class="line"><span class="comment">* 3. If so, call our registered callback with the object.</span></span><br><span class="line"><span class="comment">* 4. Finally, call the previous terminate handler.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*old_terminate)</span><span class="params">(<span class="keyword">void</span>)</span> </span>= nil;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _objc_terminate(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PrintExceptions) &#123;</span><br><span class="line">        _objc_inform(<span class="string">"EXCEPTIONS: terminating"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! __cxa_current_exception_type()) &#123;</span><br><span class="line">        <span class="comment">// No current exception.</span></span><br><span class="line">        (*old_terminate)();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// There is a current exception. Check if it's an objc exception.</span></span><br><span class="line">        @<span class="keyword">try</span> &#123;</span><br><span class="line">            __cxa_rethrow();</span><br><span class="line">        &#125; @<span class="keyword">catch</span> (id e) &#123;</span><br><span class="line">            <span class="comment">// It's an objc object. Call Foundation's handler, if any.</span></span><br><span class="line">            (*uncaught_handler)((id)e);</span><br><span class="line">            (*old_terminate)();</span><br><span class="line">        &#125; @<span class="keyword">catch</span> (...) &#123;</span><br><span class="line">            <span class="comment">// It's not an objc object. Continue to C++ terminate.</span></span><br><span class="line">            (*old_terminate)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到 <code>_objc_terminate</code> 是未处理异常的回调函数，其内部逻辑如下:</p>
<ul>
<li>检查是否是一个活跃的异常</li>
<li>如果是活跃的异常，检查是否是 <code>OC</code> 抛出的异常</li>
<li>如果是 <code>OC</code> 抛出的异常，调用 <code>uncaught_handeler</code> 回调函数指针</li>
<li>如果不是 <code>OC</code> 抛出的异常，则继续 <code>C++</code> 终止操作</li>
</ul>
<h4 id="cache-t-init"><a href="#cache-t-init" class="headerlink" title="cache_t::init()"></a><code>cache_t::init()</code></h4><p>看字面量很容易猜到，<code>cache_t</code>属性的初始化</p>
<h4 id="imp-implementationWithBlock-init"><a href="#imp-implementationWithBlock-init" class="headerlink" title="_imp_implementationWithBlock_init"></a><code>_imp_implementationWithBlock_init</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Initialize the trampoline machinery. Normally this does nothing, as</span></span><br><span class="line"><span class="comment">/// everything is initialized lazily, but for certain processes we eagerly load</span></span><br><span class="line"><span class="comment">/// the trampolines dylib.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_imp_implementationWithBlock_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_OSX</span></span><br><span class="line">    <span class="comment">// Eagerly load libobjc-trampolines.dylib in certain processes. Some</span></span><br><span class="line">    <span class="comment">// programs (most notably QtWebEngineProcess used by older versions of</span></span><br><span class="line">    <span class="comment">// embedded Chromium) enable a highly restrictive sandbox profile which</span></span><br><span class="line">    <span class="comment">// blocks access to that dylib. If anything calls</span></span><br><span class="line">    <span class="comment">// imp_implementationWithBlock (as AppKit has started doing) then we'll</span></span><br><span class="line">    <span class="comment">// crash trying to load it. Loading it here sets it up before the sandbox</span></span><br><span class="line">    <span class="comment">// profile is enabled and blocks it.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This fixes EA Origin (rdar://problem/50813789)</span></span><br><span class="line">    <span class="comment">// and Steam (rdar://problem/55286131)</span></span><br><span class="line">    <span class="keyword">if</span> (__progname &amp;&amp;</span><br><span class="line">        (<span class="built_in">strcmp</span>(__progname, <span class="string">"QtWebEngineProcess"</span>) == <span class="number">0</span> ||</span><br><span class="line">         <span class="built_in">strcmp</span>(__progname, <span class="string">"Steam Helper"</span>) == <span class="number">0</span>)) &#123;</span><br><span class="line">        Trampolines.Initialize();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动回调机制。通常不会做什么，因为所有的初始化都是惰性的，但是对于某些进程，我们会迫不及待地加载trampolines dylib。</p>
<h4 id="dyld-objc-notify-register"><a href="#dyld-objc-notify-register" class="headerlink" title="_dyld_objc_notify_register"></a><code>_dyld_objc_notify_register</code></h4><p>接下来是我们今天探索的重点了： <code>_dyld_objc_notify_register</code> ，我们先看下它的定义:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note: only for use by objc runtime</span></span><br><span class="line"><span class="comment">// Register handlers to be called when objc images are mapped, unmapped, and initialized.</span></span><br><span class="line"><span class="comment">// Dyld will call back the "mapped" function with an array of images that contain an objc-image-info section.</span></span><br><span class="line"><span class="comment">// Those images that are dylibs will have the ref-counts automatically bumped, so objc will no longer need to</span></span><br><span class="line"><span class="comment">// call dlopen() on them to keep them from being unloaded.  During the call to _dyld_objc_notify_register(),</span></span><br><span class="line"><span class="comment">// dyld will call the "mapped" function with already loaded objc images.  During any later dlopen() call,</span></span><br><span class="line"><span class="comment">// dyld will also call the "mapped" function.  Dyld will call the "init" function when dyld would be called</span></span><br><span class="line"><span class="comment">// initializers in that image.  This is when objc calls any +load methods in that image.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span> _dyld_objc_notify_register(_dyld_objc_notify_mapped    mapped,</span><br><span class="line">                                _dyld_objc_notify_init      init,</span><br><span class="line">                                _dyld_objc_notify_unmapped  unmapped);</span><br></pre></td></tr></table></figure>

<p>注意：仅供 <code>objc</code> 运行时使用<br>当 <code>objc</code> 镜像被<strong>映射（mapped）</strong>、<strong>卸载（unmapped）</strong>和<strong>初始化（initialized）</strong>的时候，注册的回调函数就会被调用。<br>这个方法是 <code>dlyd</code> 中声明的，一旦调用该方法，调用结果会作为该函数的参数回传回来。比如，当所有的 <code>images</code> 以及 <code>section</code> 为 <code>objc-image-info</code> 被加载之后会回调 <code>mapped</code> 方法。<br><code>load</code> 方法也将在这个方法中被调用。</p>
<p><code>_dyld_objc_notify_register</code> 方法的三个参数 <code>map_images</code> 、 <code>load_images</code> 、 <code>unmap_image</code> 其实都是函数指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*_dyld_objc_notify_mapped)</span><span class="params">(<span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> paths[], <span class="keyword">const</span> struct mach_header* <span class="keyword">const</span> mh[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*_dyld_objc_notify_init)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> struct mach_header* mh)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*_dyld_objc_notify_unmapped)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> struct mach_header* mh)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这三个函数指针是在 <code>dyld</code> 中回调的，我们打开 <code>dyld</code> 的源码即可一探究竟，我们直接搜索 <code>_dyld_objc_notify_register</code> :</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _dyld_objc_notify_register(_dyld_objc_notify_mapped    mapped,</span><br><span class="line">                                _dyld_objc_notify_init      init,</span><br><span class="line">                                _dyld_objc_notify_unmapped  unmapped)</span><br><span class="line">&#123;</span><br><span class="line">	dyld::registerObjCNotifiers(mapped, init, unmapped);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着来到 <code>dyld</code> 的 <code>registerObjCNotifiers</code> 方法内部：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerObjCNotifiers</span><span class="params">(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// record functions to call</span></span><br><span class="line">	sNotifyObjCMapped	= mapped;<span class="comment">//map_images</span></span><br><span class="line">	sNotifyObjCInit		= init;<span class="comment">//load_images</span></span><br><span class="line">	sNotifyObjCUnmapped = unmapped;<span class="comment">//unmap_images</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// call 'mapped' function with all images mapped so far</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		notifyBatchPartial(dyld_image_state_bound, <span class="literal">true</span>, <span class="literal">NULL</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line">		<span class="comment">// ignore request to abort during registration</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// &lt;rdar://problem/32209809&gt; call 'init' function on all images already init'ed (below libSystem)</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ImageLoader*&gt;::iterator it=sAllImages.<span class="built_in">begin</span>(); it != sAllImages.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		ImageLoader* <span class="built_in">image</span> = *it;</span><br><span class="line">		<span class="keyword">if</span> ( (<span class="built_in">image</span>-&gt;getState() == dyld_image_state_initialized) &amp;&amp; <span class="built_in">image</span>-&gt;notifyObjC() ) &#123;</span><br><span class="line">			<span class="function">dyld3::ScopedTimer <span class="title">timer</span><span class="params">(DBG_DYLD_TIMING_OBJC_INIT, (<span class="keyword">uint64_t</span>)<span class="built_in">image</span>-&gt;machHeader(), <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">			(*sNotifyObjCInit)(<span class="built_in">image</span>-&gt;getRealPath(), <span class="built_in">image</span>-&gt;machHeader());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> _dyld_objc_notify_mapped		sNotifyObjCMapped;</span><br><span class="line"><span class="keyword">static</span> _dyld_objc_notify_init		sNotifyObjCInit;</span><br><span class="line"><span class="keyword">static</span> _dyld_objc_notify_unmapped	sNotifyObjCUnmapped;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码的内容说明在<code>registerObjCNotifiers</code> 内部， <code>libObjc</code> 传过来的这三个函数指针被 <code>dyld</code> 保存在了本地静态变量中。换句话来说，最终函数指针是否能被调用，取决于这三个静态变量：</p>
<ul>
<li><code>sNotifyObjCMapped</code></li>
<li><code>sNotifyObjCInit</code></li>
<li><code>sNotifyObjCUnmapped</code></li>
</ul>
<p>我们注意到 <code>registerObjCNotifiers</code> 的 <code>try-catch</code> 语句中的 <code>try</code> 分支注释如下：</p>
<blockquote>
<p>call ‘mapped’ function with all images mapped so far<br>调用 <code>mapped</code> 函数来映射所有的镜像</p>
</blockquote>
<p>那么也就是说 <code>notifyBatchPartial</code> 里面会进行真正的函数指针的调用，我们进入这个方法内部：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notifyBatchPartial</span><span class="params">(dyld_image_states state, <span class="keyword">bool</span> orLater, dyld_image_state_change_handler onlyHandler, <span class="keyword">bool</span> preflightOnly, <span class="keyword">bool</span> onlyObjCMappedNotification)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">			<span class="comment">//省略代码</span></span><br><span class="line">			<span class="comment">// tell objc about new images</span></span><br><span class="line">			<span class="keyword">if</span> ( (onlyHandler == <span class="literal">NULL</span>) &amp;&amp; ((state == dyld_image_state_bound) || (orLater &amp;&amp; (dyld_image_state_bound &gt; state))) &amp;&amp; (sNotifyObjCMapped != <span class="literal">NULL</span>) ) &#123;</span><br><span class="line">				<span class="keyword">const</span> <span class="keyword">char</span>* paths[imageCount];</span><br><span class="line">				<span class="keyword">const</span> mach_header* mhs[imageCount];</span><br><span class="line">				<span class="keyword">unsigned</span> objcImageCount = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; imageCount; ++i) &#123;</span><br><span class="line">					ImageLoader* <span class="built_in">image</span> = findImageByMachHeader(infos[i].imageLoadAddress);</span><br><span class="line">					<span class="keyword">bool</span> hasObjC = <span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">if</span> ( <span class="built_in">image</span> != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">						<span class="keyword">if</span> ( <span class="built_in">image</span>-&gt;objCMappedNotified() )</span><br><span class="line">							<span class="keyword">continue</span>;</span><br><span class="line">						hasObjC = <span class="built_in">image</span>-&gt;notifyObjC();</span><br><span class="line">					&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_ACCELERATE_TABLES</span></span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> ( sAllCacheImagesProxy != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">						<span class="keyword">const</span> mach_header* mh;</span><br><span class="line">						<span class="keyword">const</span> <span class="keyword">char</span>* path;</span><br><span class="line">						<span class="keyword">unsigned</span> index;</span><br><span class="line">						<span class="keyword">if</span> ( sAllCacheImagesProxy-&gt;addressInCache(infos[i].imageLoadAddress, &amp;mh, &amp;path, &amp;index) ) &#123;</span><br><span class="line">							hasObjC = (mh-&gt;flags &amp; MH_HAS_OBJC);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">					<span class="keyword">if</span> ( hasObjC ) &#123;</span><br><span class="line">						paths[objcImageCount] = infos[i].imageFilePath;</span><br><span class="line">						mhs[objcImageCount]   = infos[i].imageLoadAddress;</span><br><span class="line">						++objcImageCount;</span><br><span class="line">						<span class="keyword">if</span> ( <span class="built_in">image</span> != <span class="literal">NULL</span> )</span><br><span class="line">							<span class="built_in">image</span>-&gt;setObjCMappedNotified();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> ( objcImageCount != <span class="number">0</span> ) &#123;</span><br><span class="line">					<span class="function">dyld3::ScopedTimer <span class="title">timer</span><span class="params">(DBG_DYLD_TIMING_OBJC_MAP, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">					<span class="keyword">uint64_t</span> t0 = mach_absolute_time();</span><br><span class="line">					(*sNotifyObjCMapped)(objcImageCount, paths, mhs);<span class="comment">//函数指针真正调用的地方</span></span><br><span class="line">					<span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line">					ImageLoader::fgTotalObjCSetupTime += (t1-t0);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//省略代码</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，在 <code>notifyBatchPartial</code> 方法内部，这里的注释:</p>
<blockquote>
<p>tell objc about new images 告诉 <code>objc</code> 镜像已经映射完成了</p>
</blockquote>
<p>弄清楚了三个函数指针是怎么调用的还不够，接下来我们要深入各个函数的内部看里面究竟做了什么样的事情。</p>
<h3 id="探索-map-images"><a href="#探索-map-images" class="headerlink" title="探索 map_images"></a>探索 <code>map_images</code></h3><p>首先是 <code>map_images</code> ，我们来到它的实现:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* map_images</span></span><br><span class="line"><span class="comment">* Process the given images which are being mapped in by dyld.</span></span><br><span class="line"><span class="comment">* Calls ABI-agnostic code after taking ABI-specific locks.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: write-locks runtimeLock</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">map_images(<span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> paths[],</span><br><span class="line">           <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> map_images_nolock(count, paths, mhdrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Process the given images which are being mapped in by dyld.<br>Calls ABI-agnostic code after taking ABI-specific locks.</p>
</blockquote>
<blockquote>
<p>处理由 <code>dyld</code> 映射的给定镜像<br>取得特定于 <code>ABI</code> 的锁后，调用与 <code>ABI</code> 无关的代码。</p>
</blockquote>
<p>这里会继续往下走到 <code>map_images_nolock</code></p>
<p><code>map_images_nolock</code> 内部代码十分冗长，我们经过分析之后，前面的工作基本上都是进行镜像文件信息的提取与统计，所以可以定位到最后的 <code>_read_images</code> ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里进入 <code>_read_images</code> 的条件是 <code>hCount</code> 大于 0， <code>hCount</code> 表示的是 <code>Mach-O</code> 中 <code>header</code> 的数量</p>
<p>OK，我们的主角登场了， <code>_read_images</code> 和 <code>lookupImpOrForward</code> 可以说是我们学习 <code>Runtime</code> 和 <code>iOS</code> 底层里面非常重要的两个概念了， <code>lookUpImpOrForward</code> 已经探索过了，剩下的 <code>_read_images</code> 我们也不能落下。</p>
<h4 id="read-images定义"><a href="#read-images定义" class="headerlink" title="_read_images定义"></a>_read_images定义</h4><p>Perform initial processing of the headers in the linked list beginning with headerList.<br>从 <code>headerList</code> 开始，对已经链接了的 <code>Mach-O</code> 镜像表中的头部进行初始化处理</p>
<p>我们可以看到，整个 <code>_read_images</code> 有接近 400 行代码。</p>
<p>通过查看代码，以及日志打印提示信息，我们大致可以将 <code>_read_images</code> 分为下面几个流程:</p>
<h4 id="read-images具体流程"><a href="#read-images具体流程" class="headerlink" title="_read_images具体流程"></a>_read_images具体流程</h4><p><strong>doneOnce 流程</strong></p>
<p>我们从第一个分支 <code>doneOnce</code> 开始，这个名词顾名思义，只会执行一次：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EACH_HEADER \</span></span><br><span class="line">    hIndex = <span class="number">0</span>;         \</span><br><span class="line">    hIndex &lt; hCount &amp;&amp; (hi = hList[hIndex]); \</span><br><span class="line">    hIndex++</span><br><span class="line">    <span class="keyword">if</span> (!doneOnce) &#123;</span><br><span class="line">        doneOnce = YES;</span><br><span class="line">        launchTime = YES;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">        <span class="comment">// Disable non-pointer isa under some conditions.</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class="line">        <span class="comment">// Disable nonpointer isa if any image contains old Swift code</span></span><br><span class="line">        <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hi-&gt;info()-&gt;containsSwift()  &amp;&amp;</span><br><span class="line">                hi-&gt;info()-&gt;swiftUnstableVersion() &lt; objc_image_info::SwiftVersion3)</span><br><span class="line">            &#123;</span><br><span class="line">                DisableNonpointerIsa = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (PrintRawIsa) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"RAW ISA: disabling non-pointer isa because "</span></span><br><span class="line">                                 <span class="string">"the app or a framework contains Swift code "</span></span><br><span class="line">                                 <span class="string">"older than Swift 3.0"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过宏 <code>SUPPORT_NONPOINTER_ISA</code> 判断当前是否支持开启内存优化的 <code>isa</code><ul>
<li>如果支持，则在某些条件下需要禁用这个优化</li>
</ul>
</li>
<li>通过宏 <code>SUPPORT_INDEXED_ISA</code> 判断当前是否是将类存储在 <code>isa</code> 作为类表索引<ul>
<li>如果是的话，再递归遍历所有的 <code>Mach-O</code> 的头部，并且判断如果是 <code>Swift 3.0</code> 之前的代码，就需要禁用对 <code>isa</code> 的内存优化</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">if</span> TARGET_OS_OSX</span></span><br><span class="line">        <span class="comment">// Disable non-pointer isa if the app is too old</span></span><br><span class="line">        <span class="comment">// (linked before OS X 10.11)</span></span><br><span class="line"><span class="comment">//        if (!dyld_program_sdk_at_least(dyld_platform_version_macOS_10_11)) &#123;</span></span><br><span class="line"><span class="comment">//            DisableNonpointerIsa = true;</span></span><br><span class="line"><span class="comment">//            if (PrintRawIsa) &#123;</span></span><br><span class="line"><span class="comment">//                _objc_inform("RAW ISA: disabling non-pointer isa because "</span></span><br><span class="line"><span class="comment">//                             "the app is too old.");</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Disable non-pointer isa if the app has a __DATA,__objc_rawisa section</span></span><br><span class="line">        <span class="comment">// New apps that load old extensions may need this.</span></span><br><span class="line">        <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hi-&gt;mhdr()-&gt;filetype != MH_EXECUTE) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line">            <span class="keyword">if</span> (getsectiondata(hi-&gt;mhdr(), <span class="string">"__DATA"</span>, <span class="string">"__objc_rawisa"</span>, &amp;<span class="built_in">size</span>)) &#123;</span><br><span class="line">                DisableNonpointerIsa = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (PrintRawIsa) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"RAW ISA: disabling non-pointer isa because "</span></span><br><span class="line">                                 <span class="string">"the app has a __DATA,__objc_rawisa section"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// assume only one MH_EXECUTE image</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过宏 <code>TARGET_OS_OSX</code> 判断是否是 <code>macOS</code> 执行环境</li>
<li>判断 <code>macOS</code> 的系统版本，如果小于 <code>10.11</code> 则说明 <code>app</code> 太陈旧了，需要禁用掉 <code>non-pointer isa</code></li>
<li>然后再遍历所有的 <code>Mach-O</code> 的头部，判断如果有 <code>__DATA__,__objc_rawisa</code> 段的存在，则禁用掉 <code>non-pointer isa</code> ，因为很多新的 <code>app</code> 加载老的扩展的时候会需要这样的判断操作。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// namedClasses</span></span><br><span class="line"><span class="comment">// Preoptimized classes don't go in this table.</span></span><br><span class="line"><span class="comment">// 4/3 is NXMapTable's load factor</span></span><br><span class="line"><span class="keyword">int</span> namedClassesSize = </span><br><span class="line">    (isPreoptimized() ? unoptimizedTotalClasses : totalClasses) * <span class="number">4</span> / <span class="number">3</span>;</span><br><span class="line">gdb_objc_realized_classes =</span><br><span class="line">    NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);</span><br></pre></td></tr></table></figure>

<p>预先优化过的类不会加入到 <code>gdb_objc_realized_classes</code> 这个哈希表中来， <code>gdb_objc_realized_classes</code> 哈希表的装载因子为 0.75，这是一个经过验证的效率很高的扩容临界值。</p>
<ul>
<li>加载所有类到类的 <code>gdb_objc_realized_classes</code> 表中来</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is a misnomer: gdb_objc_realized_classes is actually a list of </span></span><br><span class="line"><span class="comment">// named classes not in the dyld shared cache, whether realized or not.</span></span><br><span class="line"><span class="comment">// This list excludes lazily named classes, which have to be looked up</span></span><br><span class="line"><span class="comment">// using a getClass hook.</span></span><br><span class="line">NXMapTable *gdb_objc_realized_classes;  <span class="comment">// exported for debuggers in objc-gdb.h</span></span><br></pre></td></tr></table></figure>

<p>这是一个误称：gdb_objc_realized_classes 表实际上存储的是不在 <code>dyld</code> 共享缓存里面的命名类，无论这些类是否实现</p>
<p>除了 <code>gdb_objc_realized_classes</code> 表之外，还有一张表 <code>allocatedClasses</code> :</p>
<p>其实 <code>gdb_objc_realized_classes</code> 对 <code>allocatedClasses</code> 是一种包含的关系，一张是类的总表，一张是已经开辟了内存的类表.</p>
<h5 id="Discover-classes-流程"><a href="#Discover-classes-流程" class="headerlink" title="Discover classes 流程"></a>Discover classes 流程</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discover classes. Fix up unresolved future classes. Mark bundle classes.</span></span><br><span class="line"><span class="keyword">bool</span> hasDyldRoots = dyld_shared_cache_some_image_overridden();</span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="keyword">if</span> (! mustReadClasses(hi, hasDyldRoots)) &#123;</span><br><span class="line">        <span class="comment">// Image is sufficiently optimized that we need not call readClass()</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist = _getObjc2ClassList(hi, &amp;count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> headerIsBundle = hi-&gt;isBundle();</span><br><span class="line">    <span class="keyword">bool</span> headerIsPreoptimized = hi-&gt;hasPreoptimizedClasses();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Class cls = (Class)classlist[i];</span><br><span class="line">        Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newCls != cls  &amp;&amp;  newCls) &#123;</span><br><span class="line">            <span class="comment">// Class was moved but not deleted. Currently this occurs </span></span><br><span class="line">            <span class="comment">// only when the new class resolved a future class.</span></span><br><span class="line">            <span class="comment">// Non-lazily realize the class below.</span></span><br><span class="line">            resolvedFutureClasses = (Class *)</span><br><span class="line">                <span class="built_in">realloc</span>(resolvedFutureClasses, </span><br><span class="line">                        (resolvedFutureClassCount+<span class="number">1</span>) * <span class="keyword">sizeof</span>(Class));</span><br><span class="line">            resolvedFutureClasses[resolvedFutureClassCount++] = newCls;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Discover classes. Fix up unresolved future classes. Mark bundle classes.<br>发现类。修正未解析的 <code>future</code> 类，标记 <code>bundle</code> 类。</p>
<ul>
<li>先通过 <code>_getObjc2ClassList</code> 来获取到所有的类</li>
<li>接着还是遍历所有的 <code>Mach-O</code> 的 <code>header</code> 部分，然后通过 <code>mustReadClasses</code> 来判断哪些条件可以跳过读取类这一步骤</li>
<li>读取 <code>header</code> 是否是 <code>Bundle</code></li>
<li>读取 <code>header</code> 是否开启了 <strong>预优化</strong></li>
<li>遍历 <code>_getObjc2ClassList</code> 取出的所有的类<ul>
<li>通过 <code>readClass</code> 来读取类信息</li>
<li>判断如果不相等并且 <code>readClass</code> 结果不为空，则需要重新为类开辟内存</li>
</ul>
</li>
</ul>
<p><strong>Fix up remapped classes 流程</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fix up remapped classes</span></span><br><span class="line"><span class="comment">// Class list and nonlazy class list remain unremapped.</span></span><br><span class="line"><span class="comment">// Class refs and super refs are remapped for message dispatching.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!noClassesRemapped()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        Class *classrefs = _getObjc2ClassRefs(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            remapClassRef(&amp;classrefs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fixme why doesn't test future1 catch the absence of this?</span></span><br><span class="line">        classrefs = _getObjc2SuperRefs(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            remapClassRef(&amp;classrefs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修复 重映射类<br>类表和非懒加载类表没有被重映射 (也就是 <strong>_objc_classlist</strong>)<br>由于消息转发，类引用和父类引用会被重映射 (也就是 <strong>_objc_classrefs</strong>)</p>
<ul>
<li>通过 <code>noClassesRemapped</code> 方法判断是否有类引用(<strong>_objc_classrefs</strong>)需要进行重映射<ul>
<li>如果需要，则遍历 <code>EACH_HEADER</code></li>
<li>通过 <code>_getObjc2ClassRefs</code> 和 <code>_getObjc2SuperRefs</code> 取出当前遍历到的 <code>Mach-O</code> 的类引用和父类引用，然后调用 <code>remapClassRef</code> 进行重映射</li>
</ul>
</li>
</ul>
<p><strong>Fix up @selector references 流程</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Fix up @selector references</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> UnfixedSelectors;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(selLock)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hi-&gt;hasPreoptimizedSelectors()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> isBundle = hi-&gt;isBundle();</span><br><span class="line">            SEL *sels = _getObjc2SelectorRefs(hi, &amp;count);</span><br><span class="line">            UnfixedSelectors += count;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char</span> *name = sel_cname(sels[i]);</span><br><span class="line">                SEL sel = sel_registerNameNoLock(name, isBundle);</span><br><span class="line">                <span class="keyword">if</span> (sels[i] != sel) &#123;</span><br><span class="line">                    sels[i] = sel;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function">SEL <span class="title">sel_registerNameNoLock</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">bool</span> copy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __sel_registerName(name, <span class="number">0</span>, copy);  <span class="comment">// NO lock, maybe copy</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>修正 <code>SEL</code> 引用</p>
</blockquote>
<ul>
<li>操作前先加一个 <code>selLock</code> 锁</li>
<li>然后遍历<code>EACH_HEADER</code><ul>
<li>如果开启了<strong>预优化</strong>，contiue 到下一个 <code>Mach-O</code></li>
<li>通过 <code>_getObjc2SelectorRefs</code> 拿到所有的 <code>SEL</code> 引用</li>
<li>然后对所有的 <code>SEL</code> 引用调用 <code>sel_registerNameNoLock</code> 进行注册</li>
</ul>
</li>
</ul>
<p>也就是说这一流程最主要的目的就是注册 <code>SEL</code> ，我们注册真正发生的地方: <code>__sel_registerName</code> ，这个函数如果大家经常玩 <code>Runtime</code> 肯定不会陌生：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> SEL __sel_registerName(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">bool</span> shouldLock, <span class="keyword">bool</span> copy) </span><br><span class="line">&#123;</span><br><span class="line">    SEL result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldLock) selLock.assertUnlocked();</span><br><span class="line">    <span class="keyword">else</span> selLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!name) <span class="keyword">return</span> (SEL)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    result = search_builtins(name);</span><br><span class="line">    <span class="keyword">if</span> (result) <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">conditional_mutex_locker_t</span> <span class="title">lock</span><span class="params">(selLock, shouldLock)</span></span>;</span><br><span class="line">	<span class="keyword">auto</span> it = namedSelectors.<span class="built_in">get</span>().insert(name);</span><br><span class="line">	<span class="keyword">if</span> (it.second) &#123;</span><br><span class="line">		<span class="comment">// No match. Insert.</span></span><br><span class="line">		*it.first = (<span class="keyword">const</span> <span class="keyword">char</span> *)sel_alloc(name, copy);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (SEL)*it.first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们简单分析一下 <code>__sel_registerName</code> 方法的流程：</p>
<ul>
<li>判断是否要加锁</li>
<li>如果 <code>sel</code> 为空，则返回一个空的 <code>SEL</code></li>
<li>从 <code>builtins</code> 中搜索，看是否已经注册过，如果找到，直接返回结果</li>
<li>从 <code>namedSelectors</code> 哈希表中查询，找到了就返回结果</li>
<li>如果 <code>namedSelectors</code> 未初始化，则创建一下这个哈希表</li>
<li>如果上面的流程都没有找到，则需要调用 <code>sel_alloc</code> 来创建一下 <code>SEL</code> ，然后把新创建的 <code>SEL</code> 插入哈希表中进行缓存的填充</li>
</ul>
<h5 id="Fix-up-old-objc-msgSend-fixup-call-sites-流程"><a href="#Fix-up-old-objc-msgSend-fixup-call-sites-流程" class="headerlink" title="Fix up old objc_msgSend_fixup call sites 流程"></a><strong>Fix up old objc_msgSend_fixup call sites 流程</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_FIXUP</span></span><br><span class="line">    <span class="comment">// Fix up old objc_msgSend_fixup call sites</span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="keyword">message_ref_t</span> *refs = _getObjc2MessageRefs(hi, &amp;count);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (PrintVtables) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"VTABLES: repairing %zu unsupported vtable dispatch "</span></span><br><span class="line">                         <span class="string">"call sites in %s"</span>, count, hi-&gt;fname());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            fixupMessageRef(refs+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: fix up objc_msgSend_fixup"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>修正旧的 <code>objc_msgSend_fixup</code> 调用</p>
<p>这个流程的执行前提是 <code>FIXUP</code> 被开启。</p>
<ul>
<li>还是老套路，遍历<code>EACH_HEADER</code><ul>
<li>通过 <code>_getObjc2MessageRefs</code> 方法来获取当前遍历到的 <code>Mach-O</code> 镜像的所有消息引用</li>
<li>然后遍历这些消息引用，然后调用 <code>fixupMessageRef</code> 进行修正</li>
</ul>
</li>
</ul>
<h5 id="Discover-protocols-流程"><a href="#Discover-protocols-流程" class="headerlink" title="Discover protocols 流程"></a><strong>Discover protocols 流程</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discover protocols. Fix up protocol refs.</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="keyword">extern</span> objc_class OBJC_CLASS_$_Protocol;</span><br><span class="line">    Class cls = (Class)&amp;OBJC_CLASS_$_Protocol;</span><br><span class="line">    ASSERT(cls);</span><br><span class="line">    NXMapTable *protocol_map = protocols();</span><br><span class="line">    <span class="keyword">bool</span> isPreoptimized = hi-&gt;hasPreoptimizedProtocols();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip reading protocols if this is an image from the shared cache</span></span><br><span class="line">    <span class="comment">// and we support roots</span></span><br><span class="line">    <span class="comment">// Note, after launch we do need to walk the protocol as the protocol</span></span><br><span class="line">    <span class="comment">// in the shared cache is marked with isCanonical() and that may not</span></span><br><span class="line">    <span class="comment">// be true if some non-shared cache binary was chosen as the canonical</span></span><br><span class="line">    <span class="comment">// definition</span></span><br><span class="line">    <span class="keyword">if</span> (launchTime &amp;&amp; isPreoptimized) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintProtocols) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"PROTOCOLS: Skipping reading protocols in image: %s"</span>,</span><br><span class="line">                         hi-&gt;fname());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> isBundle = hi-&gt;isBundle();</span><br><span class="line">    <span class="keyword">protocol_t</span> * <span class="keyword">const</span> *protolist = _getObjc2ProtocolList(hi, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        readProtocol(protolist[i], cls, protocol_map, </span><br><span class="line">                     isPreoptimized, isBundle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现协议，并修正协议引用</p>
<h5 id="Fix-up-protocol-references-流程"><a href="#Fix-up-protocol-references-流程" class="headerlink" title="Fix up @protocol references 流程"></a><strong>Fix up @protocol references 流程</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fix up @protocol references</span></span><br><span class="line"><span class="comment">// Preoptimized images may have the right </span></span><br><span class="line"><span class="comment">// answer already but we don't know for sure.</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="comment">// At launch time, we know preoptimized image refs are pointing at the</span></span><br><span class="line">    <span class="comment">// shared cache definition of a protocol.  We can skip the check on</span></span><br><span class="line">    <span class="comment">// launch, but have to visit @protocol refs for shared cache images</span></span><br><span class="line">    <span class="comment">// loaded later.</span></span><br><span class="line">    <span class="keyword">if</span> (launchTime &amp;&amp; hi-&gt;isPreoptimized())</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">protocol_t</span> **protolist = _getObjc2ProtocolRefs(hi, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        remapProtocolRef(&amp;protolist[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对所有的协议做重映射</p>
<h5 id="Realize-non-lazy-classes-流程"><a href="#Realize-non-lazy-classes-流程" class="headerlink" title="Realize non-lazy classes 流程"></a><strong>Realize non-lazy classes 流程</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Realize non-lazy classes (for +load methods and static instances)</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist = hi-&gt;nlclslist(&amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Class cls = remapClass(classlist[i]);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        addClassTableEntry(cls);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;isSwiftStable()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cls-&gt;swiftMetadataInitializer()) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">"Swift class %s with a metadata initializer "</span></span><br><span class="line">                            <span class="string">"is not allowed to be non-lazy"</span>,</span><br><span class="line">                            cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// fixme also disallow relocatable classes</span></span><br><span class="line">            <span class="comment">// We can't disallow all Swift classes because of</span></span><br><span class="line">            <span class="comment">// classes like Swift.__EmptyArrayStorage</span></span><br><span class="line">        &#125;</span><br><span class="line">        realizeClassWithoutSwift(cls, nil);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化<strong>非懒加载类( <code>+load</code> 方法和静态实例</strong>)**</p>
<h5 id="Realize-newly-resolved-future-classes-流程"><a href="#Realize-newly-resolved-future-classes-流程" class="headerlink" title="Realize newly-resolved future classes 流程"></a><strong>Realize newly-resolved future classes 流程</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Realize newly-resolved future classes, in case CF manipulates them</span></span><br><span class="line"><span class="keyword">if</span> (resolvedFutureClasses) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; resolvedFutureClassCount; i++) &#123;</span><br><span class="line">        Class cls = resolvedFutureClasses[i];</span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;isSwiftStable()) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">"Swift class is not allowed to be future"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        realizeClassWithoutSwift(cls, nil);</span><br><span class="line">        cls-&gt;setInstancesRequireRawIsaRecursively(<span class="literal">false</span><span class="comment">/*inherited*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(resolvedFutureClasses);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化新解析出来的 <code>future</code> 类</p>
<h5 id="Discover-categories-流程"><a href="#Discover-categories-流程" class="headerlink" title="Discover categories 流程"></a><strong>Discover categories 流程</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discover categories. Only do this after the initial category</span></span><br><span class="line"><span class="comment">// attachment has been done. For categories present at startup,</span></span><br><span class="line"><span class="comment">// discovery is deferred until the first load_images call after</span></span><br><span class="line"><span class="comment">// the call to _dyld_objc_notify_register completes. rdar://problem/53119145</span></span><br><span class="line"><span class="keyword">if</span> (didInitialAttachCategories) &#123;</span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        load_categories_nolock(hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理所有的分类，包括类和元类</p>
<p>到这里， <code>_read_images</code> 的流程就分析完毕，我们可以新建一个文件来去掉一些干扰的信息，只保留核心的逻辑，这样从宏观的角度来分析更直观:</p>
<p><img src="/images/_read_image_schedule.png" alt="_read_image_schedule"></p>
<p>Q &amp; A 环节<br>Q： <code>dyld</code> 主要逻辑是加载库，也就是镜像文件，但是加载完是怎么读取的呢？<br>A： <code>_read_images</code> 是真正读取的地方</p>
<p>Q: <code>SEL</code> 方法编号何时加载？<br>A: <code>_read_images</code></p>
<h4 id="read-class-分析"><a href="#read-class-分析" class="headerlink" title="read_class 分析"></a>read_class 分析</h4><p>我们探索了 <code>_read_images</code> 方法的流程，接下来让我们把目光放到本文的主题 - <strong>类的加载</strong><br>既然是类的加载，那么我们在前面所探索的类的结构中出现的内容都会一一重现。<br>所以我们不妨直接进行断点调试，让我们略过其它干扰信息，聚焦于类的加载。</p>
<ul>
<li>根据上一小节我们探索的结果， <code>doneOnce</code> 流程中会创建两个哈希表，并没有涉及到类的加载，所以我们跳过</li>
<li>我们来到第二个流程 - <strong>类处理</strong></li>
</ul>
<p>我们在<code>_read_images</code>函数，定位到下面这行代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class cls = (Class)classlist[i];<span class="comment">//断点</span></span><br><span class="line">Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized);</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>cls</code> 的属性、方法、协议以及类名都为空，说明这里类并没有被真正加载完成，我们接着聚焦到 <code>read_class</code> 函数上面，我们进入其内部实现，我们大致浏览之后会定位到如下图所示的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* readClass</span></span><br><span class="line"><span class="comment">* Read a class and metaclass as written by a compiler.</span></span><br><span class="line"><span class="comment">* Returns the new class pointer. This could be: </span></span><br><span class="line"><span class="comment">* - cls</span></span><br><span class="line"><span class="comment">* - nil  (cls has a missing weak-linked superclass)</span></span><br><span class="line"><span class="comment">* - something else (space for this class was reserved by a future class)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Note that all work performed by this function is preflighted by </span></span><br><span class="line"><span class="comment">* mustReadClasses(). Do not change this function without updating that one.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: runtimeLock acquired by map_images or objc_readClassPair</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function">Class <span class="title">readClass</span><span class="params">(Class cls, <span class="keyword">bool</span> headerIsBundle, <span class="keyword">bool</span> headerIsPreoptimized)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mangledName = cls-&gt;nonlazyMangledName();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (missingWeakSuperclass(cls)) &#123;</span><br><span class="line">        <span class="comment">// No superclass (probably weak-linked). </span></span><br><span class="line">        <span class="comment">// Disavow any knowledge of this subclass.</span></span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"CLASS: IGNORING class '%s' with "</span></span><br><span class="line">                         <span class="string">"missing weak-linked superclass"</span>, </span><br><span class="line">                         cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        addRemappedClass(cls, nil);</span><br><span class="line">        cls-&gt;setSuperclass(nil);</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cls-&gt;fixupBackwardDeployingStableSwift();</span><br><span class="line"></span><br><span class="line">    Class replacing = nil;</span><br><span class="line">    <span class="keyword">if</span> (mangledName != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Class newCls = popFutureNamedClass(mangledName)) &#123;</span><br><span class="line">            <span class="comment">// This name was previously allocated as a future class.</span></span><br><span class="line">            <span class="comment">// Copy objc_class to future class's struct.</span></span><br><span class="line">            <span class="comment">// Preserve future's rw data block.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newCls-&gt;isAnySwift()) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">"Can't complete future class request for '%s' "</span></span><br><span class="line">                            <span class="string">"because the real class is too big."</span>,</span><br><span class="line">                            cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">class_rw_t</span> *rw = newCls-&gt;data();</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *old_ro = rw-&gt;ro();</span><br><span class="line">            <span class="built_in">memcpy</span>(newCls, cls, <span class="keyword">sizeof</span>(objc_class));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Manually set address-discriminated ptrauthed fields</span></span><br><span class="line">            <span class="comment">// so that newCls gets the correct signatures.</span></span><br><span class="line">            newCls-&gt;setSuperclass(cls-&gt;getSuperclass());</span><br><span class="line">            newCls-&gt;initIsa(cls-&gt;getIsa());</span><br><span class="line"></span><br><span class="line">            rw-&gt;set_ro((<span class="keyword">class_ro_t</span> *)newCls-&gt;data());</span><br><span class="line">            newCls-&gt;setData(rw);</span><br><span class="line">            freeIfMutable((<span class="keyword">char</span> *)old_ro-&gt;getName());</span><br><span class="line">            <span class="built_in">free</span>((<span class="keyword">void</span> *)old_ro);</span><br><span class="line"></span><br><span class="line">            addRemappedClass(cls, newCls);</span><br><span class="line"></span><br><span class="line">            replacing = cls;</span><br><span class="line">            cls = newCls;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (headerIsPreoptimized  &amp;&amp;  !replacing) &#123;</span><br><span class="line">        <span class="comment">// class list built in shared cache</span></span><br><span class="line">        <span class="comment">// fixme strict assert doesn't work because of duplicates</span></span><br><span class="line">        <span class="comment">// ASSERT(cls == getClass(name));</span></span><br><span class="line">        ASSERT(mangledName == <span class="literal">nullptr</span> || getClassExceptSomeSwift(mangledName));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mangledName) &#123; <span class="comment">//some Swift generic classes can lazily generate their names</span></span><br><span class="line">            addNamedClass(cls, mangledName, replacing);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Class meta = cls-&gt;ISA();</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *metaRO = meta-&gt;bits.safe_ro();</span><br><span class="line">            ASSERT(metaRO-&gt;getNonMetaclass() &amp;&amp; <span class="string">"Metaclass with lazy name must have a pointer to the corresponding nonmetaclass."</span>);</span><br><span class="line">            ASSERT(metaRO-&gt;getNonMetaclass() == cls &amp;&amp; <span class="string">"Metaclass nonmetaclass pointer must equal the original class."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        addClassTableEntry(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for future reference: shared cache never contains MH_BUNDLEs</span></span><br><span class="line">    <span class="keyword">if</span> (headerIsBundle) &#123;</span><br><span class="line">        cls-&gt;data()-&gt;flags |= RO_FROM_BUNDLE;</span><br><span class="line">        cls-&gt;ISA()-&gt;data()-&gt;flags |= RO_FROM_BUNDLE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来类的信息在这里完成了加载，那么为了验证我们的猜想，直接断点调试一下但发现断点根本走不进来，原因在于这里的判断语句</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Class newCls = popFutureNamedClass(mangledName))</span><br></pre></td></tr></table></figure>

<p>判断当前传入的类的类名是否有 <code>future</code> 类的实现，但是我们刚才已经打印了，类名是空的，所以肯定不会执行这里。我们接着往下走：</p>
<ul>
<li>addNamedClass 内部其实是将 <code>cls</code> 插入到 <code>gdb_objc_realized_classes</code> 表</li>
<li>addclassTableEntry 内部是将 <code>cls</code> 插入到 <code>allocatedClasses</code> 表</li>
</ul>
<p>分析完 <code>read_class</code> ，我们回到 <code>_read_images</code> 方法</p>
<p>我们可以看到 <code>read_class</code> 返回的 <code>newCls</code> 会进行一个判断，判断与传入 <code>read_class</code> 之前的 <code>cls</code> 是否相等，而在 <code>read_class</code> 内部只有一个地方对类的内容进行了改动，但是我们刚才测试了是进不去的，所以这个 <code>if</code> 里面的内容我们可以略过，也就是说 <code>resolvedFutureClasses</code> 的内容我们都可以暂时略过。</p>
<p>总结一下 <code>readClass</code> ：</p>
<ul>
<li>判断是不是要后期处理的类<ul>
<li>如果是的话，就取出后期处理的类，读取这个类的 <code>data()</code> 类设置 <code>ro/rw</code></li>
</ul>
</li>
<li>addNamedClass 插入总表</li>
<li>addClassTableEntry 插入已开辟内存的类的表</li>
</ul>
<h4 id="realizeClassWithoutSwift-分析"><a href="#realizeClassWithoutSwift-分析" class="headerlink" title="realizeClassWithoutSwift 分析"></a>realizeClassWithoutSwift 分析</h4><p>通过分析 <code>read_class</code> ，我们可以得知，类已经被注册到两个哈希表中去了，那么现在一切时机都已经成熟了。但是我们还是要略过像 <code>Fix up remapped classes</code> 、 <code>Fix up @selector references</code> 、 <code>fix up old objc_msgSend_fixup call sites</code> 、 <code>Discover protocols. Fix up protocol refs</code> 、 <code>Fix up @protocol references</code> ，因为我们的重点是类的加载，我们最终来到了 <code>Realize non-lazy classes (for +load methods and static instances)</code> ，略去无关信息之后，我们可以看到我们的<br>主角 <code>realizeClassWithoutSwift</code> 闪亮登场了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* realizeClassWithoutSwift</span></span><br><span class="line"><span class="comment">* Performs first-time initialization on class cls, </span></span><br><span class="line"><span class="comment">* including allocating its read-write data.</span></span><br><span class="line"><span class="comment">* Does not perform any Swift-side initialization.</span></span><br><span class="line"><span class="comment">* Returns the real class structure for the class. </span></span><br><span class="line"><span class="comment">* Locking: runtimeLock must be write-locked by the caller</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">realizeClassWithoutSwift</span><span class="params">(Class cls, Class previously)</span></span></span><br></pre></td></tr></table></figure>

<p>从方法的名称以及方法注释我们可以知道， <code>realizeClassWithoutSwift</code> 是进行类的第一次初始化操作，包括分配读写数据也就是我们常说的 <code>rw</code> ，但是并不会进行任何的 <code>Swift</code> 端初始化。我们直接聚焦下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Normal class. Allocate writeable class data.</span></span><br><span class="line">rw = objc::zalloc&lt;<span class="keyword">class_rw_t</span>&gt;();</span><br><span class="line">rw-&gt;set_ro(ro);</span><br><span class="line">rw-&gt;flags = RW_REALIZED|RW_REALIZING|isMeta;</span><br><span class="line">cls-&gt;setData(rw);</span><br></pre></td></tr></table></figure>

<ul>
<li>通过 <code>zalloc</code> 开辟内存空间，返回一个新的 <code>rw</code></li>
<li>把 <code>cls</code> 取出来的 <code>ro</code> 赋值给这个 <code>rw</code></li>
<li>将 <code>rw</code> 设置到 <code>cls</code> 身上</li>
</ul>
<p>可以清楚地看到，此时 <code>rw</code> 还是为空，说明这里只是对 <code>rw</code> 进行了初始化，但是方法、属性、协议这些都没有被添加上。</p>
<p>我们接着往下走:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Realize superclass and metaclass, if they aren't already.</span></span><br><span class="line"><span class="comment">// This needs to be done after RW_REALIZED is set above, for root classes.</span></span><br><span class="line"><span class="comment">// This needs to be done after class index is chosen, for root metaclasses.</span></span><br><span class="line"><span class="comment">// This assumes that none of those classes have Swift contents,</span></span><br><span class="line"><span class="comment">//   or that Swift's initializers have already been called.</span></span><br><span class="line"><span class="comment">//   fixme that assumption will be wrong if we add support</span></span><br><span class="line"><span class="comment">//   for ObjC subclasses of Swift classes.</span></span><br><span class="line">supercls = realizeClassWithoutSwift(remapClass(cls-&gt;getSuperclass()), nil);</span><br><span class="line">metacls = realizeClassWithoutSwift(remapClass(cls-&gt;ISA()), nil);</span><br></pre></td></tr></table></figure>

<p>这里可以看到父类和元类都会递归调用 <code>realizeClassWithoutSwift</code> 来初始化各自的 <code>rw</code> 。为什么在类的加载操作里面要去加载类和元类呢？回忆一下类的结构，答案很简单，要保证 <code>superclass</code> 和 <code>isa</code> 的完整性，也就是保证类的完整性，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update superclass and metaclass in case of remapping</span></span><br><span class="line">cls-&gt;setSuperclass(supercls);</span><br><span class="line">cls-&gt;initClassIsa(metacls);</span><br></pre></td></tr></table></figure>

<p>上面的代码就是最好的证明，初始化完毕的父类和元类被赋值到了类的 <code>superclass</code> 和 <code>isa</code> 上面。</p>
<p>接着往下走可以看到，不光要把父类关联到类上面，还要让父类知道子类的存在。</p>
<p>最后一行代码是 <code>methodizeClass(cls)</code> ，注释显示的是 <code>attach categories</code> ，附加分类到类？我们进入其内部实现一探究竟。</p>
<p>在探索 <code>methodizeClass</code> 前，我们先总结一下 <code>realizeClassWithoutSwift</code> :</p>
<ul>
<li>读取 <code>class</code> 的 <code>data()</code></li>
<li><code>ro/rw</code> 赋值</li>
<li>父类和元类实现<ul>
<li>supercls = realizeClassWithoutSwift(remapClass(cls-&gt;superclass))</li>
<li>metacls = realizeClassWithoutSwift(remapClass(cls-&gt;ISA()))</li>
</ul>
</li>
<li>父类和元类归属关系<ul>
<li>cls-&gt;superclass = supercls</li>
<li>cls-&gt;initClassIsa(metacls)</li>
</ul>
</li>
<li>将当前类链接到其父类的子类列表 addSubclass(supercls, cls)</li>
</ul>
<h4 id="methodizeClass-分析"><a href="#methodizeClass-分析" class="headerlink" title="methodizeClass 分析"></a>methodizeClass 分析</h4><p>realizeClassWithoutSwift方法最后一行调用的是<code>methodizeClass</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* methodizeClass</span></span><br><span class="line"><span class="comment">* Fixes up cls's method list, protocol list, and property list.</span></span><br><span class="line"><span class="comment">* Attaches any outstanding categories.</span></span><br><span class="line"><span class="comment">* Locking: runtimeLock must be held by the caller</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodizeClass</span><span class="params">(Class cls, Class previously)</span></span></span><br></pre></td></tr></table></figure>

<p>对类的方法列表、协议列表和属性列表进行修正<br>附加 <code>category</code> 到类上面来</p>
<p>我们直接往下面走：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Install methods and properties that the class implements itself.</span></span><br><span class="line"><span class="keyword">method_list_t</span> *<span class="built_in">list</span> = ro-&gt;baseMethods();</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">    prepareMethodLists(cls, &amp;<span class="built_in">list</span>, <span class="number">1</span>, YES, isBundleClass(cls), <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (rwe) rwe-&gt;methods.attachLists(&amp;<span class="built_in">list</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从 <code>ro</code> 中取出<strong>方法列表</strong>附加到 <code>rw</code> 上</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">property_list_t</span> *proplist = ro-&gt;baseProperties;</span><br><span class="line"><span class="keyword">if</span> (rwe &amp;&amp; proplist) &#123;</span><br><span class="line">    rwe-&gt;properties.attachLists(&amp;proplist, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从 <code>ro</code> 中取出<strong>属性列表</strong>附加到 <code>rw</code> 上</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol_list_t</span> *protolist = ro-&gt;baseProtocols;</span><br><span class="line"><span class="keyword">if</span> (rwe &amp;&amp; protolist) &#123;</span><br><span class="line">    rwe-&gt;protocols.attachLists(&amp;protolist, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从 <code>ro</code> 中取出<strong>协议列表</strong>附加到 <code>rw</code> 上</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Attach categories.</span></span><br><span class="line"><span class="keyword">if</span> (previously) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isMeta) &#123;</span><br><span class="line">        objc::unattachedCategories.attachToClass(cls, previously,</span><br><span class="line">                                                 ATTACH_METACLASS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// When a class relocates, categories with class methods</span></span><br><span class="line">        <span class="comment">// may be registered on the class itself rather than on</span></span><br><span class="line">        <span class="comment">// the metaclass. Tell attachToClass to look for those.</span></span><br><span class="line">        objc::unattachedCategories.attachToClass(cls, previously,</span><br><span class="line">                                                 ATTACH_CLASS_AND_METACLASS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">objc::unattachedCategories.attachToClass(cls, cls,</span><br><span class="line">                                         isMeta ? ATTACH_METACLASS : ATTACH_CLASS);</span><br></pre></td></tr></table></figure>

<ul>
<li>从 <code>cls</code> 中取出未附加的分类进行附加操作</li>
</ul>
<h3 id="探索-load-images"><a href="#探索-load-images" class="headerlink" title="探索 load_images"></a>探索 load_images</h3><p>我们接着探索 <code>_dyld_objc_notify_register</code> 的第二个参数 <code>load_images</code> ，这个函数指针是在什么时候调用的呢，同样的，我们接着在 <code>dyld</code> 源码中搜索对应的函数指针 <code>sNotifyObjCInit</code> :</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ImageLoader*&gt;::iterator it=sAllImages.<span class="built_in">begin</span>(); it != sAllImages.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">	ImageLoader* <span class="built_in">image</span> = *it;</span><br><span class="line">	<span class="keyword">if</span> ( (<span class="built_in">image</span>-&gt;getState() == dyld_image_state_initialized) &amp;&amp; <span class="built_in">image</span>-&gt;notifyObjC() ) &#123;</span><br><span class="line">		<span class="function">dyld3::ScopedTimer <span class="title">timer</span><span class="params">(DBG_DYLD_TIMING_OBJC_INIT, (<span class="keyword">uint64_t</span>)<span class="built_in">image</span>-&gt;machHeader(), <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">		(*sNotifyObjCInit)(<span class="built_in">image</span>-&gt;getRealPath(), <span class="built_in">image</span>-&gt;machHeader());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在 <code>notifySingle</code> 方法内部， <code>sNotifyObjCInit</code> 函数指针被调用了。根据我们上一篇文章探索 <code>dyld</code> 底层可以知道， <code>_load_images</code> 应该是对于每一个加载进来的 <code>Mach-O</code> 镜像都会递归调用一次。</p>
<p>我们来到 <code>libObjc</code> 源码中 <code>load_images</code> 的定义处:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* load_images</span></span><br><span class="line"><span class="comment">* Process +load in the given images which are being mapped in by dyld.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: write-locks runtimeLock and loadMethodLock</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">bool</span> <span class="title">hasLoadMethods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">prepare_load_methods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span>;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">load_images(<span class="keyword">const</span> <span class="keyword">char</span> *path __unused, <span class="keyword">const</span> struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!didInitialAttachCategories &amp;&amp; didCallDyldNotifyRegister) &#123;</span><br><span class="line">        didInitialAttachCategories = <span class="literal">true</span>;</span><br><span class="line">        loadAllCategories();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Return without taking locks if there are no +load methods here.</span></span><br><span class="line">    <span class="keyword">if</span> (!hasLoadMethods((<span class="keyword">const</span> headerType *)mh)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="function"><span class="keyword">recursive_mutex_locker_t</span> <span class="title">lock</span><span class="params">(loadMethodLock)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// Discover load methods</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock2</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">        prepare_load_methods((<span class="keyword">const</span> headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>处理由 <code>dyld</code> 映射的给定镜像中的 <code>+load</code> 方法</p>
</blockquote>
<ul>
<li>判断是否有 <code>load</code> 方法，如果没有，直接返回</li>
<li>搜索 <code>load</code> 方法，具体实现通过 <code>prepare_load_methods</code></li>
<li>调用 <code>load</code> 方法，具体实现通过 <code>call_load_methods</code></li>
</ul>
<h4 id="prepare-load-methods-分析"><a href="#prepare-load-methods-分析" class="headerlink" title="prepare_load_methods 分析"></a>prepare_load_methods 分析</h4><p>从这个方法名称，我们猜测这里应该做的是 <code>load</code> 方法的一些预处理工作，让我们来到源码进行分析：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_load_methods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count, i;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">category_t</span> * <span class="keyword">const</span> *categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">category_t</span> *cat = categorylist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;isSwiftStable()) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">"Swift class extensions and categories on Swift "</span></span><br><span class="line">                        <span class="string">"classes are not allowed to have +load methods"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        realizeClassWithoutSwift(cls, nil);</span><br><span class="line">        ASSERT(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* prepare_load_methods</span></span><br><span class="line"><span class="comment">* Schedule +load for classes in this image, any un-+load-ed </span></span><br><span class="line"><span class="comment">* superclasses in other images, and any categories in this image.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="comment">// Recursively schedule +load for cls and any un-+load-ed superclasses.</span></span><br><span class="line"><span class="comment">// cls must already be connected.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule_class_load</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    ASSERT(cls-&gt;isRealized());  <span class="comment">// _read_images should realize</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">    schedule_class_load(cls-&gt;getSuperclass());</span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* add_class_to_loadable_list</span></span><br><span class="line"><span class="comment">* Class cls has just become connected. Schedule it for +load if</span></span><br><span class="line"><span class="comment">* it implements a +load method.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_class_to_loadable_list</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IMP method;</span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line">    method = cls-&gt;getLoadMethod();</span><br><span class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;  <span class="comment">// Don't bother if cls has no +load method</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(<span class="string">"LOAD: class '%s' scheduled for +load"</span>, </span><br><span class="line">                     cls-&gt;nameForLogging());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class="line">        loadable_classes_allocated = loadable_classes_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        loadable_classes = (struct loadable_class *)</span><br><span class="line">            <span class="built_in">realloc</span>(loadable_classes,</span><br><span class="line">                              loadable_classes_allocated *</span><br><span class="line">                              <span class="keyword">sizeof</span>(struct loadable_class));</span><br><span class="line">    &#125;</span><br><span class="line">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">    loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先通过 <code>_getObjc2NonlazyClassList</code> 获取所有已经加载进去的类列表</p>
</li>
<li><p>然后通过<code>schedule_class_load</code> 遍历这些类</p>
<ul>
<li>递归调用遍历父类的 <code>load</code> 方法，确保父类的 <code>load</code> 方法顺序排在子类的前面</li>
<li>通过 <code>add_class_to_loadable_list</code> , 把类的 <code>load</code> 方法存在 <code>loadable_classes</code> 里面</li>
</ul>
</li>
<li><p>完成 <code>schedule_class_load</code> 之后，通过 <code>_getObjc2NonlazyCategoryList</code> 取出所有分类数据</p>
</li>
<li><p>然后遍历这些分类</p>
<ul>
<li>通过 <code>realizeClassWithoutSwift</code> 来防止类没有初始化，如果已经初始化了则不影响</li>
<li>通过 <code>add_category_to_loadable_list</code> ，加载分类中的 <code>load</code> 方法到 <code>loadable_categories</code> 里面</li>
</ul>
</li>
</ul>
<h4 id="call-load-methods-分析"><a href="#call-load-methods-分析" class="headerlink" title="call_load_methods 分析"></a>call_load_methods 分析</h4><p>通过名称我们可以知道 <code>call_load_methods</code> 应该就是 <code>load</code> 方法被调用的地方了。我们直接看源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* call_load_methods</span></span><br><span class="line"><span class="comment">* Call all pending class and category +load methods.</span></span><br><span class="line"><span class="comment">* Class +load methods are called superclass-first. </span></span><br><span class="line"><span class="comment">* Category +load methods are not called until after the parent class's +load.</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* This method must be RE-ENTRANT, because a +load could trigger </span></span><br><span class="line"><span class="comment">* more image mapping. In addition, the superclass-first ordering </span></span><br><span class="line"><span class="comment">* must be preserved in the face of re-entrant calls. Therefore, </span></span><br><span class="line"><span class="comment">* only the OUTERMOST call of this function will do anything, and </span></span><br><span class="line"><span class="comment">* that call will handle all loadable classes, even those generated </span></span><br><span class="line"><span class="comment">* while it was running.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* The sequence below preserves +load ordering in the face of </span></span><br><span class="line"><span class="comment">* image loading during a +load, and make sure that no </span></span><br><span class="line"><span class="comment">* +load method is forgotten because it was added during </span></span><br><span class="line"><span class="comment">* a +load call.</span></span><br><span class="line"><span class="comment">* Sequence:</span></span><br><span class="line"><span class="comment">* 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line"><span class="comment">* 2. Call category +loads ONCE.</span></span><br><span class="line"><span class="comment">* 3. Run more +loads if:</span></span><br><span class="line"><span class="comment">*    (a) there are more classes to load, OR</span></span><br><span class="line"><span class="comment">*    (b) there are some potential category +loads that have </span></span><br><span class="line"><span class="comment">*        still never been attempted.</span></span><br><span class="line"><span class="comment">* Category +loads are only run once to ensure "parent class first" </span></span><br><span class="line"><span class="comment">* ordering, even if a category +load triggers a new loadable class </span></span><br><span class="line"><span class="comment">* and a new loadable category attached to that class. </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: loadMethodLock must be held by the caller </span></span><br><span class="line"><span class="comment">*   All other locks must not be held.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = NO;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = YES;</span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>call_load_methods<br>调用类和类别中所有未决的 <code>+load</code> 方法<br>类里面 <code>+load</code> 方法是父类优先调用的<br>而在父类的 <code>+load</code> 之后才会调用分类的 <code>+load</code> 方法</p>
</blockquote>
<ul>
<li>通过 <code>objc_autoreleasePoolPush</code> 压栈一个自动释放池</li>
<li><code>do-while</code>循环开始<ul>
<li>循环调用类的 <code>+load</code> 方法直到找不到为止</li>
<li>调用一次分类中的 <code>+load</code> 方法</li>
</ul>
</li>
<li>通过 <code>objc_autoreleasePoolPop</code> 出栈一个自动释放池</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此， <code>_objc_init</code> 和 <code>_dyld_objc_notify_register</code> 我们就分析完了，我们对类的加载有了更细致的认知。 <code>iOS</code> 底层有时候探索起来确实很枯燥，但是如果能找到高效的方法以及明确自己的所探索的方向，会让自己从宏观上重新审视这门技术。是的，技术只是工具，我们不能被技术所绑架，我们要做到有的放矢的去探索，这样才能事半功倍。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/14/iOS%E5%BA%95%E5%B1%82%EF%BC%9A%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B-main()%E5%87%BD%E6%95%B0%E4%B9%8B%E5%89%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/14/iOS%E5%BA%95%E5%B1%82%EF%BC%9A%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B-main()%E5%87%BD%E6%95%B0%E4%B9%8B%E5%89%8D/" class="post-title-link" itemprop="url">iOS底层：应用加载流程 main()函数之前</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-14 09:57:56" itemprop="dateCreated datePublished" datetime="2021-05-14T09:57:56+08:00">2021-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-17 11:12:23" itemprop="dateModified" datetime="2021-05-17T11:12:23+08:00">2021-05-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>App从点击图标就开启了生命周期，本文从App启动开始探索。</p>
<h3 id="前导知识"><a href="#前导知识" class="headerlink" title="前导知识"></a>前导知识</h3><h4 id="Mach-O文件"><a href="#Mach-O文件" class="headerlink" title="Mach-O文件"></a>Mach-O文件</h4><p>Mach-O is a bunch of file types for different run time executables.<br><code>Mach-O</code> 是 <code>iOS</code> 系统不同运行时期<strong>可执行的文件</strong>的文件类型统称。</p>
<p>维基百科上关于 <code>Mach-O</code> 的描述：</p>
<blockquote>
<p>Mach-O 是 Mach object 文件格式的缩写，它是一种用于记录可执行文件、对象代码、共享库、动态加载代码和内存转储的文件格式。作为 a.out 格式的替代品，Mach-O 提供了更好的扩展性，并提升了符号表中信息的访问速度。<br>大多数基于 Mach 内核的操作系统都使用 Mach-O。NeXTSTEP、OS X 和 iOS 是使用这种格式作为本地可执行文件、库和对象代码的例子。</p>
</blockquote>
<p><code>Mach-O</code>有三种文件类型：Executable<code>、</code>Dylib<code>、</code>Bundle</p>
<ul>
<li><p>ExecutableL类型</p>
<p>So the first executable, that’s the main binary in an app, it’s also the main binary in an app extension.<br><code>Executable</code> 是 <code>app</code> 的二进制主文件，同时也是 <code>app extension</code> 的二进制主文件</p>
<p>我们一般可以在 <code>Xcode</code> 项目中的 <code>Products</code> 文件夹中找到它.</p>
</li>
<li><p><code>Dylib</code>类型</p>
<p>A dylib is a dynamic library, on other platforms meet, you may know those as DSOs or DLLs.<br><code>dylib</code> 是动态库，在其他平台也叫 <code>DSO</code> 或者 <code>DLL</code>。</p>
<p>对于接触 <code>iOS</code> 开发比较早的同学，可能知道我们在 <code>Xcode 7</code> 之前添加一些比如 <code>sqlite</code> 的库的时候，其后缀名为 <code>dylib</code>，而 <code>Xcode 7</code> 之后后缀名都改成了 <code>tbd</code>。</p>
<p>这里引用 <a href="https://stackoverflow.com/questions/31450690/why-xcode-7-shows-tbd-instead-of-dylib" target="_blank" rel="noopener">StackoverFlow</a> 上的一篇回答。</p>
<blockquote>
<p>So it appears that the .dylib file is the actual library of binary code that your project is using and is located in the /usr/lib/ directory on the user’s device. The .tbd file, on the other hand, is just a text file that is included in your project and serves as a link to the required .dylib binary. Since this text file is much smaller than the binary library, it makes the SDK’s download size smaller.</p>
</blockquote>
<p>刚刚我们简单介绍了动态库，还有一种库是静态库，他们的区别是什么呢。</p>
<p>我们先看一下编译的过程：</p>
<p><img src="/images/compile_process.png" alt="compile_process"></p>
<p>当然，这个过程中间其实还设计到编译器前端的 <code>词法分析</code>、<code>语法分析</code>、<code>语义分析</code>、<code>优化</code> 等流程，我们在后面探索 <code>LLVM</code> 和 <code>Clang</code> 的时候会详细介绍。</p>
<p>回到刚才的话题，静态库和动态库的区别：</p>
<blockquote>
<p>Static frameworks are linked at <strong>compile time</strong>. Dynamic frameworks are linked <strong>at runtime</strong>.</p>
</blockquote>
<p>静态库和动态库都是编译好的二进制文件，只是用法不同。那为什么要分动态和静态库呢？</p>
<p><img src="/images/static_link.png" alt="static_link"></p>
<p><img src="/images/dyld_link.png" alt="dyld_link"></p>
<p>通过上面两幅图我们可以知道：</p>
<ul>
<li>静态库表现为：在链接阶段会将汇编生成的目标文件和引用的库一起链接打包到可执行文件中。</li>
<li>动态库的表现为：程序编译并不会链接到目标代码中，在程序可执行文件里面会保留对动态库的引用，其中动态库分为动态链接库和动态加载库。<ul>
<li>动态链接库：在没有被加载到内存的前提下，当可执行文件被加载，动态库也随着被加载到内存中。在<code>Linked Framework and Libraries</code>设置的一些<code>share libraries</code>。【随着程序启动而启动】</li>
<li>动态加载库：当需要的时候再使用<code>dlopen</code>等通过代码或者命令的方式来加载。【在程序启动之后】</li>
</ul>
</li>
</ul>
</li>
<li><p><code>Bundle</code>类型</p>
<p>Now a bundle’s a special kind of dylib that you cannot link against, all you can do is load it at run time by an dlopen and that’s used on a Mac OS for plug-ins.<br>现阶段 Bundle 是一种特殊类型的 dylib，你是无法对其进行链接的。你所能做的是在 Runtime 运行时去通过 dlopen 来加载它，它可以在 macOS 上用于插件。</p>
</li>
<li><p><code>Image</code>和<code>Framework</code></p>
<p>Image refers to any of these three types.<br>镜像文件包含了上述的三种文件类型</p>
<p>a framework is a dylib with a special directory structure around it to holds files needed by that dylib.<br>有很多东西都叫做 Framework，但在本文中，Framework 指的是一个 dylib，它周围有一个特殊的目录结构来保存该 dylib 所需的文件。</p>
</li>
</ul>
<h4 id="Mach-O结构分析"><a href="#Mach-O结构分析" class="headerlink" title="Mach-O结构分析"></a>Mach-O结构分析</h4><h5 id="segment段"><a href="#segment段" class="headerlink" title="segment段"></a><code>segment</code>段</h5><p><img src="/images/Mach-O.png" alt="Mach-O"></p>
<p><code>Mach-O</code>镜像文件是由<code>segments</code>段组成的。</p>
<ul>
<li><p>段的名称为大写格式</p>
<p>所有的段都是 <code>page size</code> 的倍数。</p>
</li>
<li><p>arm64 上段大小为 <code>16</code> 字节</p>
</li>
<li><p>其它架构为 <code>4</code> 字节</p>
</li>
</ul>
<p>这里再提及一下虚拟内存和内存页的知识：</p>
<p><code>具有 VM 机制的操作系统，会对每个运行的进程创建一个逻辑地址空间 logical address space 或者叫虚拟地址空间 virtual address space；该空间的大小由操作系统位数决定：32 位的操作系统，其逻辑地址空间的大小为 4GB，64位的操作系统为 2^34 GB（其计算方式是 2^32 || 2^64(理论上是64位，x86 Intel 是48位)）。</code><br><img src="/images/vitual_memory.png" alt="vitual_memory"></p>
<p><code>虚拟地址空间(或者逻辑地址空间)会被分为相同大小的块，这些块被称为内存页（page）。计算机处理器和它的内存管理单元（MMU - memory management uinit）维护着一张将程序的逻辑地址空间映射到物理地址上的分页表</code>page table<code>。</code></p>
<p><code>在</code>masOS<code>和早版本的</code>iOS<code>中，分页的大小为</code>4kB<code>。在之后的基于</code>A7<code>和</code>A8<code>的系统中，虚拟内存（</code>64<code>位的地址空间）地址空间的分页大小变为了</code>16KB<code>，而物理RAM上的内存分页大小仍然维持在</code>4KB<code>；基于A9及之后的系统，虚拟内存和物理内存的分页都是</code>16KB<code>。</code></p>
<h5 id="section"><a href="#section" class="headerlink" title="section"></a>section</h5><p><img src="/images/Mach-O_section.png" alt="Mach-O_section"></p>
<p>在 segment 段内部还有许多的 section 区。section 名称为小写格式。</p>
<p>But sections are really just a subrange of a segment, they don’t have any of the constraints of being page size, but they are non-overlapping.<br>但是 sections 节实际上只是一个 segment 段的子范围，它们没有页面大小的任何限制，但是它们是不重叠的。</p>
<p>通过<code>MachOView</code>工具查看App的二进制可执行文件可以看到：</p>
<p><img src="/images/section_show.png" alt="section_show"></p>
<h4 id="常见的segments"><a href="#常见的segments" class="headerlink" title="常见的segments"></a>常见的<code>segments</code></h4><ul>
<li><p><code>_TEXT</code>:代码段，包括头文件、代码和常量。只读不可修改</p>
<p><img src="/images/_TEXT_image.png" alt="_TEXT_image"></p>
</li>
<li><p><code>_DATA</code>：数据段，包括全局变量，静态变量等。可读可写。</p>
<p><img src="/images/_DATA_image.png" alt="_DATA_image"></p>
</li>
<li><p><code>_LINKEDIT</code>：如何加载程序的元数据, 包含了方法和变量的元数据（位置，偏移量），以及代码签名等信息。只读不可修改。</p>
<p><img src="/images/_LINKEDIT_image.png" alt="_LINKEDIT_image"></p>
</li>
</ul>
<h5 id="Mach-O-Universal-Files"><a href="#Mach-O-Universal-Files" class="headerlink" title="Mach-O Universal Files"></a>Mach-O Universal Files</h5><p><img src="/images/Mach-o_UniversalFiles.png" alt="Mach-o_UniversalFiles"></p>
<p><code>Mach-O</code> 通用文件，将多种架构的 <code>Mach-O</code> 文件合并而成。它通过 <code>header</code> 来记录不同架构在文件中的偏移量，<code>segement</code> 占多个分页，<code>header</code>占一页的空间。可能有人会觉得 <code>header</code> 单独占一页会浪费空间，但这有利于虚拟内存的实现。</p>
<h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p><img src="/images/virtualMemory_image.png" alt="virtualMemory_image"></p>
<p>虚拟内存是一层<strong>间接寻址</strong>。</p>
<p>虚拟内存解决的是管理所有进程使用<strong>物理 RAM</strong> 的问题。通过添加间接层来让每个进程使用<strong>逻辑地址空间</strong>，它可以映射到 RAM 上的某个物理页上。这种映射不是一对一的，逻辑地址可能映射不到 RAM 上，也可能有多个逻辑地址映射到同一个物理 RAM 上。</p>
<ul>
<li>针对第一种情况，当进程要存储逻辑地址内容时会触发 page fault。</li>
<li>而第二种情况就是多进程共享内存。</li>
<li>对于文件可以不用一次性读入整个文件，可以使用分页映射 mmap() 的方式读取。也就是把文件某个片段映射到进程逻辑内存的某个页上。当某个想要读取的页没有在内存中，就会触发 page fault，内核只会读入那一页，实现文件的懒加载。也就是说 Mach-O 文件中的 __TEXT 段可以映射到多个进程，并可以懒加载，且进程之间共享内存。</li>
<li>__DATA 段是可读写的。这里使用到了 Copy-On-Write 技术，简称 COW。也就是多个进程共享一页内存空间时，一旦有进程要做写操作，它会先将这页内存内容复制一份出来，然后重新映射逻辑地址到新的 RAM 页上。也就是这个进程自己拥有了那页内存的拷贝。这就涉及到了 clean/dirty page 的概念。dirty page 含有进程自己的信息，而 clean page 可以被内核重新生成（重新读磁盘）。所以 dirty page 的代价大于 clean page。</li>
</ul>
<h4 id="多进程加载Mach-O镜像"><a href="#多进程加载Mach-O镜像" class="headerlink" title="多进程加载Mach-O镜像"></a>多进程加载<code>Mach-O</code>镜像</h4><p><img src="/images/Mach-O_image_loading.png" alt="Mach-O_image_loading"></p>
<ul>
<li>所以在多个进程加载 Mach-O 镜像时 __TEXT 和 __LINKEDIT 因为只读，都是可以共享内存的，读取速度就会很快。</li>
<li>而 __DATA 因为可读写，就有可能会产生 dirty page，如果检测到有 clean page 就可以直接使用，反之就需要重新读取 DATA page。一旦产生了 dirty page，当 dyld 执行结束后，__LINKEDIT 需要通知内核当前页面不再需要了，当别人需要的使用时候就可以重新 clean 这些页面。</li>
</ul>
<h4 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h4><p><code>ASLR</code> (Address Space Layout Randomization) 地址空间布局随机化，镜像会在随机的地址上加载。</p>
<h4 id="Code-Signing"><a href="#Code-Signing" class="headerlink" title="Code Signing"></a>Code Signing</h4><p>可能我们认为 <code>Xcode</code> 会把整个文件都做加密 <code>hash</code> 并用做数字签名。其实为了在运行时验证 <code>Mach-O</code> 文件的签名，并不是每次重复读入整个文件，而是把每页内容都生成一个单独的加密散列值，并存储在 <code>__LINKEDIT</code> 中。这使得文件每页的内容都能及时被校验确并保不被篡改。</p>
<h4 id="exec"><a href="#exec" class="headerlink" title="exec()"></a><code>exec()</code></h4><p><img src="/images/exec_image.png" alt="exec_image"></p>
<p>Exec is a system call. When you trap into the kernel, you basically say I want to replace this process with this new program.</p>
<p>exec() 是一个系统调用。系统内核把应用映射到新的地址空间，且每次起始位置都是随机的（因为使用 ASLR）。并将起始位置到 0x000000 这段范围的进程权限都标记为不可读写不可执行。如果是 32 位进程，这个范围至少是 4KB；对于 64 位进程则至少是 4GB 。NULL 指针引用和指针截断误差都是会被它捕获。这个范围也叫做 PAGEZERO。</p>
<h4 id="dyld"><a href="#dyld" class="headerlink" title="dyld"></a><code>dyld</code></h4><p><img src="/images/dyld_image.png" alt="dyld_image"></p>
<p><code>Unix 的前二十年很安逸，因为那时还没有发明动态链接库。有了动态链接库后，一个用于加载链接库的帮助程序被创建。在苹果的平台里是 dyld，其他 Unix 系统也有 ld.so。 当内核完成映射进程的工作后会将名字为 dyld 的 Mach-O 文件映射到进程中的随机地址，它将 PC 寄存器设为 dyld 的地址并运行。dyld 在应用进程中运行的工作是加载应用依赖的所有动态链接库，准备好运行所需的一切，它拥有的权限跟应用一样。</code></p>
<h4 id="dyld流程"><a href="#dyld流程" class="headerlink" title="dyld流程"></a><code>dyld</code>流程</h4><p><img src="/images/dyld_process_image.png" alt="dyld_process_image"></p>
<ul>
<li><p>Load dylibs<br><code>从主执行文件的 header 获取到需要加载的所依赖动态库列表，而 header 早就被内核映射过。然后它需要找到每个 dylib，然后打开文件读取文件起始位置，确保它是 Mach-O 文件。接着会找到代码签名并将其注册到内核。然后在 dylib 文件的每个 segment 上调用 mmap()。应用所依赖的 dylib 文件可能会再依赖其他 dylib，所以 dyld 所需要加载的是动态库列表一个递归依赖的集合。一般应用会加载 100 到 400 个 dylib 文件，但大部分都是系统 dylib，它们会被预先计算和缓存起来，加载速度很快。</code></p>
</li>
<li><p>Fix-ups<br><code>在加载所有的动态链接库之后，它们只是处在相互独立的状态，需要将它们绑定起来，这就是 Fix-ups。代码签名使得我们不能修改指令，那样就不能让一个 dylib 的调用另一个 dylib。这时需要加很多间接层。
现代 code-gen 被叫做动态 PIC（Position Independent Code），意味着代码可以被加载到间接的地址上。当调用发生时，code-gen 实际上会在 __DATA 段中创建一个指向被调用者的指针，然后加载指针并跳转过去。所以 dyld 做的事情就是修正（fix-up）指针和数据。Fix-up 有两种类型，rebasing 和 binding。</code></p>
</li>
<li><p>Rebasing 和 Binding</p>
<p><code>Rebasing：在镜像内部调整指针的指向
Binding：将指针指向镜像外部的内容</code></p>
</li>
</ul>
<p><code>dyld</code> 的时间线由上图可知为：</p>
<p>Load dylibs -&gt; Rebase -&gt; Bind -&gt; ObjC -&gt; Initializers</p>
<h4 id="dyld2-amp-amp-dyld3"><a href="#dyld2-amp-amp-dyld3" class="headerlink" title="dyld2 &amp;&amp; dyld3"></a>dyld2 &amp;&amp; dyld3</h4><p><img src="/images/dyld3_image.png" alt="dyld3_image"></p>
<p>在 <code>iOS 13</code> 之前，所有的第三方 <code>App</code> 都是通过 <code>dyld 2</code> 来启动 <code>App</code> 的，主要过程如下：</p>
<ul>
<li>解析 <code>Mach-O</code> 的 <code>Header</code> 和 <code>Load Commands</code>，找到其依赖的库，并递归找到所有依赖的库</li>
<li>加载 <code>Mach-O</code> 文件</li>
<li>进行符号查找</li>
<li>绑定和变基</li>
<li>运行初始化程序</li>
</ul>
<p>dyld3 被分为了三个组件：</p>
<ul>
<li>一个进程外的 MachO 解析器<ul>
<li>预先处理了所有可能影响启动速度的 search path、@rpaths 和环境变量</li>
<li>然后分析 Mach-O 的 Header 和依赖，并完成了所有符号查找的工作</li>
<li>最后将这些结果创建成了一个启动闭包</li>
<li>这是一个普通的 daemon 进程，可以使用通常的测试架构</li>
</ul>
</li>
<li>一个进程内的引擎，用来运行启动闭包<ul>
<li>这部分在进程中处理</li>
<li>验证启动闭包的安全性，然后映射到 dylib 之中，再跳转到 main 函数</li>
<li>不需要解析 Mach-O 的 Header 和依赖，也不需要符号查找。</li>
</ul>
</li>
<li>一个启动闭包缓存服务<ul>
<li>系统 App 的启动闭包被构建在一个 Shared Cache 中， 我们甚至不需要打开一个单独的文件</li>
<li>对于第三方的 App，我们会在 App 安装或者升级的时候构建这个启动闭包。</li>
<li>在 iOS、tvOS、watchOS中，这这一切都是 App 启动之前完成的。在 macOS 上，由于有 Side Load App，进程内引擎会在首次启动的时候启动一个 daemon 进程，之后就可以使用启动闭包启动了。</li>
</ul>
</li>
</ul>
<p>dyld 3 把很多耗时的查找、计算和 I/O 的事前都预先处理好了，这使得启动速度有了很大的提升。</p>
<p>好了，先导知识就总结到这里，接下来让我们调整呼吸进入下一章~</p>
<h3 id="App加载分析"><a href="#App加载分析" class="headerlink" title="App加载分析"></a>App加载分析</h3><p>我们在探索 <code>iOS</code> 底层的时候，对于对象、类、方法有了一定的认知哦，接下来我们就一起来探索一下应用是怎么加载的。</p>
<p>我们直接新建一个 <code>Single View App</code> 的项目，然后在 <code>main.m</code> 中打一个断点:</p>
<p><img src="/images/demoMain_image.png" alt="demoMain_image"></p>
<p>可以看到堆栈信息为：</p>
<p><img src="/images/launch_stack_image.png" alt="launch_stack_image"></p>
<p>可以看到堆栈栈底是<code>_dyld_start</code>，说明App加载是从<code>_dyld_start</code>开始的</p>
<h4 id="dyld-start"><a href="#dyld-start" class="headerlink" title="_dyld_start"></a>_dyld_start</h4><p>我们在源码里全局搜索_dyld_start。<a href="https://opensource.apple.com/tarballs/dyld/" target="_blank" rel="noopener">源码下载地址</a>,我这里下载的版本是832.7.3，我们可以来到 <code>dyldStartup.s</code> 这个汇编文件，然后我们聚焦于 <code>arm64</code> 架构下的汇编代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __arm64__ &amp;&amp; !TARGET_OS_SIMULATOR</span></span><br><span class="line">	.<span class="built_in">text</span></span><br><span class="line">	.align <span class="number">2</span></span><br><span class="line">	.globl __dyld_start</span><br><span class="line">__dyld_start:</span><br><span class="line">	mov 	x28, sp</span><br><span class="line">	<span class="keyword">and</span>     sp, x28, #~<span class="number">15</span>		<span class="comment">// force 16-byte alignment of stack</span></span><br><span class="line">	mov	x0, #<span class="number">0</span></span><br><span class="line">	mov	x1, #<span class="number">0</span></span><br><span class="line">	stp	x1, x0, [sp, #<span class="number">-16</span>]!	<span class="comment">// make aligned terminating frame</span></span><br><span class="line">	mov	fp, sp			<span class="comment">// set up fp to point to terminating frame</span></span><br><span class="line">	sub	sp, sp, #<span class="number">16</span>             <span class="comment">// make room for local variables</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LP64__</span></span><br><span class="line">	ldr     x0, [x28]               <span class="comment">// get app's mh into x0</span></span><br><span class="line">	ldr     x1, [x28, #<span class="number">8</span>]           <span class="comment">// get argc into x1 (kernel passes 32-bit int argc as 64-bits on stack to keep alignment)</span></span><br><span class="line">	add     x2, x28, #<span class="number">16</span>            <span class="comment">// get argv into x2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	ldr     w0, [x28]               <span class="comment">// get app's mh into x0</span></span><br><span class="line">	ldr     w1, [x28, #<span class="number">4</span>]           <span class="comment">// get argc into x1 (kernel passes 32-bit int argc as 64-bits on stack to keep alignment)</span></span><br><span class="line">	add     w2, w28, #<span class="number">8</span>             <span class="comment">// get argv into x2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	adrp	x3,___dso_handle@page</span><br><span class="line">	add 	x3,x3,___dso_handle@pageoff <span class="comment">// get dyld's mh in to x4</span></span><br><span class="line">	mov	x4,sp                   <span class="comment">// x5 has &amp;startGlue</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// call dyldbootstrap::start(app_mh, argc, argv, dyld_mh, &amp;startGlue)</span></span><br><span class="line">	bl	__ZN13dyldbootstrap5startEPKN5dyld311MachOLoadedEiPPKcS3_Pm</span><br><span class="line">	mov	x16,x0                  <span class="comment">// save entry point address in x16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LP64__</span></span><br><span class="line">	ldr     x1, [sp]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	ldr     w1, [sp]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	cmp	x1, #<span class="number">0</span></span><br><span class="line">	b.ne	Lnew</span><br></pre></td></tr></table></figure>

<p>对于这里的汇编代码，我们肯定也没必要逐行分析，我们直接定位到 <code>bl</code> 语句后面(<code>bl</code> 在汇编层面是跳转的意思)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call dyldbootstrap::start(app_mh, argc, argv, dyld_mh, &amp;startGlue)</span></span><br><span class="line">	bl	__ZN13dyldbootstrap5startEPKN5dyld311MachOLoadedEiPPKcS3_Pm</span><br></pre></td></tr></table></figure>

<p>看注释可以知道，调用位于 dyldbootstrap 命名空间下的 start 方法，我们继续搜索一下这个 start 方法，结果位于 dyldInitialization.cpp 文件(从文件名我们可以看出该文件主要是用来初始化 dyld)，这里查找 start 的时候可能会有很多结果，我们其实可以先搜索命名空间，再搜索 start 方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  This is code to bootstrap dyld.  This work in normally done for a program by dyld and crt.</span></span><br><span class="line"><span class="comment">//  In dyld we have to do this manually.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">uintptr_t</span> <span class="title">start</span><span class="params">(<span class="keyword">const</span> dyld3::MachOLoaded* appsMachHeader, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[],</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">const</span> dyld3::MachOLoaded* dyldsMachHeader, <span class="keyword">uintptr_t</span>* startGlue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Emit kdebug tracepoint to indicate dyld bootstrap has started &lt;rdar://46878536&gt;</span></span><br><span class="line">    dyld3::kdebug_trace_dyld_marker(DBG_DYLD_TIMING_BOOTSTRAP_START, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// if kernel had to slide dyld, we need to fix up load sensitive locations</span></span><br><span class="line">	<span class="comment">// we have to do this before using any global variables</span></span><br><span class="line">  <span class="comment">// dyld 重定向</span></span><br><span class="line">    rebaseDyld(dyldsMachHeader);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// kernel sets up env pointer to be just past end of agv array</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>** envp = &amp;argv[argc+<span class="number">1</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// kernel sets up apple pointer to be just past end of envp array</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>** apple = envp;</span><br><span class="line">	<span class="keyword">while</span>(*apple != <span class="literal">NULL</span>) &#123; ++apple; &#125;</span><br><span class="line">	++apple;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// set up random value for stack canary</span></span><br><span class="line">  <span class="comment">// 栈溢出保护</span></span><br><span class="line">	__guard_setup(apple);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DYLD_INITIALIZER_SUPPORT</span></span><br><span class="line">	<span class="comment">// run all C++ initializers inside dyld</span></span><br><span class="line">  <span class="comment">// 初始化dyld</span></span><br><span class="line">	runDyldInitializers(argc, argv, envp, apple);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	_subsystem_init(apple);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// now that we are done bootstrapping dyld, call dyld's main</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> appsSlide = appsMachHeader-&gt;getSlide();</span><br><span class="line">	<span class="keyword">return</span> dyld::_main((macho_header*)appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>start</code>方法主要做了很多<code>dyld</code>的<code>初始化</code>工作：</p>
<ul>
<li><code>rebaseDyld</code>   <code>dyld重定位</code></li>
<li><code>__guard_setup</code>   <code>栈溢出保护</code></li>
</ul>
<p>在结束<code>dyld初始化</code>工作后，函数调用 <code>dyld::_main()</code> 函数，再将返回值传递给<code>__dyld_start</code>去调用真正的<code>main</code>函数。</p>
<h4 id="dyld-main"><a href="#dyld-main" class="headerlink" title="dyld::_main"></a>dyld::_main</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Entry point for dyld.  The kernel loads dyld and jumps to __dyld_start which</span></span><br><span class="line"><span class="comment">// sets up some registers and call this function.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns address of main() in target program which __dyld_start jumps to</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">		<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">		<span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">///省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_main方法</code> 官方的注释如下：</p>
<blockquote>
<p><code>dyld</code> 的入口。内核加载了 <code>dyld</code> 然后跳转到 <code>__dyld_start</code> 来设置一些寄存器的值然后调用到了这个方法。<br>返回 <code>__dyld_start</code> 所跳转到的目标程序的 <code>main</code> 函数地址。</p>
</blockquote>
<p><code>dyld</code>流程可总结为九个步骤：</p>
<ul>
<li>第一步：<code>设置运行环境</code></li>
<li>第二步：<code>加载共享缓存</code></li>
<li>第三步：<code>实例化主程序</code></li>
<li>第四步：<code>加载插入的动态库</code></li>
<li>第五步：<code>链接主程序</code></li>
<li>第六步：<code>链接插入的动态库</code></li>
<li>第七步：<code>执行弱引用绑定</code></li>
<li>第八步：<code>执行初始化方法</code></li>
<li>第九步：<code>查找程序入口main然后返回</code></li>
</ul>
<h5 id="第一步：设置运行环境"><a href="#第一步：设置运行环境" class="headerlink" title="第一步：设置运行环境"></a>第一步：设置运行环境</h5><p>这一步主要是设置程序的<code>运行环境</code>，<code>运行条件</code>等准备工作，包括<code>环境</code>，<code>平台</code>，<code>版本</code>，<code>路径</code>，<code>主机</code>信息，设置<code>程序上下文信息</code>等</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取主程序的hash</span></span><br><span class="line">    mainExecutableCDHash = mainExecutableCDHashBuffer;</span><br><span class="line"><span class="comment">// 获取主程序的macho_header结构</span></span><br><span class="line">    sMainExecutableMachHeader = mainExecutableMH;</span><br><span class="line"><span class="comment">// 获取主程序的slide值</span></span><br><span class="line">    sMainExecutableSlide = mainExecutableSlide;</span><br><span class="line"><span class="comment">// 设置上下文信息</span></span><br><span class="line">    setContext(mainExecutableMH, argc, argv, envp, apple);</span><br><span class="line"><span class="comment">// 获取主程序路径</span></span><br><span class="line">    sExecPath = _simple_getenv(apple, <span class="string">"executable_path"</span>);</span><br><span class="line"><span class="comment">// 进程的头环境配置</span></span><br><span class="line">    configureProcessRestrictions(mainExecutableMH, envp);</span><br><span class="line"><span class="comment">// 检测环境变量</span></span><br><span class="line">    checkEnvironmentVariables(envp);</span><br><span class="line">    defaultUninitializedFallbackPaths(envp);</span><br><span class="line"><span class="comment">// 获取主机信息 可理解为 程序结构</span></span><br><span class="line">    getHostInfo(mainExecutableMH, mainExecutableSlide);</span><br></pre></td></tr></table></figure>

<h5 id="第二步：加载共享缓存"><a href="#第二步：加载共享缓存" class="headerlink" title="第二步：加载共享缓存"></a><strong>第二步：加载共享缓存</strong></h5><p>首先检查<code>dyld</code>共享缓存区是否<code>禁用</code>，<code>iOS</code>必须<code>开启</code>，在<code>checkSharedRegionDisable</code>里面<code>iOS</code>环境下注释：</p>
<p><code>// iOS cannot run without shared region</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查缓存共享区域是否开启</span></span><br><span class="line">    checkSharedRegionDisable((dyld3::MachOLoaded*)mainExecutableMH, mainExecutableSlide);</span><br><span class="line"><span class="comment">// 共享缓存加载</span></span><br><span class="line">    mapSharedCache();</span><br><span class="line"><span class="comment">// mapSharedCache 函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mapSharedCache</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dyld3::SharedCacheOptions opts;</span><br><span class="line">    opts.cacheDirOverride   = sSharedCacheOverrideDir;</span><br><span class="line">    opts.forcePrivate       = (gLinkContext.sharedRegionMode == ImageLoader::kUsePrivateSharedRegion);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __x86_64__ &amp;&amp; !TARGET_OS_SIMULATOR</span></span><br><span class="line">    opts.useHaswell         = sHaswell;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    opts.useHaswell         = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    opts.verbose            = gLinkContext.verboseMapping;</span><br><span class="line"><span class="comment">//--- 加载dyld缓存主函数</span></span><br><span class="line">    loadDyldCache(opts, &amp;sSharedCacheLoadInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update global state</span></span><br><span class="line">    <span class="keyword">if</span> ( sSharedCacheLoadInfo.loadAddress != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">        gLinkContext.dyldCache                              = sSharedCacheLoadInfo.loadAddress;</span><br><span class="line">        dyld::gProcessInfo-&gt;processDetachedFromSharedRegion = opts.forcePrivate;</span><br><span class="line">        dyld::gProcessInfo-&gt;sharedCacheSlide                = sSharedCacheLoadInfo.slide;</span><br><span class="line">        dyld::gProcessInfo-&gt;sharedCacheBaseAddress          = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)sSharedCacheLoadInfo.loadAddress;</span><br><span class="line">        sSharedCacheLoadInfo.loadAddress-&gt;getUUID(dyld::gProcessInfo-&gt;sharedCacheUUID);</span><br><span class="line">        dyld3::kdebug_trace_dyld_image(DBG_DYLD_UUID_SHARED_CACHE_A, sSharedCacheLoadInfo.path, (<span class="keyword">const</span> <span class="keyword">uuid_t</span> *)&amp;dyld::gProcessInfo-&gt;sharedCacheUUID[<span class="number">0</span>], &#123;<span class="number">0</span>,<span class="number">0</span>&#125;, &#123;&#123; <span class="number">0</span>, <span class="number">0</span> &#125;&#125;, (<span class="keyword">const</span> mach_header *)sSharedCacheLoadInfo.loadAddress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// loadDyldCache函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">loadDyldCache</span><span class="params">(<span class="keyword">const</span> SharedCacheOptions&amp; options, SharedCacheLoadInfo* results)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    results-&gt;loadAddress        = <span class="number">0</span>;</span><br><span class="line">    results-&gt;slide              = <span class="number">0</span>;</span><br><span class="line">    results-&gt;errorMessage       = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_SIMULATOR</span></span><br><span class="line">    <span class="comment">// simulator only supports mmap()ing cache privately into process</span></span><br><span class="line">    <span class="keyword">return</span> mapCachePrivate(options, results);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> ( options.forcePrivate ) &#123;</span><br><span class="line">        <span class="comment">// mmap cache into this process only</span></span><br><span class="line">        <span class="keyword">return</span> mapCachePrivate(options, results);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// fast path: when cache is already mapped into shared region</span></span><br><span class="line">        <span class="keyword">bool</span> hasError = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> ( reuseExistingCache(options, results) ) &#123;</span><br><span class="line">            hasError = (results-&gt;errorMessage != <span class="literal">nullptr</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// slow path: this is first process to load cache</span></span><br><span class="line">            hasError = mapCacheSystemWide(options, results);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasError;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mapSharedCache</code>函数主要调用<code>loadDyldCache</code> 函数，<code>loadDyldCache</code>函数主要有三种方式加载共享缓存：</p>
<ul>
<li><code>mapCachePrivate()</code> 仅加载到当前进程</li>
<li>共享缓存已经加载过，不做任何处理</li>
<li><code>mapCacheSystemWide()</code> 未加载过，首次加载</li>
</ul>
<h5 id="第三步：实例化主程序"><a href="#第三步：实例化主程序" class="headerlink" title="第三步：实例化主程序"></a><strong>第三步：实例化主程序</strong></h5><p>这一步主要是将主程序的<code>Mach-O</code>加载进内存，并实例化一个<code>ImageLoader</code>。<code>instantiateFromLoadedImage()</code> 首先调用<code>isCompatibleMachO()</code> 函数检测当前进程的<code>magic</code>、<code>cputype</code>、<code>cpusubtype</code> 等相关属性，判断<code>Mach-O</code>文件的<code>兼容性</code>，如果兼容性满足，就调用<code>ImageLoaderMachO::instantiateMainExecutable()</code>实例化主程序的<code>ImageLoader</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第三步：实例化主程序</span></span><br><span class="line">        sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);</span><br><span class="line">        gLinkContext.mainExecutable = sMainExecutable;</span><br><span class="line">        gLinkContext.mainExecutableCodeSigned = hasCodeSignatureLoadCommand(mainExecutableMH);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The kernel maps in main executable before dyld gets control.  We need to </span></span><br><span class="line"><span class="comment">// make an ImageLoader* for the already mapped in main executable.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ImageLoaderMachO* <span class="title">instantiateFromLoadedImage</span><span class="params">(<span class="keyword">const</span> macho_header* mh, <span class="keyword">uintptr_t</span> slide, <span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// try mach-o loader</span></span><br><span class="line">    <span class="keyword">if</span> ( isCompatibleMachO((<span class="keyword">const</span> <span class="keyword">uint8_t</span>*)mh, path) ) &#123;</span><br><span class="line">        ImageLoader* <span class="built_in">image</span> = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext);</span><br><span class="line">        addImage(<span class="built_in">image</span>);</span><br><span class="line">        <span class="keyword">return</span> (ImageLoaderMachO*)<span class="built_in">image</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"main executable not a known format"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create image for main executable</span></span><br><span class="line"><span class="function">ImageLoader* <span class="title">ImageLoaderMachO::instantiateMainExecutable</span><span class="params">(<span class="keyword">const</span> macho_header* mh, <span class="keyword">uintptr_t</span> slide, <span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> LinkContext&amp; context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//dyld::log("ImageLoader=%ld, ImageLoaderMachO=%ld, ImageLoaderMachOClassic=%ld, ImageLoaderMachOCompressed=%ld\n",</span></span><br><span class="line">    <span class="comment">//  sizeof(ImageLoader), sizeof(ImageLoaderMachO), sizeof(ImageLoaderMachOClassic), sizeof(ImageLoaderMachOCompressed));</span></span><br><span class="line">    <span class="keyword">bool</span> compressed;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> segCount;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> libCount;</span><br><span class="line">    <span class="keyword">const</span> linkedit_data_command* codeSigCmd;</span><br><span class="line">    <span class="keyword">const</span> encryption_info_command* encryptCmd;</span><br><span class="line">    sniffLoadCommands(mh, path, <span class="literal">false</span>, &amp;compressed, &amp;segCount, &amp;libCount, context, &amp;codeSigCmd, &amp;encryptCmd);</span><br><span class="line">    <span class="comment">// instantiate concrete class based on content of load commands</span></span><br><span class="line">    <span class="keyword">if</span> ( compressed ) </span><br><span class="line">        <span class="keyword">return</span> ImageLoaderMachOCompressed::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">#<span class="keyword">if</span> SUPPORT_CLASSIC_MACHO</span><br><span class="line">        <span class="keyword">return</span> ImageLoaderMachOClassic::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">throw</span> <span class="string">"missing LC_DYLD_INFO load command"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>instantiateMainExecutable()</code>  函数中通过<code>sniffLoadCommands()</code> 判断这个<code>mach-o</code>文件是<code>普通的</code>还是<code>压缩</code>的LINKEDIT，以及它有多少段。<br> 最后根据<code>compressed</code> 是否压缩来实例化最后返回的<code>ImageLoader</code>。</p>
<h5 id="第四步：加载插入的动态库"><a href="#第四步：加载插入的动态库" class="headerlink" title="第四步：加载插入的动态库"></a><strong>第四步：加载插入的动态库</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第四步：加载插入的动态库</span></span><br><span class="line">        <span class="keyword">if</span>  ( sEnv.DYLD_INSERT_LIBRARIES != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class="literal">NULL</span>; ++lib) </span><br><span class="line">                loadInsertedDylib(*lib);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><code>loadInsertedDylib()</code> 函数中设置了一个<code>LoadContext</code>，并为它配置一些参数后，调用<code>load()</code> 方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ImageLoader* <span class="title">load</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> LoadContext&amp; context, <span class="keyword">unsigned</span>&amp; cacheIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line"><span class="comment">// try all path permutations and check against existing loaded images</span></span><br><span class="line"></span><br><span class="line">    ImageLoader* <span class="built_in">image</span> = loadPhase0(path, orgPath, context, cacheIndex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">image</span> != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        CRSetCrashLogMessage2(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">image</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// try all path permutations and try open() until first success</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; exceptions;</span><br><span class="line">    <span class="built_in">image</span> = loadPhase0(path, orgPath, context, cacheIndex, &amp;exceptions);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_OS_SIMULATOR</span></span><br><span class="line">    <span class="comment">// &lt;rdar://problem/16704628&gt; support symlinks on disk to a path in dyld shared cache</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">image</span> == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">image</span> = loadPhase2cache(path, orgPath, context, cacheIndex, &amp;exceptions);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    CRSetCrashLogMessage2(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">image</span> != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        <span class="comment">// &lt;rdar://problem/6916014&gt; leak in dyld during dlopen when using DYLD_ variables</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;::iterator it = exceptions.<span class="built_in">begin</span>(); it != exceptions.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            <span class="built_in">free</span>((<span class="keyword">void</span>*)(*it));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if loaded image is not from cache, but original path is in cache</span></span><br><span class="line">        <span class="comment">// set gSharedCacheOverridden flag to disable some ObjC optimizations</span></span><br><span class="line">        <span class="keyword">if</span> ( !gSharedCacheOverridden &amp;&amp; !<span class="built_in">image</span>-&gt;inSharedCache() &amp;&amp; <span class="built_in">image</span>-&gt;isDylib() &amp;&amp; dyld3::MachOFile::isSharedCacheEligiblePath(path) &amp;&amp; inSharedCache(path) ) &#123;</span><br><span class="line">            gSharedCacheOverridden = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">image</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第五步：链接主程序"><a href="#第五步：链接主程序" class="headerlink" title="第五步：链接主程序"></a><strong>第五步：链接主程序</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第五步：链接主程序        Executable：可执行的意思</span></span><br><span class="line">        link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, </span><br><span class="line">        <span class="literal">true</span>, ImageLoader::RPathChain(<span class="literal">NULL</span>, <span class="literal">NULL</span>), <span class="number">-1</span>);</span><br></pre></td></tr></table></figure>

<p>调用<code>link()</code>函数将实例化后的主程序进行<code>动态修正</code>，让二进制变为可正常执行的状态。<code>link()</code>函数内部调用了<code>ImgaeLoader::link()</code> 函数，主要做了下面几件事：</p>
<ul>
<li>this-&gt;<code>recursiveLoadLibraries()</code>  递归加载依赖库进内存</li>
<li>this-&gt;<code>recursiveUpdateDepth()</code>   递归更新依赖库的路径</li>
<li>this-&gt;<code>recursiveRebaseWithAccounting()</code>   递归重定位主程序和依赖库</li>
<li>this-&gt;<code>recursiveBindWithAccounting()</code>   递归将主程序和依赖库执行符号表绑定（链接动态库使用）</li>
<li>this-&gt;<code>weakBind()</code>   如果不是正在链接主程序二进制，那就主程序弱符号绑定（链接动态库使用）</li>
<li>this-&gt;<code>recursiveApplyInterposing()</code>   递归申请可插入依赖库权限</li>
<li>this-&gt;<code>recursiveMakeDataReadOnly()</code>   递归设置所有信息只读（链接动态库使用）</li>
<li>this-&gt;<code>recursiveGetDOFSections()</code>  注册DOF节</li>
</ul>
<p>代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageLoader::link</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context, <span class="keyword">bool</span> forceLazysBound, <span class="keyword">bool</span> preflightOnly, <span class="keyword">bool</span> neverUnload, <span class="keyword">const</span> RPathChain&amp; loaderRPaths, <span class="keyword">const</span> <span class="keyword">char</span>* imagePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// clear error strings</span></span><br><span class="line">    (*context.setErrorStrings)(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> t0 = mach_absolute_time();</span><br><span class="line">       <span class="comment">// 递归加载依赖库进内存</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;recursiveLoadLibraries(context, preflightOnly, loaderRPaths, imagePath);</span><br><span class="line">    context.notifyBatch(dyld_image_state_dependents_mapped, preflightOnly);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we only do the loading step for preflights</span></span><br><span class="line">    <span class="keyword">if</span> ( preflightOnly )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line">       <span class="comment">// 递归更新依赖库的路径</span></span><br><span class="line">    context.clearAllDepths();</span><br><span class="line">    <span class="keyword">this</span>-&gt;recursiveUpdateDepth(context.imageCount());</span><br><span class="line"></span><br><span class="line">    __block <span class="keyword">uint64_t</span> t2, t3, t4, t5;</span><br><span class="line">    &#123;</span><br><span class="line">        dyld3::ScopedTimer(DBG_DYLD_TIMING_APPLY_FIXUPS, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        t2 = mach_absolute_time();</span><br><span class="line">        <span class="comment">// 递归重定位主程序和依赖库</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;recursiveRebaseWithAccounting(context);</span><br><span class="line">        context.notifyBatch(dyld_image_state_rebased, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        t3 = mach_absolute_time();</span><br><span class="line">        <span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line">            <span class="comment">// 递归将主程序和依赖库执行符号表绑定</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;recursiveBindWithAccounting(context, forceLazysBound, neverUnload);</span><br><span class="line"></span><br><span class="line">        t4 = mach_absolute_time();</span><br><span class="line">        <span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line">        <span class="comment">// 如果不是正在链接主程序二进制，那就主程序弱符号绑定</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;weakBind(context);</span><br><span class="line">        t5 = mach_absolute_time();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// interpose any dynamically loaded images</span></span><br><span class="line">    <span class="keyword">if</span> ( !context.linkingMainExecutable &amp;&amp; (fgInterposingTuples.<span class="built_in">size</span>() != <span class="number">0</span>) ) &#123;</span><br><span class="line">        <span class="function">dyld3::ScopedTimer <span class="title">timer</span><span class="params">(DBG_DYLD_TIMING_APPLY_INTERPOSING, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 递归申请可插入依赖库权限</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;recursiveApplyInterposing(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now that all fixups are done, make __DATA_CONST segments read-only</span></span><br><span class="line">    <span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line">      <span class="comment">// 递归设置所有信息只读</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;recursiveMakeDataReadOnly(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line">        context.notifyBatch(dyld_image_state_bound, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> t6 = mach_absolute_time();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( context.registerDOFs != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;DOFInfo&gt; dofs;</span><br><span class="line">       <span class="comment">//  注册DOF节</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;recursiveGetDOFSections(context, dofs);</span><br><span class="line">        context.registerDOFs(dofs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint64_t</span> t7 = mach_absolute_time();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear error strings</span></span><br><span class="line">    (*context.setErrorStrings)(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    fgTotalLoadLibrariesTime += t1 - t0;</span><br><span class="line">    fgTotalRebaseTime += t3 - t2;</span><br><span class="line">    fgTotalBindTime += t4 - t3;</span><br><span class="line">    fgTotalWeakBindTime += t5 - t4;</span><br><span class="line">    fgTotalDOF += t7 - t6;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// done with initial dylib loads</span></span><br><span class="line">    fgNextPIEDylibAddress = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第六步：链接插入的动态库"><a href="#第六步：链接插入的动态库" class="headerlink" title="第六步：链接插入的动态库"></a><strong>第六步：链接插入的动态库</strong></h5><p>这一步跟链接主程序一样，将<code>sAllImages</code>中的<code>ImageLoader</code>遍历出来，然后调用<code>link()</code>进行链接，需要注意的是，<code>sAllImages</code>中保存的第一个是<code>主程序</code>的镜像，所以要获取所有的动态库的<code>ImageLoader</code>，就必须从<code>i + 1</code> 开始遍历：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">    ImageLoader* <span class="built_in">image</span> = sAllImages[i+<span class="number">1</span>];</span><br><span class="line">    link(<span class="built_in">image</span>, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>, ImageLoader::RPathChain(<span class="literal">NULL</span>, <span class="literal">NULL</span>), <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">image</span>-&gt;setNeverUnloadRecursive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第七步：执行主程序弱符号绑定"><a href="#第七步：执行主程序弱符号绑定" class="headerlink" title="第七步：执行主程序弱符号绑定"></a><strong>第七步：执行主程序弱符号绑定</strong></h5><p><code>weakBind()</code>首先通过<code>getCoalescedImages()</code>合并所有动态库的<code>弱符号</code>到一个列表里，然后调用<code>initializeCoalIterator()</code>对需要绑定的弱符号进行排序，接着调用<code>incrementCoalIterator()</code>读取<code>dyld_info_command</code>结构的<code>weak_bind_off</code>和<code>weak_bind_size</code>字段，确定弱符号的<code>数据偏移</code>与大小，最终进行弱符号绑定</p>
<h5 id="第八步：执行初始化方法"><a href="#第八步：执行初始化方法" class="headerlink" title="第八步：执行初始化方法"></a><strong>第八步：执行初始化方法</strong></h5><p>这一步就开始进行初始化工作了，<code>initializeMainExecutable()</code> 函数中调用 <code>runInitializers()</code> 函数，接着依次调用 <code>processInitializers()</code> 函数进行一些初始化准备工作，接着<code>recursiveInitialization()</code> 函数调用进行初始化工作，接着全局搜索<code>recursiveInitialization(</code>，找到<code>ImageLoader.cpp</code>中的此方法定义，看重点，函数里面我们看到<code>noffitySingle()单个通知注入</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageLoader::recursiveInitialization</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context, <span class="keyword">mach_port_t</span> this_thread, <span class="keyword">const</span> <span class="keyword">char</span>* pathToInitialize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InitializerTimingList&amp; timingInfo, UninitedUpwards&amp; uninitUps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">recursive_lock <span class="title">lock_info</span><span class="params">(this_thread)</span></span>;</span><br><span class="line">    recursiveSpinLock(lock_info);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( fState &lt; dyld_image_state_dependents_initialized<span class="number">-1</span> ) &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> oldState = fState;</span><br><span class="line">        <span class="comment">// break cycles</span></span><br><span class="line">        fState = dyld_image_state_dependents_initialized<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// initialize lower level libraries first</span></span><br><span class="line">            <span class="comment">// 先初始化底层依赖库</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; libraryCount(); ++i) &#123;</span><br><span class="line">                ImageLoader* dependentImage = libImage(i);</span><br><span class="line">                <span class="keyword">if</span> ( dependentImage != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">                    <span class="comment">// don't try to initialize stuff "above" me yet</span></span><br><span class="line">                    <span class="keyword">if</span> ( libIsUpward(i) ) &#123;</span><br><span class="line">                        uninitUps.imagesAndPaths[uninitUps.count] = &#123; dependentImage, libPath(i) &#125;;</span><br><span class="line">                        uninitUps.count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ( dependentImage-&gt;fDepth &gt;= fDepth ) &#123;</span><br><span class="line">                        dependentImage-&gt;recursiveInitialization(context, this_thread, libPath(i), timingInfo, uninitUps);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// record termination order</span></span><br><span class="line">            <span class="comment">// 记录终端序号</span></span><br><span class="line">            <span class="keyword">if</span> ( <span class="keyword">this</span>-&gt;needsTermination() )</span><br><span class="line">                context.terminationRecorder(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// let objc know we are about to initialize this image</span></span><br><span class="line">            <span class="comment">// 单个通知注入 通知告知大家我要开始初始化啦，你们赶紧去做初始化的工作</span></span><br><span class="line">            <span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line">            fState = dyld_image_state_dependents_initialized;</span><br><span class="line">            oldState = fState;</span><br><span class="line">            context.notifySingle(dyld_image_state_dependents_initialized, <span class="keyword">this</span>, &amp;timingInfo);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// initialize this image</span></span><br><span class="line">            <span class="keyword">bool</span> hasInitializers = <span class="keyword">this</span>-&gt;doInitialization(context);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// let anyone know we finished initializing this image</span></span><br><span class="line">            fState = dyld_image_state_initialized;</span><br><span class="line">            oldState = fState;</span><br><span class="line">            context.notifySingle(dyld_image_state_initialized, <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> ( hasInitializers ) &#123;</span><br><span class="line">                <span class="keyword">uint64_t</span> t2 = mach_absolute_time();</span><br><span class="line">                timingInfo.addTime(<span class="keyword">this</span>-&gt;getShortName(), t2-t1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line">            <span class="comment">// this image is not initialized</span></span><br><span class="line">            fState = oldState;</span><br><span class="line">            recursiveSpinUnLock();</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    recursiveSpinUnLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="探索-objc-init"><a href="#探索-objc-init" class="headerlink" title="探索 _objc_init"></a>探索 _objc_init</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    runtime_init();</span><br><span class="line">    exception_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    <span class="keyword">cache_t</span>::init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    _imp_implementationWithBlock_init();</span><br><span class="line"></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    didCallDyldNotifyRegister = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过LLDB来断掉调试<code>_objc_init</code>,然后通过<code>bt</code>命令打印出当前的调用堆栈，根据上一节我们探索<code>dyld</code>源码，感觉很清晰：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(lldb) bt</span><br><span class="line">* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1</span><br><span class="line">  * frame #<span class="number">0</span>: <span class="number">0x00000001002d29c4</span> libobjc.A.dylib`_objc_init at objc-os.mm:<span class="number">925</span>:<span class="number">9</span></span><br><span class="line">    frame #<span class="number">1</span>: <span class="number">0x000000010044f0bc</span> libdispatch.dylib`_os_object_init + <span class="number">13</span></span><br><span class="line">    frame #<span class="number">2</span>: <span class="number">0x000000010045fafc</span> libdispatch.dylib`libdispatch_init + <span class="number">282</span></span><br><span class="line">    frame #<span class="number">3</span>: <span class="number">0x00007fff6a99c791</span> libSystem.B.dylib`libSystem_initializer + <span class="number">220</span></span><br><span class="line">    frame #<span class="number">4</span>: <span class="number">0x000000010002f1d3</span> dyld`ImageLoaderMachO::doModInitFunctions(ImageLoader::LinkContext <span class="keyword">const</span>&amp;) + <span class="number">535</span></span><br><span class="line">    frame #<span class="number">5</span>: <span class="number">0x000000010002f5de</span> dyld`ImageLoaderMachO::doInitialization(ImageLoader::LinkContext <span class="keyword">const</span>&amp;) + <span class="number">40</span></span><br><span class="line">    frame #<span class="number">6</span>: <span class="number">0x0000000100029ffb</span> dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext <span class="keyword">const</span>&amp;, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">char</span> <span class="keyword">const</span>*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class="number">493</span></span><br><span class="line">    frame #<span class="number">7</span>: <span class="number">0x0000000100029f66</span> dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext <span class="keyword">const</span>&amp;, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">char</span> <span class="keyword">const</span>*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class="number">344</span></span><br><span class="line">    frame #<span class="number">8</span>: <span class="number">0x00000001000280b4</span> dyld`ImageLoader::processInitializers(ImageLoader::LinkContext <span class="keyword">const</span>&amp;, <span class="keyword">unsigned</span> <span class="keyword">int</span>, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class="number">188</span></span><br><span class="line">    frame #<span class="number">9</span>: <span class="number">0x0000000100028154</span> dyld`ImageLoader::runInitializers(ImageLoader::LinkContext <span class="keyword">const</span>&amp;, ImageLoader::InitializerTimingList&amp;) + <span class="number">82</span></span><br><span class="line">    frame #<span class="number">10</span>: <span class="number">0x0000000100016662</span> dyld`dyld::initializeMainExecutable() + <span class="number">129</span></span><br><span class="line">    frame #<span class="number">11</span>: <span class="number">0x000000010001bbba</span> dyld`dyld::_main(macho_header <span class="keyword">const</span>*, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">int</span>, <span class="keyword">char</span> <span class="keyword">const</span>**, <span class="keyword">char</span> <span class="keyword">const</span>**, <span class="keyword">char</span> <span class="keyword">const</span>**, <span class="keyword">unsigned</span> <span class="keyword">long</span>*) + <span class="number">6667</span></span><br><span class="line">    frame #<span class="number">12</span>: <span class="number">0x0000000100015227</span> dyld`dyldbootstrap::start(dyld3::MachOLoaded <span class="keyword">const</span>*, <span class="keyword">int</span>, <span class="keyword">char</span> <span class="keyword">const</span>**, dyld3::MachOLoaded <span class="keyword">const</span>*, <span class="keyword">unsigned</span> <span class="keyword">long</span>*) + <span class="number">453</span></span><br><span class="line">    frame #<span class="number">13</span>: <span class="number">0x0000000100015025</span> dyld`_dyld_start + <span class="number">37</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到 <code>dyld</code> 的最后一个流程是 <code>doModInitFunctions</code> 方法的执行。</p>
<p>我们打开 <code>libSystem</code> 的源码，全局搜索 <code>libSystem_initializer</code> 可以看到：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	_dyld_initializer();</span><br><span class="line">	_libSystem_ktrace_init_func(DYLD);</span><br><span class="line"></span><br><span class="line">	libdispatch_init();</span><br><span class="line">	_libSystem_ktrace_init_func(LIBDISPATCH);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_OS_DRIVERKIT</span></span><br><span class="line">	_libxpc_initializer();</span><br><span class="line">	_libSystem_ktrace_init_func(LIBXPC);</span><br></pre></td></tr></table></figure>

<p>然后我们打开 <code>libDispatch</code> 的源码，全局搜索 <code>libdispatch_init</code> 可以看到：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">void</span></span><br><span class="line">libdispatch_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//省略代码</span></span><br><span class="line">	_dispatch_hw_config_init();</span><br><span class="line">	_dispatch_time_init();</span><br><span class="line">	_dispatch_vtable_init();</span><br><span class="line">  <span class="comment">//调用</span></span><br><span class="line">	_os_object_init();</span><br><span class="line">	_voucher_init();</span><br><span class="line">	_dispatch_introspection_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再搜索<code>_os_object_init</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_os_object_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	_objc_init();</span><br><span class="line">	Block_callbacks_RR callbacks = &#123;</span><br><span class="line">		<span class="keyword">sizeof</span>(Block_callbacks_RR),</span><br><span class="line">		(<span class="keyword">void</span> (*)(<span class="keyword">const</span> <span class="keyword">void</span> *))&amp;objc_retain,</span><br><span class="line">		(<span class="keyword">void</span> (*)(<span class="keyword">const</span> <span class="keyword">void</span> *))&amp;objc_release,</span><br><span class="line">		(<span class="keyword">void</span> (*)(<span class="keyword">const</span> <span class="keyword">void</span> *))&amp;_os_objc_destructInstance</span><br><span class="line">	&#125;;</span><br><span class="line">	_Block_use_RR2(&amp;callbacks);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_COCOA_COMPAT</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *v = getenv(<span class="string">"OBJC_DEBUG_MISSING_POOLS"</span>);</span><br><span class="line">	<span class="keyword">if</span> (v) _os_object_debug_missing_pools = _dispatch_parse_bool(v);</span><br><span class="line">	v = getenv(<span class="string">"DISPATCH_DEBUG_MISSING_POOLS"</span>);</span><br><span class="line">	<span class="keyword">if</span> (v) _os_object_debug_missing_pools = _dispatch_parse_bool(v);</span><br><span class="line">	v = getenv(<span class="string">"LIBDISPATCH_DEBUG_MISSING_POOLS"</span>);</span><br><span class="line">	<span class="keyword">if</span> (v) _os_object_debug_missing_pools = _dispatch_parse_bool(v);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完美~，<code>_objc_init</code> 在这里就被调用了。所以 <code>_objc_init</code> 的流程是</p>
<p>dyld -&gt; libSystem -&gt; libDispatch -&gt; libObjc -&gt; <code>_objc_init</code></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要探索了 app 启动之后 dyld 的流程，整个分析过程确实比较复杂，但在探索的过程中，我们不仅对底层源码有了新的认知，同时对于优化我们 app 启动也是有很多好处的。下一章，我们会对 objc_init 内部的 map_images 和 load_images 进行更深入的分析。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/13/iOS%E5%BA%95%E5%B1%82%EF%BC%9Astatic_init%E3%80%81gdb_objc_realized_classes&remapped_clasass_map&future_named_class_map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/13/iOS%E5%BA%95%E5%B1%82%EF%BC%9Astatic_init%E3%80%81gdb_objc_realized_classes&remapped_clasass_map&future_named_class_map/" class="post-title-link" itemprop="url">iOS底层：static_init、gdb_objc_realized_classes&remapped_clasass_map&future_named_class_map</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-13 13:58:39 / 修改时间：16:51:43" itemprop="dateCreated datePublished" datetime="2021-05-13T13:58:39+08:00">2021-05-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="static-init"><a href="#static-init" class="headerlink" title="static_init"></a>static_init</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* static_init</span></span><br><span class="line"><span class="comment">* Run C++ static constructor functions.</span></span><br><span class="line"><span class="comment">* libc calls _objc_init() before dyld would call our static constructors, </span></span><br><span class="line"><span class="comment">* so we have to do it ourselves.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">static_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    <span class="keyword">auto</span> inits = getLibobjcInitializers(&amp;_mh_dylib_header, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        inits[i]();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> offsets = getLibobjcInitializerOffsets(&amp;_mh_dylib_header, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="function">UnsignedInitializer <span class="title">init</span><span class="params">(offsets[i])</span></span>;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会运行 <code>C++</code> 的静态构造函数，在 <code>dyld</code> 调用我们的静态构造函数之前，<code>libc</code> 会调用 <code>_objc_init</code>，所以这里我们必须自己来做，并且这里只会初始化系统内置的 <code>C++</code> 静态构造函数，我们自己代码里面写的并不会在这里初始化。</p>
<p>通过其注释，我们大概知道static_init函数的作用是运行C++的静态构造函数。其原因在于dyld调用我们的静态构造函数晚于libc调用_objc_init函数。</p>
<p>继续深入讲解<code>static_init</code>方法，可以看出，<code>getLibobjcInitializers</code>方法是它的实现主体，点击进入可以看到如下实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETSECT(getLibobjcInitializers,       UnsignedInitializer, <span class="string">"__objc_init_func"</span>);</span><br></pre></td></tr></table></figure>

<p>这就能理解我们文章开头提出的<code>static_init()</code>方法的含义了。其实就是找出<code>__objc_init_func</code>区的数据，获取了<code>Initializer</code>指针，然后按顺序调用。</p>
<p>由于全局变量都在 <code>mod_init_func</code> 这个区中，那这就给我们优化 App 启动提供了一个思路：我们可以通过 hook 这个区中所有的函数为自己的函数，并在我们的函数中添加时间节点来计时，从而了解在 main 函数之前的耗时情况，这也可以为我们 APP 提供优化借鉴。</p>
<p>其想法很简单，就是在 load 方法中 hook <code>__mod_init_func</code> 的方法。部分源代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load&#123;</span><br><span class="line"></span><br><span class="line">    sInitInfos &#x3D; [NSMutableArray new];</span><br><span class="line"></span><br><span class="line">    g_initializer &#x3D; new std::vector&lt;MemoryType&gt;();</span><br><span class="line"></span><br><span class="line">    g_cur_index &#x3D; -1;</span><br><span class="line"></span><br><span class="line">    g_aslr &#x3D; 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    hookModInitFunc();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以及</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hookModInitFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Dl_info info;</span><br><span class="line"></span><br><span class="line">    dladdr((<span class="keyword">const</span> <span class="keyword">void</span> *)hookModInitFunc, &amp;info);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __LP64__</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//        const struct mach_header *mhp = _dyld_get_image_header(0); // both works as below line</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mach_header</span> *<span class="title">mhp</span> = (<span class="title">struct</span> <span class="title">mach_header</span>*)<span class="title">info</span>.<span class="title">dli_fbase</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    MemoryType *memory = (<span class="keyword">uint32_t</span>*)getsectiondata(mhp, <span class="string">"__DATA"</span>, <span class="string">"__mod_init_func"</span>, &amp; <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* defined(__LP64__) */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mach_header_64</span> *<span class="title">mhp</span> = (<span class="title">struct</span> <span class="title">mach_header_64</span>*)<span class="title">info</span>.<span class="title">dli_fbase</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    MemoryType *memory = (<span class="keyword">uint64_t</span>*)getsectiondata(mhp, <span class="string">"__DATA"</span>, <span class="string">"__mod_init_func"</span>, &amp; <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* defined(__LP64__) */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; <span class="built_in">size</span>/<span class="keyword">sizeof</span>(<span class="keyword">void</span>*); ++idx)&#123;</span><br><span class="line"></span><br><span class="line">        MemoryType original_ptr = memory[idx];</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存原先的方法指针</span></span><br><span class="line"></span><br><span class="line">        g_initializer-&gt;push_back(original_ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将原先的方法替换为我们自己的方法</span></span><br><span class="line"></span><br><span class="line">        memory[idx] = (MemoryType)myInitFunc_Initializer;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    NSLog(@<span class="string">"zero mod init func : size = %@"</span>,@(<span class="built_in">size</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    [sInitInfos addObject:[NSString stringWithFormat:@<span class="string">"ASLR=%p"</span>,mhp]];</span><br><span class="line"></span><br><span class="line">    g_aslr = (MemoryType)mhp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是展示方法以及消耗时长：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myInitFunc_Initializer</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], <span class="keyword">const</span> struct MyProgramVars* vars)</span></span>&#123;</span><br><span class="line">    ++g_cur_index;</span><br><span class="line">    OriginalInitializer func = (OriginalInitializer)g_initializer-&gt;at(g_cur_index);</span><br><span class="line"></span><br><span class="line">    CFTimeInterval start = CFAbsoluteTimeGetCurrent();</span><br><span class="line"></span><br><span class="line">    func(argc,argv,envp,apple,vars);</span><br><span class="line"></span><br><span class="line">    CFTimeInterval <span class="built_in">end</span> = CFAbsoluteTimeGetCurrent();</span><br><span class="line">    sSumInitTime += <span class="number">1000.0</span> * (<span class="built_in">end</span>-start);</span><br><span class="line">    NSString *cost = [NSString stringWithFormat:@<span class="string">"%p=%@"</span>,func,@(<span class="number">1000.0</span>*(<span class="built_in">end</span> - start))];</span><br><span class="line">    [sInitInfos addObject:cost];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gdb-objc-realized-classes"><a href="#gdb-objc-realized-classes" class="headerlink" title="gdb_objc_realized_classes"></a>gdb_objc_realized_classes</h3><p>gdb_objc_realized_classes 的作用已经很明显了，即是对所有的类进行缓存：从对应的 section 中读取所有的类，取出来后以 mangledName 作为键，以 class 结构体作为值。</p>
<h3 id="remapped-class-map"><a href="#remapped-class-map" class="headerlink" title="remapped_class_map"></a>remapped_class_map</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* remappedClasses</span></span><br><span class="line"><span class="comment">* Returns the oldClass =&gt; newClass map for realized future classes.</span></span><br><span class="line"><span class="comment">* Returns the oldClass =&gt; nil map for ignored weak-linked classes.</span></span><br><span class="line"><span class="comment">* Locking: runtimeLock must be read- or write-locked by the caller</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line">static objc::DenseMap&lt;Class, Class&gt; *remappedClasses(bool create)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> objc::LazyInitDenseMap&lt;Class, Class&gt; remapped_class_map;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    <span class="comment">// start big enough to hold CF's classes and a few others</span></span><br><span class="line">    <span class="keyword">return</span> remapped_class_map.<span class="built_in">get</span>(create, <span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>remap class，字面意思是 重新映射 class，那肯定有一个映射者和映射结果。map 的键是 cls，也就是 section 中拿到的 cls，而 value 就是我们 remap 的结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Class <span class="title">readClass</span><span class="params">(Class cls, <span class="keyword">bool</span> headerIsBundle, <span class="keyword">bool</span> headerIsPreoptimized)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mangledName = cls-&gt;nonlazyMangledName();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (missingWeakSuperclass(cls)) &#123;</span><br><span class="line">        <span class="comment">// No superclass (probably weak-linked). </span></span><br><span class="line">        <span class="comment">// Disavow any knowledge of this subclass.</span></span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"CLASS: IGNORING class '%s' with "</span></span><br><span class="line">                         <span class="string">"missing weak-linked superclass"</span>, </span><br><span class="line">                         cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        addRemappedClass(cls, nil);</span><br><span class="line">        cls-&gt;setSuperclass(nil);</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cls-&gt;fixupBackwardDeployingStableSwift();</span><br><span class="line"></span><br><span class="line">    Class replacing = nil;</span><br><span class="line">    <span class="keyword">if</span> (mangledName != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Class newCls = popFutureNamedClass(mangledName)) &#123;</span><br><span class="line">            <span class="comment">// This name was previously allocated as a future class.</span></span><br><span class="line">            <span class="comment">// Copy objc_class to future class's struct.</span></span><br><span class="line">            <span class="comment">// Preserve future's rw data block.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newCls-&gt;isAnySwift()) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">"Can't complete future class request for '%s' "</span></span><br><span class="line">                            <span class="string">"because the real class is too big."</span>,</span><br><span class="line">                            cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">class_rw_t</span> *rw = newCls-&gt;data();</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *old_ro = rw-&gt;ro();</span><br><span class="line">            <span class="built_in">memcpy</span>(newCls, cls, <span class="keyword">sizeof</span>(objc_class));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Manually set address-discriminated ptrauthed fields</span></span><br><span class="line">            <span class="comment">// so that newCls gets the correct signatures.</span></span><br><span class="line">            newCls-&gt;setSuperclass(cls-&gt;getSuperclass());</span><br><span class="line">            newCls-&gt;initIsa(cls-&gt;getIsa());</span><br><span class="line"></span><br><span class="line">            rw-&gt;set_ro((<span class="keyword">class_ro_t</span> *)newCls-&gt;data());</span><br><span class="line">            newCls-&gt;setData(rw);</span><br><span class="line">            freeIfMutable((<span class="keyword">char</span> *)old_ro-&gt;getName());</span><br><span class="line">            <span class="built_in">free</span>((<span class="keyword">void</span> *)old_ro);</span><br><span class="line"></span><br><span class="line">            addRemappedClass(cls, newCls);</span><br><span class="line"></span><br><span class="line">            replacing = cls;</span><br><span class="line">            cls = newCls;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (headerIsPreoptimized  &amp;&amp;  !replacing) &#123;</span><br><span class="line">        <span class="comment">// class list built in shared cache</span></span><br><span class="line">        <span class="comment">// fixme strict assert doesn't work because of duplicates</span></span><br><span class="line">        <span class="comment">// ASSERT(cls == getClass(name));</span></span><br><span class="line">        ASSERT(mangledName == <span class="literal">nullptr</span> || getClassExceptSomeSwift(mangledName));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mangledName) &#123; <span class="comment">//some Swift generic classes can lazily generate their names</span></span><br><span class="line">            addNamedClass(cls, mangledName, replacing);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Class meta = cls-&gt;ISA();</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *metaRO = meta-&gt;bits.safe_ro();</span><br><span class="line">            ASSERT(metaRO-&gt;getNonMetaclass() &amp;&amp; <span class="string">"Metaclass with lazy name must have a pointer to the corresponding nonmetaclass."</span>);</span><br><span class="line">            ASSERT(metaRO-&gt;getNonMetaclass() == cls &amp;&amp; <span class="string">"Metaclass nonmetaclass pointer must equal the original class."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        addClassTableEntry(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for future reference: shared cache never contains MH_BUNDLEs</span></span><br><span class="line">    <span class="keyword">if</span> (headerIsBundle) &#123;</span><br><span class="line">        cls-&gt;data()-&gt;flags |= RO_FROM_BUNDLE;</span><br><span class="line">        cls-&gt;ISA()-&gt;data()-&gt;flags |= RO_FROM_BUNDLE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个函数我们发现，有两个分支有机会进入方法 addRemappedClass，一个是 missingWeakSuperclass 方法是否为真，另外一个是 popFutureNamedClass(mangledName) 方法返回是否为真。这里会有两个概念</p>
<ol>
<li>WeakSuperclass</li>
<li>FutureNamedClass</li>
</ol>
<p>而这两个条件为true 的情况就是需要 remap 的情况。</p>
<h3 id="missingWeakSuperclass"><a href="#missingWeakSuperclass" class="headerlink" title="missingWeakSuperclass"></a>missingWeakSuperclass</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* missingWeakSuperclass</span></span><br><span class="line"><span class="comment">* Return YES if some superclass of cls was weak-linked and is missing.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> </span><br><span class="line">missingWeakSuperclass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;getSuperclass()) &#123;</span><br><span class="line">        <span class="comment">// superclass nil. This is normal for root classes only.</span></span><br><span class="line">        <span class="keyword">return</span> (!(cls-&gt;data()-&gt;flags &amp; RO_ROOT));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// superclass not nil. Check if a higher superclass is missing.</span></span><br><span class="line">        Class supercls = remapClass(cls-&gt;getSuperclass());</span><br><span class="line">        ASSERT(cls != cls-&gt;getSuperclass());</span><br><span class="line">        ASSERT(cls != supercls);</span><br><span class="line">        <span class="keyword">if</span> (!supercls) <span class="keyword">return</span> YES;</span><br><span class="line">        <span class="keyword">if</span> (supercls-&gt;isRealized()) <span class="keyword">return</span> NO;</span><br><span class="line">        <span class="keyword">return</span> missingWeakSuperclass(supercls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码的注释已经一目了然：该函数就是判断某个 class 的父类是否是 weak-linked 并且缺失了。那 什么叫做 weak-linked？比如 NSObject 是否是 weak-linbked ？很显然不是的。那么什么是 weak-linked？</p>
<p>weak-linked<br>我们开发的时候，都会使用最新的SDK，但是为了让老的设备可以下载并运行我们的应用，就要将Deployment Target设置成之前系统的版本号。例如我们应用使用iOS 8.1的SDK，Deployment Target设置成iOS 5.1.1，虽然我们开发的时候使用的是8.1的SDK，但是程序运行在的设备中却可能是6.0 or 7.0的SDK上，按照苹果的说法，如果我们应用使用了最新SDK引入的特性，比如符号、函数等，那么在版本较旧的设备上就运行不了。下面是苹果官方文档的一段话：<br>Normally, if an application uses a new feature in a framework, it is unable to run on earlier versions of the framework that do not support that feature. Such applications would either fail to launch or crash when an attempt to use the feature was made.<br>那么为什么我们使用最新的SDK开发的应用却可以运行在旧的系统中呢？答案是使用了弱引用。资料里面说过，我们自己创建的framework，如果需要做版本兼容，那么就要对今后加入的符号等使用弱引用，使用了弱引用之后，即使在版本较旧的环境下跑，也可以运行，只是相应的符号是NULL，下面就是教我们怎样定义弱引用。有一点需要说明的是，如果一个framework没有为新加入的符号加入弱引用，那也不必担心，我们只要在链接时弱引用整个framework就好，方法就是链接的时候使用 -weak_framework frameworkName</p>
<p>一个使用 weak 的实例为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extern int MyWeakLinkedFunction() __attribute__((weak_import));</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    if (MyWeakLinkedFunction !&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        result &#x3D; MyWeakLinkedFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码片段来自苹果官网。</p>
<p>这么一来， missingWeakSuperclass 的作用的作用就不言而喻了：查看 cls 类的祖宗类中是否有类是 weak-linked 的，并且已经 missing，祖宗类里有 missing weak-linked 的，则 cls 的所有信息也是不可信的，所以将其添加到重映射表里，映射为nil，即 cls -&gt; nil。</p>
<h3 id="future-named-class-map"><a href="#future-named-class-map" class="headerlink" title="future_named_class_map"></a>future_named_class_map</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* futureNamedClasses</span></span><br><span class="line"><span class="comment">* Returns the classname =&gt; future class map for unrealized future classes.</span></span><br><span class="line"><span class="comment">* Locking: runtimeLock must be held by the caller</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">static</span> NXMapTable *future_named_class_map = nil;</span><br><span class="line"><span class="function"><span class="keyword">static</span> NXMapTable *<span class="title">futureNamedClasses</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    <span class="keyword">if</span> (future_named_class_map) <span class="keyword">return</span> future_named_class_map;</span><br><span class="line">    <span class="comment">// future_named_class_map is big enough for CF's classes and a few others</span></span><br><span class="line">    future_named_class_map = </span><br><span class="line">        NXCreateMapTable(NXStrValueMapPrototype, <span class="number">32</span>);</span><br><span class="line">    <span class="keyword">return</span> future_named_class_map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码是创建代码，下面我们看一下使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Used by CoreFoundation's toll-free bridging.</span></span><br><span class="line"><span class="comment"> * Return the id of the named class.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return The id of the named class, or an uninitialized class</span></span><br><span class="line"><span class="comment"> *  structure that will be used for the class when and if it does </span></span><br><span class="line"><span class="comment"> *  get loaded.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @warning Do not call this function yourself.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">OBJC_EXPORT Class _Nonnull</span><br><span class="line">objc_getFutureClass(<span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name) </span><br><span class="line">    OBJC_AVAILABLE(<span class="number">10.5</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>)</span><br><span class="line">    OBJC_ARC_UNAVAILABLE;</span><br></pre></td></tr></table></figure>

<p>看注释有个警告，不要主动调用这个函数。下面是具体的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* objc_getFutureClass.  Return the id of the named class.</span></span><br><span class="line"><span class="comment">* If the class does not exist, return an uninitialized class </span></span><br><span class="line"><span class="comment">* structure that will be used for the class when and if it </span></span><br><span class="line"><span class="comment">* does get loaded.</span></span><br><span class="line"><span class="comment">* Not thread safe. </span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function">Class <span class="title">objc_getFutureClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="comment">// YES unconnected, NO class handler</span></span><br><span class="line">    <span class="comment">// (unconnected is OK because it will someday be the real class)</span></span><br><span class="line">    cls = look_up_class(name, YES, NO);</span><br><span class="line">    <span class="keyword">if</span> (cls) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintFuture) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"FUTURE: found %p already in use for %s"</span>, </span><br><span class="line">                         (<span class="keyword">void</span>*)cls, name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No class or future class with that name yet. Make one.</span></span><br><span class="line">    <span class="comment">// fixme not thread-safe with respect to </span></span><br><span class="line">    <span class="comment">// simultaneous library load or getFutureClass.</span></span><br><span class="line">    <span class="keyword">return</span> _objc_allocateFutureClass(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中函数 look_up_class 这里先不多做介绍了，里面逻辑较多，而且不是这个函数的重点，重点是最后一句：<code>_objc_allocateFutureClass(name)</code> 它才是从 hash map 中获取对应值的函数，其实现如下 ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* _objc_allocateFutureClass</span></span><br><span class="line"><span class="comment">* Allocate an unresolved future class for the given class name.</span></span><br><span class="line"><span class="comment">* Returns any existing allocation if one was already made.</span></span><br><span class="line"><span class="comment">* Assumes the named class doesn't exist yet.</span></span><br><span class="line"><span class="comment">* Locking: acquires runtimeLock</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line">Class _objc_allocateFutureClass(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">    Class cls;</span><br><span class="line">    NXMapTable *<span class="built_in">map</span> = futureNamedClasses();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((cls = (Class)NXMapGet(<span class="built_in">map</span>, name))) &#123;</span><br><span class="line">        <span class="comment">// Already have a future class for this name.</span></span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125;</span><br><span class="line">    cls = _calloc_class(<span class="keyword">sizeof</span>(objc_class));</span><br><span class="line">    addFutureNamedClass(name, cls);</span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很容易理解：有的话就通过方法 NXMapGet 取出来，没有的话则创建。</p>
<p>我们再看一下一出代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* popFutureNamedClass</span></span><br><span class="line"><span class="comment">* Removes the named class from the unrealized future class list, </span></span><br><span class="line"><span class="comment">* because it has been realized.</span></span><br><span class="line"><span class="comment">* Returns nil if the name is not used by a future class.</span></span><br><span class="line"><span class="comment">* Locking: runtimeLock must be held by the caller</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">popFutureNamedClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    Class cls = nil;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (future_named_class_map) &#123;</span><br><span class="line">        cls = (Class)NXMapKeyFreeingRemove(future_named_class_map, name);</span><br><span class="line">        <span class="keyword">if</span> (cls &amp;&amp; NXCountMapTable(future_named_class_map) == <span class="number">0</span>) &#123;</span><br><span class="line">            NXFreeMapTable(future_named_class_map);</span><br><span class="line">            future_named_class_map = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法有点熟悉了，正是上文介绍的 remap 的条件之一。上一篇文章讲述的是第一个条件，本文讲的是第二个条件。这两个条件无论哪一个符合都会调用方法：addRemappedClass，即向 remapped_class_map 中插入数据</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>future named class 的介绍就到这里了，希望大家有所收获。其实笔者看来，不管是上一篇文章的 remapped_class_map 还是本文的 future_named_class_map 里面的数据都是空。remapped_class_map 有数据是需要一定条件，而 future_named_class_map 有数据也是需要先 add 的，所以大家对于这两个 map 只需要有个大概的概念就好，后面如果真的碰到他们有数据，我们在详细分析。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/13/iOS%E5%BA%95%E5%B1%82%EF%BC%9A%E6%87%92%E5%8A%A0%E8%BD%BD%E7%B1%BB%E4%B8%8E%E9%9D%9E%E6%87%92%E5%8A%A0%E8%BD%BD%E7%B1%BB-realizeClass%E3%80%81methodizeClass/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/13/iOS%E5%BA%95%E5%B1%82%EF%BC%9A%E6%87%92%E5%8A%A0%E8%BD%BD%E7%B1%BB%E4%B8%8E%E9%9D%9E%E6%87%92%E5%8A%A0%E8%BD%BD%E7%B1%BB-realizeClass%E3%80%81methodizeClass/" class="post-title-link" itemprop="url">iOS底层：懒加载类与非懒加载类 realizeClass、methodizeClass</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-13 09:22:10 / 修改时间：13:56:24" itemprop="dateCreated datePublished" datetime="2021-05-13T09:22:10+08:00">2021-05-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>懒加载类其实就是指类的加载在第一次消息发送之前，但是如果我们在类中实现了+load方法，那么类的加载就会提前到pre-main之前,提前加载的类就称之为非懒加载类。</p>
<h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><p>realizeClassWithoutSwift我们先看其源码实现，因为我们这里主要探究的是加载，其中加载具体做的事情不做过多说明，把部分源码进行了省略。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">realizeClassWithoutSwift</span><span class="params">(Class cls, Class previously)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    <span class="keyword">class_rw_t</span> *rw;<span class="comment">//读写区，运行期间进行</span></span><br><span class="line">    Class supercls;</span><br><span class="line">    Class metacls;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;isRealized()) &#123;</span><br><span class="line">        validateAlreadyRealizedClass(cls);</span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125;</span><br><span class="line">    ASSERT(cls == remapClass(cls));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme verify class is not in an un-dlopened part of the shared cache?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ro = (<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *)cls-&gt;data();</span><br><span class="line">    <span class="keyword">auto</span> isMeta = ro-&gt;flags &amp; RO_META;</span><br><span class="line">    <span class="keyword">if</span> (ro-&gt;flags &amp; RO_FUTURE) &#123;</span><br><span class="line">        <span class="comment">// This was a future class. rw data is already allocated.</span></span><br><span class="line">        rw = cls-&gt;data();</span><br><span class="line">        ro = cls-&gt;data()-&gt;ro();</span><br><span class="line">        ASSERT(!isMeta);</span><br><span class="line">        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Normal class. Allocate writeable class data.</span></span><br><span class="line">        rw = objc::zalloc&lt;<span class="keyword">class_rw_t</span>&gt;();</span><br><span class="line">        rw-&gt;set_ro(ro);</span><br><span class="line">        rw-&gt;flags = RW_REALIZED|RW_REALIZING|isMeta;</span><br><span class="line">        cls-&gt;setData(rw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cls-&gt;cache.initializeToEmptyOrPreoptimizedInDisguise();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FAST_CACHE_META</span></span><br><span class="line">    <span class="keyword">if</span> (isMeta) cls-&gt;cache.setBit(FAST_CACHE_META);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Choose an index for this class.</span></span><br><span class="line">    <span class="comment">// Sets cls-&gt;instancesRequireRawIsa if indexes no more indexes are available</span></span><br><span class="line">    cls-&gt;chooseClassArrayIndex();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">        _objc_inform(<span class="string">"CLASS: realizing class '%s'%s %p %p #%u %s%s"</span>,</span><br><span class="line">                     cls-&gt;nameForLogging(), isMeta ? <span class="string">" (meta)"</span> : <span class="string">""</span>, </span><br><span class="line">                     (<span class="keyword">void</span>*)cls, ro, cls-&gt;classArrayIndex(),</span><br><span class="line">                     cls-&gt;isSwiftStable() ? <span class="string">"(swift)"</span> : <span class="string">""</span>,</span><br><span class="line">                     cls-&gt;isSwiftLegacy() ? <span class="string">"(pre-stable swift)"</span> : <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Realize superclass and metaclass, if they aren't already.</span></span><br><span class="line">    <span class="comment">// This needs to be done after RW_REALIZED is set above, for root classes.</span></span><br><span class="line">    <span class="comment">// This needs to be done after class index is chosen, for root metaclasses.</span></span><br><span class="line">    <span class="comment">// This assumes that none of those classes have Swift contents,</span></span><br><span class="line">    <span class="comment">//   or that Swift's initializers have already been called.</span></span><br><span class="line">    <span class="comment">//   fixme that assumption will be wrong if we add support</span></span><br><span class="line">    <span class="comment">//   for ObjC subclasses of Swift classes.</span></span><br><span class="line">  	<span class="comment">//父类加载</span></span><br><span class="line">    supercls = realizeClassWithoutSwift(remapClass(cls-&gt;getSuperclass()), nil);</span><br><span class="line">  	<span class="comment">//元类也加载了</span></span><br><span class="line">    metacls = realizeClassWithoutSwift(remapClass(cls-&gt;ISA()), nil);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    <span class="keyword">if</span> (isMeta) &#123;</span><br><span class="line">        <span class="comment">// Metaclasses do not need any features from non pointer ISA</span></span><br><span class="line">        <span class="comment">// This allows for a faspath for classes in objc_retain/objc_release.</span></span><br><span class="line">        cls-&gt;setInstancesRequireRawIsa();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Disable non-pointer isa for some classes and/or platforms.</span></span><br><span class="line">        <span class="comment">// Set instancesRequireRawIsa.</span></span><br><span class="line">        <span class="keyword">bool</span> instancesRequireRawIsa = cls-&gt;instancesRequireRawIsa();</span><br><span class="line">        <span class="keyword">bool</span> rawIsaIsInherited = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">bool</span> hackedDispatch = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DisableNonpointerIsa) &#123;</span><br><span class="line">            <span class="comment">// Non-pointer isa disabled by environment or app SDK version</span></span><br><span class="line">            instancesRequireRawIsa = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!hackedDispatch  &amp;&amp;  <span class="number">0</span> == <span class="built_in">strcmp</span>(ro-&gt;getName(), <span class="string">"OS_object"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// hack for libdispatch et al - isa also acts as vtable pointer</span></span><br><span class="line">            hackedDispatch = <span class="literal">true</span>;</span><br><span class="line">            instancesRequireRawIsa = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (supercls  &amp;&amp;  supercls-&gt;getSuperclass()  &amp;&amp;</span><br><span class="line">                 supercls-&gt;instancesRequireRawIsa())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// This is also propagated by addSubclass()</span></span><br><span class="line">            <span class="comment">// but nonpointer isa setup needs it earlier.</span></span><br><span class="line">            <span class="comment">// Special case: instancesRequireRawIsa does not propagate</span></span><br><span class="line">            <span class="comment">// from root class to root metaclass</span></span><br><span class="line">            instancesRequireRawIsa = <span class="literal">true</span>;</span><br><span class="line">            rawIsaIsInherited = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (instancesRequireRawIsa) &#123;</span><br><span class="line">            cls-&gt;setInstancesRequireRawIsaRecursively(rawIsaIsInherited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// SUPPORT_NONPOINTER_ISA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update superclass and metaclass in case of remapping</span></span><br><span class="line">    cls-&gt;setSuperclass(supercls);</span><br><span class="line">    cls-&gt;initClassIsa(metacls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reconcile instance variable offsets / layout.</span></span><br><span class="line">    <span class="comment">// This may reallocate class_ro_t, updating our ro variable.</span></span><br><span class="line">    <span class="keyword">if</span> (supercls  &amp;&amp;  !isMeta) reconcileInstanceVariables(cls, supercls, ro);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set fastInstanceSize if it wasn't set already.</span></span><br><span class="line">    cls-&gt;setInstanceSize(ro-&gt;instanceSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy some flags from ro to rw</span></span><br><span class="line">    <span class="keyword">if</span> (ro-&gt;flags &amp; RO_HAS_CXX_STRUCTORS) &#123;</span><br><span class="line">        cls-&gt;setHasCxxDtor();</span><br><span class="line">        <span class="keyword">if</span> (! (ro-&gt;flags &amp; RO_HAS_CXX_DTOR_ONLY)) &#123;</span><br><span class="line">            cls-&gt;setHasCxxCtor();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Propagate the associated objects forbidden flag from ro or from</span></span><br><span class="line">    <span class="comment">// the superclass.</span></span><br><span class="line">    <span class="keyword">if</span> ((ro-&gt;flags &amp; RO_FORBIDS_ASSOCIATED_OBJECTS) ||</span><br><span class="line">        (supercls &amp;&amp; supercls-&gt;forbidsAssociatedObjects()))</span><br><span class="line">    &#123;</span><br><span class="line">        rw-&gt;flags |= RW_FORBIDS_ASSOCIATED_OBJECTS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Connect this class to its superclass's subclass lists</span></span><br><span class="line">    <span class="keyword">if</span> (supercls) &#123;</span><br><span class="line">        addSubclass(supercls, cls);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addRootClass(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Attach categories</span></span><br><span class="line">    methodizeClass(cls, previously);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="methodizeClass"><a href="#methodizeClass" class="headerlink" title="methodizeClass"></a>methodizeClass</h4><p>关注到<code>methodizeClass(cls,previously)</code>方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodizeClass</span><span class="params">(Class cls, Class previously)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isMeta = cls-&gt;isMetaClass();</span><br><span class="line">    <span class="keyword">auto</span> rw = cls-&gt;data();</span><br><span class="line">    <span class="keyword">auto</span> ro = rw-&gt;ro();</span><br><span class="line">    <span class="keyword">auto</span> rwe = rw-&gt;ext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Methodizing for the first time</span></span><br><span class="line">    <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">        _objc_inform(<span class="string">"CLASS: methodizing class '%s' %s"</span>, </span><br><span class="line">                     cls-&gt;nameForLogging(), isMeta ? <span class="string">"(meta)"</span> : <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install methods and properties that the class implements itself.</span></span><br><span class="line">  	<span class="comment">// 方法列表 </span></span><br><span class="line">    <span class="keyword">method_list_t</span> *<span class="built_in">list</span> = ro-&gt;baseMethods();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">        prepareMethodLists(cls, &amp;<span class="built_in">list</span>, <span class="number">1</span>, YES, isBundleClass(cls), <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">if</span> (rwe) rwe-&gt;methods.attachLists(&amp;<span class="built_in">list</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 属性列表</span></span><br><span class="line">    <span class="keyword">property_list_t</span> *proplist = ro-&gt;baseProperties;</span><br><span class="line">    <span class="keyword">if</span> (rwe &amp;&amp; proplist) &#123;</span><br><span class="line">        rwe-&gt;properties.attachLists(&amp;proplist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 协议列表</span></span><br><span class="line">    <span class="keyword">protocol_list_t</span> *protolist = ro-&gt;baseProtocols;</span><br><span class="line">    <span class="keyword">if</span> (rwe &amp;&amp; protolist) &#123;</span><br><span class="line">        rwe-&gt;protocols.attachLists(&amp;protolist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Root classes get bonus method implementations if they don't have </span></span><br><span class="line">    <span class="comment">// them already. These apply before category replacements.</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;isRootMetaclass()) &#123;</span><br><span class="line">        <span class="comment">// root metaclass</span></span><br><span class="line">        addMethod(cls, @selector(initialize), (IMP)&amp;objc_noop_imp, <span class="string">""</span>, NO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Attach categories.</span></span><br><span class="line">    <span class="keyword">if</span> (previously) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) &#123;</span><br><span class="line">            objc::unattachedCategories.attachToClass(cls, previously,</span><br><span class="line">                                                     ATTACH_METACLASS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// When a class relocates, categories with class methods</span></span><br><span class="line">            <span class="comment">// may be registered on the class itself rather than on</span></span><br><span class="line">            <span class="comment">// the metaclass. Tell attachToClass to look for those.</span></span><br><span class="line">            objc::unattachedCategories.attachToClass(cls, previously,</span><br><span class="line">                                                     ATTACH_CLASS_AND_METACLASS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    objc::unattachedCategories.attachToClass(cls, cls,</span><br><span class="line">                                             isMeta ? ATTACH_METACLASS : ATTACH_CLASS);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">    <span class="comment">// Debug: sanity-check all SELs; log method list contents</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; meth : rw-&gt;methods()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"METHOD %c[%s %s]"</span>, isMeta ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(meth.name()));</span><br><span class="line">        &#125;</span><br><span class="line">        ASSERT(sel_registerName(sel_getName(meth.name())) == meth.name());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可得出以下结论：</p>
<ul>
<li>虽然实现类调用的<code>methodizeClass</code>-&gt;<code>attachToClass</code>后没调用<code>attachCategories</code>方法，但是<code>load_images</code>-&gt;<code>loadAllCategories</code>后会调用<code>attachCategories</code>方法。</li>
<li><code>attachCategories</code>方法中进行了<code>rwe</code>初始化。</li>
</ul>
<p>根据方法的注释我们可以解读出以下信息：</p>
<ul>
<li>对类cls执行首次初始化</li>
<li>包括分配读写数据。</li>
<li>不执行任何Swift侧初始化。</li>
<li>返回类的实际类结构。</li>
<li>锁定:runtimeLock必须由调用者写锁</li>
</ul>
<p>对方法的实现的一些概念进行解读<br> ro：干净内存(Clean Memory),存放的是类的原始数据<br> rw：脏内存(Dirty Memory) ，运行时会对类内存进行动态的修改所以才有rw，rw最初是从ro中读取的数据。<br> rwe：新增内容，运行时动态修改类才会生成rwe，rwe的原始数据是从rw中读取的。<br> supercls = realizeClassWithoutSwift(remapClass(cls-&gt;superclass), nil);沿着继承链递归调用realizeClassWithoutSwift。<br> metacls = realizeClassWithoutSwift(remapClass(cls-&gt;ISA()), nil);沿着isa走位递归调用realizeClassWithoutSwift。<br> 所以如果一个类加载了，其继承链上的父类、isa对应的元类等都会加载。</p>
<h3 id="懒加载类"><a href="#懒加载类" class="headerlink" title="懒加载类"></a>懒加载类</h3><p>我们实现了+load方法类的加载就会提前，+load是如何影响类的加载的时机的呢？<br> load_images源码中有说明在dyld映射的镜像中处理+load，我们需要去看看load_images中是如何处理+load方法的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">load_images(<span class="keyword">const</span> <span class="keyword">char</span> *path __unused, <span class="keyword">const</span> struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!didInitialAttachCategories &amp;&amp; didCallDyldNotifyRegister) &#123;</span><br><span class="line">        didInitialAttachCategories = <span class="literal">true</span>;</span><br><span class="line">        loadAllCategories();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return without taking locks if there are no +load methods here.</span></span><br><span class="line">  	<span class="comment">//如果没有+load方法 则返回 不带锁</span></span><br><span class="line">    <span class="keyword">if</span> (!hasLoadMethods((<span class="keyword">const</span> headerType *)mh)) <span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">//加递归锁</span></span><br><span class="line">    <span class="function"><span class="keyword">recursive_mutex_locker_t</span> <span class="title">lock</span><span class="params">(loadMethodLock)</span></span>;</span><br><span class="line">    <span class="comment">// Discover load methods</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock2</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">        prepare_load_methods((<span class="keyword">const</span> headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>hasLoadMethods:</code>判断的条件有两个：</p>
<ul>
<li>_getObjc2NonlazyClassList:获取所有类中的Load方法数量</li>
<li>_getObjc2NonlazyCategoryList:获取所有分类中的Load方法数量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Quick scan for +load methods that doesn't take a lock.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasLoadMethods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    <span class="keyword">if</span> (_getObjc2NonlazyClassList(mhdr, &amp;count)  &amp;&amp;  count &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (_getObjc2NonlazyCategoryList(mhdr, &amp;count)  &amp;&amp;  count &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果存在<code>+load</code>方法，后面加锁后开始进入<code>prepare_load_methods</code>函数，它的作用是发现所有的<code>+load</code>方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_load_methods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count, i;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">		<span class="comment">//获取非懒加载类</span></span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">//循环遍历加载非懒加载类的load方法到loadable_classes</span></span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//获取非懒加载分类列表</span></span><br><span class="line">    <span class="keyword">category_t</span> * <span class="keyword">const</span> *categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">category_t</span> *cat = categorylist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;isSwiftStable()) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">"Swift class extensions and categories on Swift "</span></span><br><span class="line">                        <span class="string">"classes are not allowed to have +load methods"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果类没有初始化就去初始化</span></span><br><span class="line">        realizeClassWithoutSwift(cls, nil);</span><br><span class="line">        ASSERT(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>prepare_load_methods中分为两部分：<br> 1.获取非懒加载类列表，猜测这里应该已经加载了对应的类，循环遍历加载非懒加载类的load方法到loadable_classes.其中关键的方法schedule_class_load、add_class_to_loadable_list。<br> 2.获取非懒加载分类列表，循环遍历去加载非懒加载分类的 load 方法到 loadable_categories。<br> 其中关键的方法add_category_to_loadable_list。<br> 非懒加载分类遍历时，有一个处理realizeClassWithoutSwift(cls, nil)，在遍历加载非懒加载类的load方法时，会调用realizeClassWithoutSwift，如果分类对应的类没有记载，在这里就会被加载。</p>
<h3 id="懒加载类-1"><a href="#懒加载类-1" class="headerlink" title="懒加载类"></a>懒加载类</h3><p>对于懒加载类，是在第一次消息发送<code>objc_msgSend</code>,调用<code>lookUpImpOrForward</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE</span><br><span class="line"><span class="function">IMP <span class="title">lookUpImpOrForward</span><span class="params">(id inst, SEL sel, Class cls, <span class="keyword">int</span> behavior)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> IMP forward_imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">    IMP imp = nil;</span><br><span class="line">    Class curClass;</span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line">    <span class="keyword">if</span> (slowpath(!cls-&gt;isInitialized())) &#123;</span><br><span class="line">        <span class="comment">// The first message sent to a class is often +new or +alloc, or +self</span></span><br><span class="line">        <span class="comment">// which goes through objc_opt_* or various optimized entry points.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// However, the class isn't realized/initialized yet at this point,</span></span><br><span class="line">        <span class="comment">// and the optimized entry points fall down through objc_msgSend,</span></span><br><span class="line">        <span class="comment">// which ends up here.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// We really want to avoid caching these, as it can cause IMP caches</span></span><br><span class="line">        <span class="comment">// to be made with a single entry forever.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Note that this check is racy as several threads might try to</span></span><br><span class="line">        <span class="comment">// message a given class for the first time at the same time,</span></span><br><span class="line">        <span class="comment">// in which case we might cache anyway.</span></span><br><span class="line">        behavior |= LOOKUP_NOCACHE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// runtimeLock is held during isRealized and isInitialized checking</span></span><br><span class="line">    <span class="comment">// to prevent races against concurrent realization.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// runtimeLock is held during method search to make</span></span><br><span class="line">    <span class="comment">// method-lookup + cache-fill atomic with respect to method addition.</span></span><br><span class="line">    <span class="comment">// Otherwise, a category could be added but ignored indefinitely because</span></span><br><span class="line">    <span class="comment">// the cache was re-filled with the old value after the cache flush on</span></span><br><span class="line">    <span class="comment">// behalf of the category.</span></span><br><span class="line"></span><br><span class="line">    runtimeLock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't want people to be able to craft a binary blob that looks like</span></span><br><span class="line">    <span class="comment">// a class but really isn't one and do a CFI attack.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// To make these harder we want to make sure this is a class that was</span></span><br><span class="line">    <span class="comment">// either built into the binary or legitimately registered through</span></span><br><span class="line">    <span class="comment">// objc_duplicateClass, objc_initializeClassPair or objc_allocateClassPair.</span></span><br><span class="line">    checkIsKnownClass(cls);</span><br><span class="line">		<span class="comment">//关注这里</span></span><br><span class="line">    cls = realizeAndInitializeIfNeeded_locked(inst, cls, behavior &amp; LOOKUP_INITIALIZE);</span><br><span class="line">    <span class="comment">// runtimeLock may have been dropped but is now locked again</span></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    curClass = cls;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The code used to lookup the class's cache again right after</span></span><br><span class="line">    <span class="comment">// we take the lock but for the vast majority of the cases</span></span><br><span class="line">    <span class="comment">// evidence shows this is a miss most of the time, hence a time loss.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The only codepath calling into this without having performed some</span></span><br><span class="line">    <span class="comment">// kind of cache lookup is class_getInstanceMethod().</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> attempts = unreasonableClassCount();;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curClass-&gt;cache.isConstantOptimizedCache(<span class="comment">/* strict */</span><span class="literal">true</span>)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_USE_PREOPT_CACHES</span></span><br><span class="line">            imp = cache_getImp(curClass, sel);</span><br><span class="line">            <span class="keyword">if</span> (imp) <span class="keyword">goto</span> done_unlock;</span><br><span class="line">            curClass = curClass-&gt;cache.preoptFallbackClass();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// curClass method list.</span></span><br><span class="line">            Method meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">            <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">                imp = meth-&gt;imp(<span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (slowpath((curClass = curClass-&gt;getSuperclass()) == nil)) &#123;</span><br><span class="line">                <span class="comment">// No implementation found, and method resolver didn't help.</span></span><br><span class="line">                <span class="comment">// Use forwarding.</span></span><br><span class="line">                imp = forward_imp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Halt if there is a cycle in the superclass chain.</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(--attempts == <span class="number">0</span>)) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">"Memory corruption in class list."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Superclass cache.</span></span><br><span class="line">        imp = cache_getImp(curClass, sel);</span><br><span class="line">        <span class="keyword">if</span> (slowpath(imp == forward_imp)) &#123;</span><br><span class="line">            <span class="comment">// Found a forward:: entry in a superclass.</span></span><br><span class="line">            <span class="comment">// Stop searching, but don't cache yet; call method</span></span><br><span class="line">            <span class="comment">// resolver for this class first.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fastpath(imp)) &#123;</span><br><span class="line">            <span class="comment">// Found the method in a superclass. Cache it in this class.</span></span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No implementation found. Try method resolver once.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</span><br><span class="line">        behavior ^= LOOKUP_RESOLVER;</span><br><span class="line">        <span class="keyword">return</span> resolveMethod_locked(inst, sel, cls, behavior);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> done:</span><br><span class="line">    <span class="keyword">if</span> (fastpath((behavior &amp; LOOKUP_NOCACHE) == <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_USE_PREOPT_CACHES</span></span><br><span class="line">        <span class="keyword">while</span> (cls-&gt;cache.isConstantOptimizedCache(<span class="comment">/* strict */</span><span class="literal">true</span>)) &#123;</span><br><span class="line">            cls = cls-&gt;cache.preoptFallbackClass();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">    &#125;</span><br><span class="line"> done_unlock:</span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line">    <span class="keyword">if</span> (slowpath((behavior &amp; LOOKUP_NIL) &amp;&amp; imp == forward_imp)) &#123;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Class</span><br><span class="line">realizeAndInitializeIfNeeded_locked(id inst, Class cls, <span class="keyword">bool</span> initialize)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    <span class="keyword">if</span> (slowpath(!cls-&gt;isRealized())) &#123;</span><br><span class="line">        cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);</span><br><span class="line">        <span class="comment">// runtimeLock may have been dropped but is now locked again</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(initialize &amp;&amp; !cls-&gt;isInitialized())) &#123;</span><br><span class="line">        cls = initializeAndLeaveLocked(cls, inst, runtimeLock);</span><br><span class="line">        <span class="comment">// runtimeLock may have been dropped but is now locked again</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If sel == initialize, class_initialize will send +initialize and</span></span><br><span class="line">        <span class="comment">// then the messenger will send +initialize again after this</span></span><br><span class="line">        <span class="comment">// procedure finishes. Of course, if this is not being called</span></span><br><span class="line">        <span class="comment">// from the messenger then it won't happen. 2778172</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> Class</span><br><span class="line">realizeClassMaybeSwiftAndLeaveLocked(Class cls, <span class="keyword">mutex_t</span>&amp; lock)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> realizeClassMaybeSwiftMaybeRelock(cls, lock, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> Class</span><br><span class="line">realizeClassMaybeSwiftMaybeRelock(Class cls, <span class="keyword">mutex_t</span>&amp; lock, <span class="keyword">bool</span> leaveLocked)</span><br><span class="line">&#123;</span><br><span class="line">    lock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;isSwiftStable_ButAllowLegacyForNow()) &#123;</span><br><span class="line">        <span class="comment">// Non-Swift class. Realize it now with the lock still held.</span></span><br><span class="line">        <span class="comment">// fixme wrong in the future for objc subclasses of swift classes</span></span><br><span class="line">        realizeClassWithoutSwift(cls, nil);</span><br><span class="line">        <span class="keyword">if</span> (!leaveLocked) lock.unlock();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Swift class. We need to drop locks and call the Swift</span></span><br><span class="line">        <span class="comment">// runtime to initialize it.</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">        cls = realizeSwiftClass(cls);</span><br><span class="line">        ASSERT(cls-&gt;isRealized());    <span class="comment">// callback must have provoked realization</span></span><br><span class="line">        <span class="keyword">if</span> (leaveLocked) lock.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以清晰的看到lookUpImpOrForward中也会调用到realizeClassWithoutSwift，对类进行加载。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>懒加载类情况  类加载延迟到第一次消息发送。<br> lookUpImOrForward<br> realizeClassMaybeSwiftMaybeRelock<br> relizeClassWithoutSwift<br> methodizeClass</p>
<p>非懒记载类调用了+load方法，类就会提前加载。<br> getObjc2NonlazyClassList<br> readClass<br> realizeClassWithoutSwift<br> methodizeClass</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/12/iOS%E5%BA%95%E5%B1%82%EF%BC%9Acache_t/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/12/iOS%E5%BA%95%E5%B1%82%EF%BC%9Acache_t/" class="post-title-link" itemprop="url">iOS底层：cache_t</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-12 13:55:04 / 修改时间：17:03:51" itemprop="dateCreated datePublished" datetime="2021-05-12T13:55:04+08:00">2021-05-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前文我们探索了iOS类的底层原理，简单了解了四个重要的属性。这篇文章主要探索第三个属性<code>cache_t</code>，对于这个属性，我们可以学习到苹果对于缓存的设计和理解。</p>
<h3 id="探索cache-t"><a href="#探索cache-t" class="headerlink" title="探索cache_t"></a>探索<code>cache_t</code></h3><p>从数据结构开始</p>
<h4 id="cache-t的基本结构"><a href="#cache-t的基本结构" class="headerlink" title="cache_t的基本结构"></a><code>cache_t</code>的基本结构</h4><p>我们看一下源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line"><span class="comment">//省略代码</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// The following four fields are public for objcdt's use only.</span></span><br><span class="line">    <span class="comment">// objcdt reaches into fields while the process is suspended</span></span><br><span class="line">    <span class="comment">// hence doesn't care for locks and pesky little details like this</span></span><br><span class="line">    <span class="comment">// and can safely use these.</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">struct <span class="keyword">bucket_t</span> *<span class="title">buckets</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//重点</span></span><br><span class="line">    <span class="function">Class <span class="title">cls</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_USE_PREOPT_CACHES</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">preopt_cache_t</span> *<span class="title">preopt_cache</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">mask_t</span> <span class="title">occupied</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initializeToEmpty</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="comment">//省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现有一个<code>buckets()</code>成员，它是一个结构体<code>bucket_t</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// IMP-first is better for arm64e ptrauth and no worse for arm64.</span></span><br><span class="line">    <span class="comment">// SEL-first is better for armv7* and i386 and x86_64.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __arm64__</span></span><br><span class="line">    explicit_atomic&lt;<span class="keyword">uintptr_t</span>&gt; _imp;</span><br><span class="line">    explicit_atomic&lt;SEL&gt; _sel;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    explicit_atomic&lt;SEL&gt; _sel;</span><br><span class="line">    explicit_atomic&lt;<span class="keyword">uintptr_t</span>&gt; _imp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// Compute the ptrauth signing modifier from &amp;_imp, newSel, and cls.</span></span><br><span class="line">    <span class="function"><span class="keyword">uintptr_t</span> <span class="title">modifierForSEL</span><span class="params">(<span class="keyword">bucket_t</span> *base, SEL newSel, Class cls)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">uintptr_t</span>)base ^ (<span class="keyword">uintptr_t</span>)newSel ^ (<span class="keyword">uintptr_t</span>)cls;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Sign newImp, with &amp;_imp, newSel, and cls as modifiers.</span></span><br><span class="line">    <span class="function"><span class="keyword">uintptr_t</span> <span class="title">encodeImp</span><span class="params">(UNUSED_WITHOUT_PTRAUTH <span class="keyword">bucket_t</span> *base, IMP newImp, UNUSED_WITHOUT_PTRAUTH SEL newSel, Class cls)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!newImp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CACHE_IMP_ENCODING == CACHE_IMP_ENCODING_PTRAUTH</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">uintptr_t</span>)</span><br><span class="line">            ptrauth_auth_and_resign(newImp,</span><br><span class="line">                                    ptrauth_key_function_pointer, <span class="number">0</span>,</span><br><span class="line">                                    ptrauth_key_process_dependent_code,</span><br><span class="line">                                    modifierForSEL(base, newSel, cls));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> CACHE_IMP_ENCODING == CACHE_IMP_ENCODING_ISA_XOR</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">uintptr_t</span>)newImp ^ (<span class="keyword">uintptr_t</span>)cls;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> CACHE_IMP_ENCODING == CACHE_IMP_ENCODING_NONE</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">uintptr_t</span>)newImp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> Unknown method cache IMP encoding.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">offsetOfSel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> offsetof(<span class="keyword">bucket_t</span>, _sel); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> SEL <span class="title">sel</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _sel.load(memory_order_relaxed); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CACHE_IMP_ENCODING == CACHE_IMP_ENCODING_ISA_XOR</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAYBE_UNUSED_ISA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAYBE_UNUSED_ISA __attribute__((unused))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> IMP <span class="title">rawImp</span><span class="params">(MAYBE_UNUSED_ISA objc_class *cls)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">uintptr_t</span> imp = _imp.load(memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (!imp) <span class="keyword">return</span> nil;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CACHE_IMP_ENCODING == CACHE_IMP_ENCODING_PTRAUTH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> CACHE_IMP_ENCODING == CACHE_IMP_ENCODING_ISA_XOR</span></span><br><span class="line">        imp ^= (<span class="keyword">uintptr_t</span>)cls;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> CACHE_IMP_ENCODING == CACHE_IMP_ENCODING_NONE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> Unknown method cache IMP encoding.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span> (IMP)imp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> IMP <span class="title">imp</span><span class="params">(UNUSED_WITHOUT_PTRAUTH <span class="keyword">bucket_t</span> *base, Class cls)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">uintptr_t</span> imp = _imp.load(memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (!imp) <span class="keyword">return</span> nil;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CACHE_IMP_ENCODING == CACHE_IMP_ENCODING_PTRAUTH</span></span><br><span class="line">        SEL sel = _sel.load(memory_order_relaxed);</span><br><span class="line">        <span class="keyword">return</span> (IMP)</span><br><span class="line">            ptrauth_auth_and_resign((<span class="keyword">const</span> <span class="keyword">void</span> *)imp,</span><br><span class="line">                                    ptrauth_key_process_dependent_code,</span><br><span class="line">                                    modifierForSEL(base, sel, cls),</span><br><span class="line">                                    ptrauth_key_function_pointer, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> CACHE_IMP_ENCODING == CACHE_IMP_ENCODING_ISA_XOR</span></span><br><span class="line">        <span class="keyword">return</span> (IMP)(imp ^ (<span class="keyword">uintptr_t</span>)cls);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> CACHE_IMP_ENCODING == CACHE_IMP_ENCODING_NONE</span></span><br><span class="line">        <span class="keyword">return</span> (IMP)imp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> Unknown method cache IMP encoding.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;Atomicity, IMPEncoding&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">bucket_t</span> *base, SEL newSel, IMP newImp, Class cls)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从源码定义中不难看出，<code>bucket_t</code> 其实缓存的是方法实现 <code>IMP</code>。这里有一个注意点，就是 <code>IMP-first</code> 和 <code>SEL-first</code>。</p>
<blockquote>
<p>IMP-first is better for arm64e ptrauth and no worse for arm64.</p>
</blockquote>
<ul>
<li>IMP-first 对 arm64e 的效果更好，对 arm64 不会有坏的影响。</li>
</ul>
<blockquote>
<p>SEL-first is better for armv7* and i386 and x86_64.</p>
</blockquote>
<ul>
<li>SEL-first 适用于 armv7 * 和 i386 和 x86_64。</li>
</ul>
<p>通过上面的源码，我们大致了解了 bucket_t 类型的结构，那么现在问题来了，类中的 cache 是在什么时候以什么样的方式来进行缓存的呢？我们使用LLDB查看一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">lldb) x pClass</span><br><span class="line"><span class="number">0x100008220</span>: f8 <span class="number">81</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">40</span> <span class="number">71</span> <span class="number">35</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ........@q5.....</span><br><span class="line"><span class="number">0x100008230</span>: <span class="number">10</span> d4 <span class="number">22</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">24</span> <span class="number">80</span> <span class="number">01</span> <span class="number">00</span>  ..<span class="string">".........$...</span></span><br><span class="line"><span class="string">(lldb) p (cache_t *)0x100008230 //0x100008220 + 16字节（isa 8字节 + superclass 8字节）</span></span><br><span class="line"><span class="string">(cache_t *) $2 = 0x0000000100008230</span></span><br><span class="line"><span class="string">(lldb) p *$2</span></span><br><span class="line"><span class="string">(cache_t) $3 = &#123;</span></span><br><span class="line"><span class="string">  _bucketsAndMaybeMask = &#123;</span></span><br><span class="line"><span class="string">    std::__1::atomic&lt;unsigned long&gt; = &#123;</span></span><br><span class="line"><span class="string">      Value = 4314027024</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">   = &#123;</span></span><br><span class="line"><span class="string">     = &#123;</span></span><br><span class="line"><span class="string">      _maybeMask = &#123;</span></span><br><span class="line"><span class="string">        std::__1::atomic&lt;unsigned int&gt; = &#123;</span></span><br><span class="line"><span class="string">          Value = 3</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      _flags = 32804</span></span><br><span class="line"><span class="string">      _occupied = 1</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    _originalPreoptCache = &#123;</span></span><br><span class="line"><span class="string">      std::__1::atomic&lt;preopt_cache_t *&gt; = &#123;</span></span><br><span class="line"><span class="string">        Value = 0x0001802400000003</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">(lldb) p $3.buckets()</span></span><br><span class="line"><span class="string">(bucket_t *) $4 = 0x000000010122d410</span></span><br><span class="line"><span class="string">(lldb) p *$4</span></span><br><span class="line"><span class="string">(bucket_t) $5 = &#123;</span></span><br><span class="line"><span class="string">  _sel = &#123;</span></span><br><span class="line"><span class="string">    std::__1::atomic&lt;objc_selector *&gt; = "</span><span class="string">" &#123;</span></span><br><span class="line"><span class="string">      Value = "</span><span class="string">"</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  _imp = &#123;</span></span><br><span class="line"><span class="string">    std::__1::atomic&lt;unsigned long&gt; = &#123;</span></span><br><span class="line"><span class="string">      Value = 3365936</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>_occupied</code> 应该是表示当前已经占用了多少缓存（每调用一个实例方法会+1）。下面验证一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        Person *p &#x3D; [[Person alloc] init];</span><br><span class="line">      	Class pClass &#x3D; object_getClass(p);</span><br><span class="line">        [p sayHello];</span><br><span class="line">        [p sayOk];&#x2F;&#x2F;断点打在这</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x pClass</span><br><span class="line"><span class="number">0x100008240</span>: <span class="number">18</span> <span class="number">82</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">40</span> <span class="number">71</span> <span class="number">35</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ........@q5.....</span><br><span class="line"><span class="number">0x100008250</span>: <span class="number">00</span> dc <span class="number">74</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">24</span> <span class="number">80</span> <span class="number">02</span> <span class="number">00</span>  ..t.........$...</span><br><span class="line">(lldb) p (<span class="keyword">cache_t</span> *)<span class="number">0x100008250</span></span><br><span class="line">(<span class="keyword">cache_t</span> *) $<span class="number">1</span> = <span class="number">0x0000000100008250</span></span><br><span class="line">(lldb) p *$<span class="number">1</span></span><br><span class="line">(<span class="keyword">cache_t</span>) $<span class="number">2</span> = &#123;</span><br><span class="line">  _bucketsAndMaybeMask = &#123;</span><br><span class="line">    <span class="built_in">std</span>::__1::atomic&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span>&gt; = &#123;</span><br><span class="line">      Value = <span class="number">4302625792</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   = &#123;</span><br><span class="line">     = &#123;</span><br><span class="line">      _maybeMask = &#123;</span><br><span class="line">        <span class="built_in">std</span>::__1::atomic&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; = &#123;</span><br><span class="line">          Value = <span class="number">3</span><span class="comment">//注意</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      _flags = <span class="number">32804</span></span><br><span class="line">      _occupied = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    _originalPreoptCache = &#123;</span><br><span class="line">      <span class="built_in">std</span>::__1::atomic&lt;<span class="keyword">preopt_cache_t</span> *&gt; = &#123;</span><br><span class="line">        Value = <span class="number">0x0002802400000003</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>_occupied = 2</code>验证了我们的猜想，我们继续走断点发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        Person *p &#x3D; [[Person alloc] init];</span><br><span class="line">      	Class pClass &#x3D; object_getClass(p);</span><br><span class="line">        [p sayHello];</span><br><span class="line">        [p sayOk];</span><br><span class="line">        &#x2F;&#x2F;断点在最后一步</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(lldb) p *$1</span><br><span class="line">(cache_t) $3 &#x3D; &#123;</span><br><span class="line">  _bucketsAndMaybeMask &#x3D; &#123;</span><br><span class="line">    std::__1::atomic&lt;unsigned long&gt; &#x3D; &#123;</span><br><span class="line">      Value &#x3D; 4305857472</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   &#x3D; &#123;</span><br><span class="line">     &#x3D; &#123;</span><br><span class="line">      _maybeMask &#x3D; &#123;</span><br><span class="line">        std::__1::atomic&lt;unsigned int&gt; &#x3D; &#123;</span><br><span class="line">          Value &#x3D; 7&#x2F;&#x2F;注意</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      _flags &#x3D; 32804</span><br><span class="line">      _occupied &#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">    _originalPreoptCache &#x3D; &#123;</span><br><span class="line">      std::__1::atomic&lt;preopt_cache_t *&gt; &#x3D; &#123;</span><br><span class="line">        Value &#x3D; 0x0001802400000007</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现<code>_occupied=1</code>,<code>_maybeMask</code>的<code>Value=7</code>(上一步=3)，这是为什么</p>
<p>如果读者了解并掌握散列表这种数据结构的话，相信已经看出端倪了。是的，这里其实就是用到了 <strong>开放寻址法</strong> 来解决散列冲突（哈希冲突）。</p>
<blockquote>
<p>关于哈希冲突，可以借助鸽笼理论，即把 11 只鸽子放进 10 个抽屉里面，肯定会有一个抽屉里面有 2 只鸽子。是不是理解起来很简单? </p>
</blockquote>
<p>通过上面的测试，我们明确了方法缓存使用的是哈希表存储，并且为了解决无法避免的哈希冲突使用的是开放寻址法，而开放寻址法必然要在合适的时机进行扩容，这个时机肯定不是会在数据已经装满的时候，我们可以进源码探索一下，我们快速定位到 <code>cache_t</code> 的源码处:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_t::insert</span><span class="params">(SEL sel, IMP imp, id receiver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    <span class="comment">///省略代码</span></span><br><span class="line">    ASSERT(sel != <span class="number">0</span> &amp;&amp; cls()-&gt;isInitialized());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the cache as-is if until we exceed our expected fill ratio.</span></span><br><span class="line">    <span class="keyword">mask_t</span> newOccupied = occupied() + <span class="number">1</span>;</span><br><span class="line">  	<span class="comment">///取当前占用的空间大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> oldCapacity = capacity(), capacity = oldCapacity;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(isConstantEmptyCache())) &#123;</span><br><span class="line">        <span class="comment">// Cache is read-only. Replace it. </span></span><br><span class="line">        <span class="keyword">if</span> (!capacity) capacity = INIT_CACHE_SIZE;</span><br><span class="line">        reallocate(oldCapacity, capacity, <span class="comment">/* freeOld */</span><span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fastpath(newOccupied + CACHE_END_MARKER &lt;= cache_fill_ratio(capacity))) &#123;</span><br><span class="line">        <span class="comment">// Cache is less than 3/4 or 7/8 full. Use it as-is.</span></span><br><span class="line">    &#125;</span><br><span class="line">#<span class="keyword">if</span> CACHE_ALLOW_FULL_UTILIZATION</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (capacity &lt;= FULL_UTILIZATION_CACHE_SIZE &amp;&amp; newOccupied + CACHE_END_MARKER &lt;= capacity) &#123;</span><br><span class="line">        <span class="comment">// Allow 100% cache utilization for small buckets. Use it as-is.</span></span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        capacity = capacity ? capacity * <span class="number">2</span> : INIT_CACHE_SIZE;</span><br><span class="line">        <span class="keyword">if</span> (capacity &gt; MAX_CACHE_SIZE) &#123;</span><br><span class="line">            capacity = MAX_CACHE_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">///分配空间</span></span><br><span class="line">        reallocate(oldCapacity, capacity, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">///省略代码</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CACHE_END_MARKER || (__arm64__ &amp;&amp; !__LP64__)</span></span><br><span class="line">    <span class="comment">// When we have a cache end marker it fills a bucket slot, so having a</span></span><br><span class="line">    <span class="comment">// initial cache size of 2 buckets would not be efficient when one of the</span></span><br><span class="line">    <span class="comment">// slots is always filled with the end marker. So start with a cache size</span></span><br><span class="line">    <span class="comment">// 4 buckets.</span></span><br><span class="line">    INIT_CACHE_SIZE_LOG2 = <span class="number">2</span>,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">    <span class="comment">// Allow an initial bucket size of 2 buckets, since a large number of</span></span><br><span class="line">    <span class="comment">// classes, especially metaclasses, have very few imps, and we support</span></span><br><span class="line">    <span class="comment">// the ability to fill 100% of the cache before resizing.</span></span><br><span class="line">    INIT_CACHE_SIZE_LOG2 = <span class="number">1</span>,</span><br><span class="line">#endif</span><br><span class="line">    INIT_CACHE_SIZE      = (<span class="number">1</span> &lt;&lt; INIT_CACHE_SIZE_LOG2),</span><br></pre></td></tr></table></figure>

<p>看上面代码可以看出，换出的初始大小为4（metaclasses这种有很少imps为2），最后调用<code>reallocate</code>函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_t::reallocate</span><span class="params">(<span class="keyword">mask_t</span> oldCapacity, <span class="keyword">mask_t</span> newCapacity, <span class="keyword">bool</span> freeOld)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bucket_t</span> *oldBuckets = buckets();</span><br><span class="line">    <span class="keyword">bucket_t</span> *newBuckets = allocateBuckets(newCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache's old contents are not propagated. </span></span><br><span class="line">    <span class="comment">// This is thought to save cache memory at the cost of extra cache fills.</span></span><br><span class="line">    <span class="comment">// fixme re-measure this</span></span><br><span class="line"></span><br><span class="line">    ASSERT(newCapacity &gt; <span class="number">0</span>);</span><br><span class="line">    ASSERT((<span class="keyword">uintptr_t</span>)(<span class="keyword">mask_t</span>)(newCapacity<span class="number">-1</span>) == newCapacity<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    setBucketsAndMask(newBuckets, newCapacity - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (freeOld) &#123;</span><br><span class="line">        collect_free(oldBuckets, oldCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_OUTLINED</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_t::setBucketsAndMask</span><span class="params">(struct <span class="keyword">bucket_t</span> *newBuckets, <span class="keyword">mask_t</span> newMask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// objc_msgSend uses mask and buckets with no locks.</span></span><br><span class="line">    <span class="comment">// It is safe for objc_msgSend to see new buckets but old mask.</span></span><br><span class="line">    <span class="comment">// (It will get a cache miss but not overrun the buckets' bounds).</span></span><br><span class="line">    <span class="comment">// It is unsafe for objc_msgSend to see old buckets and new mask.</span></span><br><span class="line">    <span class="comment">// Therefore we write new buckets, wait a lot, then write new mask.</span></span><br><span class="line">    <span class="comment">// objc_msgSend reads mask first, then buckets.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __arm__</span></span><br><span class="line">    <span class="comment">// ensure other threads see buckets contents before buckets pointer</span></span><br><span class="line">    mega_barrier();</span><br><span class="line"></span><br><span class="line">    _bucketsAndMaybeMask.store((<span class="keyword">uintptr_t</span>)newBuckets, memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ensure other threads see new buckets before new mask</span></span><br><span class="line">    mega_barrier();</span><br><span class="line"></span><br><span class="line">    _maybeMask.store(newMask, memory_order_relaxed);</span><br><span class="line">    _occupied = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> __x86_64__ || i386</span></span><br><span class="line">    <span class="comment">// ensure other threads see buckets contents before buckets pointer</span></span><br><span class="line">    _bucketsAndMaybeMask.store((<span class="keyword">uintptr_t</span>)newBuckets, memory_order_release);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ensure other threads see new buckets before new mask</span></span><br><span class="line">    _maybeMask.store(newMask, memory_order_release);</span><br><span class="line">    _occupied = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">#error Don't know how to do setBucketsAndMask on this architecture.</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到_bucketsAndMaybeMask里的<code>newBuckets</code>为<code>newCapacity - 1</code>，我们看<code>capacity()</code>方法也能验证这一点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">cache_t::capacity</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mask() ? mask()+<span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继续探索cache-t"><a href="#继续探索cache-t" class="headerlink" title="继续探索cache_t"></a>继续探索<code>cache_t</code></h3><p>通过前面的探索，我们知道了 <code>cache_t</code> 实质上是缓存了我们类的实例方法，那么对于类方法来说，自然就是缓存在了元类上了。这一点我相信读者应该都能理解。</p>
<h3 id="方法缓存策略"><a href="#方法缓存策略" class="headerlink" title="方法缓存策略"></a>方法缓存策略</h3><p>直观的感受就是会在insert的时候缓存，我们继续看<code>insert</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_t::insert</span><span class="params">(SEL sel, IMP imp, id receiver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked();<span class="comment">//加锁</span></span><br><span class="line">    <span class="comment">// Never cache before +initialize is done</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!cls()-&gt;isInitialized())) &#123;<span class="comment">//initialize调用之后才会缓存</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isConstantOptimizedCache()) &#123;<span class="comment">//内联函数 return false 所以if里不会执行</span></span><br><span class="line">        _objc_fatal(<span class="string">"cache_t::insert() called with a preoptimized cache for %s"</span>,</span><br><span class="line">                    cls()-&gt;nameForLogging());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_TASK_THREADS</span></span><br><span class="line">    <span class="keyword">return</span> _collecting_in_critical();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_USE_CACHE_LOCK</span></span><br><span class="line">    <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(cacheUpdateLock)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    ASSERT(sel != <span class="number">0</span> &amp;&amp; cls()-&gt;isInitialized());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the cache as-is if until we exceed our expected fill ratio.</span></span><br><span class="line">    <span class="keyword">mask_t</span> newOccupied = occupied() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> oldCapacity = capacity(), capacity = oldCapacity;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(isConstantEmptyCache())) &#123;</span><br><span class="line">        <span class="comment">// Cache is read-only. Replace it.</span></span><br><span class="line">        <span class="keyword">if</span> (!capacity) capacity = INIT_CACHE_SIZE;</span><br><span class="line">        reallocate(oldCapacity, capacity, <span class="comment">/* freeOld */</span><span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fastpath(newOccupied + CACHE_END_MARKER &lt;= cache_fill_ratio(capacity))) &#123;</span><br><span class="line">        <span class="comment">// Cache is less than 3/4 or 7/8 full. Use it as-is.</span></span><br><span class="line">    &#125;</span><br><span class="line">#<span class="keyword">if</span> CACHE_ALLOW_FULL_UTILIZATION</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (capacity &lt;= FULL_UTILIZATION_CACHE_SIZE &amp;&amp; newOccupied + CACHE_END_MARKER &lt;= capacity) &#123;</span><br><span class="line">        <span class="comment">// Allow 100% cache utilization for small buckets. Use it as-is.</span></span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        capacity = capacity ? capacity * <span class="number">2</span> : INIT_CACHE_SIZE;</span><br><span class="line">        <span class="keyword">if</span> (capacity &gt; MAX_CACHE_SIZE) &#123;</span><br><span class="line">            capacity = MAX_CACHE_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        reallocate(oldCapacity, capacity, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bucket_t</span> *b = buckets();</span><br><span class="line">    <span class="keyword">mask_t</span> m = capacity - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">mask_t</span> <span class="built_in">begin</span> = cache_hash(sel, m);</span><br><span class="line">    <span class="keyword">mask_t</span> i = <span class="built_in">begin</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scan for the first unused slot and insert there.</span></span><br><span class="line">    <span class="comment">// There is guaranteed to be an empty slot.</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fastpath(b[i].sel() == <span class="number">0</span>)) &#123;</span><br><span class="line">            incrementOccupied();</span><br><span class="line">            b[i].<span class="built_in">set</span>&lt;Atomic, Encoded&gt;(b, sel, imp, cls());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b[i].sel() == sel) &#123;</span><br><span class="line">            <span class="comment">// The entry was added to the cache by some other thread</span></span><br><span class="line">            <span class="comment">// before we grabbed the cacheUpdateLock.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fastpath((i = cache_next(i, m)) != <span class="built_in">begin</span>));</span><br><span class="line"></span><br><span class="line">    bad_cache(receiver, (SEL)sel);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !DEBUG_TASK_THREADS</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法缓存是否有序"><a href="#方法缓存是否有序" class="headerlink" title="方法缓存是否有序"></a>方法缓存是否有序</h3><p>方法缓存是无序的，这是因为计算缓存下标是一个哈希算法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static inline mask_t cache_hash(cache_key_t key, mask_t mask) </span><br><span class="line">&#123;</span><br><span class="line">    return (mask_t)(key &amp; mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>cache_hash</code> 之后计算出来的下标并不是有序的，下标值取决于 <code>key</code> 和 <code>mask</code> 的值。</p>
<h3 id="bucket-与-mask-capacity-sel-imp-的关系"><a href="#bucket-与-mask-capacity-sel-imp-的关系" class="headerlink" title="bucket 与 mask, capacity, sel, imp 的关系"></a>bucket 与 mask, capacity, sel, imp 的关系</h3><p>一个类有一个属性 <code>cache_t</code>，而一个 <code>cache_t</code> 的 <code>buckets</code> 会有多个 <code>bucket</code>。一个 <code>bucket</code> 存储的是 <code>imp</code> 和 <code>cache_key_t</code> 。</p>
<p><code>mask</code> 的值对于 <code>bucket</code> 来说，主要是用来在缓存查找时的哈希算法。<br>而 <code>capacity</code> 则可以获取到 <code>cache_t</code> 中 <code>bucket</code> 的数量。</p>
<p><code>sel</code> 在缓存的时候是被强转成了 <code>cache_key_t</code> 的形式，更方便查询使用。<br><code>imp</code> 则是函数指针，也就是方法的具体实现，缓存的主要目的就是通过一系列策略让编译器更快的执行消息发送的逻辑。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>OC</code> 中实例方法缓存在类上面，类方法缓存在元类上面。</li>
<li><code>cache_t</code> 缓存会提前进行扩容防止溢出。</li>
<li>方法缓存是为了最大化的提高程序的执行效率。</li>
<li>苹果在方法缓存这里用的是<code>开放寻址法</code>来解决哈希冲突。</li>
<li>通过 <code>cache_t</code> 我们可以进一步延伸去探究 <code>objc_msgSend</code>，因为查找方法缓存是属于 <code>objc_msgSend</code> 查找方法实现的快速流程。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/10/iOS%E5%BA%95%E5%B1%82%EF%BC%9A%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/10/iOS%E5%BA%95%E5%B1%82%EF%BC%9A%E7%B1%BB/" class="post-title-link" itemprop="url">iOS底层：类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-10 11:53:05 / 修改时间：17:22:33" itemprop="dateCreated datePublished" datetime="2021-05-10T11:53:05+08:00">2021-05-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="class的本质"><a href="#class的本质" class="headerlink" title="class的本质"></a>class的本质</h3><p>类是我们面向对象开发中使用很频繁的概念，我们看一下类的结构是什么。</p>
<p>首先我们定义一个类<code>Person</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Animal.m</span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>我们在main函数里初始化<code>Person</code>对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        Person *obj = [[Person alloc] init];</span><br><span class="line">        NSLog(@<span class="string">"%p"</span>,obj);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在terminal里执行<code>clang</code>命令</p>
<p><code>clang -rewrite-objc main.m -o main.cpp</code></p>
<p>会生成main.cpp文件，在main.cpp文件里搜索Person找到下面这段代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _REWRITER_typedef_Person</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _REWRITER_typedef_Person</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> <span class="title">Person</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>&#125; _objc_exc_Person;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person_IMPL</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">NSObject_IMPL</span> <span class="title">NSObject_IVARS</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* @end */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang assume_nonnull end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// @implementation Person</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        <span class="comment">//3 objc_getClass("Person")</span></span><br><span class="line">        Person *obj = ((Person *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)((Person *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"Person"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>));</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders__s_l_p47fxn36j8d2_n75spyb7c0000gn_T_main_971c67_mi_0,obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们主要看代码注释1、2、3的位置，全局搜索<code>typedef struct objc_object</code>,发现有845个结果，结果数有点多，我们再全局搜索<code>*Class</code>，这次比较幸运，只有7个结果，我们可以快速定位到其中的一行</p>
<p><code>typedef struct objc_class *Class;</code></p>
<p>看到这里我们就知道了<code>Class</code> 类型的实际是一个叫<code>objc_class</code>的结构体。我们去objc源码里搜索<code>struct objc_class</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">  objc_class(<span class="keyword">const</span> objc_class&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  objc_class(objc_class&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> objc_class&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(objc_class&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;  </span><br><span class="line">    <span class="comment">///省略后面的set get函数</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>看源码可以知道<code>objc_class</code>继承自<code>objc_object</code>,说明Class其实也是一个对象。</p>
<h3 id="类的结构"><a href="#类的结构" class="headerlink" title="类的结构"></a>类的结构</h3><p>看上面这段源码，我们知道类的本质也是对象，我们日常开发中常见的成员变量、属性、方法、协议等都在类里面存在的，我们接下来探索一下这些内容在雷利是怎么存储的。</p>
<p>从上一小节最后的源码我们看到，类中的四个属性：</p>
<ul>
<li><code>isa</code>指针</li>
<li><code>superclass</code>指针</li>
<li><code>cache</code></li>
<li><code>bits</code></li>
</ul>
<p><code>isa</code>指针是隐藏属性（继承自<code>objc_object</code>）。</p>
<h4 id="isa指针"><a href="#isa指针" class="headerlink" title="isa指针"></a><code>isa</code>指针</h4><p>我们之前已经探索过，在对象初始化的时候，通过<code>isa</code>可以让对象和类关联，类中<code>isa</code>的作用也类似，关联类和元类。</p>
<h4 id="superclass指针"><a href="#superclass指针" class="headerlink" title="superclass指针"></a><code>superclass</code>指针</h4><p>这个看名字就很好理解，指向了父类，一般来说，类的根父类都是<code>NSObject</code>类。根元类的父类也是<code>NSObject</code>类。</p>
<h4 id="cache"><a href="#cache" class="headerlink" title="cache"></a><code>cache</code></h4><p><code>cache_t</code>里的东西比较多，我们暂时先了解这个是缓存，里面会有方法的缓存。具体内容后面再探究。</p>
<h4 id="bits属性"><a href="#bits属性" class="headerlink" title="bits属性"></a><code>bits</code>属性</h4><p><code>bits</code> 的数据结构类型是 <code>class_data_bits_t</code>，同时也是一个结构体类型。而我们阅读 <code>objc_class</code> 源码的时候，会发现很多地方都有 <code>bits</code> 的身影，比如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class_rw_t</span> *<span class="title">data</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> bits.data();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCustomRR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ! bits.hasDefaultRR();</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canAllocFast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assert(!isFuture());</span><br><span class="line">    <span class="keyword">return</span> bits.canAllocFast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里值得我们注意的是，<code>objc_class</code> 的 <code>data()</code> 方法其实是返回的 <code>bits</code> 的 <code>data()</code> 方法，而通过这个 <code>data()</code> 方法，我们发现诸如类的字节对齐、<code>ARC</code>、元类等特性都有 <code>data()</code> 的出现，这间接说明 <code>bits</code> 属性其实是个大容器，有关于内存管理、C++ 析构等内容在其中有定义。</p>
<p>这里我们会遇到一个十分重要的知识点: <code>class_rw_t</code>，<code>data()</code> 方法的返回值就是 <code>class_rw_t</code> 类型的指针对象。我们在本文后面会重点介绍。</p>
<h3 id="探索-bits-属性"><a href="#探索-bits-属性" class="headerlink" title="探索 bits 属性"></a>探索 <code>bits</code> 属性</h3><p><code>bits</code>属性的结构体是<code>class_data_bits_t</code>,看一下它的源码,<code>class_data_bits_t</code>声明了<code>objc_class</code>是它的友元类，可见关系不一般。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_data_bits_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> objc_class;<span class="comment">//友元类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Values are the FAST_ flags above.</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">getBit</span><span class="params">(<span class="keyword">uintptr_t</span> <span class="built_in">bit</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bits &amp; <span class="built_in">bit</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Atomically set the bits in `set` and clear the bits in `clear`.</span></span><br><span class="line">    <span class="comment">// set and clear must not overlap.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAndClearBits</span><span class="params">(<span class="keyword">uintptr_t</span> <span class="built_in">set</span>, <span class="keyword">uintptr_t</span> <span class="built_in">clear</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ASSERT((<span class="built_in">set</span> &amp; <span class="built_in">clear</span>) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">uintptr_t</span> newBits, oldBits = LoadExclusive(&amp;bits);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            newBits = (oldBits | <span class="built_in">set</span>) &amp; ~<span class="built_in">clear</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (slowpath(!StoreReleaseExclusive(&amp;bits, &amp;oldBits, newBits)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBits</span><span class="params">(<span class="keyword">uintptr_t</span> <span class="built_in">set</span>)</span> </span>&#123;</span><br><span class="line">        __c11_atomic_fetch_or((_Atomic(<span class="keyword">uintptr_t</span>) *)&amp;bits, <span class="built_in">set</span>, __ATOMIC_RELAXED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearBits</span><span class="params">(<span class="keyword">uintptr_t</span> <span class="built_in">clear</span>)</span> </span>&#123;</span><br><span class="line">        __c11_atomic_fetch_and((_Atomic(<span class="keyword">uintptr_t</span>) *)&amp;bits, ~<span class="built_in">clear</span>, __ATOMIC_RELAXED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">class_rw_t</span>* <span class="title">data</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">class_rw_t</span> *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">class_rw_t</span> *newData)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ASSERT(!data()  ||  (newData-&gt;flags &amp; (RW_REALIZING | RW_FUTURE)));</span><br><span class="line">        <span class="comment">// Set during realization or construction only. No locking needed.</span></span><br><span class="line">        <span class="comment">// Use a store-release fence because there may be concurrent</span></span><br><span class="line">        <span class="comment">// readers of data and data's contents.</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> newBits = (bits &amp; ~FAST_DATA_MASK) | (<span class="keyword">uintptr_t</span>)newData;</span><br><span class="line">        atomic_thread_fence(memory_order_release);</span><br><span class="line">        bits = newBits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the class's ro data, even in the presence of concurrent realization.</span></span><br><span class="line">    <span class="comment">// fixme this isn't really safe without a compiler barrier at least</span></span><br><span class="line">    <span class="comment">// and probably a memory barrier when realizeClass changes the data field</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">class_ro_t</span> *<span class="title">safe_ro</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">class_rw_t</span> *maybe_rw = data();</span><br><span class="line">        <span class="keyword">if</span> (maybe_rw-&gt;flags &amp; RW_REALIZED) &#123;</span><br><span class="line">            <span class="comment">// maybe_rw is rw</span></span><br><span class="line">            <span class="keyword">return</span> maybe_rw-&gt;ro();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// maybe_rw is actually ro</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">class_ro_t</span> *)maybe_rw;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setClassArrayIndex</span><span class="params">(<span class="keyword">unsigned</span> Idx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 0 is unused as then we can rely on zero-initialisation from calloc.</span></span><br><span class="line">        ASSERT(Idx &gt; <span class="number">0</span>);</span><br><span class="line">        data()-&gt;index = Idx;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setClassArrayIndex</span><span class="params">(__unused <span class="keyword">unsigned</span> Idx)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">classArrayIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class="line">        <span class="keyword">return</span> data()-&gt;index;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnySwift</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isSwiftStable() || isSwiftLegacy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSwiftStable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBit(FAST_IS_SWIFT_STABLE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setIsSwiftStable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setAndClearBits(FAST_IS_SWIFT_STABLE, FAST_IS_SWIFT_LEGACY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSwiftLegacy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBit(FAST_IS_SWIFT_LEGACY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setIsSwiftLegacy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setAndClearBits(FAST_IS_SWIFT_LEGACY, FAST_IS_SWIFT_STABLE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme remove this once the Swift runtime uses the stable bits</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSwiftStable_ButAllowLegacyForNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isAnySwift();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_objc_swiftMetadataInitializer <span class="title">swiftMetadataInitializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// This function is called on un-realized classes without</span></span><br><span class="line">        <span class="comment">// holding any locks.</span></span><br><span class="line">        <span class="comment">// Beware of races with other realizers.</span></span><br><span class="line">        <span class="keyword">return</span> safe_ro()-&gt;swiftMetadataInitializer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们主要看下面两块代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class_rw_t</span>* <span class="title">data</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">class_rw_t</span> *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">class_ro_t</span> *<span class="title">safe_ro</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">class_rw_t</span> *maybe_rw = data();</span><br><span class="line">        <span class="keyword">if</span> (maybe_rw-&gt;flags &amp; RW_REALIZED) &#123;</span><br><span class="line">            <span class="comment">// maybe_rw is rw</span></span><br><span class="line">            <span class="keyword">return</span> maybe_rw-&gt;ro();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// maybe_rw is actually ro</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">class_ro_t</span> *)maybe_rw;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>先看<code>class_rw_t</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint16_t</span> witness;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class="line">    <span class="keyword">uint16_t</span> index;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    explicit_atomic&lt;<span class="keyword">uintptr_t</span>&gt; ro_or_rw_ext;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">    <span class="comment">//省略代码 ...</span></span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">const</span> <span class="keyword">method_array_t</span> <span class="title">methods</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> v = get_ro_or_rwe();</span><br><span class="line">        <span class="keyword">if</span> (v.is&lt;<span class="keyword">class_rw_ext_t</span> *&gt;()) &#123;</span><br><span class="line">            <span class="keyword">return</span> v.<span class="built_in">get</span>&lt;<span class="keyword">class_rw_ext_t</span> *&gt;(&amp;ro_or_rw_ext)-&gt;methods;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">method_array_t</span>&#123;v.<span class="built_in">get</span>&lt;<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *&gt;(&amp;ro_or_rw_ext)-&gt;baseMethods()&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">property_array_t</span> <span class="title">properties</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> v = get_ro_or_rwe();</span><br><span class="line">        <span class="keyword">if</span> (v.is&lt;<span class="keyword">class_rw_ext_t</span> *&gt;()) &#123;</span><br><span class="line">            <span class="keyword">return</span> v.<span class="built_in">get</span>&lt;<span class="keyword">class_rw_ext_t</span> *&gt;(&amp;ro_or_rw_ext)-&gt;properties;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">property_array_t</span>&#123;v.<span class="built_in">get</span>&lt;<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *&gt;(&amp;ro_or_rw_ext)-&gt;baseProperties&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">protocol_array_t</span> <span class="title">protocols</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> v = get_ro_or_rwe();</span><br><span class="line">        <span class="keyword">if</span> (v.is&lt;<span class="keyword">class_rw_ext_t</span> *&gt;()) &#123;</span><br><span class="line">            <span class="keyword">return</span> v.<span class="built_in">get</span>&lt;<span class="keyword">class_rw_ext_t</span> *&gt;(&amp;ro_or_rw_ext)-&gt;protocols;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">protocol_array_t</span>&#123;v.<span class="built_in">get</span>&lt;<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *&gt;(&amp;ro_or_rw_ext)-&gt;baseProtocols&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个结构体里有一些我们熟悉的字样<code>methods</code>、<code>properties</code>、<code>protocols</code>。这里的<code>properties</code>是不是就是存储属性的地方呢。让我们验证一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">#import &lt;objc&#x2F;runtime.h&gt;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    NSString *hobby;</span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic, copy) NSString *nickName;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        &#x2F;&#x2F; insert code here...</span><br><span class="line">        Person *p &#x3D; [[Person alloc] init];</span><br><span class="line">        Class pClass &#x3D; object_getClass(p);</span><br><span class="line">        NSLog(@&quot;%s&quot;, p);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义一个Person类，在里面定义一个成员变量和一个属性。在main函数里打断点，我们用LLDB打印看一下<code>pClass</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x/<span class="number">4</span>gx pClass</span><br><span class="line"><span class="number">0x1000081d0</span>: <span class="number">0x00000001000081a8</span> <span class="number">0x0000000100357140</span></span><br><span class="line"><span class="number">0x1000081e0</span>: <span class="number">0x000000010072fdc0</span> <span class="number">0x0001802400000003</span></span><br><span class="line">(lldb) p (<span class="keyword">class_data_bits_t</span> *)<span class="number">0x1000081f0</span><span class="comment">//0x1000081d0+0x20 bits地址偏移量</span></span><br><span class="line">(<span class="keyword">class_data_bits_t</span> *) $<span class="number">16</span> = <span class="number">0x00000001000081f0</span></span><br><span class="line">(lldb) p $<span class="number">16</span>-&gt;data()</span><br><span class="line">(<span class="keyword">class_rw_t</span> *) $<span class="number">17</span> = <span class="number">0x0000000100731e10</span></span><br><span class="line">(lldb) p *$<span class="number">17</span></span><br><span class="line">(<span class="keyword">class_rw_t</span>) $<span class="number">18</span> = &#123;</span><br><span class="line">  flags = <span class="number">2148007936</span></span><br><span class="line">  witness = <span class="number">1</span></span><br><span class="line">  ro_or_rw_ext = &#123;</span><br><span class="line">    <span class="built_in">std</span>::__1::atomic&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span>&gt; = &#123;</span><br><span class="line">      Value = <span class="number">4295000208</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  firstSubclass = nil</span><br><span class="line">  nextSiblingClass = NSUUID</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看最后<code>$18</code>里面并没有打印出属性列表。我们接着探索<code>class_ro_t</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceSize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;</span><br><span class="line">        Class nonMetaclass;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    explicit_atomic&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; name;</span><br><span class="line">    <span class="comment">// With ptrauth, this is signed if it points to a small list, but</span></span><br><span class="line">    <span class="comment">// may be unsigned if it points to a big list.</span></span><br><span class="line">    <span class="keyword">void</span> *baseMethodList;</span><br><span class="line">    <span class="keyword">protocol_list_t</span> * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout;</span><br><span class="line">    <span class="keyword">property_list_t</span> *baseProperties;</span><br><span class="line">  <span class="comment">//隐藏代码 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现<code>class_ro_t</code>接口中包含了<code>baseMethodList</code>、<code>baseProtocols</code>、<code>baseProperties</code>等属性。验证一下属性是不是存储在这里了。和上面方式类似，我们利用LLDB查看</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> p (<span class="keyword">class_data_bits_t</span> *)<span class="number">0x1000081f0</span></span><br><span class="line">(<span class="keyword">class_data_bits_t</span> *) $<span class="number">19</span> = <span class="number">0x00000001000081f0</span></span><br><span class="line">(lldb) p $<span class="number">19</span>-&gt;safe_ro()</span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *) $<span class="number">20</span> = <span class="number">0x0000000100008090</span></span><br><span class="line">(lldb) p $<span class="number">20</span></span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">class_ro_t</span>) $<span class="number">21</span> = &#123;</span><br><span class="line">  flags = <span class="number">388</span></span><br><span class="line">  instanceStart = <span class="number">8</span></span><br><span class="line">  instanceSize = <span class="number">24</span></span><br><span class="line">  reserved = <span class="number">0</span></span><br><span class="line">   = &#123;</span><br><span class="line">    ivarLayout = <span class="number">0x0000000100003f1d</span> <span class="string">"\x02"</span></span><br><span class="line">    nonMetaclass = <span class="number">0x0000000100003f1d</span></span><br><span class="line">  &#125;</span><br><span class="line">  name = &#123;</span><br><span class="line">    <span class="built_in">std</span>::__1::atomic&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; = <span class="string">"Person"</span> &#123;</span><br><span class="line">      Value = <span class="number">0x0000000100003f16</span> <span class="string">"Person"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  baseMethodList = <span class="number">0x00000001000080d8</span></span><br><span class="line">  baseProtocols = <span class="number">0x0000000000000000</span></span><br><span class="line">  ivars = <span class="number">0x0000000100008128</span></span><br><span class="line">  weakIvarLayout = <span class="number">0x0000000000000000</span></span><br><span class="line">  baseProperties = <span class="number">0x0000000100008170</span></span><br><span class="line">  _swiftMetadataInitializer_NEVER_USE = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">20.b</span>aseProperties</span><br><span class="line">(<span class="keyword">property_list_t</span> *<span class="keyword">const</span>) $<span class="number">22</span> = <span class="number">0x0000000100008170</span></span><br><span class="line">  Fix-it applied, fixed expression was: </span><br><span class="line">    $<span class="number">20</span>-&gt;baseProperties</span><br><span class="line">(lldb) p *$<span class="number">22</span></span><br><span class="line">(<span class="keyword">property_list_t</span>) $<span class="number">23</span> = &#123;</span><br><span class="line">  entsize_list_tt&lt;<span class="keyword">property_t</span>, <span class="keyword">property_list_t</span>, <span class="number">0</span>, PointerModifierNop&gt; = (entsizeAndFlags = <span class="number">16</span>, count = <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">23.</span><span class="built_in">get</span>(<span class="number">0</span>)</span><br><span class="line">(<span class="keyword">property_t</span>) $<span class="number">28</span> = (name = <span class="string">"nickName"</span>, attributes = <span class="string">"T@\"NSString\",C,N,V_nickName"</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到了nickName属性，这里的count是1，说明只有这一个属性。我们接下来看一下<code>ivars</code>属性,继续使用LLDB</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $<span class="number">20.</span>ivars</span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">ivar_list_t</span> *<span class="keyword">const</span>) $<span class="number">24</span> = <span class="number">0x0000000100008128</span></span><br><span class="line">  Fix-it applied, fixed expression was: </span><br><span class="line">    $<span class="number">20</span>-&gt;ivars</span><br><span class="line">(lldb) p *$<span class="number">24</span></span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">ivar_list_t</span>) $<span class="number">25</span> = &#123;</span><br><span class="line">  entsize_list_tt&lt;<span class="keyword">ivar_t</span>, <span class="keyword">ivar_list_t</span>, <span class="number">0</span>, PointerModifierNop&gt; = (entsizeAndFlags = <span class="number">32</span>, count = <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">25.</span><span class="built_in">get</span>(<span class="number">1</span>)</span><br><span class="line">(<span class="keyword">ivar_t</span>) $<span class="number">26</span> = &#123;</span><br><span class="line">  offset = <span class="number">0x00000001000081a0</span></span><br><span class="line">  name = <span class="number">0x0000000100003f5b</span> <span class="string">"_nickName"</span></span><br><span class="line">  type = <span class="number">0x0000000100003f89</span> <span class="string">"@\"NSString\""</span></span><br><span class="line">  alignment_raw = <span class="number">3</span></span><br><span class="line">  <span class="built_in">size</span> = <span class="number">8</span></span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">25.</span><span class="built_in">get</span>(<span class="number">0</span>)</span><br><span class="line">(<span class="keyword">ivar_t</span>) $<span class="number">27</span> = &#123;</span><br><span class="line">  offset = <span class="number">0x0000000100008198</span></span><br><span class="line">  name = <span class="number">0x0000000100003f55</span> <span class="string">"hobby"</span></span><br><span class="line">  type = <span class="number">0x0000000100003f89</span> <span class="string">"@\"NSString\""</span></span><br><span class="line">  alignment_raw = <span class="number">3</span></span><br><span class="line">  <span class="built_in">size</span> = <span class="number">8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<strong>ivars</strong>属性里一共有两个值，_nickName和hobby。这一结果证实了编译器会帮助我们给属性 <code>nickName</code> 生成一个带下划线前缀的实例变量 <code>_nickName</code>。</p>
<p>至此，我们可以得出以下结论:</p>
<blockquote>
<p><code>class_ro_t</code> 是在编译时就已经确定了的，存储的是类的成员变量、属性、方法和协议等内容。<br><code>class_rw_t</code> 是可以在运行时来拓展类的一些属性、方法和协议等内容。</p>
</blockquote>
<h4 id="类的方法存储在哪"><a href="#类的方法存储在哪" class="headerlink" title="类的方法存储在哪"></a>类的方法存储在哪</h4><p>我们用相同的方法验证一下，先在Person类中增加一个<code>sayHello</code> 的实例方法和一个 <code>sayHappy</code> 的类方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    NSString *hobby;</span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic, copy) NSString *nickName;</span><br><span class="line">- (void)sayHello;</span><br><span class="line">+ (void)sayHappy;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">- (void)sayHello</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)sayHappy</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>按照上面的思路，我们直接读取 <code>class_ro_t</code> 中的 <code>baseMethods()</code> 的内容:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $<span class="number">3.b</span>aseMethods()</span><br><span class="line">(<span class="keyword">method_list_t</span> *) $<span class="number">7</span> = <span class="number">0x00000001000080f0</span></span><br><span class="line">(lldb) p *$<span class="number">7</span></span><br><span class="line">(<span class="keyword">method_list_t</span>) $<span class="number">8</span> = &#123;</span><br><span class="line">  entsize_list_tt&lt;<span class="keyword">method_t</span>, <span class="keyword">method_list_t</span>, <span class="number">4294901763</span>, <span class="keyword">method_t</span>::pointer_modifier&gt; = (entsizeAndFlags = <span class="number">27</span>, count = <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">8.</span><span class="built_in">get</span>(<span class="number">0</span>)</span><br><span class="line">(<span class="keyword">method_t</span>) $<span class="number">9</span> = &#123;&#125;</span><br><span class="line">(lldb) p $<span class="number">8.</span><span class="built_in">get</span>(<span class="number">1</span>)</span><br><span class="line">(<span class="keyword">method_t</span>) $<span class="number">10</span> = &#123;&#125;</span><br><span class="line">(lldb) p $<span class="number">8.</span><span class="built_in">get</span>(<span class="number">2</span>)</span><br><span class="line">(<span class="keyword">method_t</span>) $<span class="number">11</span> = &#123;&#125;</span><br><span class="line">(lldb) p $<span class="number">8.</span><span class="built_in">get</span>(<span class="number">3</span>)</span><br><span class="line">(<span class="keyword">method_t</span>) $<span class="number">12</span> = &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到baseMethods有四个方法。</p>
<h3 id="类的类方法存储在哪"><a href="#类的类方法存储在哪" class="headerlink" title="类的类方法存储在哪"></a>类的类方法存储在哪</h3><p>我们用Runtime的API来实际测试一下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.m</span></span><br><span class="line"><span class="keyword">void</span> testInstanceMethod_classToMetaclass(Class pClass)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *className = class_getName(pClass);</span><br><span class="line">    Class metaClass = objc_getMetaClass(className);</span><br><span class="line">    </span><br><span class="line">    Method method1 = class_getInstanceMethod(pClass, <span class="keyword">@selector</span>(sayHello));</span><br><span class="line">    Method method2 = class_getInstanceMethod(metaClass, <span class="keyword">@selector</span>(sayHello));</span><br><span class="line"></span><br><span class="line">    Method method3 = class_getInstanceMethod(pClass, <span class="keyword">@selector</span>(sayHappy));</span><br><span class="line">    Method method4 = class_getInstanceMethod(metaClass, <span class="keyword">@selector</span>(sayHappy));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%p-%p-%p-%p"</span>,method1,method2,method3,method4);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// insert code here...</span></span><br><span class="line">        Person *p = [[Person alloc] init];</span><br><span class="line">        Class pClass = object_getClass(p);</span><br><span class="line">        </span><br><span class="line">        testInstanceMethod_classToMetaclass(pClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x100008110-0x0-0x0-0x1000080a8</span><br><span class="line">testInstanceMethod_classToMetaclass</span><br></pre></td></tr></table></figure>

<p>首先 <code>testInstanceMethod_classToMetaclass</code> 方法测试的是分别从类和元类去获取实例方法、类方法的结果。由打印结果我们可以知道：</p>
<ul>
<li>对于类对象来说，<code>sayHello</code> 是实例方法，存储于类对象的内存中，不存在于元类对象中。而 <code>sayHappy</code> 是类方法，存储于元类对象的内存中，不存在于类对象中。</li>
<li>对于元类对象来说，<code>sayHello</code> 是类对象的实例方法，跟元类没关系；<code>sayHappy</code> 是元类对象的实例方法，所以存在元类中。</li>
</ul>
<h3 id="类和元类的创建时机"><a href="#类和元类的创建时机" class="headerlink" title="类和元类的创建时机"></a>类和元类的创建时机</h3><p>先看结论：</p>
<p>类和元类是在编译期创建的，即在进行alloc操作之前，类和元类就已经被编译器床架你出来了。</p>
<p>我们通过LLDB打印类和元类的指针来验证一下，断点打在main的第一行，这时候Person对象还没有初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p/x Person<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">(<span class="title">Class</span>) $1 = 0<span class="title">x0000000100008220</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">(<span class="title">lldb</span>) <span class="title">x</span>/4<span class="title">gx</span> 0<span class="title">x0000000100008220</span>//<span class="title">Person</span> 类对象</span></span><br><span class="line"><span class="class">0<span class="title">x100008220</span>:</span> <span class="number">0x00000001000081f8</span> <span class="number">0x0000000100357140</span></span><br><span class="line"><span class="number">0x100008230</span>: <span class="number">0x000000010034f360</span> <span class="number">0x0000802400000000</span></span><br><span class="line">(lldb) p/x <span class="number">0x00000001000081f8</span> &amp; <span class="number">0x00007ffffffffff8</span></span><br><span class="line">(<span class="keyword">long</span>) $<span class="number">2</span> = <span class="number">0x00000001000081f8</span><span class="comment">//Person 元类对象</span></span><br><span class="line">(lldb) po $<span class="number">2</span></span><br><span class="line">Person</span><br><span class="line"></span><br><span class="line">(lldb) x/<span class="number">4</span>gx <span class="number">0x00000001000081f8</span></span><br><span class="line"><span class="number">0x1000081f8</span>: <span class="number">0x00000001003570f0</span> <span class="number">0x00000001003570f0</span></span><br><span class="line"><span class="number">0x100008208</span>: <span class="number">0x0000000100615130</span> <span class="number">0x0001e03500000003</span></span><br><span class="line">(lldb) p/x <span class="number">0x00000001003570f0</span> &amp; <span class="number">0x00007ffffffffff8</span></span><br><span class="line">(<span class="keyword">long</span>) $<span class="number">3</span> = <span class="number">0x00000001003570f0</span><span class="comment">//NSObject 根元类对象</span></span><br><span class="line">(lldb) po $<span class="number">3</span></span><br><span class="line">NSObject</span><br><span class="line"></span><br><span class="line">(lldb) x/<span class="number">4</span>gx <span class="number">0x00000001003570f0</span></span><br><span class="line"><span class="number">0x1003570f0</span>: <span class="number">0x00000001003570f0</span> <span class="number">0x0000000100357140</span></span><br><span class="line"><span class="number">0x100357100</span>: <span class="number">0x0000000101104ac0</span> <span class="number">0x0004e03100000007</span></span><br><span class="line">(lldb) p/x <span class="number">0x00000001003570f0</span> &amp; <span class="number">0x00007ffffffffff8</span></span><br><span class="line">(<span class="keyword">long</span>) $<span class="number">4</span> = <span class="number">0x00000001003570f0</span><span class="comment">//NSObject 根元类对象</span></span><br><span class="line">(lldb) po $<span class="number">4</span></span><br><span class="line">NSObject</span><br></pre></td></tr></table></figure>

<p>还有一种方式是通过<code>MachoView</code>应用打开编译的二进制mach-o文件,<code>MachoView</code>的使用就不介绍了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>类和元类创建于编译时，可以通过 <code>LLDB</code> 来打印类和元类的指针，或者 <code>MachOView</code> 查看二进制可执行文件</li>
<li>万物皆对象：类的本质就是对象</li>
<li>类在 <code>class_ro_t</code> 结构中存储了编译时确定的属性、成员变量、方法和协议等内容。</li>
<li>实例方法存放在类中</li>
<li>类方法存放在元类中</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/09/iOS%E5%BA%95%E5%B1%82%EF%BC%9Acalloc%E5%92%8Cisa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/09/iOS%E5%BA%95%E5%B1%82%EF%BC%9Acalloc%E5%92%8Cisa/" class="post-title-link" itemprop="url">iOS底层：calloc和isa</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-09 10:46:01 / 修改时间：20:35:32" itemprop="dateCreated datePublished" datetime="2021-05-09T10:46:01+08:00">2021-05-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="calloc底层"><a href="#calloc底层" class="headerlink" title="calloc底层"></a><code>calloc</code>底层</h3><p>calloc的源码在<code>libMalloc</code>,不是之前用的<code>libObjc</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line"><span class="built_in">calloc</span>(<span class="keyword">size_t</span> num_items, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> _malloc_zone_calloc(default_zone, num_items, <span class="built_in">size</span>, MZ_POSIX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出<code>calloc</code>调用了<code>_malloc_zone_calloc</code>函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">MALLOC_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">_malloc_zone_calloc(<span class="keyword">malloc_zone_t</span> *zone, <span class="keyword">size_t</span> num_items, <span class="keyword">size_t</span> <span class="built_in">size</span>,</span><br><span class="line">		<span class="keyword">malloc_zone_options_t</span> mzo)</span><br><span class="line">&#123;</span><br><span class="line">	MALLOC_TRACE(TRACE_calloc | DBG_FUNC_START, (<span class="keyword">uintptr_t</span>)zone, num_items, <span class="built_in">size</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> *ptr;</span><br><span class="line">	<span class="keyword">if</span> (malloc_check_start) &#123;</span><br><span class="line">		internal_check();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 这里调用了calloc函数 </span></span><br><span class="line">	ptr = zone-&gt;<span class="built_in">calloc</span>(zone, num_items, <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (os_unlikely(malloc_logger)) &#123;</span><br><span class="line">		malloc_logger(MALLOC_LOG_TYPE_ALLOCATE | MALLOC_LOG_TYPE_HAS_ZONE | MALLOC_LOG_TYPE_CLEARED, (<span class="keyword">uintptr_t</span>)zone,</span><br><span class="line">				(<span class="keyword">uintptr_t</span>)(num_items * <span class="built_in">size</span>), <span class="number">0</span>, (<span class="keyword">uintptr_t</span>)ptr, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	MALLOC_TRACE(TRACE_calloc | DBG_FUNC_END, (<span class="keyword">uintptr_t</span>)zone, num_items, <span class="built_in">size</span>, (<span class="keyword">uintptr_t</span>)ptr);</span><br><span class="line">	<span class="keyword">if</span> (os_unlikely(ptr == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		malloc_set_errno_fast(mzo, ENOMEM);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，如果继续调用就又回到了<code>calloc</code>函数，这个时候我们借助LLDB打印内存地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p zone-&gt;<span class="built_in">calloc</span></span><br><span class="line">会输出：(<span class="keyword">void</span> *(*)(<span class="keyword">_malloc_zone_t</span> *, <span class="keyword">size_t</span>, <span class="keyword">size_t</span>)) $<span class="number">0</span> = <span class="number">0x00000001002e1b87</span> (.dylib`default_zone_calloc at <span class="built_in">malloc</span>.c:<span class="number">385</span>)</span><br></pre></td></tr></table></figure>

<p>可以看出这里调用了<code>malloc.c</code>文件的385行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">default_zone_calloc(<span class="keyword">malloc_zone_t</span> *zone, <span class="keyword">size_t</span> num_items, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span><br><span class="line">&#123;</span><br><span class="line">	zone = runtime_default_zone();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> zone-&gt;<span class="built_in">calloc</span>(zone, num_items, <span class="built_in">size</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>default_zone_calloc</code>里依然会调用<code>calloc</code>,我们用相同的方法查看具体执行的代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p zone-&gt;<span class="built_in">calloc</span></span><br><span class="line">(<span class="keyword">void</span> *(*)(<span class="keyword">_malloc_zone_t</span> *, <span class="keyword">size_t</span>, <span class="keyword">size_t</span>)) $<span class="number">1</span> = <span class="number">0x00000001002e72cd</span> (.dylib`nano_calloc at nano_malloc.c:<span class="number">878</span>)</span><br></pre></td></tr></table></figure>

<p>这次执行的代码在nano_malloc.c的878行。nano_calloc函数的实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">nano_calloc(<span class="keyword">nanozone_t</span> *nanozone, <span class="keyword">size_t</span> num_items, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">size_t</span> total_bytes;</span><br><span class="line">	<span class="comment">//判断是否有足够内存分配？？</span></span><br><span class="line">	<span class="keyword">if</span> (calloc_get_size(num_items, <span class="built_in">size</span>, <span class="number">0</span>, &amp;total_bytes)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (total_bytes &lt;= NANO_MAX_SIZE) &#123;</span><br><span class="line">		<span class="keyword">void</span> *p = _nano_malloc_check_clear(nanozone, total_bytes, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (p) &#123;</span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* FALLTHROUGH to helper zone */</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">malloc_zone_t</span> *zone = (<span class="keyword">malloc_zone_t</span> *)(nanozone-&gt;helper_zone);</span><br><span class="line">	<span class="keyword">return</span> zone-&gt;<span class="built_in">calloc</span>(zone, <span class="number">1</span>, total_bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看代码，我们后面应该继续看<code>_nano_malloc_check_clear</code>函数，分析<code>_nano_malloc_check_clear</code>函数，内存大小分配应该是调用<code>segregated_size_to_fit</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_t slot_bytes &#x3D; segregated_size_to_fit(nanozone, size, &amp;slot_key);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> MALLOC_INLINE <span class="keyword">size_t</span></span><br><span class="line">segregated_size_to_fit(<span class="keyword">nanozone_t</span> *nanozone, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> *pKey)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//size = 40</span></span><br><span class="line">	<span class="keyword">size_t</span> k, slot_bytes;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">size</span>) &#123;</span><br><span class="line">		<span class="built_in">size</span> = NANO_REGIME_QUANTA_SIZE; <span class="comment">// Historical behavior</span></span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 40 + 16-1 &gt;&gt; 4 &lt;&lt; 4 (先除以16余数舍去，再乘以16)</span></span><br><span class="line">	k = (<span class="built_in">size</span> + NANO_REGIME_QUANTA_SIZE - <span class="number">1</span>) &gt;&gt; SHIFT_NANO_QUANTUM; <span class="comment">// round up and shift for number of quanta</span></span><br><span class="line">	slot_bytes = k &lt;&lt; SHIFT_NANO_QUANTUM;							<span class="comment">// multiply by power of two quanta size</span></span><br><span class="line">	*pKey = k - <span class="number">1</span>;													<span class="comment">// Zero-based!</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> slot_bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看出进行的是 16 字节对齐，那么也就是说我们传入的 <code>size</code> 是 40，在经过 (40 + 16 - 1) &gt;&gt; 4 &lt;&lt; 4 操作后，结果为48，也就是16的整数倍。</p>
<p>小结：</p>
<ul>
<li><p>对象的属性是进行8字节对齐</p>
</li>
<li><p>对象自己进行的是16字节对齐，原因：1、内存是连续的，通过 16 字节对齐规避风险和容错，防止访问溢出。2、提高了寻址访问效率，也就是<strong>空间换时间</strong></p>
</li>
</ul>
<h3 id="isa底层"><a href="#isa底层" class="headerlink" title="isa底层"></a><code>isa</code>底层</h3><p><code>isa</code>是一个联合体,是从内存管理层面来设计的，因为联合体是所有成员共享一个内存，联合体内存的大小取决于内部成员内存大小最大的那个元素，对应<code>isa</code>指针来说，就不用额外声明很多属性，直接在内部<code>ISA_BITFIELD</code>保存信息。同时由于联合体属性间是互斥的，所以 <code>cls</code> 和 <code>bits</code> 在 <code>isa</code> 初始化流程时是在两个分支中被赋值的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> &#123;</span><br><span class="line">    <span class="keyword">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="keyword">isa_t</span>(<span class="keyword">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Accessing the class requires custom ptrauth operations, so</span></span><br><span class="line">    <span class="comment">// force clients to go through setClass/getClass by making this</span></span><br><span class="line">    <span class="comment">// private.</span></span><br><span class="line">    Class cls;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(ISA_BITFIELD)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        ISA_BITFIELD;  <span class="comment">// defined in isa.h</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isDeallocating</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> extra_rc == <span class="number">0</span> &amp;&amp; has_sidetable_rc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDeallocating</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        extra_rc = <span class="number">0</span>;</span><br><span class="line">        has_sidetable_rc = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setClass</span><span class="params">(Class cls, objc_object *obj)</span></span>;</span><br><span class="line">    <span class="function">Class <span class="title">getClass</span><span class="params">(<span class="keyword">bool</span> authenticated)</span></span>;</span><br><span class="line">    <span class="function">Class <span class="title">getDecodedClass</span><span class="params">(<span class="keyword">bool</span> authenticated)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面是<code>isa</code>的初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">objc_object::initIsa(Class cls, <span class="keyword">bool</span> nonpointer, UNUSED_WITHOUT_INDEXED_ISA_AND_DTOR_BIT <span class="keyword">bool</span> hasCxxDtor)</span><br><span class="line">&#123; </span><br><span class="line">    ASSERT(!isTaggedPointer()); </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">isa_t</span> <span class="title">newisa</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!nonpointer) &#123;</span><br><span class="line">        newisa.setClass(cls, <span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ASSERT(!DisableNonpointerIsa);</span><br><span class="line">        ASSERT(!cls-&gt;instancesRequireRawIsa());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class="line">        ASSERT(cls-&gt;classArrayIndex() &gt; <span class="number">0</span>);</span><br><span class="line">        newisa.bits = ISA_INDEX_MAGIC_VALUE;</span><br><span class="line">        <span class="comment">// isa.magic is part of ISA_MAGIC_VALUE</span></span><br><span class="line">        <span class="comment">// isa.nonpointer is part of ISA_MAGIC_VALUE</span></span><br><span class="line">        newisa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        newisa.indexcls = (<span class="keyword">uintptr_t</span>)cls-&gt;classArrayIndex();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        newisa.bits = ISA_MAGIC_VALUE;</span><br><span class="line">        <span class="comment">// isa.magic is part of ISA_MAGIC_VALUE</span></span><br><span class="line">        <span class="comment">// isa.nonpointer is part of ISA_MAGIC_VALUE</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> ISA_HAS_CXX_DTOR_BIT</span></span><br><span class="line">        newisa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line">        newisa.setClass(cls, <span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        newisa.extra_rc = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This write must be performed in a single store in some cases</span></span><br><span class="line">    <span class="comment">// (for example when realizing a class because other threads</span></span><br><span class="line">    <span class="comment">// may simultaneously try to use the class).</span></span><br><span class="line">    <span class="comment">// fixme use atomics here to guarantee single-store and to</span></span><br><span class="line">    <span class="comment">// guarantee memory order w.r.t. the class index table</span></span><br><span class="line">    <span class="comment">// ...but not too atomic because we don't want to hurt instantiation</span></span><br><span class="line">    isa = newisa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>isa</code>是一个联合体，有一个结构体属性是<code>ISA_BITFIELD</code>,其大小为 8 个字节，也就是 64 位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_BITFIELD                                                        \</span></span><br><span class="line">      <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">44</span>; <span class="comment">/*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/</span> \</span><br><span class="line">      <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> unused            : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">8</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>nonpointer</code>: 表示是否对 <code>isa</code> 指针开启指针优化 0:纯 <code>isa</code> 指针  1:不止是类对象地址, <code>isa</code> 中包含了类信息、对象的引用计数等</li>
<li>has_assoc: 关联对象标志位，0 没有，1 存在</li>
<li>has_cxx_dtor: 该对象是否有 C++ 或者 Objc 的析构器,如果有析构函数,则需要做析构逻辑, 如果没有,则可以更快的释放对象</li>
<li>shiftcls: 存储类指针的值。开启指针优化的情况下，在 arm64 架构中有 33 位用来存储类指针。</li>
<li>magic: 用于调试器判断当前对象是真的对象还是没有初始化的空间</li>
<li>weakly_referenced: 标志对象是否被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放。</li>
<li>has_sidetable_rc: 当对象引用技术大于 10 时，则需要借用该变量存储进位</li>
<li>extra_rc: 当表示该对象的引用计数值，实际上是引用计数值减 1， 例如，如果对象的引用计数为 10，那么 extra_rc 为 9。如果引用计数大于 10， 则需要使用到下面的 has_sidetable_rc。</li>
</ul>
<h3 id="isa关联对象和类"><a href="#isa关联对象和类" class="headerlink" title="isa关联对象和类"></a><code>isa</code>关联对象和类</h3><p><code>isa</code> 是对象中的第一个属性，因为这一步是在继承的时候发生的，要早于对象的成员变量，属性列表，方法列表以及所遵循的协议列表。</p>
<p>我们在探索 <code>alloc</code> 底层原理的时候，有一个方法叫做 <code>initIsa</code>。</p>
<p>这个方法的作用就是初始化 <code>isa</code> 联合体位域。其中有这么一行代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newisa.shiftcls = (<span class="keyword">uintptr_t</span>)cls &gt;&gt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>通过这行代码，我们知道 <code>shiftcls</code> 这个位域其实存储的是类的信息。这个类就是实例化对象所指向的那个类。</p>
<p>这里的左移右移操作其实很好理解，首先我们先观察 <code>isa</code> 的 <code>ISA_BITFIELD</code> 位域的结构:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_BITFIELD                                                        \</span></span><br><span class="line">      <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">44</span>; <span class="comment">/*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/</span> \</span><br><span class="line">      <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> unused            : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到，<code>ISA_BITFIELD</code> 的前 3 位是 <code>nonpointer</code>，<code>has_assoc</code>，<code>has_cxx_dtor</code>，中间 44 位是 <code>shiftcls</code> ，后面 17 位是剩余的内容，同时因为 iOS 是小端模式，那么我们就需要去掉右边的 3 位和左边的 17位，所以就会采用 &gt;&gt;3&lt;&lt;3 然后 &lt;&lt;17&gt;&gt;17 的操作了。</p>
<p>通过这个测试，我们就知道了 <code>isa</code> 实现了对象与类之间的关联。</p>
<p>我们还可以探索 <code>object_getClass</code> 底层，可以发现有这样一行代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (Class)(isa.bits &amp; ISA_MASK);</span><br></pre></td></tr></table></figure>

<p>这行代码就是将 <code>isa</code> 中的联合体位域与上一个蒙版，这个蒙版定义是怎么样的呢?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x00007ffffffffff8ULL</span></span><br></pre></td></tr></table></figure>

<p><code>x00007ffffffffff8ULL</code> 这个值我们转成二进制表示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0000 0000 0000 0000 0111 1111 1111 1111 </span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1000</span><br></pre></td></tr></table></figure>

<p>结果一目了然，这个蒙版就是帮我们去过滤掉除 <code>shiftcls</code> 之外的内容。</p>
<p>我们直接将对象的 <code>isa</code> 地址与上这个mask之后，就会得到 <code>object.class</code> 一样的内存地址。</p>
<h3 id="isa走位分析"><a href="#isa走位分析" class="headerlink" title="isa走位分析"></a>isa走位分析</h3><h3 id="类与元类"><a href="#类与元类" class="headerlink" title="类与元类"></a>类与元类</h3><p>我们都知道对象可以创建多个，但是类是否可以创建多个呢?<br>答案很简单，一个。那么如果来验证呢?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MARK: - 分析类对象内存存在个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lgTestClassNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Class class1 = [LGPerson class];</span><br><span class="line">    Class class2 = [LGPerson alloc].class;</span><br><span class="line">    Class class3 = object_getClass([LGPerson alloc]);</span><br><span class="line">    Class class4 = [LGPerson alloc].class;</span><br><span class="line">    NSLog(@<span class="string">"\n%p-\n%p-\n%p-\n%p"</span>,class1,class2,class3,class4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印输出如下:</span></span><br><span class="line"></span><br><span class="line"><span class="number">0x100002108</span>-</span><br><span class="line"><span class="number">0x100002108</span>-</span><br><span class="line"><span class="number">0x100002108</span>-</span><br><span class="line"><span class="number">0x100002108</span></span><br></pre></td></tr></table></figure>

<p>所以我们就知道了类在内存中只会存在一份。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x/<span class="number">4</span>gx LGTeacher<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">0<span class="title">x100001420</span>:</span> <span class="number">0x001d8001000013f9</span> <span class="number">0x0000000100b38140</span></span><br><span class="line"><span class="number">0x100001430</span>: <span class="number">0x00000001003db270</span> <span class="number">0x0000000000000000</span></span><br><span class="line">(lldb) po <span class="number">0x001d8001000013f9</span></span><br><span class="line"><span class="number">17082823967917874</span></span><br><span class="line"></span><br><span class="line">(lldb) p <span class="number">0x001d8001000013f9</span></span><br><span class="line">(<span class="keyword">long</span>) $<span class="number">2</span> = <span class="number">8303516107936761</span></span><br><span class="line">(lldb) po <span class="number">0x100001420</span></span><br><span class="line">LGTeacher</span><br></pre></td></tr></table></figure>

<p>我们通过上面的打印，就发现 类的内存结构里面的第一个结构打印出来还是 <code>LGTeacher</code>，那么是不是就意味着 对象-&gt;类-&gt;类 这样的死循环呢？这里的第二个类其实是 <code>元类</code>。是由系统帮我们创建的。这个元类也无法被我们实例化。</p>
<h3 id="对象的本质"><a href="#对象的本质" class="headerlink" title="对象的本质"></a>对象的本质</h3><p>在我们认知里面，<code>OC</code> 对象的本质就是一个结构体，这个结论在 <code>libObjc</code> 源码的 <code>objc-private.h</code> 源文件中可以得到证实。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">isa_t</span> isa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ISA() assumes this is NOT a tagged pointer object</span></span><br><span class="line">    <span class="function">Class <span class="title">ISA</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getIsa() allows this to be a tagged pointer object</span></span><br><span class="line">    <span class="function">Class <span class="title">getIsa</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    ...省略其他的内容...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而对于对象所属的类来说，我们也可以在 <code>objc-runtime-new.h</code> 源文件中找到</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line">    </span><br><span class="line">    ...省略其他的内容...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说 <code>objc_class</code> 内存中第一个位置是 <code>isa</code>，第二个位置是 <code>superclass</code>。</p>
<p>不过我们本着求真的态度可以用 <code>clang</code> 来重写我们的 <code>OC</code> 源文件来查看是不是这么回事。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m -o main.cpp</span><br></pre></td></tr></table></figure>

<p>这行命令会把我们的 <code>main.m</code> 文件编译成 <code>C++</code> 格式，输出为 <code>main.cpp</code>。</p>
<p>我们可以看到 <code>LGPerson</code> 对象在底层其实是一个结构体 <code>objc_object</code> 。</p>
<p>而我们的 <code>Class</code> 在底层也是一个结构体 <code>objc_class</code> 。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jason</p>
  <div class="site-description" itemprop="description">个人技术博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
