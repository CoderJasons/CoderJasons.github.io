<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yujiusheng.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="个人技术博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Jason的博客">
<meta property="og:url" content="http://yujiusheng.com/page/3/index.html">
<meta property="og:site_name" content="Jason的博客">
<meta property="og:description" content="个人技术博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yujiusheng.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Jason的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jason的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/06/08/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/08/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/" class="post-title-link" itemprop="url">iOS底层探索 - 内存对齐</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-08 19:46:07" itemprop="dateCreated datePublished" datetime="2021-06-08T19:46:07+08:00">2021-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-05 17:23:04" itemprop="dateModified" datetime="2021-07-05T17:23:04+08:00">2021-07-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在上一篇<code>alloc</code>方法的探索中，我们提到了<code>内存对齐</code>的概念，这篇文章我们就主要介绍一下<code>内存对齐</code>。</p>
<h3 id="结构体的字节对齐"><a href="#结构体的字节对齐" class="headerlink" title="结构体的字节对齐"></a>结构体的字节对齐</h3><h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><p>我们首先定义几个结构体，初始化，看一下每个结构体的内存大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">struct JSPerson1 &#123;</span><br><span class="line">    double a;</span><br><span class="line">    char b;</span><br><span class="line">    int c;</span><br><span class="line">    short d;</span><br><span class="line">&#125;struct1;</span><br><span class="line">struct JSPerson2 &#123;</span><br><span class="line">    double a;</span><br><span class="line">    int b;</span><br><span class="line">    char c;</span><br><span class="line">    short d;        </span><br><span class="line">&#125;struct2;</span><br><span class="line">struct JSPerson3 &#123;</span><br><span class="line">    double a;</span><br><span class="line">    int b;</span><br><span class="line">    char c;</span><br><span class="line">    short d;</span><br><span class="line">    int e;</span><br><span class="line">    struct JSPerson1 str;</span><br><span class="line">  	int f;</span><br><span class="line">&#125;struct3;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@&quot;struct1的大小&#x3D;&#x3D;%lu&quot;,sizeof(struct1));</span><br><span class="line">        NSLog(@&quot;struct2的大小&#x3D;&#x3D;%lu&quot;,sizeof(struct2));</span><br><span class="line">        NSLog(@&quot;struct3的大小&#x3D;&#x3D;%lu&quot;,sizeof(struct3));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到打印结果为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct1的大小==<span class="number">24</span></span><br><span class="line">struct2的大小==<span class="number">16</span></span><br><span class="line">struct3的大小==<span class="number">56</span></span><br></pre></td></tr></table></figure>

<p><code>JSPerson1</code>和<code>JSPerson2</code>的属性数量相同，为什么打印的大小结果不一样呢，这里就引入了<code>字节对齐</code>的概念，我们先看一下OC中各类型占用的内存大小：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1036c1a589444b1b811de1c69f12bd0d~tplv-k3u1fbpfcp-watermark.image" alt="类型占用空间"></p>
<h4 id="结构体对齐原则"><a href="#结构体对齐原则" class="headerlink" title="结构体对齐原则"></a>结构体对齐原则</h4><ul>
<li>1、数据成员对⻬规则:结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小(只要该成员有子成员，比如说是数组，结构体等)的整数倍开始(比如int为4字节,则要从4的整数倍地址开始存储。</li>
<li>2、结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部最大元素大小的整数倍地址开始存储.(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储.)</li>
<li>3、收尾工作:结构体的总大小,也就是sizeof的结果,.必须是其内部最大成员(基本数据类型)的整数倍.不足的要补⻬。</li>
</ul>
<p>根据上面的表格和规则我们分析一下例子中三个结构体占用的内存大小(64位系统)</p>
<ul>
<li><p>首先看<code>struct1</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct JSPerson1 &#123;</span><br><span class="line">    double a;</span><br><span class="line">    char b;</span><br><span class="line">    int c;</span><br><span class="line">    short d;</span><br><span class="line">&#125;struct1;</span><br></pre></td></tr></table></figure>

<p>根据规则1，<code>a</code>变量存储的空间是<code>[0,7]</code>,<code>b</code>变量存储的位置是<code>[8]</code>,<code>c</code>因为本身是<code>int</code>4个字节大小，所以不能从<code>9</code>的位置开始存储，要从<code>4</code>整数倍开始存储所以<code>c</code>存储的空间是[12,15],<code>d</code>是<code>short</code>类型大小为<code>2</code>，<code>16</code>是<code>2</code>的整数倍，所以d的存储位置是[16,17]。根据规则3，结构体的总大小需要是内部最大成员的整数倍，所以<code>struct1</code>的大小为<code>24</code>.</p>
</li>
<li><p>再看<code>struct2</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct JSPerson2 &#123;</span><br><span class="line">    double a;</span><br><span class="line">    int b;</span><br><span class="line">    char c;</span><br><span class="line">    short d;        </span><br><span class="line">&#125;struct2;</span><br></pre></td></tr></table></figure>

<p>和上面一样<code>a</code>变量存储的空间是<code>[0,7]</code>，<code>b</code>变量存储的位置是<code>[8,11]</code>，<code>c</code>变量的存储空间是<code>[12]</code>,<code>d</code>变量的存储空间是[14,15]</p>
<p>根据规则3<code>struct2</code>的大小为<code>16</code></p>
</li>
<li><p>最后看<code>struct3</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct JSPerson3 &#123;</span><br><span class="line">    double a;</span><br><span class="line">    int b;</span><br><span class="line">    char c;</span><br><span class="line">    short d;</span><br><span class="line">    int e;</span><br><span class="line">    struct JSPerson1 str;</span><br><span class="line">  	int f;</span><br><span class="line">&#125;struct3;</span><br></pre></td></tr></table></figure>

<p>前四个变量和<code>struct2</code>类似，<code>a</code>变量存储的空间是<code>[0,7]</code>，<code>b</code>变量存储的位置是<code>[8,11]</code>，<code>c</code>变量的存储空间是<code>[12]</code>,<code>d</code>变量的存储空间是[14,15]，<code>e</code>变量存储空间是<code>[16,19]</code>，结构体成员比较特殊我们根据规则2，<code>str</code>成员的起始地址要是它内部最大成员的大小的整数倍也就是<code>8</code>，所以str存储的空间是[24,47],<code>f</code>所占的内存空间是[48,51],<strong>注意这个地方有个点：结构体的总大小是其最大基本成员变量的大小的整数倍</strong>，所以<code>struct3</code>的内存大小是<code>56</code>(<code>8</code>的整数倍)。</p>
</li>
</ul>
<h3 id="对象的字节对齐"><a href="#对象的字节对齐" class="headerlink" title="对象的字节对齐"></a>对象的字节对齐</h3><p>看完了结构体的内存对齐，我们看一下对象的，其实我们很容易可以想到，对象其实也是一个结构体，它和结构体的字节对齐规则也是一样的。我们来验证一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@interface Person1 : NSObject&#123;</span><br><span class="line">    int _age;</span><br><span class="line">    int _weight;</span><br><span class="line">    NSString *_name;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@implementation Person1</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Person2 : NSObject&#123;</span><br><span class="line">    int _age;</span><br><span class="line">    NSString *_name;</span><br><span class="line">    int _weight;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Person2</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        Person1 *obj1 &#x3D; [[Person1 alloc] init];</span><br><span class="line">        NSLog(@&quot;Person1实际占用： class_getInstanceSize &#x3D; %zd&quot;, class_getInstanceSize([Person1 class]));</span><br><span class="line">        NSLog(@&quot;Person1系统分配：malloc_size &#x3D; %zd&quot;, malloc_size((__bridge const void *)(obj1)));</span><br><span class="line">        Person2 *obj2 &#x3D; [[Person2 alloc] init];</span><br><span class="line">        NSLog(@&quot;Person2实际占用： class_getInstanceSize &#x3D; %zd&quot;, class_getInstanceSize([Person2 class]));</span><br><span class="line">        NSLog(@&quot;Person2系统分配：malloc_size &#x3D; %zd&quot;, malloc_size((__bridge const void *)(obj2)));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义两个类<code>Person1</code>和<code>Person2</code>,分别打印他们实际占用内存和系统分配内存大小：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person1实际占用： class_getInstanceSize = <span class="number">24</span></span><br><span class="line">Person1系统分配：malloc_size = <span class="number">32</span></span><br><span class="line">Person2实际占用： class_getInstanceSize = <span class="number">32</span></span><br><span class="line">Person2系统分配：malloc_size = <span class="number">32</span></span><br></pre></td></tr></table></figure>

<p>这里有个注意的点就是不要漏掉<code>isa</code>指针，对象结构体中第一个成员变量就是<code>isa</code>，所以我们分析的方法和结构体一样，<code>Person1</code>的<code>isa</code>存储地址是<code>[0,7]</code>,<code>_age</code>的存储空间是<code>[8,11]</code>,<code>_weight</code>的存储空间是<code>[12,15]</code>，<code>_name</code>的存储空间是<code>[16，23]</code>，所以<code>Person1</code>实际空间是<code>24</code>,同样的方法可得<code>Person2</code>的实际空间是<code>32</code>。</p>
<p>这里我们可以看到，成员变量的顺序是会影响到对象实际占用的内存大小，类的属性最后其实也是会生成对应的成员变量，那么属性的定义顺序是不是也会影响对象的实际占用内存大小呢，我们带着这个问题继续探索：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@interface Person1 : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic,assign)int age;</span><br><span class="line">@property (nonatomic,assign)int weight;</span><br><span class="line">@property (nonatomic,strong)NSString *name;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Person1</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Person2 : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic,assign)int age;</span><br><span class="line">@property (nonatomic,strong)NSString *name;</span><br><span class="line">@property (nonatomic,assign)int weight;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Person2</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        Person1 *obj1 &#x3D; [[Person1 alloc] init];</span><br><span class="line">        NSLog(@&quot;Person1实际占用： class_getInstanceSize &#x3D; %zd&quot;, class_getInstanceSize([Person1 class]));</span><br><span class="line">        NSLog(@&quot;Person1系统分配：malloc_size &#x3D; %zd&quot;, malloc_size((__bridge const void *)(obj1)));</span><br><span class="line">        Person2 *obj2 &#x3D; [[Person2 alloc] init];</span><br><span class="line">        NSLog(@&quot;Person2实际占用： class_getInstanceSize &#x3D; %zd&quot;, class_getInstanceSize([Person2 class]));</span><br><span class="line">        NSLog(@&quot;Person2系统分配：malloc_size &#x3D; %zd&quot;, malloc_size((__bridge const void *)(obj2)));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们把成员变量换成属性继续打印上面的内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person1实际占用： class_getInstanceSize = <span class="number">24</span></span><br><span class="line">Person1系统分配：malloc_size = <span class="number">32</span></span><br><span class="line">Person2实际占用： class_getInstanceSize = <span class="number">24</span></span><br><span class="line">Person2系统分配：malloc_size = <span class="number">32</span></span><br></pre></td></tr></table></figure>

<p>发现这次打印<code>Person1</code>和<code>Person2</code>实际占用的内存大小是相同的，这是为什么呢？我们将<code>main.m</code>文件转换成<code>c++</code>代码看一下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphonesimulator clang -rewrite-objc main.m</span><br></pre></td></tr></table></figure>

<p>我们打开<code>main.cpp</code>文件，搜索<code>Person1</code>和<code>Person2</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person1_IMPL</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">NSObject_IMPL</span> <span class="title">NSObject_IVARS</span>;</span></span><br><span class="line">	<span class="keyword">int</span> _age;</span><br><span class="line">	<span class="keyword">int</span> _weight;</span><br><span class="line">	NSString * _Nonnull _name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person2_IMPL</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">NSObject_IMPL</span> <span class="title">NSObject_IVARS</span>;</span></span><br><span class="line">	<span class="keyword">int</span> _age;</span><br><span class="line">	<span class="keyword">int</span> _weight;</span><br><span class="line">	NSString *_name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看到这里我们明白了，原来编译器帮我们做了一层优化，将属性按照最优的顺序转换成成员变量。所以我们定义属性的顺序并不会影响到对象实际占用的内存大小。</p>
<p>内存对齐的内容就探索到这里，后面会继续探索<code>ios 底层</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/06/06/iOS%E5%BA%95%E5%B1%82-alloc%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/06/iOS%E5%BA%95%E5%B1%82-alloc%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">iOS底层探索-alloc方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-06 16:23:12" itemprop="dateCreated datePublished" datetime="2021-06-06T16:23:12+08:00">2021-06-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-20 22:21:12" itemprop="dateModified" datetime="2021-06-20T22:21:12+08:00">2021-06-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>alloc</code>是我们日常开发中经常遇到，下面我们从源码层面分析一下，<code>alloc</code>方法的底层。</p>
<h3 id="准备工作-获取源码"><a href="#准备工作-获取源码" class="headerlink" title="准备工作-获取源码"></a>准备工作-获取源码</h3><ul>
<li>从苹果<a href="https://opensource.apple.com/tarballs/" target="_blank" rel="noopener">开源网站</a>下载<code>objc</code>的源码。</li>
<li>根据<a href="https://juejin.cn/post/6914265121183236104" target="_blank" rel="noopener">这个教程</a>将源码调试成可编译的状态<h3 id="开始探究"><a href="#开始探究" class="headerlink" title="开始探究"></a>开始探究</h3>我们新建一个类JSPerson<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;.h</span><br><span class="line">@interface JSPerson : NSObject</span><br><span class="line">@end</span><br><span class="line">&#x2F;&#x2F;.m</span><br><span class="line">@implementation JSPerson</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
在<code>main</code>方法中初始化<code>JSPerson</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        JSPerson *person &#x3D; [JSPerson alloc];</span><br><span class="line">        NSLog(@&quot;%@&quot;,person);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在<code>JSPerson *person = [JSPerson alloc];</code>这行添加断点运行。<br>按<code>control</code>键发现断点走到了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KCObjcBuild&#96;objc_alloc:</span><br><span class="line">-&gt;  0x100003f44 &lt;+0&gt;: jmpq   *0x40be(%rip)             ; (void *)0x0000000100003f76</span><br></pre></td></tr></table></figure>
说明这个时候调用了<code>objc_alloc</code>方法，我们打一个<code>objc_alloc</code>的符号断点，继续执行程序，发现断点来到了<code>objc_alloc</code>的源码部分。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Calls [cls alloc].</span><br><span class="line">id</span><br><span class="line">objc_alloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    return callAlloc(cls, true&#x2F;*checkNil*&#x2F;, false&#x2F;*allocWithZone*&#x2F;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们继续进入<code>callAlloc</code>方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE id</span><br><span class="line">callAlloc(Class cls, bool checkNil, bool allocWithZone&#x3D;false)</span><br><span class="line">&#123;</span><br><span class="line">#if __OBJC2__</span><br><span class="line">    if (slowpath(checkNil &amp;&amp; !cls)) return nil;</span><br><span class="line">    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        return _objc_rootAllocWithZone(cls, nil);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; No shortcuts available.</span><br><span class="line">    if (allocWithZone) &#123;</span><br><span class="line">        return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil);</span><br><span class="line">    &#125;</span><br><span class="line">    return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们继续走断点，发现走到了<code>return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc));</code>即又调用了alloc方法，也就是说<code>callAlloc</code>也会再次调用。<br>继续调试这次走到了<code>return _objc_rootAllocWithZone(cls, nil);</code>,断点进入<code>_objc_rootAllocWithZone</code>方法看一下源码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone __unused)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; allocWithZone under __OBJC2__ ignores the zone parameter</span><br><span class="line">    return _class_createInstanceFromZone(cls, 0, nil,</span><br><span class="line">                                         OBJECT_CONSTRUCT_CALL_BADALLOC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
代码很简单，我们继续跟进到<code>_class_createInstanceFromZone</code>方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE id</span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,</span><br><span class="line">                              int construct_flags &#x3D; OBJECT_CONSTRUCT_NONE,</span><br><span class="line">                              bool cxxConstruct &#x3D; true,</span><br><span class="line">                              size_t *outAllocatedSize &#x3D; nil)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line">    &#x2F;&#x2F; Read class&#39;s info bits all at once for performance</span><br><span class="line">    bool hasCxxCtor &#x3D; cxxConstruct &amp;&amp; cls-&gt;hasCxxCtor();</span><br><span class="line">    bool hasCxxDtor &#x3D; cls-&gt;hasCxxDtor();</span><br><span class="line">    bool fast &#x3D; cls-&gt;canAllocNonpointer();</span><br><span class="line">    size_t size;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;获取实例大小</span><br><span class="line">    size &#x3D; cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    if (outAllocatedSize) *outAllocatedSize &#x3D; size;</span><br><span class="line">    id obj;</span><br><span class="line">    if (zone) &#123;</span><br><span class="line">        obj &#x3D; (id)malloc_zone_calloc((malloc_zone_t *)zone, 1, size);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;分配内存</span><br><span class="line">        obj &#x3D; (id)calloc(1, size);</span><br><span class="line">    &#125;</span><br><span class="line">    if (slowpath(!obj)) &#123;</span><br><span class="line">        if (construct_flags &amp; OBJECT_CONSTRUCT_CALL_BADALLOC) &#123;</span><br><span class="line">            return _objc_callBadAllocHandler(cls);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;关联isa指针</span><br><span class="line">    if (!zone &amp;&amp; fast) &#123;</span><br><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; Use raw pointer isa on the assumption that they might be</span><br><span class="line">        &#x2F;&#x2F; doing something weird with the zone or RR.</span><br><span class="line">        obj-&gt;initIsa(cls);</span><br><span class="line">    &#125;</span><br><span class="line">    if (fastpath(!hasCxxCtor)) &#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">    construct_flags |&#x3D; OBJECT_CONSTRUCT_FREE_ONFAILURE;</span><br><span class="line">    return object_cxxConstructFromClass(obj, cls, construct_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>_class_createInstanceFromZone</code>方法有三个关键的点，我们下面分别分析：<h4 id="获取实例大小-size-cls-gt-instanceSize-extraBytes"><a href="#获取实例大小-size-cls-gt-instanceSize-extraBytes" class="headerlink" title="获取实例大小 size = cls-&gt;instanceSize(extraBytes)"></a>获取实例大小 <code>size = cls-&gt;instanceSize(extraBytes)</code></h4>内联函数<code>instanceSize</code>的作用是获取实例的大小，对象的大小取决于其<code>ivars</code>(成员变量)的大小。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; May be unaligned depending on class&#39;s ivars.</span><br><span class="line">uint32_t unalignedInstanceSize() const &#123;</span><br><span class="line">    ASSERT(isRealized());</span><br><span class="line">    return data()-&gt;ro()-&gt;instanceSize;</span><br><span class="line">&#125;</span><br><span class="line">inline size_t instanceSize(size_t extraBytes) const &#123;</span><br><span class="line">    if (fastpath(cache.hasFastInstanceSize(extraBytes))) &#123;</span><br><span class="line">        return cache.fastInstanceSize(extraBytes);</span><br><span class="line">    &#125;</span><br><span class="line">    size_t size &#x3D; alignedInstanceSize() + extraBytes;</span><br><span class="line">    &#x2F;&#x2F; CF requires all objects be at least 16 bytes.</span><br><span class="line">    if (size &lt; 16) size &#x3D; 16;</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
根据<code>if (size &lt; 16) size = 16;</code>可以看出，对象最小大小为16，这个就是内存对齐的概念，上面的<code>alignedInstanceSize()</code>函数,会继续调用内联函数<code>word_align</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; __LP64__</span><br><span class="line">#   define WORD_MASK 7UL</span><br><span class="line">static inline uint32_t word_align(uint32_t x) &#123;</span><br><span class="line">    return (x + WORD_MASK) &amp; ~WORD_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里就引入一个概念就是字节对齐。可以看到<code>WORD_MASK=7</code>,它的作用是保证字节的大小为8的倍数。<h4 id="给对象分配内存空间"><a href="#给对象分配内存空间" class="headerlink" title="给对象分配内存空间"></a>给对象分配内存空间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (zone) &#123;</span><br><span class="line">    obj &#x3D; (id)malloc_zone_calloc((malloc_zone_t *)zone, 1, size);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    obj &#x3D; (id)calloc(1, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="给对象关联isa指针"><a href="#给对象关联isa指针" class="headerlink" title="给对象关联isa指针"></a>给对象关联isa指针</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (!zone &amp;&amp; fast) &#123;</span><br><span class="line">    obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; Use raw pointer isa on the assumption that they might be</span><br><span class="line">    &#x2F;&#x2F; doing something weird with the zone or RR.</span><br><span class="line">    obj-&gt;initIsa(cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>总结来看<code>alloc</code>的流程图即为下图所示：</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62281d7404a940a9bcf2390166545e97~tplv-k3u1fbpfcp-watermark.image" alt="alloc流程.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/06/06/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-alloc%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/06/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-alloc%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">iOS底层探索-alloc方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-06 16:23:12" itemprop="dateCreated datePublished" datetime="2021-06-06T16:23:12+08:00">2021-06-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-11 00:27:14" itemprop="dateModified" datetime="2021-07-11T00:27:14+08:00">2021-07-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>alloc</code>是我们日常开发中经常遇到，下面我们从源码层面分析一下，<code>alloc</code>方法的底层。</p>
<h3 id="准备工作-获取源码"><a href="#准备工作-获取源码" class="headerlink" title="准备工作-获取源码"></a>准备工作-获取源码</h3><ul>
<li>从苹果<a href="https://opensource.apple.com/tarballs/" target="_blank" rel="noopener">开源网站</a>下载<code>objc</code>的源码。</li>
<li>根据<a href="https://juejin.cn/post/6914265121183236104" target="_blank" rel="noopener">这个教程</a>将源码调试成可编译的状态<h3 id="开始探究"><a href="#开始探究" class="headerlink" title="开始探究"></a>开始探究</h3>我们新建一个类JSPerson<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;.h</span><br><span class="line">@interface JSPerson : NSObject</span><br><span class="line">@end</span><br><span class="line">&#x2F;&#x2F;.m</span><br><span class="line">@implementation JSPerson</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
在<code>main</code>方法中初始化<code>JSPerson</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        JSPerson *person &#x3D; [JSPerson alloc];</span><br><span class="line">        NSLog(@&quot;%@&quot;,person);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在<code>JSPerson *person = [JSPerson alloc];</code>这行添加断点运行。<br>按<code>control</code>键发现断点走到了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KCObjcBuild&#96;objc_alloc:</span><br><span class="line">-&gt;  0x100003f44 &lt;+0&gt;: jmpq   *0x40be(%rip)             ; (void *)0x0000000100003f76</span><br></pre></td></tr></table></figure>
说明这个时候调用了<code>objc_alloc</code>方法，我们打一个<code>objc_alloc</code>的符号断点，继续执行程序，发现断点来到了<code>objc_alloc</code>的源码部分。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Calls [cls alloc].</span><br><span class="line">id</span><br><span class="line">objc_alloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    return callAlloc(cls, true&#x2F;*checkNil*&#x2F;, false&#x2F;*allocWithZone*&#x2F;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们继续进入<code>callAlloc</code>方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE id</span><br><span class="line">callAlloc(Class cls, bool checkNil, bool allocWithZone&#x3D;false)</span><br><span class="line">&#123;</span><br><span class="line">#if __OBJC2__</span><br><span class="line">    if (slowpath(checkNil &amp;&amp; !cls)) return nil;</span><br><span class="line">    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        return _objc_rootAllocWithZone(cls, nil);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; No shortcuts available.</span><br><span class="line">    if (allocWithZone) &#123;</span><br><span class="line">        return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil);</span><br><span class="line">    &#125;</span><br><span class="line">    return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们继续走断点，发现走到了<code>return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc));</code>即又调用了alloc方法，也就是说<code>callAlloc</code>也会再次调用。<br>继续调试这次走到了<code>return _objc_rootAllocWithZone(cls, nil);</code>,断点进入<code>_objc_rootAllocWithZone</code>方法看一下源码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone __unused)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; allocWithZone under __OBJC2__ ignores the zone parameter</span><br><span class="line">    return _class_createInstanceFromZone(cls, 0, nil,</span><br><span class="line">                                         OBJECT_CONSTRUCT_CALL_BADALLOC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
代码很简单，我们继续跟进到<code>_class_createInstanceFromZone</code>方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE id</span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,</span><br><span class="line">                              int construct_flags &#x3D; OBJECT_CONSTRUCT_NONE,</span><br><span class="line">                              bool cxxConstruct &#x3D; true,</span><br><span class="line">                              size_t *outAllocatedSize &#x3D; nil)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line">    &#x2F;&#x2F; Read class&#39;s info bits all at once for performance</span><br><span class="line">    bool hasCxxCtor &#x3D; cxxConstruct &amp;&amp; cls-&gt;hasCxxCtor();</span><br><span class="line">    bool hasCxxDtor &#x3D; cls-&gt;hasCxxDtor();</span><br><span class="line">    bool fast &#x3D; cls-&gt;canAllocNonpointer();</span><br><span class="line">    size_t size;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;获取实例大小</span><br><span class="line">    size &#x3D; cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    if (outAllocatedSize) *outAllocatedSize &#x3D; size;</span><br><span class="line">    id obj;</span><br><span class="line">    if (zone) &#123;</span><br><span class="line">        obj &#x3D; (id)malloc_zone_calloc((malloc_zone_t *)zone, 1, size);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;分配内存</span><br><span class="line">        obj &#x3D; (id)calloc(1, size);</span><br><span class="line">    &#125;</span><br><span class="line">    if (slowpath(!obj)) &#123;</span><br><span class="line">        if (construct_flags &amp; OBJECT_CONSTRUCT_CALL_BADALLOC) &#123;</span><br><span class="line">            return _objc_callBadAllocHandler(cls);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;关联isa指针</span><br><span class="line">    if (!zone &amp;&amp; fast) &#123;</span><br><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; Use raw pointer isa on the assumption that they might be</span><br><span class="line">        &#x2F;&#x2F; doing something weird with the zone or RR.</span><br><span class="line">        obj-&gt;initIsa(cls);</span><br><span class="line">    &#125;</span><br><span class="line">    if (fastpath(!hasCxxCtor)) &#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">    construct_flags |&#x3D; OBJECT_CONSTRUCT_FREE_ONFAILURE;</span><br><span class="line">    return object_cxxConstructFromClass(obj, cls, construct_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>_class_createInstanceFromZone</code>方法有三个关键的点，我们下面分别分析：<h4 id="获取实例大小-size-cls-gt-instanceSize-extraBytes"><a href="#获取实例大小-size-cls-gt-instanceSize-extraBytes" class="headerlink" title="获取实例大小 size = cls-&gt;instanceSize(extraBytes)"></a>获取实例大小 <code>size = cls-&gt;instanceSize(extraBytes)</code></h4>内联函数<code>instanceSize</code>的作用是获取实例的大小，对象的大小取决于其<code>ivars</code>(成员变量)的大小。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; May be unaligned depending on class&#39;s ivars.</span><br><span class="line">uint32_t unalignedInstanceSize() const &#123;</span><br><span class="line">    ASSERT(isRealized());</span><br><span class="line">    return data()-&gt;ro()-&gt;instanceSize;</span><br><span class="line">&#125;</span><br><span class="line">inline size_t instanceSize(size_t extraBytes) const &#123;</span><br><span class="line">    if (fastpath(cache.hasFastInstanceSize(extraBytes))) &#123;</span><br><span class="line">        return cache.fastInstanceSize(extraBytes);</span><br><span class="line">    &#125;</span><br><span class="line">    size_t size &#x3D; alignedInstanceSize() + extraBytes;</span><br><span class="line">    &#x2F;&#x2F; CF requires all objects be at least 16 bytes.</span><br><span class="line">    if (size &lt; 16) size &#x3D; 16;</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
根据<code>if (size &lt; 16) size = 16;</code>可以看出，对象最小大小为16，这个就是内存对齐的概念，上面的<code>alignedInstanceSize()</code>函数,会继续调用内联函数<code>word_align</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; __LP64__</span><br><span class="line">#   define WORD_MASK 7UL</span><br><span class="line">static inline uint32_t word_align(uint32_t x) &#123;</span><br><span class="line">    return (x + WORD_MASK) &amp; ~WORD_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里就引入一个概念就是字节对齐。可以看到<code>WORD_MASK=7</code>,它的作用是保证字节的大小为8的倍数。<h4 id="给对象分配内存空间"><a href="#给对象分配内存空间" class="headerlink" title="给对象分配内存空间"></a>给对象分配内存空间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (zone) &#123;</span><br><span class="line">    obj &#x3D; (id)malloc_zone_calloc((malloc_zone_t *)zone, 1, size);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    obj &#x3D; (id)calloc(1, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="给对象关联isa指针"><a href="#给对象关联isa指针" class="headerlink" title="给对象关联isa指针"></a>给对象关联isa指针</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (!zone &amp;&amp; fast) &#123;</span><br><span class="line">    obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; Use raw pointer isa on the assumption that they might be</span><br><span class="line">    &#x2F;&#x2F; doing something weird with the zone or RR.</span><br><span class="line">    obj-&gt;initIsa(cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>总结来看<code>alloc</code>的流程图即为下图所示：</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62281d7404a940a9bcf2390166545e97~tplv-k3u1fbpfcp-watermark.image" alt="alloc流程.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/06/01/Swift-RxSwift%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/01/Swift-RxSwift%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Swift - RxSwift源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-01 15:35:58" itemprop="dateCreated datePublished" datetime="2021-06-01T15:35:58+08:00">2021-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-03 21:54:22" itemprop="dateModified" datetime="2021-06-03T21:54:22+08:00">2021-06-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="RxSwift简介"><a href="#RxSwift简介" class="headerlink" title="RxSwift简介"></a>RxSwift简介</h3><p><code>RxSwift</code> 是 <a href="http://reactivex.io/" target="_blank" rel="noopener"><code>ReactiveX</code></a> 家族的重要一员, <code>ReactiveX</code> 是 <code>Reactive Extensions</code> 的缩写，一般简写为 <code>Rx</code>。<code>ReactiveX</code> 官方给<code>Rx</code>的定义是：<strong>Rx是一个使用可观察数据流进行异步编程的编程接口。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactiveX&#96; 不仅仅是一个编程接口，它是一种编程思想的突破，它影响了许多其它的程序库和框架以及编程语言。它拓展了&#96;观察者模式&#96;，使你能够&#96;自由组合多个异步事件&#96;，而&#96;不需要去关心线程&#96;，&#96;同步，线程安全&#96;，&#96;并发数据以及I&#x2F;O阻塞</span><br></pre></td></tr></table></figure>

<p><code>RxSwift</code> 是 <code>Rx</code> 为 <code>Swift</code> 语言开发的一门函数响应式编程语言， 它可以代替iOS系统的 <code>Target Action</code> / <code>代理</code> / <code>闭包</code> / <code>通知</code> / <code>KVO</code>,同时还提供<code>网络</code>、<code>数据绑定</code>、<code>UI事件处理</code>、<code>UI的展示和更新</code>、<code>多线程</code>……</p>
<p><code>Swift</code>为值类型，在传值与方法回调上有影响，<code>RxSwift</code>一定程度上弥补<code>Swift</code>的灵活性</p>
<ul>
<li><code>RxSwift</code>使得代码复用性较强，减少代码量</li>
<li><code>RxSwift</code>因为声明都是不可变更，增加代码可读性</li>
<li><code>RxSwift</code>使得更易于理解业务代码，抽象异步编程，统一代码风格</li>
<li><code>RxSwift</code>使得代码更易于编写集成单元测试，增加代码稳定性</li>
</ul>
<h3 id="RxSwift核心流程"><a href="#RxSwift核心流程" class="headerlink" title="RxSwift核心流程"></a>RxSwift核心流程</h3><p>RxSwift的api设计非常精简，流程就是：</p>
<p>1、创建序列（）</p>
<p>2、订阅序列</p>
<p>3、发送信号</p>
<p>4、销毁</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1: 创建序列</span></span><br><span class="line"><span class="number">_</span> = <span class="type">Observable</span>&lt;<span class="type">String</span>&gt;.create &#123; (obserber) -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// 3:发送信号</span></span><br><span class="line">    obserber.onNext(<span class="string">"RxSwift 研究"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create()  <span class="comment">// 4、销毁</span></span><br><span class="line">    <span class="comment">// 2: 订阅序列</span></span><br><span class="line">    &#125;.subscribe(onNext: &#123; (text) <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"订阅到:\(text)"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台打印：“订阅到:RxSwift 研究”</span></span><br></pre></td></tr></table></figure>

<h3 id="创建序列"><a href="#创建序列" class="headerlink" title="创建序列"></a>创建序列</h3><p>我们先看Create.swift文件的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ObservableType</span> </span>&#123;</span><br><span class="line">    <span class="comment">// MARK: create</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     Creates an observable sequence from a specified subscribe method implementation.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     - seealso: [create operator on reactivex.io](http://reactivex.io/documentation/operators/create.html)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     - parameter subscribe: Implementation of the resulting observable sequence's `subscribe` method.</span></span><br><span class="line"><span class="comment">     - returns: The observable sequence with the specified implementation for the `subscribe` method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(<span class="number">_</span> subscribe: @escaping <span class="params">(AnyObserver&lt;Element&gt;)</span></span></span> -&gt; <span class="type">Disposable</span>) -&gt; <span class="type">Observable</span>&lt;<span class="type">Element</span>&gt; &#123;</span><br><span class="line">        <span class="type">AnonymousObservable</span>(subscribe)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousObservable</span>&lt;<span class="title">Element</span>&gt;: <span class="title">Producer</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">SubscribeHandler</span> = (<span class="type">AnyObserver</span>&lt;<span class="type">Element</span>&gt;) -&gt; <span class="type">Disposable</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> subscribeHandler: <span class="type">SubscribeHandler</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> subscribeHandler: @escaping <span class="type">SubscribeHandler</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.subscribeHandler = subscribeHandler</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">run</span>&lt;Observer: ObserverType&gt;<span class="params">(<span class="number">_</span> observer: Observer, cancel: Cancelable)</span></span> -&gt; (sink: <span class="type">Disposable</span>, subscription: <span class="type">Disposable</span>) <span class="keyword">where</span> <span class="type">Observer</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> sink = <span class="type">AnonymousObservableSink</span>(observer: observer, cancel: cancel)</span><br><span class="line">        <span class="keyword">let</span> subscription = sink.run(<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">return</span> (sink: sink, subscription: subscription)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，可观察序列的创建是利用扩展<code>ObservableType</code>协议的<code>create</code>方法实现的,里面创建了<code>AnonymousObservable</code>(匿名可观察序列) ，这个命名体现了作者的思维，这是一个内部类，具备一些通用特性（具有自己功能的类才会命名）可以总结一下：</p>
<ul>
<li><code>create</code>方法的时候创建了一个内部对象<code>AnonymousObservable</code></li>
<li><code>AnonymousObservable</code>保存了外界传入的闭包</li>
<li><code>AnonymousObservable</code>继承了<code>Producer</code></li>
</ul>
<p>接下来我们看一下<code>Producer</code>类</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span>&lt;<span class="title">Element</span>&gt;: <span class="title">Observable</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span>&lt;Observer: ObserverType&gt;<span class="params">(<span class="number">_</span> observer: Observer)</span></span> -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">Observer</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !<span class="type">CurrentThreadScheduler</span>.isScheduleRequired &#123;</span><br><span class="line">            <span class="comment">// The returned disposable needs to release all references once it was disposed.</span></span><br><span class="line">            <span class="keyword">let</span> disposer = <span class="type">SinkDisposer</span>()</span><br><span class="line">            <span class="keyword">let</span> sinkAndSubscription = <span class="keyword">self</span>.run(observer, cancel: disposer)</span><br><span class="line">            disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink, subscription: sinkAndSubscription.subscription)</span><br><span class="line">            <span class="keyword">return</span> disposer</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">CurrentThreadScheduler</span>.instance.schedule(()) &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">let</span> disposer = <span class="type">SinkDisposer</span>()</span><br><span class="line">                <span class="keyword">let</span> sinkAndSubscription = <span class="keyword">self</span>.run(observer, cancel: disposer)</span><br><span class="line">                disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink, subscription: sinkAndSubscription.subscription)</span><br><span class="line">                <span class="keyword">return</span> disposer</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span>&lt;Observer: ObserverType&gt;<span class="params">(<span class="number">_</span> observer: Observer, cancel: Cancelable)</span></span> -&gt; (sink: <span class="type">Disposable</span>, subscription: <span class="type">Disposable</span>) <span class="keyword">where</span> <span class="type">Observer</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">        rxAbstractMethod()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到Producer有一个很重要的方法<code>subscribe</code>(订阅)，<code>subscribe</code>方法最后返回一个<code>Disposable</code>对象。</p>
<h3 id="订阅序列"><a href="#订阅序列" class="headerlink" title="订阅序列"></a>订阅序列</h3><p>我们看一下<code>ObservableType</code>拓展（ObservableType+Extensions.swift）的功能，订阅的方法<code>subscribe</code>（注意这个方法和<code>Producer</code>的<code>subscribe</code>不是同一个）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     Subscribes an element handler, an error handler, a completion handler and disposed handler to an observable sequence.</span></span><br><span class="line"><span class="comment">     - parameter onNext: Action to invoke for each element in the observable sequence.</span></span><br><span class="line"><span class="comment">     - parameter onError: Action to invoke upon errored termination of the observable sequence.</span></span><br><span class="line"><span class="comment">     - parameter onCompleted: Action to invoke upon graceful termination of the observable sequence.</span></span><br><span class="line"><span class="comment">     - parameter onDisposed: Action to invoke upon any type of termination of sequence (if the sequence has</span></span><br><span class="line"><span class="comment">     gracefully completed, errored, or if the generation is canceled by disposing subscription).</span></span><br><span class="line"><span class="comment">     - returns: Subscription object used to unsubscribe from the observable sequence.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        onNext: <span class="params">(<span class="params">(Element)</span></span></span></span> -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span>,</span><br><span class="line">        onError: ((<span class="type">Swift</span>.<span class="type">Error</span>) -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span>,</span><br><span class="line">        onCompleted: (() -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span>,</span><br><span class="line">        onDisposed: (() -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span></span><br><span class="line">    ) -&gt; <span class="type">Disposable</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> disposable: <span class="type">Disposable</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> disposed = onDisposed &#123;</span><br><span class="line">                disposable = <span class="type">Disposables</span>.create(with: disposed)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                disposable = <span class="type">Disposables</span>.create()</span><br><span class="line">            &#125;</span><br><span class="line">            #<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line">                <span class="keyword">let</span> synchronizationTracker = <span class="type">SynchronizationTracker</span>()</span><br><span class="line">            #endif</span><br><span class="line">            <span class="keyword">let</span> callStack = <span class="type">Hooks</span>.recordCallStackOnError ? <span class="type">Hooks</span>.customCaptureSubscriptionCallstack() : []</span><br><span class="line">      			<span class="comment">///以下重点关注的代码 创建匿名观察者</span></span><br><span class="line">            <span class="keyword">let</span> observer = <span class="type">AnonymousObserver</span>&lt;<span class="type">Element</span>&gt; &#123; event <span class="keyword">in</span> </span><br><span class="line">                #<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line">                    synchronizationTracker.register(synchronizationErrorMessage: .<span class="keyword">default</span>)</span><br><span class="line">                    <span class="keyword">defer</span> &#123; synchronizationTracker.unregister() &#125;</span><br><span class="line">                #endif</span><br><span class="line">                <span class="keyword">switch</span> event &#123;</span><br><span class="line">                <span class="keyword">case</span> .next(<span class="keyword">let</span> value):</span><br><span class="line">                    onNext?(value)</span><br><span class="line">                <span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> onError = onError &#123;</span><br><span class="line">                        onError(error)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="type">Hooks</span>.defaultErrorHandler(callStack, error)</span><br><span class="line">                    &#125;</span><br><span class="line">                    disposable.dispose()</span><br><span class="line">                <span class="keyword">case</span> .completed:</span><br><span class="line">                    onCompleted?()</span><br><span class="line">                    disposable.dispose()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Disposables</span>.create(</span><br><span class="line">                <span class="keyword">self</span>.asObservable().subscribe(observer),</span><br><span class="line">                disposable</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码说明：</p>
<ul>
<li><p><code>E</code>是<code>Swift</code>的关联类型，这个如果仔细看过可观察序列的继承链源码应该不难得出：这个<code>E</code> 就是我们的 序列类型，我们这里就是<code>String</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span>&lt;<span class="title">Element</span>&gt; : <span class="title">ObservableType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Type of elements in sequence.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">E</span> = <span class="type">Element</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建<code>AnonymousObserver</code>对象，可以类比前面<code>create</code>的<code>AnonymousObservable</code>对象，初始化参数为闭包，保存了外界传入的<code>onNext</code>,<code>onError</code>,<code>onComplete</code>,<code>onDisposed</code>的处理回调闭包。</p>
</li>
<li><p><code>self.asObservable()</code>是我们的<code>RxSwift</code>为了保持一致性的写法。</p>
</li>
<li><p><code>self.asObservable().subscribe(observer)</code>其实本质就是<code>self.</code>subscribe(observer),通过可观察序列的继承关系，我们可以快速定位到<code>Producer</code>订阅代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span>&lt;Observer: ObserverType&gt;<span class="params">(<span class="number">_</span> observer: Observer)</span></span> -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">Observer</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !<span class="type">CurrentThreadScheduler</span>.isScheduleRequired &#123;</span><br><span class="line">        <span class="comment">// The returned disposable needs to release all references once it was disposed.</span></span><br><span class="line">        <span class="keyword">let</span> disposer = <span class="type">SinkDisposer</span>()</span><br><span class="line">        <span class="keyword">let</span> sinkAndSubscription = <span class="keyword">self</span>.run(observer, cancel: disposer)</span><br><span class="line">        disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink, subscription: sinkAndSubscription.subscription)</span><br><span class="line">        <span class="keyword">return</span> disposer</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CurrentThreadScheduler</span>.instance.schedule(()) &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> disposer = <span class="type">SinkDisposer</span>()</span><br><span class="line">            <span class="keyword">let</span> sinkAndSubscription = <span class="keyword">self</span>.run(observer, cancel: disposer)</span><br><span class="line">            disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink, subscription: sinkAndSubscription.subscription)</span><br><span class="line">            <span class="keyword">return</span> disposer</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>销毁代码后面在分析</p>
</li>
<li><p><code>self.run</code>这个代码最终由我们生产者<code>Producer</code>(抽象方法找子类)延伸到具体事务代码<code>AnonymousObservable.run</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">run</span>&lt;Observer: ObserverType&gt;<span class="params">(<span class="number">_</span> observer: Observer, cancel: Cancelable)</span></span> -&gt; (sink: <span class="type">Disposable</span>, subscription: <span class="type">Disposable</span>) <span class="keyword">where</span> <span class="type">Observer</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> sink = <span class="type">AnonymousObservableSink</span>(observer: observer, cancel: cancel)</span><br><span class="line">      <span class="keyword">let</span> subscription = sink.run(<span class="keyword">self</span>)</span><br><span class="line">      <span class="keyword">return</span> (sink: sink, subscription: subscription)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里调用了<code>sink.run(self)</code>方法，将业务处理下沉，分工更加明确。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(<span class="number">_</span> parent: Parent)</span></span> -&gt; <span class="type">Disposable</span> &#123;</span><br><span class="line">    parent.subscribeHandler(<span class="type">AnyObserver</span>(<span class="keyword">self</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>parent</code>是上面传入进来的<code>AnonymousObservable</code>对象</p>
</li>
<li><p>这个地方我们可以看到调用了<code>AnonymousObservable</code>对象的<code>subscribeHandler</code>方法，这里我们清楚了，为什么<code>序列订阅</code>的时候流程会执行我们的<code>序列闭包</code>，然后去执行<code>发送响应</code></p>
</li>
<li><p>发送响应的代码后面再分析，下面还有个点是<code>AnyObserver(self)</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Construct an instance whose `on(event)` calls `observer.on(event)`</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - parameter observer: Observer that receives sequence events.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">Observer</span>: <span class="type">ObserverType</span>&gt;(<span class="number">_</span> observer: <span class="type">Observer</span>) <span class="keyword">where</span> <span class="type">Observer</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">     <span class="keyword">self</span>.observer = observer.on</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个构造方法里面，我们创建了一个结构体<code>AnyObserver</code>保存了一个信息<code>AnonymousObservableSink.on</code>函数。注意不是<code>AnonymousObservableSink</code></p>
</li>
</ul>
<h3 id="发送响应"><a href="#发送响应" class="headerlink" title="发送响应"></a>发送响应</h3><p>通过上面的分析，我们清楚了<code>observer.onNext(&quot;&quot;)</code>本质是<code>AnyObserver.onNext(&quot;&quot;)</code>,我们发现AnyObserver没有这个方法，顺着思路找父类，找<code>ObserverType</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Convenience API extensions to provide alternate next, error, completed events</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ObserverType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Convenience method equivalent to `on(.next(element: Element))`</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - parameter element: Next element to send to observer(s)</span></span><br><span class="line">  	<span class="comment">///这里是我们关注的点 AnyObserver.onNext("")实际调用这里</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">onNext</span><span class="params">(<span class="number">_</span> element: Element)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.on(.next(element))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Convenience method equivalent to `on(.completed)`</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">onCompleted</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.on(.completed)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Convenience method equivalent to `on(.error(Swift.Error))`</span></span><br><span class="line">    <span class="comment">/// - parameter error: Swift.Error to send to observer(s)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">onError</span><span class="params">(<span class="number">_</span> error: Swift.Error)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.on(.error(error))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>外界调用的<code>observer.onNext(&quot;&quot;)</code>再次变形：<code>AnyObserver.on(.next(&quot;&quot;))</code>,<code>AnyObserver</code>调用了<code>on</code>里面的<code>.next</code>函数，<code>.next</code>函数带有我们最终的参数</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Construct an instance whose `on(event)` calls `observer.on(event)`</span></span><br><span class="line"><span class="comment">/// - parameter observer: Observer that receives sequence events.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">Observer</span>: <span class="type">ObserverType</span>&gt;(<span class="number">_</span> observer: <span class="type">Observer</span>) <span class="keyword">where</span> <span class="type">Observer</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.observer = observer.on</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// Send `event` to this observer.</span></span><br><span class="line"><span class="comment">/// - parameter event: Event instance.</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">on</span><span class="params">(<span class="number">_</span> event: Event&lt;Element&gt;)</span></span> &#123;</span><br><span class="line">     <span class="keyword">self</span>.observer(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>self.observer</code> 构造初始化就是：<code>AnonymousObservableSink .on 函数</code></p>
</li>
<li><p><code>self.observer(event)</code> -&gt; <code>AnonymousObservableSink .on(event)</code> 其中 <code>event = .next(&quot;&quot;)</code> 最终我们的核心逻辑又回到了 <code>sink</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousObservableSink</span>&lt;<span class="title">Observer</span>: <span class="title">ObserverType</span>&gt;: <span class="title">Sink</span>&lt;<span class="title">Observer</span>&gt;, <span class="title">ObserverType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">on</span><span class="params">(<span class="number">_</span> event: Event&lt;Element&gt;)</span></span> &#123;</span><br><span class="line">        #<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line">            <span class="keyword">self</span>.synchronizationTracker.register(synchronizationErrorMessage: .<span class="keyword">default</span>)</span><br><span class="line">            <span class="keyword">defer</span> &#123; <span class="keyword">self</span>.synchronizationTracker.unregister() &#125;</span><br><span class="line">        #endif</span><br><span class="line">        <span class="keyword">switch</span> event &#123;</span><br><span class="line">        <span class="keyword">case</span> .next:</span><br><span class="line">            <span class="keyword">if</span> load(<span class="keyword">self</span>.isStopped) == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.forwardOn(event)</span><br><span class="line">        <span class="keyword">case</span> .error, .completed:</span><br><span class="line">            <span class="keyword">if</span> fetchOr(<span class="keyword">self</span>.isStopped, <span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.forwardOn(event)</span><br><span class="line">                <span class="keyword">self</span>.dispose()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>self.forwardOn(event)</code> 这也是执行的核心代码，因为 <code>AnonymousObservableSink</code> 继承 <code>Sink</code> 这里还有封装，请看下面的代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sink</span>&lt;<span class="title">Observer</span>: <span class="title">ObserverType</span>&gt;: <span class="title">Disposable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="function"><span class="keyword">func</span> <span class="title">forwardOn</span><span class="params">(<span class="number">_</span> event: Event&lt;Observer.Element&gt;)</span></span> &#123;</span><br><span class="line">        #<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line">            <span class="keyword">self</span>.synchronizationTracker.register(synchronizationErrorMessage: .<span class="keyword">default</span>)</span><br><span class="line">            <span class="keyword">defer</span> &#123; <span class="keyword">self</span>.synchronizationTracker.unregister() &#125;</span><br><span class="line">        #endif</span><br><span class="line">        <span class="keyword">if</span> isFlagSet(<span class="keyword">self</span>.disposed, <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.observer.on(event)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其中 <code>self.observer</code> 就是我们初始化保存的 <code>观察者：AnonymousObserver</code></p>
</li>
<li><p>到这里我们得出了发送序列的本质就是<code>AnonymousObserver.on（.next(&quot;&quot;)）</code>,这个逻辑又回到了我们<code>订阅序列</code>时候创建的<code>AnonymousObserver</code>参数闭包的调用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="type">AnonymousObserver</span>&lt;<span class="type">E</span>&gt; &#123; event <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> event &#123;</span><br><span class="line">    <span class="keyword">case</span> .next(<span class="keyword">let</span> value):</span><br><span class="line">        onNext?(value)</span><br><span class="line">    <span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> onError = onError &#123;</span><br><span class="line">            onError(error)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Hooks</span>.defaultErrorHandler(callStack, error)</span><br><span class="line">        &#125;</span><br><span class="line">        disposable.dispose()</span><br><span class="line">    <span class="keyword">case</span> .completed:</span><br><span class="line">        onCompleted?()</span><br><span class="line">        disposable.dispose()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断<code>event</code>进而调用<code>onNext?(value)</code>,因为枚举的关联值<code>value=&quot;&quot;</code>,接下来外界<code>onNext</code>的调用参数。</p>
</li>
</ul>
<h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><p>我们先看一下创建序列到销毁的执行代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建序列</span></span><br><span class="line"><span class="keyword">let</span> ob = <span class="type">Observable</span>&lt;<span class="type">Any</span>&gt;.create &#123; (observer) -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">    observer.onNext(<span class="string">"Jason"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"销毁释放了"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 序列订阅</span></span><br><span class="line"><span class="keyword">let</span> dispose = ob.subscribe(onNext: &#123; (anything) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"订阅到了:\(anything)"</span>)</span><br><span class="line">&#125;, onError: &#123; (error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"订阅到了:\(error)"</span>)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"完成了"</span>)</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"销毁回调"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这段代码里面关于销毁相关的代码就是<code>Disposables.create {print(&quot;销毁释放了&quot;)}</code>,所以我们直接定位到<code>Disposables</code>类（AnonymousDisposable.swift文件）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Disposables</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Constructs a new disposable with the given action used for disposal.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - parameter dispose: Disposal action which will be run upon calling `dispose`.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(with dispose: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Cancelable</span> &#123;</span><br><span class="line">        <span class="type">AnonymousDisposable</span>(disposeAction: dispose)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以看出，这里创建了一个匿名销毁序列<code>AnonymousDisposable</code>,和订阅一样的手法。继续看<code>AnonymousDisposable</code>代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// When dispose method is called, disposal action will be dereferenced.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousDisposable</span> : <span class="title">DisposeBase</span>, <span class="title">Cancelable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Non-deprecated version of the constructor, used by `Disposables.create(with:)`</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">init</span>(disposeAction: @escaping <span class="type">DisposeAction</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.disposeAction = disposeAction</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Calls the disposal action if and only if the current instance hasn't been disposed yet.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// After invoking disposal action, disposal action will be dereferenced.</span></span><br><span class="line">    <span class="comment">///销毁核心的逻辑</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">dispose</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> fetchOr(<span class="keyword">self</span>.disposed, <span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> action = <span class="keyword">self</span>.disposeAction &#123;</span><br><span class="line">                <span class="keyword">self</span>.disposeAction = <span class="literal">nil</span></span><br><span class="line">                action()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上我们看到，初始化方法里保存了销毁响应闭包，什么时候调用，我们看下面的<code>dispose()</code>方法。</p>
</li>
<li><p>fetchOr(self.disposed, 1)是一个单项标记手段，这里利用了牛逼的算法标记可以降低依赖和更加快速。</p>
</li>
<li><p>主要就是保证只会销毁一次</p>
</li>
<li><p>销毁会首先<code>self.disposeAction = nil</code>,将回调闭包置空</p>
</li>
<li><p>最后调用闭包调用<code>action()</code>,这里是一个局部变量不需要再置空</p>
</li>
</ul>
<p>下面我们看一下<code>dispose()</code>是什么时候调用的</p>
<p>上面的流程，我们再序列的回调闭包：<code>subscriberHandle</code>里面，这个流程之前有一个重要的流程就是订阅<code>subscriber</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> disposed = onDisposed &#123;</span><br><span class="line">  disposable = <span class="type">Disposables</span>.create(with: disposed)  </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  disposable = <span class="type">Disposables</span>.create()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这里保存外界传入的销毁闭包</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> event &#123;</span><br><span class="line"><span class="keyword">case</span> .next(<span class="keyword">let</span> value):</span><br><span class="line">    onNext?(value)</span><br><span class="line"><span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">  <span class="comment">// 响应外界调回闭包</span></span><br><span class="line">    disposable.dispose()</span><br><span class="line"><span class="keyword">case</span> .completed:</span><br><span class="line">  <span class="comment">// 响应外界调回闭包</span></span><br><span class="line">    disposable.dispose()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>观察者回调里面调用， 响应外界调回闭包</p>
</li>
</ul>
<ul>
<li><code>return Disposables.create(self.asObservable().subscribe(observer),disposable)</code> 综合来看，我们的重点必然在这句代码，沟通下面流程的 <code>subscribe</code>, 外界订阅返回的销毁者（可以随时随地进行 <code>dispose.dispose()</code> ）</li>
<li>上面代码跟进去看到<code>BinaryDisposable(disposable1, disposable2)</code> 原来创建的二元销毁者！</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dispose</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> fetchOr(<span class="keyword">self</span>._isDisposed, <span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>._disposable1?.dispose()</span><br><span class="line">        <span class="keyword">self</span>._disposable2?.dispose()</span><br><span class="line">        <span class="keyword">self</span>._disposable1 = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>._disposable2 = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>二元销毁者的 <code>dispose</code> 方法也在预料之中，分别销毁</p>
</li>
<li><p>那么我们的重点就应该探索，在 <code>subscribe</code> 这里面创建的关键销毁者是什么?</p>
</li>
<li><p>下面我们进入非常熟悉的：<code>Producer</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> disposer = <span class="type">SinkDisposer</span>()</span><br><span class="line"><span class="keyword">let</span> sinkAndSubscription = <span class="keyword">self</span>.run(observer, cancel: disposer)</span><br><span class="line">disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink,</span><br><span class="line"> subscription: sinkAndSubscription.subscription)</span><br><span class="line"><span class="comment">// 返回销毁者</span></span><br><span class="line"><span class="keyword">return</span> disposer</span><br></pre></td></tr></table></figure>
</li>
<li><p>看到 <code>SinkDisposer</code> 就熟悉了，普通销毁者：<code>AnonymousDisposable</code> , 关键销毁者： <code>SinkDisposer</code></p>
</li>
<li><p>先看什么东西进入了 <code>SinkDisposer</code></p>
</li>
<li><p><code>self.run(observer, cancel: disposer)</code> 证明里面需要用到 <code>SinkDisposer</code></p>
</li>
<li><p><code>disposer.setSinkAndSubscription</code> 常规操作</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setSinkAndSubscription</span><span class="params">(sink: Disposable, subscription: Disposable)</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>._sink = sink</span><br><span class="line">    <span class="keyword">self</span>._subscription = subscription</span><br><span class="line"><span class="comment">// 获取状态 </span></span><br><span class="line">    <span class="keyword">let</span> previousState = fetchOr(<span class="keyword">self</span>._state, </span><br><span class="line"><span class="type">DisposeState</span>.sinkAndSubscriptionSet.rawValue)</span><br><span class="line"><span class="comment">// 如果状态满足就销毁</span></span><br><span class="line">    <span class="keyword">if</span> (previousState &amp; <span class="type">DisposeState</span>.disposed.rawValue) != <span class="number">0</span> &#123;</span><br><span class="line">        sink.dispose()</span><br><span class="line">        subscription.dispose()</span><br><span class="line">        <span class="keyword">self</span>._sink = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>._subscription = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>保存了两个属性 : <code>sink</code> 和 <code>subscription</code>(就是外界创建序列的闭包的返回销毁者)</p>
</li>
<li><p>取了某一个状态：<code>previousState</code>,判断状态的条件，然后执行 这两个保存属性的销毁和置空释放销毁 ： <code>.dispose() + = nil</code></p>
</li>
<li><p>其实是可以理解，就是我们在加入的东西其实需要销毁的，不应该保留的，那么没必要给它继续保留生命迹象</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 sink 保存了销毁者</span></span><br><span class="line"><span class="keyword">let</span> sink = <span class="type">AnonymousObservableSink</span>(observer: observer, cancel: cancel)</span><br><span class="line"><span class="comment">// 省略不相管代码。。。。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">on</span><span class="params">(<span class="number">_</span> event: Event&lt;Element&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> event &#123;</span><br><span class="line">    <span class="keyword">case</span> .next:</span><br><span class="line">        <span class="keyword">self</span>.forwardOn(event)</span><br><span class="line">    <span class="keyword">case</span> .error, .completed:</span><br><span class="line">        <span class="keyword">if</span> fetchOr(<span class="keyword">self</span>._isStopped, <span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.forwardOn(event)</span><br><span class="line">            <span class="comment">// 关键点：完成和错误信号的响应式必然会直接开启销毁的</span></span><br><span class="line">            <span class="keyword">self</span>.dispose()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>完成和错误信号的响应式必然会直接开启销毁的 ： <code>self.dispose()</code>! 这里也解释了：一旦我们的序列发出完成或者错误就无法再次响应了！</p>
</li>
<li><p>剩下一个问题： <strong>到底我们的销毁的是什么</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dispose</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> previousState = fetchOr(<span class="keyword">self</span>._state, <span class="type">DisposeState</span>.disposed.rawValue)</span><br><span class="line">    <span class="keyword">if</span> (previousState &amp; <span class="type">DisposeState</span>.sinkAndSubscriptionSet.rawValue) != <span class="number">0</span> &#123;</span><br><span class="line">        sink.dispose()</span><br><span class="line">        subscription.dispose()</span><br><span class="line">        <span class="keyword">self</span>._sink = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>._subscription = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>无论我们直接销毁还是系统帮助我们销毁必然会调用：<code>dispose()</code></p>
</li>
<li><p>我们查看 <code>dispose()</code> 得出: 就是在初始化初期我们保留的两个属性的操作</p>
</li>
<li><p><code>sink.dispose() + self._sink = nil</code> &amp; <code>subscription.dispose() + self._subscription = nil</code> 执行相关释放和销毁</p>
</li>
</ul>
<h4 id="总结一下销毁"><a href="#总结一下销毁" class="headerlink" title="总结一下销毁"></a>总结一下销毁</h4><p>第一：内部创建的临时序列和观察者都会随着对外的观察者和序列的生命周期而销毁释放。</p>
<p>第二：外界观察者和序列会随着他们的作用域空间而释放</p>
<p>第三：释放不了只是对象的释放有问题，常规内存管理问题</p>
<p>第四：最为一个再牛逼的框架也不能对程序员写的代码直接管理控制</p>
<p>第五：<code>RxSwift</code> 的观察和序列以及销毁者就是普通对象。</p>
<p>到这里RxSwift从创建序列-&gt;订阅序列-&gt;发送信号-&gt;销毁的源码解析就结束了，里面的精妙还是需要细细品味的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/28/GitHub-s-file-size-limit-of-100-00-MB%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/28/GitHub-s-file-size-limit-of-100-00-MB%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/" class="post-title-link" itemprop="url">GitHub's file size limit of 100.00 MB解决办法(转)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-28 14:42:48 / 修改时间：17:32:00" itemprop="dateCreated datePublished" datetime="2021-05-28T14:42:48+08:00">2021-05-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">遇到的问题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上传github发现不给上传100m以上文件的错误,按着提示进行了,用到一个叫lfs的工具专门用来上传大文件的！附<a href="https://github.com/git-lfs/git-lfs" target="_blank" rel="noopener">git-lfs</a> 1.安装 mac</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install git-lfs</span><br><span class="line">git lfs install</span><br></pre></td></tr></table></figure>

<p>找出超过100m的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 目标项目path</span><br><span class="line">find .&#x2F; -size +100M</span><br></pre></td></tr></table></figure>

<p>大文件加入git large file storage上面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git lfs track &quot;name_of_a_giant_file&quot;</span><br><span class="line">#example:</span><br><span class="line">git lfs track &quot;.&#x2F;&#x2F;huanxin&#x2F;HXTest&#x2F;Hyphenate.framework&#x2F;Hyphenate&quot;</span><br></pre></td></tr></table></figure>

<p>添加到git上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add path_of_a_giant_file</span><br><span class="line">#example:</span><br><span class="line">git add .&#x2F;&#x2F;huanxin&#x2F;HXTest&#x2F;Hyphenate.framework&#x2F;Hyphenate</span><br></pre></td></tr></table></figure>

<p>仅供记录以后遇到类似问题查找。</p>
<p><a href="https://juejin.cn/post/6844904205476478989" target="_blank" rel="noopener">原文地址</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/21/flutter%E6%8E%A2%E7%B4%A2-%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/21/flutter%E6%8E%A2%E7%B4%A2-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">flutter探索  - 多线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-21 10:36:00 / 修改时间：16:06:28" itemprop="dateCreated datePublished" datetime="2021-05-21T10:36:00+08:00">2021-05-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Flutter默认是单线程任务处理的，如果不开启新的线程，任务默认在主线程中处理。</p>
<h3 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a>事件队列</h3><p>和iOS应用很像，在<code>Dart</code>的线程中也存在事件循环和消息队列的概念，但在<code>Dart</code>中线程叫做<code>isolate</code>。应用程序启动后，开始执行<code>main</code>函数并运行<code>main isolate</code>。</p>
<p>每个<code>isolate</code>包含一个事件循环以及两个事件队列，<code>event loop</code>事件循环，以及<code>event queue</code>和<code>microtask queue</code>事件队列，<code>event</code>和<code>microtask</code>队列有点类似iOS的<code>source0</code>和<code>source1</code>。</p>
<ul>
<li>event queue：负责处理I/O事件、绘制事件、手势事件、接收其他<code>isolate</code>消息等外部事件。</li>
<li>microtask queue：可以自己向<code>isolate</code>内部添加事件，事件的优先级比<code>event queue</code>高。</li>
</ul>
<p>这两个队列也是有优先级的，当<code>isolate</code>开始执行后，会先处理<code>microtask</code>的事件，当<code>microtask</code>队列中没有事件后，才会处理<code>event</code>队列中的事件，并按照这个顺序反复执行。但需要注意的是，当执行<code>microtask</code>事件时，会阻塞<code>event</code>队列的事件执行，这样就会导致渲染、手势响应等<code>event</code>事件响应延时。为了保证渲染和手势响应，应该尽量将耗时操作放在<code>event</code>队列中。</p>
<h3 id="async、await"><a href="#async、await" class="headerlink" title="async、await"></a>async、await</h3><p>在异步调用中有三个关键词，<code>async</code>、<code>await</code>、<code>Future</code>，其中<code>async</code>和<code>await</code>需要一起使用。在<code>Dart</code>中可以通过<code>async</code>和<code>await</code>进行异步操作，<code>async</code>表示开启一个异步操作，也可以返回一个<code>Future</code>结果。如果没有返回值，则默认返回一个返回值为<code>null</code>的<code>Future</code>。</p>
<p><code>async</code>、<code>await</code>本质上就是<code>Dart</code>对异步操作的一个语法糖，可以减少异步调用的嵌套调用，并且由<code>async</code>修饰后返回一个<code>Future</code>，外界可以以链式调用的方式调用。这个语法是<code>JS</code>的<code>ES7</code>标准中推出的，<code>Dart</code>的设计和<code>JS</code>相同。</p>
<p>下面封装了一个网络请求的异步操作，并且将请求后的<code>Response</code>类型的<code>Future</code>返回给外界，外界可以通过<code>await</code>调用这个请求，并获取返回数据。从代码中可以看到，即便直接返回一个字符串，<code>Dart</code>也会对其进行包装并成为一个<code>Future</code>。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Response&gt; dataReqeust() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="built_in">String</span> requestURL = <span class="string">'https://jsonplaceholder.typicode.com/posts'</span>;</span><br><span class="line">    Client client = Client();</span><br><span class="line">    Future&lt;Response&gt; response = client.<span class="keyword">get</span>(requestURL);</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; loadData() <span class="keyword">async</span> &#123;</span><br><span class="line">    Response response = <span class="keyword">await</span> dataReqeust();</span><br><span class="line">    <span class="keyword">return</span> response.body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码示例中，执行到<code>loadData</code>方法时，会同步进入方法内部进行执行，当执行到<code>await</code>时就会停止<code>async</code>内部的执行，从而继续执行外面的代码。当<code>await</code>有返回后，会继续从<code>await</code>的位置继续执行。所以<code>await</code>的操作，不会影响后面代码的执行。</p>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p><code>Future</code>就是延时操作的一个封装，可以将异步任务封装为<code>Future</code>对象。获取到<code>Future</code>对象后，最简单的方法就是用<code>await</code>修饰，并等待返回结果继续向下执行。正如上面<code>async、await</code>中讲到的，使用<code>await</code>修饰时需要配合<code>async</code>一起使用。</p>
<p>在<code>Dart</code>中，和时间相关的操作基本都和<code>Future</code>有关，例如延时操作、异步操作等。下面是一个很简单的延时操作，通过<code>Future</code>的<code>delayed</code>方法实现。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">loadData() &#123;</span><br><span class="line">    <span class="comment">// DateTime.now()，获取当前时间</span></span><br><span class="line">    <span class="built_in">DateTime</span> now = <span class="built_in">DateTime</span>.now();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'request begin <span class="subst">$now</span>'</span>);</span><br><span class="line">    Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">1</span>), ()&#123;</span><br><span class="line">      now = <span class="built_in">DateTime</span>.now();</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'request response <span class="subst">$now</span>'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Dart</code>还支持对<code>Future</code>的链式调用，通过追加一个或多个<code>then</code>方法来实现，这个特性非常实用。例如一个延时操作完成后，会调用<code>then</code>方法，并且可以传递一个参数给<code>then</code>。调用方式是链式调用，也就代表可以进行很多层的处理。这有点类似于iOS的<code>RAC</code>框架，链式调用进行信号处理。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">1</span>), ()&#123;</span><br><span class="line">  <span class="built_in">int</span> age = <span class="number">18</span>;</span><br><span class="line">  <span class="keyword">return</span> age;</span><br><span class="line">&#125;).then((onValue)&#123;</span><br><span class="line">  onValue++;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'age <span class="subst">$onValue</span>'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>如果想要了解<code>async</code>、<code>await</code>的原理，就要先了解协程的概念，<code>async</code>、<code>await</code>本质上就是协程的一种语法糖。协程，也叫作<code>coroutine</code>，是一种比线程更小的单元。如果从单元大小来说，基本可以理解为进程-&gt;线程-&gt;协程。</p>
<h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>在弄懂协程之前，首先要明白并发和并行的概念，并发指的是由系统来管理多个IO的切换，并交由CPU去处理。并行指的是多核CPU在同一时间里执行多个任务。</p>
<p>并发的实现由非阻塞操作+事件通知来完成，事件通知也叫做“中断”。操作过程分为两种，一种是CPU对IO进行操作，在操作完成后发起中断告诉IO操作完成。另一种是IO发起中断，告诉CPU可以进行操作。</p>
<p>线程本质上也是依赖于中断来进行调度的，线程还有一种叫做“阻塞式中断”，就是在执行IO操作时将线程阻塞，等待执行完成后再继续执行。但线程的消耗是很大的，并不适合大量并发操作的处理，而通过单线程并发可以进行大量并发操作。当多核CPU出现后，单个线程就无法很好的利用多核CPU的优势了，所以又引入了线程池的概念，通过线程池来管理大量线程。</p>
<h3 id="协程-1"><a href="#协程-1" class="headerlink" title="协程"></a>协程</h3><p>在程序执行过程中，离开当前的调用位置有两种方式，继续调用其他函数和<code>return</code>返回离开当前函数。但是执行<code>return</code>时，当前函数在调用栈中的局部变量、形参等状态则会被销毁。</p>
<p>协程分为无线协程和有线协程，无线协程在离开当前调用位置时，会将当前变量放在堆区，当再次回到当前位置时，还会继续从堆区中获取到变量。所以，一般在执行当前函数时就会将变量直接分配到堆区，而<code>async</code>、<code>await</code>就属于无线协程的一种。有线协程则会将变量继续保存在栈区，在回到指针指向的离开位置时，会继续从栈中取出调用。</p>
<h3 id="async、await原理"><a href="#async、await原理" class="headerlink" title="async、await原理"></a>async、await原理</h3><p>以<code>async</code>、<code>await</code>为例，协程在执行时，执行到<code>async</code>则表示进入一个协程，会同步执行<code>async</code>的代码块。<code>async</code>的代码块本质上也相当于一个函数，并且有自己的上下文环境。当执行到<code>await</code>时，则表示有任务需要等待，CPU则去调度执行其他IO，也就是后面的代码或其他协程代码。过一段时间CPU就会轮训一次，看某个协程是否任务已经处理完成，有返回结果可以被继续执行，如果可以被继续执行的话，则会沿着上次离开时指针指向的位置继续执行，也就是<code>await</code>标志的位置。</p>
<p>由于并没有开启新的线程，只是进行IO中断改变CPU调度，所以网络请求这样的异步操作可以使用<code>async</code>、<code>await</code>，但如果是执行大量耗时同步操作的话，应该使用<code>isolate</code>开辟新的线程去执行。</p>
<p>如果用协程和iOS的<code>dispatch_async</code>进行对比，可以发现二者是比较相似的。从结构定义来看，协程需要将当前<code>await</code>的代码块相关的变量进行存储，<code>dispatch_async</code>也可以通过<code>block</code>来实现临时变量的存储能力。</p>
<p>我之前还在想一个问题，苹果为什么不引入协程的特性呢？后来想了一下，<code>await</code>和<code>dispatch_async</code>都可以简单理解为异步操作，OC的线程是基于<code>Runloop</code>实现的，<code>Dart</code>本质上也是有事件循环的，而且二者都有自己的事件队列，只是队列数量和分类不同。</p>
<p>我觉得当执行到<code>await</code>时，保存当前的上下文，并将当前位置标记为待处理任务，用一个指针指向当前位置，并将待处理任务放入当前<code>isolate</code>的队列中。在每个事件循环时都去询问这个任务，如果需要进行处理，就恢复上下文进行任务处理。</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>这里想提一下<code>JS</code>里的<code>Promise</code>语法，在iOS中会出现很多<code>if</code>判断或者其他的嵌套调用，而<code>Promise</code>可以把之前横向的嵌套调用，改成纵向链式调用。如果能把<code>Promise</code>引入到OC里，可以让代码看起来更简洁，直观。</p>
<h3 id="isolate"><a href="#isolate" class="headerlink" title="isolate"></a>isolate</h3><p><code>isolate</code>是<code>Dart</code>平台对线程的实现方案，但和普通<code>Thread</code>不同的是，<code>isolate</code>拥有独立的内存，<code>isolate</code>由线程和独立内存构成。正是由于<code>isolate</code>线程之间的内存不共享，所以<code>isolate</code>线程之间并不存在资源抢夺的问题，所以也不需要锁。</p>
<p>通过<code>isolate</code>可以很好的利用多核CPU，来进行大量耗时任务的处理。<code>isolate</code>线程之间的通信主要通过<code>port</code>来进行，这个<code>port</code>消息传递的过程是异步的。通过<code>Dart</code>源码也可以看出，实例化一个<code>isolate</code>的过程包括，实例化<code>isolate</code>结构体、在堆中分配线程内存、配置<code>port</code>等过程。</p>
<p><code>isolate</code>看起来其实和进程比较相似，之前请教阿里架构师宗心问题时，宗心也说过“<code>isolate</code>的整体模型我自己的理解其实更像进程，而<code>async</code>、<code>await</code>更像是线程”。如果对比一下<code>isolate</code>和进程的定义，会发现确实<code>isolate</code>很像是进程。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>下面是一个<code>isolate</code>的例子，例子中新创建了一个<code>isolate</code>，并且绑定了一个方法进行网络请求和数据解析的处理，并通过<code>port</code>将处理好的数据返回给调用方。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">loadData() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// 通过spawn新建一个isolate，并绑定静态方法</span></span><br><span class="line">    ReceivePort receivePort =ReceivePort();</span><br><span class="line">    <span class="keyword">await</span> Isolate.spawn(dataLoader, receivePort.sendPort);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取新isolate的监听port</span></span><br><span class="line">    SendPort sendPort = <span class="keyword">await</span> receivePort.first;</span><br><span class="line">    <span class="comment">// 调用sendReceive自定义方法</span></span><br><span class="line">    <span class="built_in">List</span> dataList = <span class="keyword">await</span> sendReceive(sendPort, <span class="string">'https://jsonplaceholder.typicode.com/posts'</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'dataList <span class="subst">$dataList</span>'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// isolate的绑定方法</span></span><br><span class="line"><span class="keyword">static</span> dataLoader(SendPort sendPort) <span class="keyword">async</span>&#123;</span><br><span class="line">    <span class="comment">// 创建监听port，并将sendPort传给外界用来调用</span></span><br><span class="line">    ReceivePort receivePort =ReceivePort();</span><br><span class="line">    sendPort.send(receivePort.sendPort);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 监听外界调用</span></span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> msg <span class="keyword">in</span> receivePort) &#123;</span><br><span class="line">      <span class="built_in">String</span> requestURL =msg[<span class="number">0</span>];</span><br><span class="line">      SendPort callbackPort =msg[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">      Client client = Client();</span><br><span class="line">      Response response = <span class="keyword">await</span> client.<span class="keyword">get</span>(requestURL);</span><br><span class="line">      <span class="built_in">List</span> dataList = json.decode(response.body);</span><br><span class="line">      <span class="comment">// 回调返回值给调用者</span></span><br><span class="line">      callbackPort.send(dataList);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建自己的监听port，并且向新isolate发送消息</span></span><br><span class="line">Future sendReceive(SendPort sendPort, <span class="built_in">String</span> url) &#123;</span><br><span class="line">    ReceivePort receivePort =ReceivePort();</span><br><span class="line">    sendPort.send([url, receivePort.sendPort]);</span><br><span class="line">    <span class="comment">// 接收到返回值，返回给调用者</span></span><br><span class="line">    <span class="keyword">return</span> receivePort.first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>isolate</code>和iOS中的线程还不太一样，<code>isolate</code>的线程更偏底层。当生成一个<code>isolate</code>后，其内存是各自独立的，相互之间并不能进行访问。但<code>isolate</code>提供了基于<code>port</code>的消息机制，通过建立通信双方的<code>sendPort</code>和<code>receiveport</code>，进行相互的消息传递，在<code>Dart</code>中叫做消息传递。</p>
<p>从上面例子中可以看出，在进行<code>isolate</code>消息传递的过程中，本质上就是进行<code>port</code>的传递。将<code>port</code>传递给其他<code>isolate</code>，其他<code>isolate</code>通过<code>port</code>拿到<code>sendPort</code>，向调用方发送消息来进行相互的消息传递。</p>
<h3 id="Embedder"><a href="#Embedder" class="headerlink" title="Embedder"></a>Embedder</h3><p>正如其名，<code>Embedder</code>是一个嵌入层，将<code>Flutter</code>嵌入到各个平台上。<code>Embedder</code>负责范围包括原生平台插件、线程管理、事件循环等。</p>
<p><code>Embedder</code>中存在四个<code>Runner</code>，四个<code>Runner</code>分别如下。其中每个<code>Flutter Engine</code>各自对应一个<code>UI Runner</code>、<code>GPU Runner</code>、<code>IO Runner</code>，但所有<code>Engine</code>共享一个<code>Platform Runner</code>。</p>
<p><code>Runner</code>和<code>isolate</code>并不是一码事，彼此相互独立。以iOS平台为例，<code>Runner</code>的实现就是<code>CFRunLoop</code>，以一个事件循环的方式不断处理任务。并且<code>Runner</code>不只处理<code>Engine</code>的任务，还有<code>Native Plugin</code>带来的原生平台的任务。而<code>isolate</code>则由<code>Dart VM</code>进行管理，和原生平台线程并无关系。</p>
<h3 id="Platform-Runner"><a href="#Platform-Runner" class="headerlink" title="Platform Runner"></a>Platform Runner</h3><p><code>Platform Runner</code>和iOS平台的<code>Main Thread</code>非常相似，在<code>Flutter</code>中除耗时操作外，所有任务都应该放在<code>Platform</code>中，<code>Flutter</code>中的很多API并不是线程安全的，放在其他线程中可能会导致一些bug。</p>
<p>但例如IO之类的耗时操作，应该放在其他线程中完成，否则会影响<code>Platform</code>的正常执行，甚至于被<code>watchdog</code>干掉。但需要注意的是，由于<code>Embedder Runner</code>的机制，<code>Platform</code>被阻塞后并不会导致页面卡顿。</p>
<p>不只是<code>Flutter Engine</code>的代码在<code>Platform</code>中执行，<code>Native Plugin</code>的任务也会派发到<code>Platform</code>中执行。实际上，在原生侧的代码运行在<code>Platform Runner</code>中，而<code>Flutter</code>侧的代码运行在<code>Root Isolate</code>中，如果在<code>Platform</code>中执行耗时代码，则会卡原生平台的主线程。 </p>
<h3 id="UI-Runner"><a href="#UI-Runner" class="headerlink" title="UI Runner"></a>UI Runner</h3><p><code>UI Runner</code>负责为<code>Flutter Engine</code>执行<code>Root Isolate</code>的代码，除此之外，也处理来自<code>Native Plugin</code>的任务。<code>Root Isolate</code>为了处理自身事件，绑定了很多函数方法。程序启动时，<code>Flutter Engine</code>会为<code>Root</code>绑定<code>UI Runner</code>的处理函数，使<code>Root Isolate</code>具备提交渲染帧的能力。</p>
<p>当<code>Root Isolate</code>向<code>Engine</code>提交一次渲染帧时，<code>Engine</code>会等待下次vsync，当下次vsync到来时，由<code>Root Isolate</code>对<code>Widgets</code>进行布局操作，并生成页面的显示信息的描述，并将信息交给<code>Engine</code>去处理。</p>
<p>由于对<code>widgets</code>进行<code>layout</code>并生成<code>layer tree</code>是<code>UI Runner</code>进行的，如果在<code>UI Runner</code>中进行大量耗时处理，会影响页面的显示，所以应该将耗时操作交给其他<code>isolate</code>处理，例如来自<code>Native Plugin</code>的事件。</p>
<h3 id="GPU-Runner"><a href="#GPU-Runner" class="headerlink" title="GPU Runner"></a>GPU Runner</h3><p><code>GPU Runner</code>并不直接负责渲染操作，其负责GPU相关的管理和调度。当<code>layer tree</code>信息到来时，<code>GPU Runner</code>将其提交给指定的渲染平台，渲染平台是Skia配置的，不同平台可能有不同的实现。</p>
<p><code>GPU Runner</code>相对比较独立，除了<code>Embedder</code>外其他线程均不可向其提交渲染信息。</p>
<h3 id="IO-Runner"><a href="#IO-Runner" class="headerlink" title="IO Runner"></a>IO Runner</h3><p>一些<code>GPU Runner</code>中比较耗时的操作，就放在<code>IO Runner</code>中进行处理，例如图片读取、解压、渲染等操作。但是只有<code>GPU Runner</code>才能对GPU提交渲染信息，为了保证<code>IO Runner</code>也具备这个能力，所以<code>IO Runner</code>会引用<code>GPU Runner</code>的<code>context</code>，这样就具备向GPU提交渲染信息的能力</p>
<p><a href="https://www.jianshu.com/p/54da18ed1a9e" target="_blank" rel="noopener">本文地址</a></p>
<p><a href="https://www.jianshu.com/p/aaa6a8b1d6b0" target="_blank" rel="noopener">闲鱼讲解</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/20/flutter%E6%8E%A2%E7%B4%A2-Provider%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/20/flutter%E6%8E%A2%E7%B4%A2-Provider%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">flutter探索  - Provider源码解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-20 10:00:34" itemprop="dateCreated datePublished" datetime="2021-05-20T10:00:34+08:00">2021-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-01 21:29:37" itemprop="dateModified" datetime="2021-08-01T21:29:37+08:00">2021-08-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一篇中我们列举了几种状态管理，我们已经知道Provider是对InheritedWidget的包装，只是让InheritedWidget用起来更加简单且高可复用。我们上一篇也提到过InheritedWidget的缺点。</p>
<p>我们这篇主要带着问题，看Provider是如果规避InheritedWidget的缺点，而且Provider提供了dispose回调，你可以在该函数中主动关闭，如何做到的呢。带着这些问题，我们寻找答案。</p>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>我们先看怎么使用provider。</p>
<h4 id="1、定义一个ChangeNotifier"><a href="#1、定义一个ChangeNotifier" class="headerlink" title="1、定义一个ChangeNotifier"></a>1、定义一个ChangeNotifier</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="title">with</span> <span class="title">ChangeNotifier</span>, <span class="title">DiagnosticableTreeMixin</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _count = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> count =&gt; _count;</span><br><span class="line">  <span class="keyword">void</span> increment() &#123;</span><br><span class="line">    _count++;</span><br><span class="line">    notifyListeners();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Makes <span class="code">`Counter`</span> readable inside the devtools by listing all of its properties</span></span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> debugFillProperties(DiagnosticPropertiesBuilder properties) &#123;</span><br><span class="line">    <span class="keyword">super</span>.debugFillProperties(properties);</span><br><span class="line">    properties.add(IntProperty(<span class="string">'count'</span>, count));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、用ChangeNotifierProvider来订阅Counter"><a href="#2、用ChangeNotifierProvider来订阅Counter" class="headerlink" title="2、用ChangeNotifierProvider来订阅Counter"></a>2、用ChangeNotifierProvider来订阅Counter</h4><p>不难猜出，ChangeNotifierProvider肯定是InheritedWidget的包装类，负责将Counter的状态共享给子Widget。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(</span><br><span class="line">    <span class="comment">/// <span class="markdown">Providers are above [MyApp] instead of inside it, so that tests</span></span></span><br><span class="line">    <span class="comment">/// <span class="markdown">can use [MyApp] while mocking the providers</span></span></span><br><span class="line">    MultiProvider(</span><br><span class="line">      providers: [</span><br><span class="line">        ChangeNotifierProvider(create: (_) =&gt; Counter()),</span><br><span class="line">      ],</span><br><span class="line">      child: <span class="keyword">const</span> MyApp(),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、接收数据通过Consumer&lt;Counter&gt;</p>
<p>Consumer是个消费者，它负责消费ChangeNotifierProvider生产的数据。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> MyApp(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const</span> MaterialApp(</span><br><span class="line">      home: MyHomePage(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> MyHomePage(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: <span class="keyword">const</span> Text(<span class="string">'Example'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisSize: MainAxisSize.min,</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: <span class="keyword">const</span> &lt;Widget&gt;[</span><br><span class="line">            Text(<span class="string">'You have pushed the button this many times:'</span>),</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// <span class="markdown">Extracted as a separate widget for performance optimization.</span></span></span><br><span class="line">            <span class="comment">/// <span class="markdown">As a separate widget, it will rebuild independently from [MyHomePage].</span></span></span><br><span class="line">            <span class="comment">///</span></span><br><span class="line">            <span class="comment">/// <span class="markdown">This is totally optional (and rarely needed).</span></span></span><br><span class="line">            <span class="comment">/// <span class="markdown">Similarly, we could also use [Consumer] or [Selector].</span></span></span><br><span class="line">            Consume&lt;Counter&gt;(</span><br><span class="line">            	builder:(BuildContext context,Counter value,Widget child)&#123;</span><br><span class="line">                <span class="keyword">return</span> Text(<span class="string">'<span class="subst">$&#123;value.count&#125;</span>'</span>)</span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">            Count(),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        key: <span class="keyword">const</span> Key(<span class="string">'increment_floatingActionButton'</span>),</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// <span class="markdown">Calls <span class="code">`context.read`</span> instead of <span class="code">`context.watch`</span> so that it does not rebuild</span></span></span><br><span class="line">        <span class="comment">/// <span class="markdown">when [Counter] changes.</span></span></span><br><span class="line">        onPressed: () =&gt; context.read&lt;Counter&gt;().increment(),</span><br><span class="line">        tooltip: <span class="string">'Increment'</span>,</span><br><span class="line">        child: <span class="keyword">const</span> Icon(Icons.add),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Count(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Text(</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// <span class="markdown">Calls <span class="code">`context.watch`</span> to make [Count] rebuild when [Counter] changes.</span></span></span><br><span class="line">        <span class="string">'<span class="subst">$&#123;context.watch&lt;Counter&gt;().count&#125;</span>'</span>,</span><br><span class="line">        key: <span class="keyword">const</span> Key(<span class="string">'counterState'</span>),</span><br><span class="line">        style: Theme.of(context).textTheme.headline4);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过看Provider的用法例子，可以判断出Provider的封装足够易用，而且Counter作为Model层使用with ChangeNotifier而不是继承，所以说它的侵入性也比较低。下面我们看InheritedWidget的缺点看是否已经规避</p>
<h5 id="1、-容易造成不必要的刷新（看是否已经解决）"><a href="#1、-容易造成不必要的刷新（看是否已经解决）" class="headerlink" title="1、 容易造成不必要的刷新（看是否已经解决）"></a>1、 容易造成不必要的刷新（看是否已经解决）</h5><p>我们家两个子Widget进去，排在Consumer的后面，OtherWidget什么都不干，不去订阅Counter，OtherWidget2通过contex.watch&lt;Counter&gt;().count函数监听而不是Consumer，来看一下效果一样不，然后在build函数中都加入<code>print</code></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OtherWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'OtherWidget build'</span>);</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">return</span> Text(<span class="string">'OtherWidget'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OtherWidget2</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'OtherWidget2 build'</span>);</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">return</span> Text(<span class="string">'OtherWidget2 <span class="subst">$&#123;context.watch&lt;Counter&gt;().count&#125;</span>'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出几个结论</p>
<ul>
<li>Consumer、context.watch都可以监听Counter变化</li>
<li>Consumer只会刷新自己</li>
<li>context.watch所在的子widget不管是否是const都会被重建后刷新数据</li>
<li>OtherWidget并没有被重建，因为它没有订阅Counter</li>
</ul>
<p>局部刷新确实实现了通过Consumer，第二个问题不支持跨页面router的状态，这个不支持，第三个问题数据是不可变的（只读），经过这个例子可以分辨出数据确实是可变的，如何变化的我们分析源码找本质。</p>
<p>ChangeNotifier和ChangeNotifierProvider是被观察者和观察者的关系。ChangeNotifierProvider和Cosumer是生产者和消费者的关系。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="ChangeNotifier"><a href="#ChangeNotifier" class="headerlink" title="ChangeNotifier"></a>ChangeNotifier</h4><p>在包package:meta/meta.dart下，是flutter sdk的代码，并不属于Provider框架的一部分。通过查看代码可以看出，这是一个标准的观察者模型，而真正的监听者就是typedef VoidCallback = void Function();是dart.ui包下定义的一个函数，没有任何返回参数的函数。ChangeNotifer实现抽象类Listenable，通过源码注释我们看到Listenable是一个转么负责维护监听列表的一个抽象类。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ListenerEntry</span> <span class="keyword">extends</span> <span class="title">LinkedListEntry</span>&lt;<span class="title">_ListenerEntry</span>&gt; </span>&#123;</span><br><span class="line">  _ListenerEntry(<span class="keyword">this</span>.listener);</span><br><span class="line">  <span class="keyword">final</span> VoidCallback listener;<span class="comment">//真正的监听者</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// <span class="markdown">A class that can be extended or mixed in that provides a change notification</span></span></span><br><span class="line"><span class="comment">/// <span class="markdown">API using [VoidCallback] for notifications.</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="markdown">It is O(1) for adding listeners and O(N) for removing listeners and dispatching</span></span></span><br><span class="line"><span class="comment">/// <span class="markdown">notifications (where N is the number of listeners).</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="markdown">See also:</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///  <span class="markdown"><span class="bullet">* </span>[ValueNotifier], which is a [ChangeNotifier] that wraps a single value.</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangeNotifier</span> <span class="keyword">implements</span> <span class="title">Listenable</span> </span>&#123;</span><br><span class="line">  LinkedList&lt;_ListenerEntry&gt;? _listeners = LinkedList&lt;_ListenerEntry&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> _debugAssertNotDisposed() &#123;</span><br><span class="line">    <span class="keyword">assert</span>(() &#123;</span><br><span class="line">      <span class="keyword">if</span> (_listeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> FlutterError(</span><br><span class="line">          <span class="string">'A <span class="subst">$runtimeType</span> was used after being disposed.\n'</span></span><br><span class="line">          <span class="string">'Once you have called dispose() on a <span class="subst">$runtimeType</span>, it can no longer be used.'</span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Whether any listeners are currently registered.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">Clients should not depend on this value for their behavior, because having</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">one listener's logic change when another listener happens to start or stop</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">listening will lead to extremely hard-to-track bugs. Subclasses might use</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">this information to determine whether to do any work when there are no</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">listeners, however; for example, resuming a [Stream] when a listener is</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">added and pausing it when a listener is removed.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">Typically this is used by overriding [addListener], checking if</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">[hasListeners] is false before calling <span class="code">`super.addListener()`</span>, and if so,</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">starting whatever work is needed to determine when to call</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">[notifyListeners]; and similarly, by overriding [removeListener], checking</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">if [hasListeners] is false after calling <span class="code">`super.removeListener()`</span>, and if</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">so, stopping that same work.</span></span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> hasListeners &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_debugAssertNotDisposed());</span><br><span class="line">    <span class="keyword">return</span> _listeners!.isNotEmpty;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Register a closure to be called when the object changes.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">This method must not be called after [dispose] has been called.</span></span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> addListener(VoidCallback listener) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_debugAssertNotDisposed());</span><br><span class="line">    _listeners!.add(_ListenerEntry(listener));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Remove a previously registered closure from the list of closures that are</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">notified when the object changes.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">If the given listener is not registered, the call is ignored.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">This method must not be called after [dispose] has been called.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">If a listener had been added twice, and is removed once during an</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">iteration (i.e. in response to a notification), it will still be called</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">again. If, on the other hand, it is removed as many times as it was</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">registered, then it will no longer be called. This odd behavior is the</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">result of the [ChangeNotifier] not being able to determine which listener</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">is being removed, since they are identical, and therefore conservatively</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">still calling all the listeners when it knows that any are still</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">registered.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">This surprising behavior can be unexpectedly observed when registering a</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">listener on two separate objects which are both forwarding all</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">registrations to a common upstream object.</span></span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> removeListener(VoidCallback listener) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_debugAssertNotDisposed());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> _ListenerEntry entry <span class="keyword">in</span> _listeners!) &#123;</span><br><span class="line">      <span class="keyword">if</span> (entry.listener == listener) &#123;</span><br><span class="line">        entry.unlink();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Discards any resources used by the object. After this is called, the</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">object is not in a usable state and should be discarded (calls to</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">[addListener] and [removeListener] will throw after the object is</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">disposed).</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">This method should only be called by the object's owner.</span></span></span><br><span class="line">  <span class="meta">@mustCallSuper</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_debugAssertNotDisposed());</span><br><span class="line">    _listeners = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Call all the registered listeners.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">Call this method whenever the object changes, to notify any clients the</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">object may have changed. Listeners that are added during this iteration</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">will not be visited. Listeners that are removed during this iteration will</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">not be visited after they are removed.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">Exceptions thrown by listeners will be caught and reported using</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">[FlutterError.reportError].</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">This method must not be called after [dispose] has been called.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">Surprising behavior can result when reentrantly removing a listener (i.e.</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">in response to a notification) that has been registered multiple times.</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">See the discussion at [removeListener].</span></span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="meta">@visibleForTesting</span></span><br><span class="line">  <span class="keyword">void</span> notifyListeners() &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_debugAssertNotDisposed());</span><br><span class="line">    <span class="keyword">if</span> (_listeners!.isEmpty)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">List</span>&lt;_ListenerEntry&gt; localListeners = <span class="built_in">List</span>&lt;_ListenerEntry&gt;.from(_listeners!);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> _ListenerEntry entry <span class="keyword">in</span> localListeners) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.list != <span class="keyword">null</span>)</span><br><span class="line">          entry.listener();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (exception, stack) &#123;</span><br><span class="line">        FlutterError.reportError(FlutterErrorDetails(</span><br><span class="line">          exception: exception,</span><br><span class="line">          stack: stack,</span><br><span class="line">          <span class="keyword">library</span>: <span class="string">'foundation library'</span>,</span><br><span class="line">          context: ErrorDescription(<span class="string">'while dispatching notifications for <span class="subst">$runtimeType</span>'</span>),</span><br><span class="line">          informationCollector: () <span class="keyword">sync</span>* &#123;</span><br><span class="line">            <span class="keyword">yield</span> DiagnosticsProperty&lt;ChangeNotifier&gt;(</span><br><span class="line">              <span class="string">'The <span class="subst">$runtimeType</span> sending notification was'</span>,</span><br><span class="line">              <span class="keyword">this</span>,</span><br><span class="line">              style: DiagnosticsTreeStyle.errorProperty,</span><br><span class="line">            );</span><br><span class="line">          &#125;,</span><br><span class="line">        ));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ChangeNotifierProvider"><a href="#ChangeNotifierProvider" class="headerlink" title="ChangeNotifierProvider"></a>ChangeNotifierProvider</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangeNotifierProvider</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">ChangeNotifier</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">ListenableProvider</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Creates a [ChangeNotifier] using <span class="code">`create`</span> and automatically</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">dispose it when [ChangeNotifierProvider] is removed from the widget tree.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown"><span class="code">`create`</span> must not be <span class="code">`null`</span>.</span></span></span><br><span class="line">  ChangeNotifierProvider(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> Create&lt;T&gt; create,</span><br><span class="line">    <span class="built_in">bool</span> lazy,</span><br><span class="line">    TransitionBuilder builder,</span><br><span class="line">    Widget child,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(</span><br><span class="line">          key: key,</span><br><span class="line">          create: create,</span><br><span class="line">          dispose: _dispose,</span><br><span class="line">          lazy: lazy,</span><br><span class="line">          builder: builder,</span><br><span class="line">          child: child,</span><br><span class="line">        );</span><br><span class="line">  <span class="comment">/// <span class="markdown">Provides an existing [ChangeNotifier].</span></span></span><br><span class="line">  ChangeNotifierProvider.value(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> T value,</span><br><span class="line">    TransitionBuilder builder,</span><br><span class="line">    Widget child,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>.value(</span><br><span class="line">          key: key,</span><br><span class="line">          builder: builder,</span><br><span class="line">          value: value,</span><br><span class="line">          child: child,</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> _dispose(BuildContext context, ChangeNotifier notifier) &#123;</span><br><span class="line">    notifier?.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析一下构造</p>
<ul>
<li><p>Create&lt;T&gt; create</p>
<p>是个通用函数typedef Create&lt;T&gt; = T Function(BuildContext context)用于创建T类，这里负责创建ChangeNotifier</p>
</li>
<li><p>bool lazy</p>
<p>是否是懒加载</p>
</li>
<li><p>TransitionBuilder builder</p>
<p>当builder存在时将不会用child作为子widget，追溯源码实现，根据继承关系找到InheritedProvider：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget buildWithChild(BuildContext context, Widget child) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(</span><br><span class="line">    builder != <span class="keyword">null</span> || child != <span class="keyword">null</span>,</span><br><span class="line">    <span class="string">'<span class="subst">$runtimeType</span> used outside of MultiProvider must specify a child'</span>,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> _InheritedProviderScope&lt;T&gt;(</span><br><span class="line">    owner: <span class="keyword">this</span>,</span><br><span class="line">    child: builder != <span class="keyword">null</span></span><br><span class="line">        ? Builder(</span><br><span class="line">            builder: (context) =&gt; builder(context, child),</span><br><span class="line">          )</span><br><span class="line">        : child,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Widget child</p>
<p>builder不存在时就用child。</p>
</li>
</ul>
<p>ChangeNotifierProvider继承 ListenableProvider,我们我们继续看ListenableProvider：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListenableProvider</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Listenable</span>&gt; <span class="keyword">extends</span> <span class="title">InheritedProvider</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Creates a [Listenable] using [create] and subscribes to it.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">[dispose] can optionally passed to free resources</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">when [ListenableProvider] is removed from the tree.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">[create] must not be <span class="code">`null`</span>.</span></span></span><br><span class="line">  ListenableProvider(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> Create&lt;T&gt; create,</span><br><span class="line">    Dispose&lt;T&gt; dispose,</span><br><span class="line">    <span class="built_in">bool</span> lazy,</span><br><span class="line">    TransitionBuilder builder,</span><br><span class="line">    Widget child,</span><br><span class="line">  &#125;)  : <span class="keyword">assert</span>(create != <span class="keyword">null</span>),</span><br><span class="line">        <span class="keyword">super</span>(</span><br><span class="line">          key: key,</span><br><span class="line">          startListening: _startListening,</span><br><span class="line">          create: create,</span><br><span class="line">          dispose: dispose,</span><br><span class="line">          lazy: lazy,</span><br><span class="line">          builder: builder,</span><br><span class="line">          child: child,</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Provides an existing [Listenable].</span></span></span><br><span class="line">  ListenableProvider.value(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> T value,</span><br><span class="line">    UpdateShouldNotify&lt;T&gt; updateShouldNotify,</span><br><span class="line">    TransitionBuilder builder,</span><br><span class="line">    Widget child,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>.value(</span><br><span class="line">          key: key,</span><br><span class="line">          builder: builder,</span><br><span class="line">          value: value,</span><br><span class="line">          updateShouldNotify: updateShouldNotify,</span><br><span class="line">          startListening: _startListening,</span><br><span class="line">          child: child,</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> VoidCallback _startListening(</span><br><span class="line">    InheritedContext&lt;Listenable&gt; e,</span><br><span class="line">    Listenable value,</span><br><span class="line">  ) &#123;</span><br><span class="line">    value?.addListener(e.markNeedsNotifyDependents);</span><br><span class="line">    <span class="keyword">return</span> () =&gt; value?.removeListener(e.markNeedsNotifyDependents);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Listenable上面已经分析，它是负责管理观察者列表的抽象</li>
<li>它比子类ChangeNotifierProvider多了一个构造函数dispose，这个函数是 typedef Dispose&lt;T&gt; = void Function(BuildContext context, T value);是个回调，应该是当页面被销毁时出发（需要继续探究源码，目前只是猜测）。</li>
</ul>
<p>因为ListenableProvider是继承自InheritedProvider，我们继续看InheritedProvider的实现：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">A generic implementation of an [InheritedWidget].</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="markdown">Any descendant of this widget can obtain <span class="code">`value`</span> using [Provider.of].</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="markdown">Do not use this class directly unless you are creating a custom "Provider".</span></span></span><br><span class="line"><span class="comment">/// <span class="markdown">Instead use [Provider] class, which wraps [InheritedProvider].</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="markdown">See also:</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///  <span class="markdown"><span class="bullet">- </span>[DeferredInheritedProvider], a variant of this object where the provided</span></span></span><br><span class="line"><span class="comment">///    <span class="markdown">object and the created object are two different entity.</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InheritedProvider</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SingleChildStatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Creates a value, then expose it to its descendants.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">The value will be disposed of when [InheritedProvider] is removed from</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">the widget tree.</span></span></span><br><span class="line">  InheritedProvider(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    Create&lt;T&gt; create,</span><br><span class="line">    T <span class="built_in">Function</span>(BuildContext context, T value) update,</span><br><span class="line">    UpdateShouldNotify&lt;T&gt; updateShouldNotify,</span><br><span class="line">    <span class="keyword">void</span> <span class="built_in">Function</span>(T value) debugCheckInvalidValueType,</span><br><span class="line">    StartListening&lt;T&gt; startListening,</span><br><span class="line">    Dispose&lt;T&gt; dispose,</span><br><span class="line">    <span class="keyword">this</span>.builder,</span><br><span class="line">    <span class="built_in">bool</span> lazy,</span><br><span class="line">    Widget child,</span><br><span class="line">  &#125;)  : _lazy = lazy,</span><br><span class="line">        _delegate = _CreateInheritedProvider(</span><br><span class="line">          create: create,</span><br><span class="line">          update: update,</span><br><span class="line">          updateShouldNotify: updateShouldNotify,</span><br><span class="line">          debugCheckInvalidValueType: debugCheckInvalidValueType,</span><br><span class="line">          startListening: startListening,</span><br><span class="line">          dispose: dispose,</span><br><span class="line">        ),</span><br><span class="line">        <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Expose to its descendants an existing value,</span></span></span><br><span class="line">  InheritedProvider.value(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> T value,</span><br><span class="line">    UpdateShouldNotify&lt;T&gt; updateShouldNotify,</span><br><span class="line">    StartListening&lt;T&gt; startListening,</span><br><span class="line">    <span class="built_in">bool</span> lazy,</span><br><span class="line">    <span class="keyword">this</span>.builder,</span><br><span class="line">    Widget child,</span><br><span class="line">  &#125;)  : _lazy = lazy,</span><br><span class="line">        _delegate = _ValueInheritedProvider(</span><br><span class="line">          value: value,</span><br><span class="line">          updateShouldNotify: updateShouldNotify,</span><br><span class="line">          startListening: startListening,</span><br><span class="line">        ),</span><br><span class="line">        <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  InheritedProvider._constructor(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    _Delegate&lt;T&gt; delegate,</span><br><span class="line">    <span class="built_in">bool</span> lazy,</span><br><span class="line">    <span class="keyword">this</span>.builder,</span><br><span class="line">    Widget child,</span><br><span class="line">  &#125;)  : _lazy = lazy,</span><br><span class="line">        _delegate = delegate,</span><br><span class="line">        <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> _Delegate&lt;T&gt; _delegate;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> _lazy;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Syntax sugar for obtaining a [BuildContext] that can read the provider</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">created.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">This code:</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown"><span class="code">```dart</span></span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">Provider<span class="xml"><span class="tag">&lt;<span class="name">int</span>&gt;</span></span>(</span></span></span><br><span class="line">  <span class="comment">///   <span class="markdown">create: (context) =&gt; 42,</span></span></span><br><span class="line">  <span class="comment">///   <span class="markdown">builder: (context, child) &#123;</span></span></span><br><span class="line">  <span class="comment">///     <span class="markdown">final value = context.watch<span class="xml"><span class="tag">&lt;<span class="name">int</span>&gt;</span></span>();</span></span></span><br><span class="line">  <span class="comment">///     <span class="markdown">return Text('$value');</span></span></span><br><span class="line">  <span class="comment">///   <span class="markdown">&#125;</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">)</span></span></span><br><span class="line">  <span class="comment">///</span></span><br></pre></td></tr></table></figure>
<p>  ///<br>  /// is strictly equivalent to:<br>  ///<br>  /// <code>dart
  /// Provider&lt;int&gt;(
  ///   create: (context) =&gt; 42,
  ///   child: Builder(
  ///     builder: (context) {
  ///       final value = context.watch&lt;int&gt;();
  ///       return Text(&#39;$value&#39;);
  ///     },
  ///   ),
  /// )
  ///</code><br>  ///<br>  /// For an explanation on the <code>child</code> parameter that <code>builder</code> receives,<br>  /// see the “Performance optimizations” section of [AnimatedBuilder].<br>  final TransitionBuilder builder;</p>
<p>  @override<br>  void debugFillProperties(DiagnosticPropertiesBuilder properties) {<br>    super.debugFillProperties(properties);<br>    _delegate.debugFillProperties(properties);<br>  }</p>
<p>  @override<br>  _InheritedProviderElement<T> createElement() {<br>    return _InheritedProviderElement<T>(this);<br>  }</p>
<p>  @override<br>  Widget buildWithChild(BuildContext context, Widget child) {<br>    assert(<br>      builder != null || child != null,<br>      ‘$runtimeType used outside of MultiProvider must specify a child’,<br>    );<br>    return _InheritedProviderScope<T>(<br>      owner: this,<br>      child: builder != null<br>          ? Builder(<br>              builder: (context) =&gt; builder(context, child),<br>            )<br>          : child,<br>    );<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">构造函数中多出来的参数：</span><br><span class="line"></span><br><span class="line">*  T Function(BuildContext context, T value) update，该函数返回数据变更值value，具体实现在\_CreateInheritedProvider类中，说白了InheritedProvider\&lt;T&gt;是无状态的，他要变更的话依赖于\_CreateInheritedProvider类，\_CreateInheritedProvider是\_Delegate的实现类，\_Delegate是一个状态代理类，来看一下\_Delegate的实现</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;dart</span><br><span class="line">  @immutable</span><br><span class="line">  abstract class _Delegate&lt;T&gt; &#123;</span><br><span class="line">    _DelegateState&lt;T, _Delegate&lt;T&gt;&gt; createState();</span><br><span class="line">  </span><br><span class="line">    void debugFillProperties(DiagnosticPropertiesBuilder properties) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  abstract class _DelegateState&lt;T, D extends _Delegate&lt;T&gt;&gt; &#123;</span><br><span class="line">    _InheritedProviderScopeElement&lt;T&gt; element;</span><br><span class="line">  </span><br><span class="line">    T get value;</span><br><span class="line">  </span><br><span class="line">    D get delegate &#x3D;&gt; element.widget.owner._delegate as D;</span><br><span class="line">  </span><br><span class="line">    bool get hasValue;</span><br><span class="line">  </span><br><span class="line">    bool debugSetInheritedLock(bool value) &#123;</span><br><span class="line">      return element._debugSetInheritedLock(value);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    bool willUpdateDelegate(D newDelegate) &#x3D;&gt; false;</span><br><span class="line">  </span><br><span class="line">    void dispose() &#123;&#125;</span><br><span class="line">  </span><br><span class="line">    void debugFillProperties(DiagnosticPropertiesBuilder properties) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">    void build(&#123;@required bool isBuildFromExternalSources&#125;) &#123;&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>  这里用到了委托模式，这里就有点类似StatefulWidget和State的关系，同样的_DelegateState提供了类似生命周期的函数，如willUpdateDelegate更新新的委托，dispose注销等。</p>
<ul>
<li>UpdateShouldNotify&lt;T&gt; updateShouldNotify,<br>   void Function(T value) debugCheckInvalidValueType,<br>   StartListening&lt;T&gt; startListening,<br>   Dispose&lt;T&gt; dispose,这些函数全部交给了委托类。</li>
<li>最关键的实现来了，到目前为止还没看到InheritedWidget的逻辑，他来了Widget buildWithChild(BuildContext context, Widget child)，我们传入的Widget就被叫_InheritedProviderScope的类包裹了，看一下源码：</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_InheritedProviderScope</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">InheritedWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> _InheritedProviderScope(&#123;</span><br><span class="line">    <span class="keyword">this</span>.owner,</span><br><span class="line">    <span class="meta">@required</span> Widget child,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(child: child);</span><br><span class="line">  <span class="keyword">final</span> InheritedProvider&lt;T&gt; owner;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> updateShouldNotify(InheritedWidget oldWidget) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _InheritedProviderScopeElement&lt;T&gt; createElement() &#123;</span><br><span class="line">    <span class="keyword">return</span> _InheritedProviderScopeElement&lt;T&gt;(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此你有没有发现一个特点，所有的函数都被_Delegate带走了，剩下的只有Widget交给了_InheritedProviderScope,这个设计很好，毕竟InheritedWidget其实也就只能做到数据共享，跟函数并没有关系，唯一有关系的地方，猜测在InheritedWidget提供的Widget中调用。</p>
<p>一个细节：this在buildWithChild函数中，将InheritedProvider本身传递给InheritedWidget，应该是为了方便调用它的_Delegate委托类，用来回调各种函数。</p>
<p>_InheritedProviderScope唯一特殊的地方，我们发现它自己创建了一个Element实现通过覆盖createElement函数，返回_InheritedProviderScopeElement实例，flutter三板斧Widget、Element、RenderObject，该框架自己实现一层Element，我们知道Widget是配置文件，只有build和rebuild以及remove from the tree，而Element作为一层虚拟Dom，主要负责优化，优化页面刷新的逻辑，我们详细看有一下_InheritedProviderScopeElement的源码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承自InheritedElement，因为InheritedWidget对应的Element就是它</span></span><br><span class="line"><span class="comment">//实现InheritedContext，InheritedContext继承自BuildContext，多了个T泛型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_InheritedProviderScopeElement</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">InheritedElement</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">InheritedContext</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">//构造函数，将Element对应的Widget传进来</span></span><br><span class="line">  _InheritedProviderScopeElement(_InheritedProviderScope&lt;T&gt; widget)</span><br><span class="line">      : <span class="keyword">super</span>(widget);</span><br><span class="line">  <span class="comment">//是否需要通知依赖的Element变更</span></span><br><span class="line">  <span class="built_in">bool</span> _shouldNotifyDependents = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">bool</span> _debugInheritLocked = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">//是否允许通知变更</span></span><br><span class="line">  <span class="built_in">bool</span> _isNotifyDependentsEnabled = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">//是否第一次构建</span></span><br><span class="line">  <span class="built_in">bool</span> _firstBuild = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">//是否更新newWidget的Delegate委托</span></span><br><span class="line">  <span class="built_in">bool</span> _updatedShouldNotify = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">//这个变量就是控制的数据变更，在Widget变更和Element依赖变更的时候都会被设置为true</span></span><br><span class="line">  <span class="built_in">bool</span> _isBuildFromExternalSources = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">//委托类的状态 this就是为了那到上层的委托类</span></span><br><span class="line">  _DelegateState&lt;T, _Delegate&lt;T&gt;&gt; _delegateState;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _InheritedProviderScope&lt;T&gt; <span class="keyword">get</span> widget =&gt;</span><br><span class="line">      <span class="keyword">super</span>.widget <span class="keyword">as</span> _InheritedProviderScope&lt;T&gt;;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> reassemble() &#123;</span><br><span class="line">    <span class="keyword">super</span>.reassemble();</span><br><span class="line">    <span class="keyword">final</span> value = _delegateState.hasValue ? _delegateState.value : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">is</span> ReassembleHandler) &#123;</span><br><span class="line">      value.reassemble();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> updateDependencies(<span class="built_in">Element</span> dependent, <span class="built_in">Object</span> aspect) &#123;</span><br><span class="line">    <span class="keyword">final</span> dependencies = getDependencies(dependent);</span><br><span class="line">    <span class="comment">// once subscribed to everything once, it always stays subscribed to everything</span></span><br><span class="line">    <span class="keyword">if</span> (dependencies != <span class="keyword">null</span> &amp;&amp; dependencies <span class="keyword">is</span>! _Dependency&lt;T&gt;) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (aspect <span class="keyword">is</span> _SelectorAspect&lt;T&gt;) &#123;</span><br><span class="line">      <span class="keyword">final</span> selectorDependency =</span><br><span class="line">          (dependencies ?? _Dependency&lt;T&gt;()) <span class="keyword">as</span> _Dependency&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (selectorDependency.shouldClearSelectors) &#123;</span><br><span class="line">        selectorDependency.shouldClearSelectors = <span class="keyword">false</span>;</span><br><span class="line">        selectorDependency.selectors.clear();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (selectorDependency.shouldClearMutationScheduled == <span class="keyword">false</span>) &#123;</span><br><span class="line">        selectorDependency.shouldClearMutationScheduled = <span class="keyword">true</span>;</span><br><span class="line">        SchedulerBinding.instance.addPostFrameCallback((_) &#123;</span><br><span class="line">          selectorDependency</span><br><span class="line">            ..shouldClearMutationScheduled = <span class="keyword">false</span></span><br><span class="line">            ..shouldClearSelectors = <span class="keyword">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      selectorDependency.selectors.add(aspect);</span><br><span class="line">      setDependencies(dependent, selectorDependency);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// subscribes to everything</span></span><br><span class="line">      setDependencies(dependent, <span class="keyword">const</span> <span class="built_in">Object</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> notifyDependent(InheritedWidget oldWidget, <span class="built_in">Element</span> dependent) &#123;</span><br><span class="line">    <span class="keyword">final</span> dependencies = getDependencies(dependent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> shouldNotify = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (dependencies != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dependencies <span class="keyword">is</span> _Dependency&lt;T&gt;) &#123;</span><br><span class="line">        <span class="comment">// select can never be used inside `didChangeDependencies`, so if the</span></span><br><span class="line">        <span class="comment">// dependent is already marked as needed build, there is no point</span></span><br><span class="line">        <span class="comment">// in executing the selectors.</span></span><br><span class="line">        <span class="keyword">if</span> (dependent.dirty) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> updateShouldNotify <span class="keyword">in</span> dependencies.selectors) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span>(() &#123;</span><br><span class="line">              _debugIsSelecting = <span class="keyword">true</span>;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;());</span><br><span class="line">            shouldNotify = updateShouldNotify(value);</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span>(() &#123;</span><br><span class="line">              _debugIsSelecting = <span class="keyword">false</span>;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (shouldNotify) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shouldNotify = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldNotify) &#123;</span><br><span class="line">      dependent.didChangeDependencies();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> performRebuild() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_firstBuild) &#123;</span><br><span class="line">      _firstBuild = <span class="keyword">false</span>;</span><br><span class="line">      _delegateState = widget.owner._delegate.createState()..element = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.performRebuild();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> update(_InheritedProviderScope&lt;T&gt; newWidget) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(() &#123;</span><br><span class="line">      <span class="keyword">if</span> (widget.owner._delegate.runtimeType !=</span><br><span class="line">          newWidget.owner._delegate.runtimeType) &#123;</span><br><span class="line">        <span class="keyword">throw</span> StateError(<span class="string">'''</span></span><br><span class="line"><span class="string">Rebuilt <span class="subst">$widget</span> using a different constructor.</span></span><br><span class="line"><span class="string">      </span></span><br><span class="line"><span class="string">This is likely a mistake and is unsupported.</span></span><br><span class="line"><span class="string">If you're in this situation, consider passing a `key` unique to each individual constructor.</span></span><br><span class="line"><span class="string">'''</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;());</span><br><span class="line"></span><br><span class="line">    _isBuildFromExternalSources = <span class="keyword">true</span>;</span><br><span class="line">    _updatedShouldNotify =</span><br><span class="line">        _delegateState.willUpdateDelegate(newWidget.owner._delegate);</span><br><span class="line">    <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">    _updatedShouldNotify = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> updated(InheritedWidget oldWidget) &#123;</span><br><span class="line">    <span class="keyword">super</span>.updated(oldWidget);</span><br><span class="line">    <span class="keyword">if</span> (_updatedShouldNotify) &#123;</span><br><span class="line">      notifyClients(oldWidget);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didChangeDependencies() &#123;</span><br><span class="line">    _isBuildFromExternalSources = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">super</span>.didChangeDependencies();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build() &#123;</span><br><span class="line">    <span class="keyword">if</span> (widget.owner._lazy == <span class="keyword">false</span>) &#123;</span><br><span class="line">      value; <span class="comment">// this will force the value to be computed.</span></span><br><span class="line">    &#125;</span><br><span class="line">    _delegateState.build(</span><br><span class="line">      isBuildFromExternalSources: _isBuildFromExternalSources,</span><br><span class="line">    );</span><br><span class="line">    _isBuildFromExternalSources = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (_shouldNotifyDependents) &#123;</span><br><span class="line">      _shouldNotifyDependents = <span class="keyword">false</span>;</span><br><span class="line">      notifyClients(widget);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> unmount() &#123;</span><br><span class="line">    _delegateState.dispose();</span><br><span class="line">    <span class="keyword">super</span>.unmount();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> hasValue =&gt; _delegateState.hasValue;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> markNeedsNotifyDependents() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_isNotifyDependentsEnabled) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    markNeedsBuild();</span><br><span class="line">    _shouldNotifyDependents = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> _debugSetInheritedLock(<span class="built_in">bool</span> value) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(() &#123;</span><br><span class="line">      _debugInheritLocked = value;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  T <span class="keyword">get</span> value =&gt; _delegateState.value;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  InheritedWidget dependOnInheritedElement(</span><br><span class="line">    InheritedElement ancestor, &#123;</span><br><span class="line">    <span class="built_in">Object</span> aspect,</span><br><span class="line">  &#125;) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(() &#123;</span><br><span class="line">      <span class="keyword">if</span> (_debugInheritLocked) &#123;</span><br><span class="line">        <span class="keyword">throw</span> FlutterError.fromParts(</span><br><span class="line">          &lt;DiagnosticsNode&gt;[</span><br><span class="line">            ErrorSummary(</span><br><span class="line">              <span class="string">'Tried to listen to an InheritedWidget '</span></span><br><span class="line">              <span class="string">'in a life-cycle that will never be called again.'</span>,</span><br><span class="line">            ),</span><br><span class="line">            ErrorDescription(<span class="string">'''</span></span><br><span class="line"><span class="string">This error typically happens when calling Provider.of with `listen` to `true`,</span></span><br><span class="line"><span class="string">in a situation where listening to the provider doesn't make sense, such as:</span></span><br><span class="line"><span class="string">- initState of a StatefulWidget</span></span><br><span class="line"><span class="string">- the "create" callback of a provider</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This is undesired because these life-cycles are called only once in the</span></span><br><span class="line"><span class="string">lifetime of a widget. As such, while `listen` is `true`, the widget has</span></span><br><span class="line"><span class="string">no mean to handle the update scenario.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">To fix, consider:</span></span><br><span class="line"><span class="string">- passing `listen: false` to `Provider.of`</span></span><br><span class="line"><span class="string">- use a life-cycle that handles updates (like didChangeDependencies)</span></span><br><span class="line"><span class="string">- use a provider that handles updates (like ProxyProvider).</span></span><br><span class="line"><span class="string">'''</span>),</span><br><span class="line">          ],</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dependOnInheritedElement(ancestor, aspect: aspect);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> debugFillProperties(DiagnosticPropertiesBuilder properties) &#123;</span><br><span class="line">    <span class="keyword">super</span>.debugFillProperties(properties);</span><br><span class="line">    _delegateState.debugFillProperties(properties);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>void update(_InheritedProviderScope&lt;T&gt; newWidget)让页面重新build是在这里，因为InheritedElement继承自ProxyElement，而ProxyElement的update函数调用了两个函数updated(已更新完成)，rebuild函数出发重新build逻辑，下面是代码</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyElement</span> <span class="keyword">extends</span> <span class="title">ComponentElement</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Initializes fields for subclasses.</span></span></span><br><span class="line">  ProxyElement(ProxyWidget widget) : <span class="keyword">super</span>(widget);</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ProxyWidget <span class="keyword">get</span> widget =&gt; <span class="keyword">super</span>.widget <span class="keyword">as</span> ProxyWidget;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build() =&gt; widget.child;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> update(ProxyWidget newWidget) &#123;</span><br><span class="line">    <span class="keyword">final</span> ProxyWidget oldWidget = widget;</span><br><span class="line">    <span class="keyword">assert</span>(widget != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">assert</span>(widget != newWidget);</span><br><span class="line">    <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">    <span class="keyword">assert</span>(widget == newWidget);</span><br><span class="line">    updated(oldWidget);</span><br><span class="line">    _dirty = <span class="keyword">true</span>;</span><br><span class="line">    rebuild();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Called during build when the [widget] has changed.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">By default, calls [notifyClients]. Subclasses may override this method to</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">avoid calling [notifyClients] unnecessarily (e.g. if the old and new</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">widgets are equivalent).</span></span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="keyword">void</span> updated(<span class="keyword">covariant</span> ProxyWidget oldWidget) &#123;</span><br><span class="line">    notifyClients(oldWidget);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>performRebuild()是在update触发真正调用rebuild之后被调用。</p>
</li>
<li><p>updateDependencies、notifyDependent处理Element依赖逻辑</p>
</li>
<li><p>update、updated处理widget更新逻辑</p>
</li>
<li><p>didChangeDependencies当此State对象的依赖项更改时调用，子类很少重写此方法，因为框架总是在依赖项更改后调用build。一些子类确实重写了此方法，因为当他们的依存关系发生变化时，他们需要做一些昂贵的工作（如：网络获取），并且对于每个构建而言这些工作将太昂贵。</p>
</li>
<li><p>build()构建需要的widget，Element在调用build的时候也会触发Widget的build</p>
</li>
<li><p>void unmount（）这里看到了_delegateState.dispose();的调用，当Element从树上移除的时候，回调了dispose函数</p>
</li>
</ul>
<p>来看一个生命周期的图：</p>
<p><img src="/images/widget_lifecycle.png" alt="widget_lifecycle"></p>
<ul>
<li><p>notifyClients是InheritedElement中实现的函数，通过官方文档了解到，它是通过调用Element.didChangeDependencies通知所有从属Element此继承的widget已更改，此方法只能在构建阶段调用，通常，在重建Inherited widget时自动调用此方法，还有InheritedNotifier，它是InheritedWidget的子类，在其Listenable发送通知时也调用此方法。</p>
</li>
<li><p>markNeedsNotifyDependents，如果调用它，会强制build后，通知所有依赖Element刷新widget，看下面代码，发现该函数在InheritedContext中定义，所以我们可以通过InheritedContext上下文来强制页面的构建。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritedContext</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BuildContext</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">The current value exposed by [InheritedProvider].</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">This property is lazy loaded, and reading it the first time may trigger</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">some side-effects such as creating a [T] instance or start a subscription.</span></span></span><br><span class="line">  T <span class="keyword">get</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Marks the [InheritedProvider] as needing to update dependents.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">This bypass [InheritedWidget.updateShouldNotify] and will force widgets</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">that depends on [T] to rebuild.</span></span></span><br><span class="line">  <span class="keyword">void</span> markNeedsNotifyDependents();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Wether <span class="code">`setState`</span> was called at least once or not.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">It can be used by [DeferredStartListening] to differentiate between the</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">very first listening, and a rebuild after <span class="code">`controller`</span> changed.</span></span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> hasValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>我们先回顾一下我们是如何使用InheritedWidget的，为了能让InheritedWidget的子Widget能够刷新，我们不得不依赖于Statefulwidget，并通过State控制刷新Element，调用setState刷新页面，其实是底层调用_element.markNeedsBuild()函数，这样我们明白了，其实最终控制页面的还是Element，那么Provider它也巧妙的封装了自己的_delegateState,是私有的，并没有给我们公开是用，也没有提供类似setState，单可以通过markNeedsNotifyDependents大号和setState一样的调用效果，一样的都是让所有子Widget进行重建，可我们要局部刷新呢，那就是Consumer。</p>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SingleChildStatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">&#123;@template provider.consumer.constructor&#125;</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">Consumes a [Provider<span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span></span>]</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">&#123;@endtemplate&#125;</span></span></span><br><span class="line">  Consumer(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.builder,</span><br><span class="line">    Widget child,</span><br><span class="line">  &#125;)  : <span class="keyword">assert</span>(builder != <span class="keyword">null</span>),</span><br><span class="line">        <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">&#123;@template provider.consumer.builder&#125;</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">Build a widget tree based on the value from a [Provider<span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span></span>].</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">Must not be <span class="code">`null`</span>.</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">&#123;@endtemplate&#125;</span></span></span><br><span class="line">  <span class="keyword">final</span> Widget <span class="built_in">Function</span>(BuildContext context, T value, Widget child) builder;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget buildWithChild(BuildContext context, Widget child) &#123;</span><br><span class="line">    <span class="keyword">return</span> builder(</span><br><span class="line">      context,</span><br><span class="line">      Provider.of&lt;T&gt;(context),</span><br><span class="line">      child,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这里源码有点绕，widget child传给了父类 SingleChildStatelessWidget，最终通过buildWithChild函数的参数child传递回来，而Builder函数收到了此child，然后再组合child和需要刷新的widget组合一个新的widget给Consumer。一句话就是Consumer的构造函数可以传两个widget，一个是buider，一个是child，最终是通过builder构建最终的widget，如果child不为空，那么你需要自己组织child和builder中返回widget的关系。</p>
</li>
<li><p>Provider.of&lt;T&gt;(context)获取共享数据，怎么获取的，继续看代码</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用_inheritedElementOf函数</span></span><br><span class="line"><span class="keyword">static</span> T of&lt;T&gt;(BuildContext context, &#123;<span class="built_in">bool</span> listen = <span class="keyword">true</span>&#125;) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(context != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">assert</span>(</span><br><span class="line">      context.owner.debugBuilding ||</span><br><span class="line">          listen == <span class="keyword">false</span> ||</span><br><span class="line">          debugIsInInheritedProviderUpdate,</span><br><span class="line">      <span class="string">'''</span></span><br><span class="line"><span class="string">Tried to listen to a value exposed with provider, from outside of the widget tree.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This is likely caused by an event handler (like a button's onPressed) that called</span></span><br><span class="line"><span class="string">Provider.of without passing `listen: false`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">To fix, write:</span></span><br><span class="line"><span class="string">Provider.of&lt;<span class="subst">$T</span>&gt;(context, listen: false);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">It is unsupported because may pointlessly rebuild the widget associated to the</span></span><br><span class="line"><span class="string">event handler, when the widget tree doesn't care about the value.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The context used was: <span class="subst">$context</span></span></span><br><span class="line"><span class="string">'''</span>,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> inheritedElement = _inheritedElementOf&lt;T&gt;(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen) &#123;</span><br><span class="line">      context.dependOnInheritedElement(inheritedElement);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inheritedElement.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> _InheritedProviderScopeElement&lt;T&gt; _inheritedElementOf&lt;T&gt;(</span><br><span class="line">    BuildContext context,</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(context != <span class="keyword">null</span>, <span class="string">'''</span></span><br><span class="line"><span class="string">Tried to call context.read/watch/select or similar on a `context` that is null.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This can happen if you used the context of a StatefulWidget and that</span></span><br><span class="line"><span class="string">StatefulWidget was disposed.</span></span><br><span class="line"><span class="string">'''</span>);</span><br><span class="line">    <span class="keyword">assert</span>(</span><br><span class="line">      _debugIsSelecting == <span class="keyword">false</span>,</span><br><span class="line">      <span class="string">'Cannot call context.read/watch/select inside the callback of a context.select'</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">assert</span>(</span><br><span class="line">      T != <span class="built_in">dynamic</span>,</span><br><span class="line">      <span class="string">'''</span></span><br><span class="line"><span class="string">Tried to call Provider.of&lt;dynamic&gt;. This is likely a mistake and is therefore</span></span><br><span class="line"><span class="string">unsupported.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">If you want to expose a variable that can be anything, consider changing</span></span><br><span class="line"><span class="string">`dynamic` to `Object` instead.</span></span><br><span class="line"><span class="string">'''</span>,</span><br><span class="line">    );</span><br><span class="line">    _InheritedProviderScopeElement&lt;T&gt; inheritedElement;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context.widget <span class="keyword">is</span> _InheritedProviderScope&lt;T&gt;) &#123;</span><br><span class="line">      <span class="comment">// An InheritedProvider&lt;T&gt;'s update tries to obtain a parent provider of</span></span><br><span class="line">      <span class="comment">// the same type.</span></span><br><span class="line">      context.visitAncestorElements((parent) &#123;</span><br><span class="line">        inheritedElement = parent.getElementForInheritedWidgetOfExactType&lt;</span><br><span class="line">            _InheritedProviderScope&lt;T&gt;&gt;() <span class="keyword">as</span> _InheritedProviderScopeElement&lt;T&gt;;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      inheritedElement = context.getElementForInheritedWidgetOfExactType&lt;</span><br><span class="line">          _InheritedProviderScope&lt;T&gt;&gt;() <span class="keyword">as</span> _InheritedProviderScopeElement&lt;T&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inheritedElement == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ProviderNotFoundException(T, context.widget.runtimeType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inheritedElement;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过visitAncestorElements往复机查找_InheritedProviderScope的实现类也就是InheritedWidget，当找到时就返回_InheritedProviderScopeElement,而_InheritedProviderScopeElement正好可以拿到value，这个value也就是_delegateState的value</p>
</li>
</ul>
<p>走到这里只是实现了读取数据，那么数据到底是如何刷新的呢？我们回过头来看下面极端代码：</p>
<p>1、Model数据调用ChangeNotifier提供的函数notifyListeners</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@protected</span></span><br><span class="line"><span class="meta">@visibleForTesting</span></span><br><span class="line"><span class="keyword">void</span> notifyListeners() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(_debugAssertNotDisposed());</span><br><span class="line">  <span class="keyword">if</span> (_listeners!.isEmpty)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;_ListenerEntry&gt; localListeners = <span class="built_in">List</span>&lt;_ListenerEntry&gt;.from(_listeners!);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> _ListenerEntry entry <span class="keyword">in</span> localListeners) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (entry.list != <span class="keyword">null</span>)</span><br><span class="line">        entry.listener();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (exception, stack) &#123;</span><br><span class="line">      FlutterError.reportError(FlutterErrorDetails(</span><br><span class="line">        exception: exception,</span><br><span class="line">        stack: stack,</span><br><span class="line">        <span class="keyword">library</span>: <span class="string">'foundation library'</span>,</span><br><span class="line">        context: ErrorDescription(<span class="string">'while dispatching notifications for <span class="subst">$runtimeType</span>'</span>),</span><br><span class="line">        informationCollector: () <span class="keyword">sync</span>* &#123;</span><br><span class="line">          <span class="keyword">yield</span> DiagnosticsProperty&lt;ChangeNotifier&gt;(</span><br><span class="line">            <span class="string">'The <span class="subst">$runtimeType</span> sending notification was'</span>,</span><br><span class="line">            <span class="keyword">this</span>,</span><br><span class="line">            style: DiagnosticsTreeStyle.errorProperty,</span><br><span class="line">          );</span><br><span class="line">        &#125;,</span><br><span class="line">      ));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候遍历所有的监听，然后执行函数listener(),这里其实等于执行VoidCallback的实例，那这个listener到底是哪个函数？</p>
<p>2、在ChangeNotifierProvider父类ListenableProvider的静态函数中，自动订阅了观察者，前面说了观察者就是一个普通函数，而e.markNeedsNotifyDependents就是InheritedContext的一个函数，当你notifyListemers的时候执行的就是它markNeedsNotifyDependents，上面我们知道了markNeedsNotifyDependents类似setState效果，就这样实现了UI的刷新。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ListenableProvider 的静态函数</span></span><br><span class="line"><span class="keyword">static</span> VoidCallback _startListening(</span><br><span class="line">  InheritedContext&lt;Listenable&gt; e,</span><br><span class="line">  Listenable value,</span><br><span class="line">) &#123;</span><br><span class="line">  value?.addListener(e.markNeedsNotifyDependents);</span><br><span class="line">  <span class="keyword">return</span> () =&gt; value?.removeListener(e.markNeedsNotifyDependents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在还有一个点就是局部刷新，我们继续寻找</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget buildWithChild(BuildContext context, Widget child) &#123;</span><br><span class="line">  <span class="keyword">return</span> builder(</span><br><span class="line">    context,</span><br><span class="line">    Provider.of&lt;T&gt;(context),</span><br><span class="line">    child,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Consumer通过Provider.of&lt;T&gt;(context)这段代码才能监听到数据，而且刷新的内容也只是这一部分，我们再看下它的实现发现另一个细节</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">static</span> T of&lt;T&gt;(BuildContext context, &#123;<span class="built_in">bool</span> listen = <span class="keyword">true</span>&#125;) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(context != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">assert</span>(</span><br><span class="line">      context.owner.debugBuilding ||</span><br><span class="line">          listen == <span class="keyword">false</span> ||</span><br><span class="line">          debugIsInInheritedProviderUpdate,</span><br><span class="line">      <span class="string">'''</span></span><br><span class="line"><span class="string">Tried to listen to a value exposed with provider, from outside of the widget tree.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This is likely caused by an event handler (like a button's onPressed) that called</span></span><br><span class="line"><span class="string">Provider.of without passing `listen: false`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">To fix, write:</span></span><br><span class="line"><span class="string">Provider.of&lt;<span class="subst">$T</span>&gt;(context, listen: false);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">It is unsupported because may pointlessly rebuild the widget associated to the</span></span><br><span class="line"><span class="string">event handler, when the widget tree doesn't care about the value.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The context used was: <span class="subst">$context</span></span></span><br><span class="line"><span class="string">'''</span>,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> inheritedElement = _inheritedElementOf&lt;T&gt;(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen) &#123;</span><br><span class="line">      context.dependOnInheritedElement(inheritedElement);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inheritedElement.value;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>它调用了BuildContext的dependOnInheritedElement函数，这个函数做了什么</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">InheritedWidget dependOnInheritedElement(InheritedElement ancestor, &#123; <span class="built_in">Object</span> aspect &#125;);</span><br><span class="line"><span class="comment">/// <span class="markdown">Obtains the nearest widget of the given type, which must be the type of a</span></span></span><br><span class="line"><span class="comment">/// <span class="markdown">concrete [InheritedWidget] subclass, and registers this build context with</span></span></span><br><span class="line"><span class="comment">/// <span class="markdown">that widget such that when that widget changes (or a new widget of that</span></span></span><br><span class="line"><span class="comment">/// <span class="markdown">type is introduced, or the widget goes away), this build context is</span></span></span><br><span class="line"><span class="comment">/// <span class="markdown">rebuilt so that it can obtain new values from that widget.</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="markdown">This method is deprecated. Please use [dependOnInheritedWidgetOfExactType] instead.</span></span></span><br><span class="line"><span class="comment">// TODO(a14n): Remove this when it goes to stable, https://github.com/flutter/flutter/pull/44189</span></span><br><span class="line"><span class="meta">@Deprecated</span>(</span><br><span class="line">  <span class="string">'Use dependOnInheritedWidgetOfExactType instead. '</span></span><br><span class="line">  <span class="string">'This feature was deprecated after v1.12.1.'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>触发updateDependencies，通过setDependencies，将Element缓存到_dependetns Map中，最后通过下面代码更新：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> notifyDependent(InheritedWidget oldWidget, <span class="built_in">Element</span> dependent) &#123;</span><br><span class="line">  <span class="keyword">final</span> dependencies = getDependencies(dependent);</span><br><span class="line">  <span class="keyword">var</span> shouldNotify = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (dependencies != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dependencies <span class="keyword">is</span> _Dependency&lt;T&gt;) &#123;</span><br><span class="line">      <span class="comment">// select can never be used inside `didChangeDependencies`, so if the</span></span><br><span class="line">      <span class="comment">// dependent is already marked as needed build, there is no point</span></span><br><span class="line">      <span class="comment">// in executing the selectors.</span></span><br><span class="line">      <span class="keyword">if</span> (dependent.dirty) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> updateShouldNotify <span class="keyword">in</span> dependencies.selectors) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">assert</span>(() &#123;</span><br><span class="line">            _debugIsSelecting = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;());</span><br><span class="line">          shouldNotify = updateShouldNotify(value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">assert</span>(() &#123;</span><br><span class="line">            _debugIsSelecting = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (shouldNotify) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      shouldNotify = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (shouldNotify) &#123;</span><br><span class="line">    dependent.didChangeDependencies();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以说整体流程是这样，当notifyListeners的时候其实是出发了InheritedWidget的performRebuild，再到build，build后触发notifyClients，notifyClients触发notifyDependent，notifyDependent这个时候通过getDependencies获取缓存好的Element，最终确定是否需要刷新然后调用dependent.didChangeDependencies()更新，只要widget中通过Provider.of函数订阅后，就会被InheritedWidget缓存在一个Map中，然后刷新页面的时候，如果子Widget不在缓存的Map中，就不会走刷新，而且如果shouldNotify变量是false也不会刷新，这个控制可能是虽然widget订阅了，但它自己就是不刷新，可以更加细粒度的控制。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Provider通过缓存inheritedElement实现局部刷新。</li>
<li>通过控制自己实现的Element层来更新UI</li>
<li>通过Element提供的unmount函数回调dispose，实现选择性释放。</li>
</ul>
<p><img src="/images/provider_class_view.png" alt="provider_class_view"></p>
<p><a href="https://www.jianshu.com/p/bf2f33b2b5ef" target="_blank" rel="noopener">转载自</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/19/flutter%E6%8E%A2%E7%B4%A2-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/19/flutter%E6%8E%A2%E7%B4%A2-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Flutter探索  - 状态管理分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-19 16:05:48" itemprop="dateCreated datePublished" datetime="2021-05-19T16:05:48+08:00">2021-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-20 09:57:51" itemprop="dateModified" datetime="2021-05-20T09:57:51+08:00">2021-05-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="状态管理是什么"><a href="#状态管理是什么" class="headerlink" title="状态管理是什么"></a>状态管理是什么</h3><p>我们知道最基本的程序是什么</p>
<ul>
<li><p>程序 = 算法 + 数据结构</p>
<p>数据是程序的中心。数据结构和算法两个概念间的逻辑关系贯穿整个程序世界，首先两者表现为不可分割的关系。flutter也是一个程序。由此得出</p>
</li>
<li><p>Flutter = 算法 + 数据结构</p>
<p>那状态管理是什么？我们也用公式表示一下：</p>
</li>
<li><p>Flutter状态管理 = 算法 + 数据结构 + UI绑定</p>
<p>来看一段代码例子：</p>
</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThemeBloc</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> _themeStreamController = StreamController&lt;AppTheme&gt;();</span><br><span class="line">  <span class="keyword">get</span> changeTheTheme =&gt; _themeStreamController.sink.add;</span><br><span class="line">  <span class="keyword">get</span> darkThemIsEnABLE =&gt; _themeStreamController.stream;</span><br><span class="line">  dispose()&#123;</span><br><span class="line">    _themStreamController.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> bloc = ThemeBloc();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppTheme</span> </span>&#123;</span><br><span class="line">  ThemeData themeData;</span><br><span class="line">  AppTheme(<span class="keyword">this</span>.themeData);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//绑定到UI</span></span><br><span class="line">StreamBulder&lt;AppTheme&gt;(</span><br><span class="line">	initialData:AppTheme.LIGHT_THEME,</span><br><span class="line">  stream:bloc.dartThemeIsEnabled,</span><br><span class="line">  builder:(contenxt,AsyncSnapshot&lt;AppTheme&gt; snapshot)&#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title:<span class="string">"Jason"</span>,</span><br><span class="line">      theme:snapshot.data.themeData,</span><br><span class="line">      home:PageHome(),</span><br><span class="line">      routes:&lt;<span class="built_in">String</span>,WidgetBuilder&gt;&#123;</span><br><span class="line">        <span class="string">"/pageChatGroup"</span>:(context) =&gt; PageChatGroup(),</span><br><span class="line">        <span class="string">"/laoYu"</span>:(context) =&gt; LaoYu(),</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>AppTheme 是数据结构</li>
<li>changeTheTheme 是算法</li>
<li>StreamBuilder 是绑定UI</li>
</ul>
<p>这样一整套代码的逻辑就是我们所说的Flutter状态管理。算法就是我们如何管理，数据结构是数据状态，状态管理的本质还是如何通过合理的算法管理数据，如何取，如何接收等，最终展示在UI上，通过UI的变更来提现状态的管理逻辑。</p>
<h3 id="为什么需要状态管理"><a href="#为什么需要状态管理" class="headerlink" title="为什么需要状态管理"></a>为什么需要状态管理</h3><p>状态管理可以实现组件通信、跨组件数据储存。原生的状态变更是通过具体的组件直接复制，如果页面全部变更，是不是需要每一个都设置一遍，而Flutter的变更就简单粗暴 ，setState搞定，它背后的逻辑是重新build整个页面，发现有变更，再将新的数据复制。其实原生开发与Flutter的本质的区别就是数据与视图完全分离，目前原生也出现了UI绑定框架。说明flutter的设计的先进性。这样设计的弊端是什么？</p>
<p>答案就是<code>页面如何刷新才是Flutter的关键</code>，原生也面临这个问题，页面的重绘导致丢帧问题，为了效果更好，我们很多时候都选择局部刷新，原生已经很明确的告诉UI要刷新什么更新什么，而对于Flutter来说，这一点恨不清晰，虽然Flutter也做了类似虚拟Dom优化重绘逻辑，但这远远不够，如何合理的更新UI才是最主要的，这个时候一大堆的状态管理就出来了，当然状态管理也不是仅仅为了解决更新问题。我们再思考一个问题，如果我有一个widget A，我想在另外一个widget B中改变widget A的一个状态，或者从网络、数据库取到数据，然后刷新它。</p>
<p>一个糟糕的写法是，A widget的 state为全局的，当B widget 需要刷新的时候 直接调用 AState对象的 <code>setState</code> 方法.</p>
<p>这样写有几个问题：</p>
<p>1、违背了封装的概念，其他所有类都可以拿到A的state对象。</p>
<p>2、A和B强耦合了。</p>
<p>3、每次都是重绘整个widget A 性能变差。</p>
<p>4、不利于测试。</p>
<p>如何变好了，这就需要我们选择一种合适的状态管理方式。</p>
<h4 id="状态管理的目标"><a href="#状态管理的目标" class="headerlink" title="状态管理的目标"></a>状态管理的目标</h4><p>其实我们做状态管理，不仅仅是因为它的特点，也是更好地架构。</p>
<ul>
<li>代码层次分明，易维护，易阅读。</li>
<li>可扩展，可以动态替换UI而不影响算法逻辑。</li>
<li>安全可靠，保持数据的稳定伸缩</li>
<li>性能佳，局部刷新。</li>
</ul>
<p>这不仅仅是状态管理的目的，也是我们做一款优秀应用的基础架构。</p>
<h3 id="状态管理的基本分类"><a href="#状态管理的基本分类" class="headerlink" title="状态管理的基本分类"></a>状态管理的基本分类</h3><ul>
<li>局部管理 官方也称Ephemeral State，意思是短暂的状态，这种状态根本不需要做全局处理，StatefulWidget处理即可完成。</li>
<li>全局管理 官方称App state ，即应用状态，非短暂状态，你要在应用程序的许多部分之间共享，以及希望在用户会话之间保持的状态，就是我们所说的应用程序状态（也称共享状态）。例如：<ul>
<li>用户偏好</li>
<li>登录信息</li>
<li>购物车</li>
<li>新闻阅读状态</li>
</ul>
</li>
</ul>
<p>总之，任何Flutter应用程序中都有两种概念性的状态类型。临时状态可以使用State和setState来事项，并且通常是单个窗口小部件的本地状态。剩下的就是应用的状态。两种类型在任何Flutter应用程序中都有自己的位置，两者之间的划分取决于你自己的喜好和应用程序的复杂性。没有最好的管理方式，只有最合适的管理方式。</p>
<h3 id="底层逻辑"><a href="#底层逻辑" class="headerlink" title="底层逻辑"></a>底层逻辑</h3><p>底层逻辑主要讲，Flutter中目前有哪些可以做到状态管理，有什么缺点，适合做什么不适合做什么，完全明白底层逻辑才不会畏惧复杂的逻辑，即使逻辑复杂也能选择合理的方式去管理状态。</p>
<ul>
<li><p>State</p>
<p>StatefulWidget、SteamBuilder状态管理方式。</p>
</li>
<li><p>InheritedWidget</p>
<p>专门负责Widget树种数据共享的功能型Widget，如Provider、scoped_model就是基于它开发</p>
</li>
<li><p>Notification</p>
<p>与InheritedWidget正好相反，InheritedWidget是从上往下传递数据，Notification是从下往上，但两者都是在自己的Widget树种传递，无法跨越树传递。</p>
</li>
<li><p>Stream</p>
<p>数据流 如Bloc、flutter_redux、fish_redux等也都基于它来做实现。</p>
</li>
</ul>
<p>下面一一分析</p>
<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>State是我们常用而且使用最频繁的一个状态管理类，它必须结合StatefulWidget一起使用，StreamBuilder继承自StatefulWidget，同样使用setState来管理状态。</p>
<p>为什么用State管理状态，而不是Widget本身。Flutter设计时让Widget本身是不变的，类似固定的配置信息，那么就需要一个角色来控制它，State就出现了，但State的任何更改都会强制整个Widget重新构建，当然也可以覆盖必要的方法自己控制逻辑。</p>
<p>注意：setState是整个Widget重新构建（子Widget也会销毁重建），这个点也是为什么不推荐大量使用StatefulWidget的原因。如果页面足够复杂，就会导致严重的性能损耗。建议使用StreamBuilder，它原理上是State，但它做到了子Widget的局部刷新，不会导致整个页面的重建。</p>
<h4 id="State的缺点"><a href="#State的缺点" class="headerlink" title="State的缺点"></a>State的缺点</h4><ul>
<li>无法做到夸组件共享数据（这个夸是无关联的，如果是直接的父子关系，不算是跨组件）。一般我们将State的子类设置为私有，所以无法做到让别的组件调用State的setState函数来刷新。</li>
<li>setState会成为维护的难点，因为到处都有。随着页面状态的增多，可能调用的setState的地方会越来越多，不能统一管理。</li>
<li>处理数据逻辑和视图混合在一起，违反代码设计原则。比如网络的数据取出来setState的UI上，这样编写代码，导致状态和UI耦合在一起，不利于测试和复用。</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>反过来讲，State简单高效，当复杂到需要更好地管理的时候再重构，一个基本原则就是，状态是否需要跨组件使用，如果需要那就用别的方法管理状态而不是State管理。</p>
<h3 id="InheritedWidget"><a href="#InheritedWidget" class="headerlink" title="InheritedWidget"></a>InheritedWidget</h3><p>InheritedWidget是一个无私的Widget，它可以把自己的状态数据，无私交给所有的子Widget，所有的子Widget可以无条件的继承它的状态。它的数据是只读的，子widget不能修改。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>缺点：</p>
<ul>
<li>容易造成不必要的刷新。</li>
<li>不支持跨页面（router）的状态，不是同一个树的状态无法获取。</li>
<li>数据不可变，必须结合StatefulWidget、ChangeNotifier或者Steam使用。</li>
</ul>
<p>比较适合在一个属性Widget中，抽象出公有状态，每一个子Widget或者孙Widget都可以获取该状态，我们可以通过手段控制rebuild的粒度来优化重绘逻辑，但它更适合从上往下传递，如果从下往上传递，如何做，下面解答。</p>
<h3 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h3><p>它是flutter中跨层数据共享的一种机制，它不是widget，它提供了dispatch方法，来让我们沿着context对应的Element节点向上逐层发送通知。</p>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p>缺点</p>
<ul>
<li>不支持跨页面的状态，准确的说不支持NotificationListener同级或者父级Widget的状态通知</li>
<li>本身不支持刷新UI,需要结合State使用</li>
<li>如果结合State，会导致整个UI的重绘，效率低下不科学。</li>
</ul>
<p>使用起来简单，如果页面复杂度高不推荐。</p>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p>Stream其实是一个生产者消费者模型，一端负责生产，一端负责消费，而且是纯Dart的实现，跟Flutter没什么关系，扯上关系的就是StreamBuilder来构建一个Stream通道的Widget，像知名的rxdart、Bloc、flutter_redux全都用到了Stream的api。所以学习它才是我们掌握状态管理的关键。</p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>缺点</p>
<ul>
<li>api生涩，不好理解。</li>
<li>需要定制化，才能满足更复杂的场景。</li>
<li>没有自动dispose逻辑。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上所有的状态更新都离不开State的支持。</p>
<h3 id="状态管理的使用原则"><a href="#状态管理的使用原则" class="headerlink" title="状态管理的使用原则"></a>状态管理的使用原则</h3><h4 id="局部管理优于全局"><a href="#局部管理优于全局" class="headerlink" title="局部管理优于全局"></a>局部管理优于全局</h4><p>这个原则来源于，Flutter的性能优化，局部刷新肯定比全局刷新要好很多，那么我们在管理状态的同时，也要考虑该状态到底是局部还是全局，从而编写正确的逻辑。</p>
<h4 id="保持数据安全性"><a href="#保持数据安全性" class="headerlink" title="保持数据安全性"></a>保持数据安全性</h4><p>用<code>_</code>私有化状态，因为当开发人员众多，当别人看到你的变量的时候，第一反应可能不是找你提供的方法，而是直接对变量操作，那就有可能出现想不到的后果，如果他只能调用你提供的方法，那他就要遵循你方法的逻辑，避免数据被处理错误。</p>
<h4 id="考虑页面重新build带来的影响"><a href="#考虑页面重新build带来的影响" class="headerlink" title="考虑页面重新build带来的影响"></a>考虑页面重新build带来的影响</h4><p>很多时候页面的重建都会调用build函数，也就是说，在一个生命周期内，build函数是多次被调用的，所以你就要考虑数据的初始化或者刷新怎么样才能合理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/19/iOS%E6%8E%A2%E7%B4%A2-Block/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/19/iOS%E6%8E%A2%E7%B4%A2-Block/" class="post-title-link" itemprop="url">iOS探索 - Block</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-19 11:06:45" itemprop="dateCreated datePublished" datetime="2021-05-19T11:06:45+08:00">2021-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-11 00:31:12" itemprop="dateModified" datetime="2021-07-11T00:31:12+08:00">2021-07-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在Objective-C中，block是一个很常见的东西，说白了就是个匿名函数，网上有很多关于block如何使用的文章，讲的都非常精彩，这里主要探讨下block的实现原理。</p>
<h3 id="先看一个例子"><a href="#先看一个例子" class="headerlink" title="先看一个例子"></a>先看一个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">void blockFunc1() &#123;</span><br><span class="line">    int num &#x3D; 100;</span><br><span class="line">    void (^block)(void) &#x3D; ^() &#123;</span><br><span class="line">        NSLog(@&quot;num &#x3D; %d\n&quot;, num);</span><br><span class="line">    &#125;;</span><br><span class="line">    num &#x3D; 200;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void blockFunc2() &#123;</span><br><span class="line">    __block int num &#x3D; 100;</span><br><span class="line">    void (^block)(void) &#x3D; ^() &#123;</span><br><span class="line">        NSLog(@&quot;num &#x3D; %d\n&quot;, num);</span><br><span class="line">    &#125;;</span><br><span class="line">    num &#x3D; 200;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int num &#x3D; 100;</span><br><span class="line">void blockFunc3() &#123;</span><br><span class="line">    void (^block)(void) &#x3D; ^() &#123;</span><br><span class="line">        NSLog(@&quot;num &#x3D; %d\n&quot;, num);</span><br><span class="line">    &#125;;</span><br><span class="line">    num &#x3D; 200;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void blockFunc4()</span><br><span class="line">&#123;</span><br><span class="line">    static int num &#x3D; 100;</span><br><span class="line">    void (^block)(void) &#x3D; ^&#123;</span><br><span class="line">        NSLog(@&quot;num &#x3D; %d&quot;, num);</span><br><span class="line">    &#125;;</span><br><span class="line">    num &#x3D; 200;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        ^&#123; printf(&quot;Hello, World!\n&quot;); &#125; ();</span><br><span class="line">        blockFunc1();</span><br><span class="line">        blockFunc2();</span><br><span class="line">        blockFunc3();</span><br><span class="line">        blockFunc4();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-19</span> <span class="number">11</span>:<span class="number">25</span>:<span class="number">19.532572</span>+<span class="number">0800</span> OCDemo[<span class="number">60496</span>:<span class="number">2272335</span>] num = <span class="number">100</span></span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-19</span> <span class="number">11</span>:<span class="number">25</span>:<span class="number">19.534041</span>+<span class="number">0800</span> OCDemo[<span class="number">60496</span>:<span class="number">2272335</span>] num = <span class="number">200</span></span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-19</span> <span class="number">11</span>:<span class="number">25</span>:<span class="number">19.534166</span>+<span class="number">0800</span> OCDemo[<span class="number">60496</span>:<span class="number">2272335</span>] num = <span class="number">200</span></span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-19</span> <span class="number">11</span>:<span class="number">25</span>:<span class="number">19.534292</span>+<span class="number">0800</span> OCDemo[<span class="number">60496</span>:<span class="number">2272335</span>] num = <span class="number">200</span></span><br></pre></td></tr></table></figure>

<p>我们先简单解释一下：</p>
<p>1、”Hello, World!”应该很简单，执行block直接打印。</p>
<p>2、<code>blockFunc1</code>里面,<code>num</code>是以值传递的方式被block获取，所以尽管后面更改了<code>num</code>的值，但是在block里面还是保持保持原来的值。</p>
<p>3、<code>blockFunc2</code>里面，num由<code>__block</code>修饰，<code>num</code>在block变成了外部的一个引用（后面会通过源码解释），所以在block外部改变<code>num</code>的值时，block里面的<code>num</code>也随着改变。</p>
<p>4、<code>blockFunc3</code>里面，block引用的是一个全局的num，所以，num改变的时候也会改变block内部num的值。</p>
<p>5、<code>blockFunc3</code>里面，block引用的是一个static的num，所以，num改变也会改变block内部的num的值。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>也许大家看到上面的解释还是不知道为啥会这样，所以接下，我通过源码来分析下其中的缘由，我们先把这段先转换成c++文件，cd到main.m所在的目录，并执行这条命令<code>clang -rewrite-objc main.m</code>，</p>
<p>如果上面的命令报错<code>&#39;UIKit/UIKit.h&#39; file not found</code>,可以使用下面命令</p>
<p><code>clang -x objective-c -rewrite-objc -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk main.m</code></p>
<p>通过这条命令可以把main.m文件转换成cpp文件，里面可以看到block的结构。我们打开这份文件，这个文件比较长，直接拉到最后。可以看到在文件的最后是main函数的入口，代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA)) ();</span><br><span class="line">        blockFunc1();</span><br><span class="line">        blockFunc2();</span><br><span class="line"></span><br><span class="line">        blockFunc3();</span><br><span class="line">        blockFunc4();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看第一行代码，构造了一个<strong>main_block_impl_0对象，</strong>main_block_impl_0是一个结构体。相关代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从代码可知，最后block会转化成一个__block_impl对象，而block执行的代码会转化成一个静态函数，__block_impl里面的FuncPtr会指向这个静态函数。在这里<code>printf(&quot;Hello, World!\n&quot;);</code>这个block转换后的静态函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以整个过程是这样的：<br>1、先构造一个<code>__main_block_impl_0</code>对象，构造的时候把<code>__main_block_func_0</code>传进去，当然还有别的参数，这里先不考虑。</p>
<p>2、在<code>__main_block_impl_0</code>的构造方法中，再把<code>__main_block_func_0</code>赋给<code>__block_impl</code>的FuncPtr。</p>
<p>3、调用FuncPtr。</p>
<p>所以，从上面可以看出，block实际上是转化为了一个<code>__block_impl</code>对象，这个对象有isa指针，用来表示block的类型，上面的block的isa指向&amp;_NSConcreteStackBlock。同时block对象还有一个FuncPtr指针，用来指向block执行的方法（转换后的静态函数）。</p>
<p>再来看看blockFunc1相关的内容</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc1_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc1_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  __blockFunc1_block_impl_0(<span class="keyword">void</span> *fp, struct __blockFunc1_block_desc_0 *desc, <span class="keyword">int</span> _num, <span class="keyword">int</span> flags=<span class="number">0</span>) : num(_num) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __blockFunc1_block_func_0(struct __blockFunc1_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> num = __cself-&gt;num; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders__s_l_p47fxn36j8d2_n75spyb7c0000gn_T_main_324f63_mi_0, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc1_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __blockFunc1_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __blockFunc1_block_impl_0)&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blockFunc1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">void</span> (*block)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__blockFunc1_block_impl_0((<span class="keyword">void</span> *)__blockFunc1_block_func_0, &amp;__blockFunc1_block_desc_0_DATA, num));</span><br><span class="line">    num = <span class="number">200</span>;</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个函数里面，构造block的时候把num传了进去，而且是普通值传递，这样的话其实是拷贝了一份num。然后在执行block方法的时候，使用的是拷贝的那份num，从<code>int num = __cself-&gt;num; // bound by copy</code>可以看出。这个block也是_NSConcreteStackBlock类型的。</p>
<p>再来看看__block修饰过的num在block里面是怎么传递的，我们看看blockFunc2相关的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_num_0</span> &#123;</span></span><br><span class="line"> <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_num_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc2_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc2_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __Block_byref_num_0 *num; <span class="comment">// by ref</span></span><br><span class="line">  __blockFunc2_block_impl_0(<span class="keyword">void</span> *fp, struct __blockFunc2_block_desc_0 *desc, __Block_byref_num_0 *_num, <span class="keyword">int</span> flags=<span class="number">0</span>) : num(_num-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __blockFunc2_block_func_0(struct __blockFunc2_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_num_0 *num = __cself-&gt;num; <span class="comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders__s_l_p47fxn36j8d2_n75spyb7c0000gn_T_main_324f63_mi_1, (num-&gt;__forwarding-&gt;num));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __blockFunc2_block_copy_0(struct __blockFunc2_block_impl_0*dst, struct __blockFunc2_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;num, (<span class="keyword">void</span>*)src-&gt;num, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __blockFunc2_block_dispose_0(struct __blockFunc2_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;num, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc2_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*copy)(struct __blockFunc2_block_impl_0*, struct __blockFunc2_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(struct __blockFunc2_block_impl_0*);</span><br><span class="line">&#125; __blockFunc2_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __blockFunc2_block_impl_0), __blockFunc2_block_copy_0, __blockFunc2_block_dispose_0&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blockFunc2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_num_0 num = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_num_0 *)&amp;num, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_num_0), <span class="number">100</span>&#125;;</span><br><span class="line">    <span class="keyword">void</span> (*block)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__blockFunc2_block_impl_0((<span class="keyword">void</span> *)__blockFunc2_block_func_0, &amp;__blockFunc2_block_desc_0_DATA, (__Block_byref_num_0 *)&amp;num, <span class="number">570425344</span>));</span><br><span class="line">    (num.__forwarding-&gt;num) = <span class="number">200</span>;</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看到，__block修饰的num在内部被包装成一个__Block_byref_num_0的对象，假设叫a，原来num的值100存储在对象a的num字段中，同时这个对象a有一个<strong>forwarding字段，指向a本身。当改变num的值的时候（源代码是<code>num = 200;</code>），这段代码变为`(num.</strong>forwarding-&gt;num) = 200;<code>，也就是说把对象a里面的num字段的值变为了200。同时，在block的执行函数__blockFunc2_block_func_0中，打印出来的取值是从</code><strong>Block_byref_num_0 *num = __cself-&gt;num;`取出，也就是取得是改变后的值，所以打印结果是200。这就是为什么用</strong>block修饰的变量可以在block内部被修改。</p>
<p>那当num为全局变量的时候，block又是怎样的呢？请看代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc3_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc3_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __blockFunc3_block_impl_0(<span class="keyword">void</span> *fp, struct __blockFunc3_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __blockFunc3_block_func_0(struct __blockFunc3_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders__s_l_p47fxn36j8d2_n75spyb7c0000gn_T_main_324f63_mi_2, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc3_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __blockFunc3_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __blockFunc3_block_impl_0)&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blockFunc3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (*block)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__blockFunc3_block_impl_0((<span class="keyword">void</span> *)__blockFunc3_block_func_0, &amp;__blockFunc3_block_desc_0_DATA));</span><br><span class="line">    num = <span class="number">200</span>;</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码里可以看出，这种情况很简单，block对象根本没有num字段，也就是打印的时候直接取得全局的num。</p>
<p>最后一种情况也很简单，当num时static的时候，构造block对象的时候直接用引用传值的方式把num放到block对象中。所以，当外部改变num的值的时候，也能反映到block内部。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc4_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc4_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> *num;</span><br><span class="line">  __blockFunc4_block_impl_0(<span class="keyword">void</span> *fp, struct __blockFunc4_block_desc_0 *desc, <span class="keyword">int</span> *_num, <span class="keyword">int</span> flags=<span class="number">0</span>) : num(_num) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __blockFunc4_block_func_0(struct __blockFunc4_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> *num = __cself-&gt;num; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders__s_l_p47fxn36j8d2_n75spyb7c0000gn_T_main_324f63_mi_3, (*num));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc4_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __blockFunc4_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __blockFunc4_block_impl_0)&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blockFunc4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">void</span> (*block)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__blockFunc4_block_impl_0((<span class="keyword">void</span> *)__blockFunc4_block_func_0, &amp;__blockFunc4_block_desc_0_DATA, &amp;num));</span><br><span class="line">    num = <span class="number">200</span>;</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章主要从源码的角度讲述了block的实现机制，并针对四种情况分析了block是如何引用外部变量的，分别是:<br>1、当引用局部变量的时候，如果没有__block修饰，那么在block内部获取的是外部变量的一份拷贝，改变外部变量不影响block内部的那份拷贝。</p>
<p>2、当引用局部变量的时候，同时局部变量用__block修饰，那么在block内部使用的实际上是外部变量的一个引用，所以改变外部变量会影响block内部变量的值。</p>
<p>3、当引用全局变量的时候，block并不持有这个变量。</p>
<p>4、当引用static变量的时候，block会以引用的方式持有这个变量。当在外部修改这个变量的时候，会影响block内部持有的这个变量的值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/18/iOS-Runloop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/18/iOS-Runloop/" class="post-title-link" itemprop="url">iOS  - Runloop</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-18 15:33:42" itemprop="dateCreated datePublished" datetime="2021-05-18T15:33:42+08:00">2021-05-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jason</p>
  <div class="site-description" itemprop="description">个人技术博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
