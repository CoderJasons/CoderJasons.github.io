<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yujiusheng.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="个人技术博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Jason的博客">
<meta property="og:url" content="http://yujiusheng.com/page/2/index.html">
<meta property="og:site_name" content="Jason的博客">
<meta property="og:description" content="个人技术博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yujiusheng.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Jason的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jason的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/07/22/Flutter-runApp-%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/22/Flutter-runApp-%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">Flutter-runApp()方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-22 14:46:42" itemprop="dateCreated datePublished" datetime="2021-07-22T14:46:42+08:00">2021-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-23 17:05:06" itemprop="dateModified" datetime="2021-07-23T17:05:06+08:00">2021-07-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>Flutter</code>程序的入口<code>main()</code>方法会调用<code>runApp()</code>方法，我们本篇探索<code>runApp</code>都做了啥。</p>
<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> runApp(Widget app) &#123;</span><br><span class="line">  WidgetsFlutterBinding.ensureInitialized()</span><br><span class="line">    ..scheduleAttachRootWidget(app)</span><br><span class="line">    ..scheduleWarmUpFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法一看很简洁，一共调用了<code>WidgetsFlutterBinding</code>的三个方法，在看三个方法的实现之前，我们看一下<code>WidgetsFlutterBinding</code>是什么。</p>
<h3 id="WidgetsFlutterBinding"><a href="#WidgetsFlutterBinding" class="headerlink" title="WidgetsFlutterBinding"></a>WidgetsFlutterBinding</h3><p>我们看一下官方的解释：</p>
<p><code>A concrete binding for applications based on the Widgets framework.This is the glue that binds the framework to the Flutter engine.</code></p>
<p>翻译过来就是，一个基于<code>Widgets framework</code>的应用程序的具体绑定，它是绑定<code>framework</code>和<code>Flutter engine</code>的胶水层。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetsFlutterBinding</span> <span class="keyword">extends</span> <span class="title">BindingBase</span> <span class="title">with</span> <span class="title">GestureBinding</span>, <span class="title">SchedulerBinding</span>, <span class="title">ServicesBinding</span>, <span class="title">PaintingBinding</span>, <span class="title">SemanticsBinding</span>, <span class="title">RendererBinding</span>, <span class="title">WidgetsBinding</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> WidgetsBinding ensureInitialized() &#123;</span><br><span class="line">    <span class="keyword">if</span> (WidgetsBinding.instance == <span class="keyword">null</span>)</span><br><span class="line">      WidgetsFlutterBinding();</span><br><span class="line">    <span class="keyword">return</span> WidgetsBinding.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的父类<code>BindingBase</code>是一个抽象类，<code>with</code>实现了很多<code>mixin</code>,这些<code>mixin</code>只能用于继承自<code>BindingBase</code>的类。<code>mixin</code>的作用是扩展功能，<code>mixin</code>可以类比于<code>iOS</code>的<code>protocol</code>(个人见解，如果不对欢迎指正)。</p>
<h4 id="BindingBase"><a href="#BindingBase" class="headerlink" title="BindingBase"></a>BindingBase</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingBase</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">省略代码</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">However, multiple window support is not yet implemented, so currently this</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">provides access to the one and only window.</span></span></span><br><span class="line">  <span class="comment">// TODO(gspencergoog): remove the preceding note once multi-window support is</span></span><br><span class="line">  <span class="comment">// active.</span></span><br><span class="line">  <span class="comment">// 唯一的window</span></span><br><span class="line">  ui.SingletonFlutterWindow <span class="keyword">get</span> <span class="built_in">window</span> =&gt; ui.<span class="built_in">window</span>;</span><br><span class="line">  <span class="comment">/// <span class="markdown">每一个BindingBase类定义行为 都有一个 platformDispatcher 作为回调(handlers)</span></span></span><br><span class="line">  ui.PlatformDispatcher <span class="keyword">get</span> platformDispatcher =&gt; ui.PlatformDispatcher.instance;</span><br><span class="line">  <span class="comment">/// <span class="markdown">初始化实例</span></span></span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">assert</span>(!_debugInitialized);</span><br><span class="line">    <span class="keyword">assert</span>(() &#123;</span><br><span class="line">      _debugInitialized = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// <span class="markdown">The current [WidgetsBinding], if one has been created.</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">ensureInitialized方法返回的实例</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">If you need the binding to be constructed before calling [runApp],</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">you can ensure a Widget binding has been constructed by calling the</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown"><span class="code">`WidgetsFlutterBinding.ensureInitialized()`</span> function.</span></span></span><br><span class="line">  <span class="keyword">static</span> WidgetsBinding? <span class="keyword">get</span> instance =&gt; _instance;</span><br><span class="line">  <span class="keyword">static</span> WidgetsBinding? _instance;</span><br><span class="line">  <span class="comment">/// <span class="markdown">注册 service extensions 初始化之后调用</span></span></span><br><span class="line">  <span class="keyword">void</span> initServiceExtensions() &#123;</span><br><span class="line">    <span class="comment">///<span class="markdown">省略代码</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ui.window</code>：是<code>Flutter App</code>显示的窗口，它继承自<code>FlutterView</code>,位于<code>Flutter engine</code>层。</li>
<li><code>ui.PlatformDispatcher.instance</code>：platformDispatcher是Flutter 的一个事件分发器，负责Flutter分发engine的事件，和传递事件给engine层。</li>
<li><code>initInstances</code>：初始化实例的方法。</li>
<li><code>initServiceExtensions()</code>：注册 <code>service extensions</code>,比如<code>platformOverride</code>、<code>activeDevToolsServerAddress</code>等。</li>
</ul>
<h3 id="ensureInitialized（）方法"><a href="#ensureInitialized（）方法" class="headerlink" title="ensureInitialized（）方法"></a>ensureInitialized（）方法</h3><p>该方法的作用是返回一个<code>WidgetsBinding</code>类型实例，如果未创建就新创建一个。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> WidgetsBinding ensureInitialized() &#123;</span><br><span class="line">  <span class="keyword">if</span> (WidgetsBinding.instance == <span class="keyword">null</span>)</span><br><span class="line">    WidgetsFlutterBinding();</span><br><span class="line">  <span class="keyword">return</span> WidgetsBinding.instance!;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是返回一个<code>WidgetsBinding.instance</code>实例，因为<code>WidgetsFlutterBinding</code>实现了<code>GestureBinding, SchedulerBinding, ServicesBinding, PaintingBinding, SemanticsBinding, RendererBinding, WidgetsBinding</code>mixin，mixin的<code>initInstances</code>和<code>initServiceExtensions</code>方法也会调用，每个mixin的功能：</p>
<ul>
<li><code>GestureBinding</code>：处理手势。</li>
<li><code>SchedulerBinding</code>: 处理系统调度。</li>
<li><code>ServicesBinding</code>：处理与原生的交互。</li>
<li><code>PaintingBinding</code>：处理绘制。</li>
<li><code>SemanticsBinding</code>：处理语义化。</li>
<li><code>RendererBinding</code>：处理渲染。</li>
<li><code>WidgetsBinding</code>：<code>Widgets</code>相关。</li>
</ul>
<p>我们下面主要看<code>WidgetsBinding</code>和<code>RendererBinding</code>。</p>
<h4 id="WidgetsBinding"><a href="#WidgetsBinding" class="headerlink" title="WidgetsBinding"></a>WidgetsBinding</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> WidgetsBinding <span class="keyword">on</span> BindingBase, ServicesBinding, SchedulerBinding, GestureBinding, RendererBinding, SemanticsBinding &#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initInstances();</span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">assert</span>(() &#123;</span><br><span class="line">      _debugAddStackFilters();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;());</span><br><span class="line">    <span class="comment">// Initialization of [_buildOwner] has to be done after</span></span><br><span class="line">    <span class="comment">// [super.initInstances] is called, as it requires [ServicesBinding] to</span></span><br><span class="line">    <span class="comment">// properly setup the [defaultBinaryMessenger] instance.</span></span><br><span class="line">    _buildOwner = BuildOwner();</span><br><span class="line">    buildOwner!.onBuildScheduled = _handleBuildScheduled;</span><br><span class="line">    <span class="built_in">window</span>.onLocaleChanged = handleLocaleChanged;</span><br><span class="line">    <span class="built_in">window</span>.onAccessibilityFeaturesChanged = handleAccessibilityFeaturesChanged;</span><br><span class="line">    SystemChannels.navigation.setMethodCallHandler(_handleNavigationInvocation);</span><br><span class="line">    FlutterErrorDetails.propertiesTransformers.add(transformDebugCreator);</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="comment">///<span class="markdown">省略代码</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WidgetsBinding</code>初始化会创建一个<code>BuildOwner</code>对象，它的作用是管理<code>Widget</code>树和<code>Element</code>树。</p>
<h4 id="RendererBinding"><a href="#RendererBinding" class="headerlink" title="RendererBinding"></a>RendererBinding</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> RendererBinding <span class="keyword">on</span> BindingBase, ServicesBinding, SchedulerBinding, GestureBinding, SemanticsBinding, HitTestable &#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initInstances();</span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line">    _pipelineOwner = PipelineOwner(</span><br><span class="line">      onNeedVisualUpdate: ensureVisualUpdate,</span><br><span class="line">      onSemanticsOwnerCreated: _handleSemanticsOwnerCreated,</span><br><span class="line">      onSemanticsOwnerDisposed: _handleSemanticsOwnerDisposed,</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">window</span></span><br><span class="line">      ..onMetricsChanged = handleMetricsChanged</span><br><span class="line">      ..onTextScaleFactorChanged = handleTextScaleFactorChanged</span><br><span class="line">      ..onPlatformBrightnessChanged = handlePlatformBrightnessChanged</span><br><span class="line">      ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged</span><br><span class="line">      ..onSemanticsAction = _handleSemanticsAction;</span><br><span class="line">    initRenderView();</span><br><span class="line">    _handleSemanticsEnabledChanged();</span><br><span class="line">    <span class="keyword">assert</span>(renderView != <span class="keyword">null</span>);</span><br><span class="line">    addPersistentFrameCallback(_handlePersistentFrameCallback);</span><br><span class="line">    initMouseTracker();</span><br><span class="line">    <span class="keyword">if</span> (kIsWeb) &#123;</span><br><span class="line">      addPostFrameCallback(_handleWebFirstFrame);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">The current [RendererBinding], if one has been created.</span></span></span><br><span class="line">  <span class="keyword">static</span> RendererBinding? <span class="keyword">get</span> instance =&gt; _instance;</span><br><span class="line">  <span class="keyword">static</span> RendererBinding? _instance;</span><br><span class="line">  <span class="comment">///<span class="markdown">省略代码</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RendererBinding</code>初始化会创建一个<code>PipelineOwner</code>对象，用于管理<code>RenderObject</code>树。<code>PipelineOwner</code>和<code>BuildOwner</code>都位于<code>framework</code>层，它们通过<code>Bingding</code>(胶水层)与<code>engine</code>交互。</p>
<ul>
<li>初始化了一个PipelineOwner用于管理RenderObject.</li>
<li>将<code>_handlePersistentFrameCallback</code>这个callback传入<code>SchedulerBinding</code>中的<code>_postFrameCallbacks</code>中，这样在硬件每次发出<code>VSync</code>信号的时候都会调用<code>RenderBinding</code>中的<code>_handlePersistentFrameCallback</code>方法.<code>_handlePersistentFrameCallback</code>方法中直接调用了<code>drawFrame</code>方法。</li>
</ul>
<h3 id="scheduleAttachRootWidget"><a href="#scheduleAttachRootWidget" class="headerlink" title="scheduleAttachRootWidget"></a>scheduleAttachRootWidget</h3><p>实例化之后会调用<code>scheduleAttachRootWidget</code>方法。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@protected</span></span><br><span class="line"><span class="keyword">void</span> scheduleAttachRootWidget(Widget rootWidget) &#123;</span><br><span class="line">  Timer.run(() &#123;</span><br><span class="line">    attachRootWidget(rootWidget);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了<code>attachRootWidget</code>方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> attachRootWidget(Widget rootWidget) &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> isBootstrapFrame = renderViewElement == <span class="keyword">null</span>;</span><br><span class="line">  _readyToProduceFrames = <span class="keyword">true</span>;</span><br><span class="line">  _renderViewElement = RenderObjectToWidgetAdapter&lt;RenderBox&gt;(</span><br><span class="line">    container: renderView,</span><br><span class="line">    debugShortDescription: <span class="string">'[root]'</span>,</span><br><span class="line">    child: rootWidget,</span><br><span class="line">  ).attachToRenderTree(buildOwner!, renderViewElement <span class="keyword">as</span> RenderObjectToWidgetElement&lt;RenderBox&gt;?);</span><br><span class="line">  <span class="keyword">if</span> (isBootstrapFrame) &#123;</span><br><span class="line">    SchedulerBinding.instance!.ensureVisualUpdate();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>attachRootWidget方法用于是为根Widget生成一个根Element。生成Element调用了attachToRenderTree方法并传入了BuildOwner和Element。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RenderObjectToWidgetElement&lt;T&gt; attachToRenderTree(BuildOwner owner, [ RenderObjectToWidgetElement&lt;T&gt;? element ]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (element == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">///<span class="markdown">新创建一个 element</span></span></span><br><span class="line">      owner.lockState(() &#123;</span><br><span class="line">        element = createElement();</span><br><span class="line">        <span class="keyword">assert</span>(element != <span class="keyword">null</span>);</span><br><span class="line">        element!.assignOwner(owner);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 建立能更新widget 树的能力，可以回调 callback，构建所有标记为dirty的elment</span></span><br><span class="line">      owner.buildScope(element!, () &#123;</span><br><span class="line">        element!.mount(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element._newWidget = <span class="keyword">this</span>;</span><br><span class="line">      element.markNeedsBuild();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> element!;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要是<code>element</code>为空的时候新建一个<code>element</code>，新建后会调用<code>BuildOwner</code>的<code>buildScope</code>主要作用是建立能更新<code>widget</code> 树的能力，可以回调 <code>callback</code>，构建所有标记为<code>dirty</code>的<code>element</code>。</p>
<p><code>attachRootWidget</code>方法，最后会执行<code>SchedulerBinding.instance!.ensureVisualUpdate()</code>，</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ensureVisualUpdate() &#123;</span><br><span class="line">  <span class="keyword">switch</span> (schedulerPhase) &#123;</span><br><span class="line">    <span class="keyword">case</span> SchedulerPhase.idle:</span><br><span class="line">    <span class="keyword">case</span> SchedulerPhase.postFrameCallbacks:</span><br><span class="line">      scheduleFrame();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> SchedulerPhase.transientCallbacks:</span><br><span class="line">    <span class="keyword">case</span> SchedulerPhase.midFrameMicrotasks:</span><br><span class="line">    <span class="keyword">case</span> SchedulerPhase.persistentCallbacks:</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它主要是调用新的帧的调度管理。它会调用<code>scheduleFrame</code>方法</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> scheduleFrame() &#123;</span><br><span class="line">  <span class="keyword">if</span> (_hasScheduledFrame || !framesEnabled)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">assert</span>(() &#123;</span><br><span class="line">    <span class="keyword">if</span> (debugPrintScheduleFrameStacks)</span><br><span class="line">      debugPrintStack(label: <span class="string">'scheduleFrame() called. Current phase is <span class="subst">$schedulerPhase</span>.'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;());</span><br><span class="line">  <span class="comment">///<span class="markdown">给window设置回调</span></span></span><br><span class="line">  ensureFrameCallbacksRegistered();</span><br><span class="line">  <span class="comment">///<span class="markdown">调度更新</span></span></span><br><span class="line">  <span class="built_in">window</span>.scheduleFrame();</span><br><span class="line">  _hasScheduledFrame = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会给<code>window</code>设置<code>onBeginFrame</code>和<code>onDrawFrame</code>的回调，<code>window</code>会把回调传给<code>platformDispatcher</code>。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">set</span> onBeginFrame(ui.FrameCallback? callback) &#123;</span><br><span class="line">  platformDispatcher.onBeginFrame = callback;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">ui.VoidCallback? <span class="keyword">get</span> onDrawFrame =&gt; platformDispatcher.onDrawFrame;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">set</span> onDrawFrame(ui.VoidCallback? callback) &#123;</span><br><span class="line">  platformDispatcher.onDrawFrame = callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说<code>scheduleAttachRootWidget</code>经过一系列调用之后，会把<code>SchedulerBinding</code>的<code>_handleBeginFrame</code>和<code>_handleDrawFrame</code>传给<code>platformDispatcher</code>。<code>platformDispatcher</code>分发来自enginee的事件。而在这里<code>SingletonFlutterWindow</code>把<code>platformDispatcher</code>的<code>onBeginFrame</code>和<code>onDrawFrame</code>这两个事件交给<code>SchedulerBinding</code>处理。</p>
<p>当硬件发出<code>VSync</code>信号时，会调用<code>platformDispatcher的onDrawFrame</code>。实际上会调用<code>SchedulerBinding</code>中的<code>_handleDrawFrame</code>方法。<code>_handleDrawFrame</code>会调用<code>handleDrawFrame</code>方法:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> handleDrawFrame() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(_schedulerPhase == SchedulerPhase.midFrameMicrotasks);</span><br><span class="line">  Timeline.finishSync(); <span class="comment">// end the "Animate" phase</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// PERSISTENT FRAME CALLBACKS</span></span><br><span class="line">    _schedulerPhase = SchedulerPhase.persistentCallbacks;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> FrameCallback callback <span class="keyword">in</span> _persistentCallbacks)</span><br><span class="line">      _invokeFrameCallback(callback, _currentFrameTimeStamp!);</span><br><span class="line">    <span class="comment">// POST-FRAME CALLBACKS</span></span><br><span class="line">    _schedulerPhase = SchedulerPhase.postFrameCallbacks;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">List</span>&lt;FrameCallback&gt; localPostFrameCallbacks =</span><br><span class="line">        <span class="built_in">List</span>&lt;FrameCallback&gt;.from(_postFrameCallbacks);</span><br><span class="line">    _postFrameCallbacks.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> FrameCallback callback <span class="keyword">in</span> localPostFrameCallbacks)</span><br><span class="line">      _invokeFrameCallback(callback, _currentFrameTimeStamp!);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">///<span class="markdown">省略代码</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_postFrameCallbacks</code>里面存储的是<code>callback</code>，作用是硬件每次发出<code>VSync</code>信号的时候都会调用。这里的<code>_postFrameCallbacks</code>是在<code>RenderBinding</code>这个<code>mixin</code>的<code>initInstances</code>方法中传入的</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addPersistentFrameCallback(_handlePersistentFrameCallback);</span><br></pre></td></tr></table></figure>

<h3 id="scheduleWarmUpFrame"><a href="#scheduleWarmUpFrame" class="headerlink" title="scheduleWarmUpFrame"></a>scheduleWarmUpFrame</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> scheduleWarmUpFrame() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_warmUpFrame || schedulerPhase != SchedulerPhase.idle)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    _warmUpFrame = <span class="keyword">true</span>;</span><br><span class="line">    Timeline.startSync(<span class="string">'Warm-up frame'</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">bool</span> hadScheduledFrame = _hasScheduledFrame;</span><br><span class="line">    <span class="comment">// We use timers here to ensure that microtasks flush in between.</span></span><br><span class="line">    Timer.run(() &#123;</span><br><span class="line">      <span class="keyword">assert</span>(_warmUpFrame);</span><br><span class="line">      handleBeginFrame(<span class="keyword">null</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    Timer.run(() &#123;</span><br><span class="line">      <span class="keyword">assert</span>(_warmUpFrame);</span><br><span class="line">      handleDrawFrame();</span><br><span class="line">      <span class="comment">// We call resetEpoch after this frame so that, in the hot reload case,</span></span><br><span class="line">      <span class="comment">// the very next frame pretends to have occurred immediately after this</span></span><br><span class="line">      <span class="comment">// warm-up frame. The warm-up frame's timestamp will typically be far in</span></span><br><span class="line">      <span class="comment">// the past (the time of the last real frame), so if we didn't reset the</span></span><br><span class="line">      <span class="comment">// epoch we would see a sudden jump from the old time in the warm-up frame</span></span><br><span class="line">      <span class="comment">// to the new time in the "real" frame. The biggest problem with this is</span></span><br><span class="line">      <span class="comment">// that implicit animations end up being triggered at the old time and</span></span><br><span class="line">      <span class="comment">// then skipping every frame and finishing in the new time.</span></span><br><span class="line">      resetEpoch();</span><br><span class="line">      _warmUpFrame = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (hadScheduledFrame)</span><br><span class="line">        scheduleFrame();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// Lock events so touch events etc don't insert themselves until the</span></span><br><span class="line">    <span class="comment">// scheduled frame has finished.</span></span><br><span class="line">    lockEvents(() <span class="keyword">async</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> endOfFrame;</span><br><span class="line">      Timeline.finishSync();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要调用是<code>scheduleFrame</code>，跟进代码实际是调用的<code>window.scheduleFrame()</code>,</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> scheduleFrame() &#123;</span><br><span class="line">  platformDispatcher.scheduleFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>window.scheduleFrame()</code>调用了<code>platformDispatcher.scheduleFrame()</code>,通知<code>engine</code>层需要绘制。engine会根据情况尽快地调用platformDispatcher的onDrawFrame方法。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>runApp方法主要做了以下事情：</p>
<ul>
<li>创建<code>WidgetsFlutterBinding</code>它是连接<code>framework</code>和<code>engine</code>的胶水层。注册<code>Vsync</code>回调，后面每一帧的调用会出发<code>WidgetsFlutterBinding</code>的回调，最后传递到<code>framework</code>层处理逻辑。</li>
<li><code>attachRootWidget</code>：遍历挂载整个视图树，建立<code>widget</code>、<code>element</code>、<code>renderObjcect</code>的连接关系。</li>
<li><code>scheduleWarmUpFrame</code>：调度帧预热(warmUp)。执行帧绘制<code>handleBeginFrame</code>和<code>handleDrawFrame</code>方法。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/07/20/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E7%B1%BB%E7%9A%84%E6%89%A9%E5%B1%95%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/20/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E7%B1%BB%E7%9A%84%E6%89%A9%E5%B1%95%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">iOS底层探索-类的扩展和关联对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-20 09:24:28" itemprop="dateCreated datePublished" datetime="2021-07-20T09:24:28+08:00">2021-07-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-21 11:34:53" itemprop="dateModified" datetime="2021-07-21T11:34:53+08:00">2021-07-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前面几篇我们探索了<code>类</code>的加载过程，本篇我们研究类相关的两个点：<code>类的扩展</code>和<code>关联对象</code>。</p>
<h3 id="类扩展"><a href="#类扩展" class="headerlink" title="类扩展"></a>类扩展</h3><h4 id="clang编译"><a href="#clang编译" class="headerlink" title="clang编译"></a>clang编译</h4><p>我们首先在<code>main.m</code>文件中新建一个类<code>JSAnimal</code>,并给类定义扩展，注意<code>扩展</code>要在<code>声明之后</code>和<code>实现之后</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@interface JSAnimal : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic,copy)NSString *name;</span><br><span class="line"></span><br><span class="line">- (void)sayWow;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface JSAnimal ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic,copy)NSString *type;</span><br><span class="line"></span><br><span class="line">- (void)ex_sayWow;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation JSAnimal</span><br><span class="line"></span><br><span class="line">+ (void)classMethod&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sayWow&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)ex_sayWow&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        JSAnimal *animal &#x3D; [[JSAnimal alloc] init];</span><br><span class="line">        [animal ex_sayWow];</span><br><span class="line">        NSLog(@&quot;done&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用<code>clang</code>命令，将<code>main.m</code>转成<code>main.cpp</code>文件，看一下分类的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m -o main.cpp</span><br></pre></td></tr></table></figure>

<p><code>main.cpp</code>文件搜索<code>JSAnimal</code></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfcccacbc80a4621b82cd607c8089ade~tplv-k3u1fbpfcp-watermark.image" alt="1626779765218"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f79df3e864584213815b25cd6c2a5cbc~tplv-k3u1fbpfcp-watermark.image" alt="1626779854673"></p>
<p>发现<code>扩展</code>里声明的<code>属性</code>和<code>方法</code>编译后和<code>类</code>中的在一起，作为<code>类</code>的一部分，也就是说<code>扩展中的属性和方法</code>在<code>编译期</code>就添加到<code>本类</code>中了。</p>
<h4 id="通过源码探索运行时"><a href="#通过源码探索运行时" class="headerlink" title="通过源码探索运行时"></a>通过源码探索运行时</h4><p>定义一个<code>JSPerson</code>类和扩展，本类中实现扩展中声明的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface JSPerson : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line"></span><br><span class="line">- (void)saySomething;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;JSPerson.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation JSPerson</span><br><span class="line"></span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)saySomething&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)ext_instanceMethod&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)ext_classMethod&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface JSPerson ()</span><br><span class="line"></span><br><span class="line">- (void)ext_instanceMethod;</span><br><span class="line"></span><br><span class="line">+ (void)ext_classMethod;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>注意<code>JSPerson</code>类实现了<code>load</code>方法，目的是让其<code>非懒加载</code>。根据我们的经验，我们在<code>realizeClassWithoutSwift</code>添加断点调试</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af878f11eefc4b4b89daf2d446cba41d~tplv-k3u1fbpfcp-watermark.image" alt="1626781568401"></p>
<p>通过<code>lldb</code>打印<code>ro</code>中的方法列表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p ro</span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *) $<span class="number">0</span> = <span class="number">0x0000000100004790</span></span><br><span class="line">(lldb) p *$<span class="number">0</span></span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">class_ro_t</span>) $<span class="number">1</span> = &#123;</span><br><span class="line">  flags = <span class="number">0</span></span><br><span class="line">  instanceStart = <span class="number">8</span></span><br><span class="line">  instanceSize = <span class="number">16</span></span><br><span class="line">  reserved = <span class="number">0</span></span><br><span class="line">   = &#123;</span><br><span class="line">    ivarLayout = <span class="number">0x0000000000000000</span></span><br><span class="line">    nonMetaclass = nil</span><br><span class="line">  &#125;</span><br><span class="line">  name = &#123;</span><br><span class="line">    <span class="built_in">std</span>::__1::atomic&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; = <span class="string">"JSPerson"</span> &#123;</span><br><span class="line">      Value = <span class="number">0x0000000100003b58</span> <span class="string">"JSPerson"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  baseMethodList = <span class="number">0x00000001000047d8</span></span><br><span class="line">  baseProtocols = nil</span><br><span class="line">  ivars = <span class="number">0x0000000100004840</span></span><br><span class="line">  weakIvarLayout = <span class="number">0x0000000000000000</span></span><br><span class="line">  baseProperties = <span class="number">0x0000000100004868</span></span><br><span class="line">  _swiftMetadataInitializer_NEVER_USE = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">1.b</span>aseMethods()</span><br><span class="line">(<span class="keyword">method_list_t</span> *) $<span class="number">2</span> = <span class="number">0x00000001000047d8</span></span><br><span class="line">(lldb) p *$<span class="number">2</span></span><br><span class="line">(<span class="keyword">method_list_t</span>) $<span class="number">3</span> = &#123;</span><br><span class="line">  entsize_list_tt&lt;<span class="keyword">method_t</span>, <span class="keyword">method_list_t</span>, <span class="number">4294901763</span>, <span class="keyword">method_t</span>::pointer_modifier&gt; = (entsizeAndFlags = <span class="number">24</span>, count = <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">3.</span><span class="built_in">get</span>(<span class="number">0</span>).big()</span><br><span class="line">(<span class="keyword">method_t</span>::big) $<span class="number">4</span> = &#123;</span><br><span class="line">  name = <span class="string">"saySomething"</span></span><br><span class="line">  types = <span class="number">0x0000000100003d84</span> <span class="string">"v16@0:8"</span></span><br><span class="line">  imp = <span class="number">0x0000000100003600</span> (KCObjcBuild`-[JSPerson saySomething])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">3.</span><span class="built_in">get</span>(<span class="number">1</span>).big()</span><br><span class="line">(<span class="keyword">method_t</span>::big) $<span class="number">5</span> = &#123;</span><br><span class="line">  name = <span class="string">"ext_instanceMethod"</span></span><br><span class="line">  types = <span class="number">0x0000000100003d84</span> <span class="string">"v16@0:8"</span></span><br><span class="line">  imp = <span class="number">0x0000000100003630</span> (KCObjcBuild`-[JSPerson ext_instanceMethod])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">3.</span><span class="built_in">get</span>(<span class="number">2</span>).big()</span><br><span class="line">(<span class="keyword">method_t</span>::big) $<span class="number">6</span> = &#123;</span><br><span class="line">  name = <span class="string">"name"</span></span><br><span class="line">  types = <span class="number">0x0000000100003d98</span> <span class="string">"@16@0:8"</span></span><br><span class="line">  imp = <span class="number">0x0000000100003660</span> (KCObjcBuild`-[JSPerson name])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">3.</span><span class="built_in">get</span>(<span class="number">3</span>).big()</span><br><span class="line">(<span class="keyword">method_t</span>::big) $<span class="number">7</span> = &#123;</span><br><span class="line">  name = <span class="string">"setName:"</span></span><br><span class="line">  types = <span class="number">0x0000000100003da0</span> <span class="string">"v24@0:8@16"</span></span><br><span class="line">  imp = <span class="number">0x0000000100003690</span> (KCObjcBuild`-[JSPerson setName:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>扩展</code>中的方向现在已经加载了已知<code>ro</code>中的方法是<code>编译期</code>就确定的，所以也验证了<code>扩展</code>的方法是在<code>编译期</code>添加到<code>本类</code>的。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>类的扩展 在<code>编译期</code> 会作为类的一部分，和类一起编译进来</li>
<li>类的扩展只是<code>声明</code>，依赖于<code>本类</code>的实现。</li>
</ul>
<h3 id="分类的关联对象"><a href="#分类的关联对象" class="headerlink" title="分类的关联对象"></a>分类的关联对象</h3><p>我们知道<code>分类</code>正常是不能添加<code>属性</code>的，但是通过<code>关联对象</code>可以，其实现通过两个方法</p>
<ul>
<li>通过<code>objc_setAssociatedObject</code>方法设置值。</li>
<li>通过<code>objc_getAssociatedObject</code>方法取值。</li>
</ul>
<p>下面我们分别探索。</p>
<h4 id="objc-setAssociatedObject流程"><a href="#objc-setAssociatedObject流程" class="headerlink" title="objc_setAssociatedObject流程"></a>objc_setAssociatedObject流程</h4><p><code>objc_setAssociatedObject</code>有四个参数：</p>
<ul>
<li>参数1：要关联的对象</li>
<li>参数2：表示符，方便查找识别</li>
<li>参数3：value值</li>
<li>参数4：属性的<code>策略</code>,我们定义属性经常用到的如<code>nonatomic</code>、<code>strong</code>、<code>weak</code>。</li>
</ul>
<p>首先定义<code>JSPerson</code>的<code>分类</code>，定义一个属性<code>cateegory_name</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@interface JSPerson (JSCategory)</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *cateegory_name;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation JSPerson (JSCategory)</span><br><span class="line"></span><br><span class="line">- (void)setCateegory_name:(NSString *)category_name&#123;</span><br><span class="line">    objc_setAssociatedObject(self, &quot;category_name&quot;, category_name, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)category_name&#123;</span><br><span class="line">    return  objc_getAssociatedObject(self, &quot;category_name&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>在<code>main</code>函数赋值属性的地方添加断点，根据调用情况</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/565a6873ad724e6db775d38ea637c95a~tplv-k3u1fbpfcp-watermark.image" alt="1626783154111"></p>
<p>定位到<code>objc_setAssociatedObject</code>方法</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10b7f73974e746a6bedd5b3ab397f809~tplv-k3u1fbpfcp-watermark.image" alt="1626783226697"></p>
<p>调用的是<code>_object_set_associative_reference</code>方法，我们继续跟进查看源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_object_set_associative_reference(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key, id value, <span class="keyword">uintptr_t</span> policy)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This code used to work when nil was passed for object and key. Some code</span></span><br><span class="line">    <span class="comment">// probably relies on that to not crash. Check and handle it explicitly.</span></span><br><span class="line">    <span class="comment">// rdar://problem/44094390</span></span><br><span class="line">    <span class="keyword">if</span> (!object &amp;&amp; !value) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (object-&gt;getIsa()-&gt;forbidsAssociatedObjects())</span><br><span class="line">        _objc_fatal(<span class="string">"objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects"</span>, object, object_getClassName(object));</span><br><span class="line">		<span class="comment">///将object封装一下 类型为DisguisedPtr</span></span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; disguised&#123;(objc_object *)object&#125;;</span><br><span class="line">    <span class="comment">///包装policy  value</span></span><br><span class="line">    ObjcAssociation association&#123;policy, value&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// retain the new value (if any) outside the lock.</span></span><br><span class="line">    <span class="comment">//根据策略类型(strong、weak等)进行处理</span></span><br><span class="line">    association.acquireValue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isFirstAssociation = <span class="literal">false</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化manager变量，相当于自动调用AssociationsManager的构造函数进行初始化</span></span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">      	<span class="comment">///一个HashMap</span></span><br><span class="line">        <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.<span class="built_in">get</span>())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">          	<span class="comment">//返回的结果是一个类对</span></span><br><span class="line">            <span class="keyword">auto</span> refs_result = associations.try_emplace(disguised, ObjectAssociationMap&#123;&#125;);</span><br><span class="line">            <span class="keyword">if</span> (refs_result.second) &#123;</span><br><span class="line">                <span class="comment">/* it's the first association we make */</span></span><br><span class="line">                isFirstAssociation = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* establish or replace the association 建立或者替换关联*/</span></span><br><span class="line">            <span class="keyword">auto</span> &amp;refs = refs_result.first-&gt;second;<span class="comment">///得到一个空的桶，找到引用对象类型,即第一个元素的second值</span></span><br><span class="line">            <span class="keyword">auto</span> result = refs.try_emplace(key, <span class="built_in">std</span>::<span class="built_in">move</span>(association));<span class="comment">//查找当前的key是否有association关联对象</span></span><br><span class="line">            <span class="keyword">if</span> (!result.second) &#123;<span class="comment">///如果结果不存在</span></span><br><span class="line">                association.swap(result.first-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果传的是空值，则移除关联，相当于移除</span></span><br><span class="line">            <span class="keyword">auto</span> refs_it = associations.<span class="built_in">find</span>(disguised);</span><br><span class="line">            <span class="keyword">if</span> (refs_it != associations.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> &amp;refs = refs_it-&gt;second;</span><br><span class="line">                <span class="keyword">auto</span> it = refs.<span class="built_in">find</span>(key);</span><br><span class="line">                <span class="keyword">if</span> (it != refs.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    association.swap(it-&gt;second);</span><br><span class="line">                    refs.erase(it);</span><br><span class="line">                    <span class="keyword">if</span> (refs.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                        associations.erase(refs_it);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Call setHasAssociatedObjects outside the lock, since this</span></span><br><span class="line">    <span class="comment">// will call the object's _noteAssociatedObjects method if it</span></span><br><span class="line">    <span class="comment">// has one, and this may trigger +initialize which might do</span></span><br><span class="line">    <span class="comment">// arbitrary stuff, including setting more associated objects.</span></span><br><span class="line">    <span class="keyword">if</span> (isFirstAssociation)</span><br><span class="line">        object-&gt;setHasAssociatedObjects();</span><br><span class="line">    <span class="comment">// release the old value (outside of the lock).释放老的关联值</span></span><br><span class="line">    association.releaseHeldValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过源码我们看到大体的流程为：</p>
<ul>
<li>创建一个<code>AssociationsManager</code>管理类</li>
<li>获取<code>静态哈希表</code>:<code>associations</code></li>
<li>判断<code>关联值value</code>是否为空<ul>
<li>如果为空就走：<code>插入空值</code>流程。</li>
<li>如果不为空继续下一步</li>
</ul>
</li>
<li>通过<code>try_emplace</code>方法，创建一个空的 <code>ObjectAssociationMap</code> 去取查询的键值对</li>
<li>如果发现<code>没有</code> <code>key</code> 就<code>插入一个 空的 BucketT</code>进去并返回true</li>
<li>通过<code>setHasAssociatedObjects</code>方法<code>标记对象存在关联对象</code></li>
<li>用当前 <code>policy 和 value</code> 组成了一个 <code>ObjcAssociation</code> 替换原来 <code>BucketT</code>中的值</li>
<li>标记一下 <code>ObjectAssociationMap</code> 的<code>第一次</code>为 <code>false</code></li>
</ul>
<h4 id="源码调试"><a href="#源码调试" class="headerlink" title="源码调试"></a>源码调试</h4><p>对流程有了大概的认识，我们开始断点调试</p>
<h5 id="if-value-之前变量的值"><a href="#if-value-之前变量的值" class="headerlink" title="if (value) 之前变量的值"></a><strong>if</strong> (value) 之前变量的值</h5><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d0c1f116d8b4d999e54a29b275453cc~tplv-k3u1fbpfcp-watermark.image" alt="1626785173962"></p>
<p>通过<code>lldb</code>我们打印出了<code>disguised</code>、<code>association</code>、<code>manager</code>、<code>associations</code>、<code>value</code>的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p disguised</span><br><span class="line">(DisguisedPtr&lt;objc_object&gt;) $<span class="number">0</span> = (value = <span class="number">18446744069393517536</span>)</span><br><span class="line">(lldb) p association</span><br><span class="line">(objc::ObjcAssociation) $<span class="number">1</span> = &#123;</span><br><span class="line">  _policy = <span class="number">3</span></span><br><span class="line">  _value = <span class="number">0x0000000100004080</span> <span class="string">"哈哈哈"</span></span><br><span class="line">&#125;</span><br><span class="line">(lldb) p manager</span><br><span class="line">(objc::AssociationsManager) $<span class="number">2</span> = &#123;&#125;</span><br><span class="line">(lldb) p associations</span><br><span class="line">(objc::AssociationsHashMap) $<span class="number">3</span> = &#123;</span><br><span class="line">  Buckets = nil</span><br><span class="line">  NumEntries = <span class="number">0</span></span><br><span class="line">  NumTombstones = <span class="number">0</span></span><br><span class="line">  NumBuckets = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">(lldb) p value</span><br><span class="line">(__NSCFConstantString *) $<span class="number">4</span> = <span class="number">0x0000000100004080</span> <span class="string">"哈哈哈"</span></span><br></pre></td></tr></table></figure>

<h5 id="value不为空流程"><a href="#value不为空流程" class="headerlink" title="value不为空流程"></a><code>value</code>不为空流程</h5><p>上面我们看到<code>value</code>值不为空，我们进入<code>if</code>语句继续调试。</p>
<ul>
<li><code>p refs_result</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p refs_result</span><br><span class="line">(<span class="built_in">std</span>::pair&lt;objc::DenseMapIterator&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt;, objc::DenseMapValueInfo&lt;objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt;, objc::DenseMapInfo&lt;DisguisedPtr&lt;objc_object&gt; &gt;, objc::detail::DenseMapPair&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt;, <span class="literal">false</span>&gt;, <span class="keyword">bool</span>&gt;) $<span class="number">5</span> = &#123;</span><br><span class="line">  first = &#123;</span><br><span class="line">    Ptr = <span class="number">0x00000001012102a0</span></span><br><span class="line">    End = <span class="number">0x0000000101210300</span></span><br><span class="line">  &#125;</span><br><span class="line">  second = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到<code>refs_result</code>的数据结构看起来比较复杂，但是值比较简单，有两个属性<code>first</code>、<code>second</code>。其中<code>first</code>的值为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $<span class="number">5.f</span>irst.Ptr</span><br><span class="line">(objc::DenseMapIterator&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt;, objc::DenseMapValueInfo&lt;objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt;, objc::DenseMapInfo&lt;DisguisedPtr&lt;objc_object&gt; &gt;, objc::detail::DenseMapPair&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt;, <span class="literal">false</span>&gt;::pointer) $<span class="number">6</span> = <span class="number">0x00000001012102a0</span></span><br><span class="line"> (lldb) p $<span class="number">5.f</span>irst.End</span><br><span class="line">(objc::DenseMapIterator&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt;, objc::DenseMapValueInfo&lt;objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt;, objc::DenseMapInfo&lt;DisguisedPtr&lt;objc_object&gt; &gt;, objc::detail::DenseMapPair&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt;, <span class="literal">false</span>&gt;::pointer) $<span class="number">7</span> = <span class="number">0x0000000101210300</span></span><br></pre></td></tr></table></figure>

<p><code>second</code>值为<code>true</code>，所以会执行<code>isFirstAssociation = true</code>。</p>
<ul>
<li><p><code>try_emplace</code>方法，<code>associations</code>调用了<code>try_emplace</code>方法，我们看一下他的源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line">std::pair&lt;iterator, bool&gt; try_emplace(const KeyT &amp;Key, Ts &amp;&amp;... Args) &#123;</span><br><span class="line">  BucketT *TheBucket;</span><br><span class="line">  <span class="comment">///根据key找桶</span></span><br><span class="line">  <span class="keyword">if</span> (LookupBucketFor(Key, TheBucket))</span><br><span class="line">    <span class="comment">///如果桶存在 则返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(</span><br><span class="line">             makeIterator(TheBucket, getBucketsEnd(), <span class="literal">true</span>),</span><br><span class="line">             <span class="literal">false</span>); <span class="comment">// Already in map.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Otherwise, insert the new element.</span></span><br><span class="line">  <span class="comment">///如果不存在则插入桶 并返回</span></span><br><span class="line">  TheBucket = InsertIntoBucket(TheBucket, Key, <span class="built_in">std</span>::forward&lt;Ts&gt;(Args)...);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(</span><br><span class="line">           makeIterator(TheBucket, getBucketsEnd(), <span class="literal">true</span>),</span><br><span class="line">           <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两个返回，都是通过<code>std::make_pair</code>生成相应的键值对。</p>
<ol>
<li>通过<code>LookupBucketFor</code>方法<code>查找桶</code>，如果map中已经<code>存在</code>，则<code>直接返回</code>，其中<code>make_pair</code>的第二个参数<code>bool值为false</code></li>
<li>如果没<code>有找到</code>，则通过<code>InsertIntoBucket</code>插入map，其中<code>make_pair</code>的第二个参数<code>bool值为true</code></li>
</ol>
<p>我们断点进来使用<code>lldb</code>调试</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b57bcdf62c24de9932bddcc72f87cc9~tplv-k3u1fbpfcp-watermark.image" alt="1626787367239"></p>
<p><code>p TheBucket</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p TheBucket</span><br><span class="line">(objc::detail::DenseMapPair&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt; *) $<span class="number">1</span> = <span class="number">0x0000000101c04200</span></span><br><span class="line">(lldb) p *$<span class="number">1</span></span><br><span class="line">(objc::detail::DenseMapPair&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt;) $<span class="number">2</span> = &#123;</span><br><span class="line">  <span class="built_in">std</span>::__1::pair&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt; = &#123;</span><br><span class="line">    first = (value = <span class="number">18446744069384153152</span>)</span><br><span class="line">    second = &#123;</span><br><span class="line">      Buckets = nil</span><br><span class="line">      NumEntries = <span class="number">0</span></span><br><span class="line">      NumTombstones = <span class="number">0</span></span><br><span class="line">      NumBuckets = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到<code>TheBucket</code>的类型与 <code>refs_result</code>中属性的类型是一致的。</p>
</li>
<li><p><code>LookupBucketFor</code>方法</p>
<p>我们进入<code>LookupBucketFor</code>源码发现有两个实现，它们的区别是<code>FoundBucket</code>的参数类型第一个实现多<code>const</code>修饰。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63c705dadb7446558d8876e8bb63a56e~tplv-k3u1fbpfcp-watermark.image" alt="1626786329854"></p>
<p>我们通过断点调试，发现调用的是第2个实现，第2个方法内部调用了第1个实现。我们先看第1个实现源码，注释中有流程说明。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> LookupKeyT&gt;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">LookupBucketFor</span><span class="params">(<span class="keyword">const</span> LookupKeyT &amp;Val,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> BucketT *&amp;FoundBucket)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> BucketT *BucketsPtr = getBuckets();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> NumBuckets = getNumBuckets();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (NumBuckets == <span class="number">0</span>) &#123;</span><br><span class="line">      FoundBucket = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// FoundTombstone - Keep track of whether we find a tombstone while probing.</span></span><br><span class="line">    <span class="keyword">const</span> BucketT *FoundTombstone = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">const</span> KeyT EmptyKey = getEmptyKey();</span><br><span class="line">    <span class="keyword">const</span> KeyT TombstoneKey = getTombstoneKey();</span><br><span class="line">    assert(!KeyInfoT::isEqual(Val, EmptyKey) &amp;&amp;</span><br><span class="line">           !KeyInfoT::isEqual(Val, TombstoneKey) &amp;&amp;</span><br><span class="line">           <span class="string">"Empty/Tombstone value shouldn't be inserted into map!"</span>);</span><br><span class="line">  	<span class="comment">///通过哈希函数得到BucketNo</span></span><br><span class="line">    <span class="keyword">unsigned</span> BucketNo = getHashValue(Val) &amp; (NumBuckets<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> ProbeAmt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;<span class="comment">//与catche_t查找imp类似，通过哈希查找</span></span><br><span class="line">      <span class="keyword">const</span> BucketT *ThisBucket = BucketsPtr + BucketNo;</span><br><span class="line">      <span class="comment">// Found Val's bucket?  If so, return it. 如果找到直接返回 true</span></span><br><span class="line">      <span class="keyword">if</span> (LLVM_LIKELY(KeyInfoT::isEqual(Val, ThisBucket-&gt;getFirst()))) &#123;</span><br><span class="line">        FoundBucket = ThisBucket;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">			</span><br><span class="line">      <span class="comment">// If we found an empty bucket, the key doesn't exist in the set.</span></span><br><span class="line">      <span class="comment">// Insert it and return the default value.</span></span><br><span class="line">      <span class="comment">//如果是一个空桶 说明key不在集合中，将key插入 返回false</span></span><br><span class="line">      <span class="keyword">if</span> (LLVM_LIKELY(KeyInfoT::isEqual(ThisBucket-&gt;getFirst(), EmptyKey))) &#123;</span><br><span class="line">        <span class="comment">// If we've already seen a tombstone while probing, fill it in instead</span></span><br><span class="line">        <span class="comment">// of the empty bucket we eventually probed to.</span></span><br><span class="line">        FoundBucket = FoundTombstone ? FoundTombstone : ThisBucket;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If this is a tombstone, remember it.  If Val ends up not in the map, we</span></span><br><span class="line">      <span class="comment">// prefer to return it than something that would require more probing.</span></span><br><span class="line">      <span class="comment">// Ditto for zero values.</span></span><br><span class="line">      <span class="comment">// 以上条件都不满足 BucketNo调整进行平移、再哈希继续查找</span></span><br><span class="line">      <span class="keyword">if</span> (KeyInfoT::isEqual(ThisBucket-&gt;getFirst(), TombstoneKey) &amp;&amp;</span><br><span class="line">          !FoundTombstone)</span><br><span class="line">        FoundTombstone = ThisBucket;  <span class="comment">// Remember the first tombstone found.</span></span><br><span class="line">      <span class="keyword">if</span> (ValueInfoT::isPurgeable(ThisBucket-&gt;getSecond())  &amp;&amp;  !FoundTombstone)</span><br><span class="line">        FoundTombstone = ThisBucket;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Otherwise, it's a hash collision or a tombstone, continue quadratic</span></span><br><span class="line">      <span class="comment">// probing.</span></span><br><span class="line">      <span class="keyword">if</span> (ProbeAmt &gt; NumBuckets) &#123;</span><br><span class="line">        FatalCorruptHashTables(BucketsPtr, NumBuckets);</span><br><span class="line">      &#125;</span><br><span class="line">      BucketNo += ProbeAmt++;</span><br><span class="line">      BucketNo &amp;= (NumBuckets<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>第2个<code>LookupBucketFor</code>的实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LookupBucketFor</span><span class="params">(<span class="keyword">const</span> LookupKeyT &amp;Val, BucketT *&amp;FoundBucket)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> BucketT *ConstFoundBucket;<span class="comment">//空的桶</span></span><br><span class="line">  <span class="keyword">bool</span> Result = <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> DenseMapBase *&gt;(<span class="keyword">this</span>)</span><br><span class="line">    -&gt;LookupBucketFor(Val, ConstFoundBucket);<span class="comment">//调用第一个LookupBucketFor方法查找</span></span><br><span class="line">  FoundBucket = <span class="keyword">const_cast</span>&lt;BucketT *&gt;(ConstFoundBucket);<span class="comment">//如果找到复制给第二个参数，因为第二个参数是引用类型会直接让调用的地方获取到值。也就是try_emplace方法的TheBucket</span></span><br><span class="line">  <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>继续走<code>value</code>为<code>true</code>的流程</p>
<p>后面还会执行<code>try_emplace</code>方法，我们在执行之前查看一下<code>refs</code>的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p refs</span><br><span class="line">(objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt;) $<span class="number">3</span> = &#123;</span><br><span class="line">  Buckets = nil</span><br><span class="line">  NumEntries = <span class="number">0</span></span><br><span class="line">  NumTombstones = <span class="number">0</span></span><br><span class="line">  NumBuckets = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>try_emplace</code>方法之后<code>refs</code>的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p refs</span><br><span class="line">(objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt;) $<span class="number">4</span> = &#123;</span><br><span class="line">  Buckets = <span class="number">0x0000000100711390</span></span><br><span class="line">  NumEntries = <span class="number">1</span></span><br><span class="line">  NumTombstones = <span class="number">0</span></span><br><span class="line">  NumBuckets = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次执行<code>try_emplace</code>插入的是一个空桶，还没有值，第二次执行第一次执行<code>try_emplace</code>才插入值，即往空桶中插入<code>ObjectAssociationMap（value，policy）</code>，返回true。</p>
<p>此时<code>result.second</code>为<code>true</code>，此时属性的<code>value</code>就关联上了。</p>
</li>
</ul>
<h5 id="关联对象结构"><a href="#关联对象结构" class="headerlink" title="关联对象结构"></a>关联对象结构</h5><p>关联对象的设置图如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/518c45cdebd6464199f8f249c2f0a134~tplv-k3u1fbpfcp-watermark.image" alt="关联对象"></p>
<p>属性设计的哈希表结构如下：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0aee709a499d45c8a1aa14d9be1f626b~tplv-k3u1fbpfcp-watermark.image" alt="关联对象哈希表"></p>
<p>map中有很多的关联对象map，类型是<code>ObjectAssociationMap</code>，其中key为<code>DisguisedPtr&lt;objc_object&gt;</code>，例如<code>JSPerson</code>会对应一个<code>ObjectAssociationMap</code>，<code>JSTeacher</code>也会对应一个<code>ObjectAssociationMap</code>。</p>
<p><code>ObjectAssociationMap</code>哈希表中有很多<code>key-value</code>键值对，其中<code>key</code>的类型为<code>const void *</code>，其实这个<code>key</code>从底层这个方法<code>_object_set_associative_reference(id object, const void *key, id value, uintptr_t policy)</code>的参数就可以看出，<code>key</code>是我们关联属性时<code>设置的字符串</code>，<code>value</code>的类型为<code>ObjcAssociation</code></p>
<h5 id="value为空流程"><a href="#value为空流程" class="headerlink" title="value为空流程"></a><code>value</code>为空流程</h5><p>这个过程其实就是<code>else</code>流程，也就是我们对<code>value</code>设置为<code>nil</code>的流程，主要就是移除关联。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">auto</span> refs_it = associations.<span class="built_in">find</span>(disguised);</span><br><span class="line">     <span class="keyword">if</span> (refs_it != associations.<span class="built_in">end</span>()) &#123;</span><br><span class="line">         <span class="keyword">auto</span> &amp;refs = refs_it-&gt;second;</span><br><span class="line">         <span class="keyword">auto</span> it = refs.<span class="built_in">find</span>(key);</span><br><span class="line">         <span class="keyword">if</span> (it != refs.<span class="built_in">end</span>()) &#123;</span><br><span class="line">             association.swap(it-&gt;second);</span><br><span class="line">             refs.erase(it);</span><br><span class="line">             <span class="keyword">if</span> (refs.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                 associations.erase(refs_it);</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>根据 DisguisedPtr 找到 AssociationsHashMap 中的 iterator 迭代查询器</li>
<li>清理迭代器</li>
<li>实际上如果插入空置 相当于清除</li>
</ul>
<h4 id="objc-getAssociatedObject流程"><a href="#objc-getAssociatedObject流程" class="headerlink" title="objc_getAssociatedObject流程"></a>objc_getAssociatedObject流程</h4><h5 id="在main方法中添加一个取值的语句"><a href="#在main方法中添加一个取值的语句" class="headerlink" title="在main方法中添加一个取值的语句"></a>在<code>main</code>方法中添加一个取值的语句</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        JSPerson *person &#x3D; [[JSPerson alloc] init];</span><br><span class="line">        person.category_name &#x3D; @&quot;哈哈哈&quot;;</span><br><span class="line">        NSString *name &#x3D; person.category_name;</span><br><span class="line">        NSLog(@&quot;done&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="objc-getAssociatedObject源码实现"><a href="#objc-getAssociatedObject源码实现" class="headerlink" title="objc_getAssociatedObject源码实现"></a><code>objc_getAssociatedObject</code>源码实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">objc_getAssociatedObject(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _object_get_associative_reference(object, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>_object_get_associative_reference</code>函数。</p>
<h5 id="object-get-associative-reference源码"><a href="#object-get-associative-reference源码" class="headerlink" title="_object_get_associative_reference源码"></a><code>_object_get_associative_reference</code>源码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">_object_get_associative_reference(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    ObjcAssociation association&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      	<span class="comment">///创建AssociationsManager管理类</span></span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">      	<span class="comment">///获取静态哈希表</span></span><br><span class="line">        <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.<span class="built_in">get</span>())</span></span>;</span><br><span class="line">      	<span class="comment">/////找到迭代器，即获取buckets</span></span><br><span class="line">        AssociationsHashMap::iterator i = associations.<span class="built_in">find</span>((objc_object *)object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.<span class="built_in">end</span>()) &#123;<span class="comment">//如果这个迭代查询器不是最后一个 继续获取</span></span><br><span class="line">            <span class="comment">//找到ObjectAssociationMap的迭代查询器获取一个经过属性修饰符修饰的value</span></span><br><span class="line">            ObjectAssociationMap &amp;refs = i-&gt;second;</span><br><span class="line">          	<span class="comment">//根据key查找ObjectAssociationMap，即获取bucket</span></span><br><span class="line">            ObjectAssociationMap::iterator j = refs.<span class="built_in">find</span>(key);</span><br><span class="line">            <span class="keyword">if</span> (j != refs.<span class="built_in">end</span>()) &#123;</span><br><span class="line">              	<span class="comment">//获取ObjcAssociation</span></span><br><span class="line">                association = j-&gt;second;</span><br><span class="line">                association.retainReturnedValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">///返回值</span></span><br><span class="line">    <span class="keyword">return</span> association.autoreleaseReturnedValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看源码分析主要分为以下几步</p>
<ul>
<li>创建一个 <code>AssociationsManager</code> 管理类</li>
<li>获取静态哈希表：<code>AssociationsHashMap</code></li>
<li>通过<code>find</code>方法根据 <code>DisguisedPtr</code> 找到 <code>AssociationsHashMap</code> 中的 <code>iterator</code> 迭代查询器</li>
<li>如果这个迭代查询器不是最后一个 继续获取 : <code>ObjectAssociationMap (policy和value)</code></li>
<li>通过<code>find</code>方法找到<code>ObjectAssociationMap</code>的迭代查询器获取一个经过属性修饰符修饰的<code>value</code></li>
<li>返回 <code>value</code></li>
</ul>
<h5 id="查找方法find"><a href="#查找方法find" class="headerlink" title="查找方法find"></a>查找方法<code>find</code></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(<span class="keyword">const_arg_type_t</span>&lt;KeyT&gt; Val)</span> </span>&#123;</span><br><span class="line">  BucketT *TheBucket;</span><br><span class="line">  <span class="keyword">if</span> (LookupBucketFor(Val, TheBucket))</span><br><span class="line">    <span class="keyword">return</span> makeIterator(TheBucket, getBucketsEnd(), <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据关联对象迭代查找<code>AssociationsHashMap</code>，也就是<code>buckets</code></p>
<h5 id="通过源码看取值流程"><a href="#通过源码看取值流程" class="headerlink" title="通过源码看取值流程"></a>通过源码看取值流程</h5><p>我们直接断点到<code>_object_get_associative_reference</code>函数</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd50af8bbb204b1b92447fa2a245d626~tplv-k3u1fbpfcp-watermark.image" alt="1626789232319"></p>
<p>执行<code>p i</code>和<code>p i-&gt;second</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p i</span><br><span class="line">(objc::DenseMapBase&lt;objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt;, objc::DenseMapValueInfo&lt;objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt;, objc::DenseMapInfo&lt;DisguisedPtr&lt;objc_object&gt; &gt;, objc::detail::DenseMapPair&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt; &gt;, DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt;, objc::DenseMapValueInfo&lt;objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt;, objc::DenseMapInfo&lt;DisguisedPtr&lt;objc_object&gt; &gt;, objc::detail::DenseMapPair&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt; &gt;::iterator) $<span class="number">0</span> = &#123;</span><br><span class="line">  Ptr = <span class="number">0x0000000100631d60</span></span><br><span class="line">  End = <span class="number">0x0000000100631d80</span></span><br><span class="line">&#125;</span><br><span class="line">(lldb) p i-&gt;second</span><br><span class="line">(objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt;) $<span class="number">1</span> = &#123;</span><br><span class="line">  Buckets = <span class="number">0x0000000100631d80</span></span><br><span class="line">  NumEntries = <span class="number">1</span></span><br><span class="line">  NumTombstones = <span class="number">0</span></span><br><span class="line">  NumBuckets = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次执行<code>find</code>方法，在调用<code>find</code>方法之前，我们先打印<code>j</code>,此时<code>value</code>为<code>nil</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p j</span><br><span class="line">(objc::DenseMapBase&lt;objc::DenseMap&lt;const void *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;const void *&gt;, objc::detail::DenseMapPair&lt;const void *, objc::ObjcAssociation&gt; &gt;, const void *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;const void *&gt;, objc::detail::DenseMapPair&lt;const void *, objc::ObjcAssociation&gt; &gt;::iterator) $2 &#x3D; &#123;</span><br><span class="line">  Ptr &#x3D; 0x00007ffeefbff400</span><br><span class="line">  End &#x3D; 0x00000001002e70db</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p j-&gt;second</span><br><span class="line">(objc::ObjcAssociation) $3 &#x3D; &#123;</span><br><span class="line">  _policy &#x3D; 4294980472</span><br><span class="line">  _value &#x3D; nil</span><br><span class="line">&#125;</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>执行<code>find</code>方法之后再次打印,发现<code>value</code>已经有值，也就是取到了关联对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p j</span><br><span class="line">(objc::DenseMapBase&lt;objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt;, <span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt;::iterator) $<span class="number">4</span> = &#123;</span><br><span class="line">  Ptr = <span class="number">0x0000000100631d80</span></span><br><span class="line">  End = <span class="number">0x0000000100631de0</span></span><br><span class="line">&#125;</span><br><span class="line">(lldb) p j-&gt;second</span><br><span class="line">(objc::ObjcAssociation) $<span class="number">5</span> = &#123;</span><br><span class="line">  _policy = <span class="number">3</span></span><br><span class="line">  _value = <span class="number">0x0000000100004080</span> <span class="string">"哈哈哈"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇主要探索了<code>扩展</code>和<code>关联对象</code>，其中<code>类的扩展</code> 在<code>编译期</code> 会作为类的一部分，和类一起编译进来。</p>
<p>关联对象设置流程为：</p>
<ul>
<li>创建一个<code>AssociationsManager</code>管理类</li>
<li>获取<code>静态哈希表</code>:<code>associations</code></li>
<li>判断<code>关联值value</code>是否为空<ul>
<li>如果为空就走：<code>插入空值</code>流程。</li>
<li>如果不为空继续下一步</li>
</ul>
</li>
<li>通过<code>try_emplace</code>方法，创建一个空的 <code>ObjectAssociationMap</code> 去取查询的键值对</li>
<li>如果发现<code>没有</code> <code>key</code> 就<code>插入一个 空的 BucketT</code>进去并返回true</li>
<li>通过<code>setHasAssociatedObjects</code>方法<code>标记对象存在关联对象</code></li>
<li>用当前 <code>policy 和 value</code> 组成了一个 <code>ObjcAssociation</code> 替换原来 <code>BucketT</code>中的值</li>
<li>标记一下 <code>ObjectAssociationMap</code> 的<code>第一次</code>为 <code>false</code></li>
</ul>
<p>关联对象取值的流程为：</p>
<ul>
<li>创建一个 <code>AssociationsManager</code> 管理类</li>
<li>获取静态哈希表：<code>AssociationsHashMap</code></li>
<li>通过<code>find</code>方法根据 <code>DisguisedPtr</code> 找到 <code>AssociationsHashMap</code> 中的 <code>iterator</code> 迭代查询器</li>
<li>如果这个迭代查询器不是最后一个 继续获取 : <code>ObjectAssociationMap (policy和value)</code></li>
<li>通过<code>find</code>方法找到<code>ObjectAssociationMap</code>的迭代查询器获取一个经过属性修饰符修饰的<code>value</code></li>
<li>返回 <code>value</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/07/18/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD-%E4%B8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/18/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD-%E4%B8%8B/" class="post-title-link" itemprop="url">iOS底层探索-类的加载(下)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-18 14:03:41 / 修改时间：20:37:27" itemprop="dateCreated datePublished" datetime="2021-07-18T14:03:41+08:00">2021-07-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文我们研究分类的加载流程。</p>
<h3 id="分类的本质"><a href="#分类的本质" class="headerlink" title="分类的本质"></a>分类的本质</h3><p>在研究<code>对象</code>、<code>类</code>的本质的时候，我们都用<code>clang</code>命令将<code>main.m</code>转换成<code>main.cpp</code>文件查看其本质，<code>分类</code>也不例外，我们使用相同的方法分析。</p>
<p>首先我们定义一个<code>JSPerson</code>的分类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface JSPerson (TestLoad)</span><br><span class="line"></span><br><span class="line">- (void)sayCategory;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation JSPerson (TestLoad)</span><br><span class="line"></span><br><span class="line">- (void)sayCategory&#123;</span><br><span class="line">    NSLog(@&quot;JSPersonCategpry say : %s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    NSLog(@&quot;JSPersonCategpry load&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>然后在<code>main.m</code>文件中使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        JSPerson *p &#x3D; [JSPerson alloc];</span><br><span class="line">        [p sayCategory];</span><br><span class="line">        NSLog(@&quot;Hello, World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们执行：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m -o main.cpp</span><br></pre></td></tr></table></figure>

<p>我们打开<code>main.cpp</code>文件，找到分类相关的代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> *<span class="title">L_OBJC_LABEL_CATEGORY_</span>$ [1] __<span class="title">attribute__</span>((<span class="title">used</span>, <span class="title">section</span> ("__<span class="title">DATA</span>, __<span class="title">objc_catlist</span>,<span class="title">regular</span>,<span class="title">no_dead_strip</span>")))= &#123;</span></span><br><span class="line">	&amp;_OBJC_$_CATEGORY_JSPerson_$_TestLoad,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">class_t</span> *<span class="title">cls</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">method_list_t</span> *<span class="title">instance_methods</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">method_list_t</span> *<span class="title">class_methods</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">prop_list_t</span> *<span class="title">properties</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们从源码里也能搜索到它的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">classref_t</span> cls;</span><br><span class="line">    WrappedPtr&lt;<span class="keyword">method_list_t</span>, PtrauthStrip&gt; instanceMethods;</span><br><span class="line">    WrappedPtr&lt;<span class="keyword">method_list_t</span>, PtrauthStrip&gt; classMethods;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span></span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *_<span class="title">classProperties</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">method_list_t</span> *<span class="title">methodsForMeta</span><span class="params">(<span class="keyword">bool</span> isMeta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">property_list_t</span> *<span class="title">propertiesForMeta</span><span class="params">(<span class="keyword">bool</span> isMeta, struct header_info *hi)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protocol_list_t</span> *<span class="title">protocolsForMeta</span><span class="params">(<span class="keyword">bool</span> isMeta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> protocols;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>分类</code>的本质是<code>结构体</code>：<code>category_t</code>。</p>
<p>我们继续回到<code>_read_images</code>函数探索。</p>
<h3 id="rwe的赋值"><a href="#rwe的赋值" class="headerlink" title="rwe的赋值"></a>rwe的赋值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> rwe = cls-&gt;data()-&gt;extAllocIfNeeded();</span><br></pre></td></tr></table></figure>

<p><code>extAllocIfNeeded</code>方法的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class_rw_ext_t</span> *<span class="title">extAllocIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> v = get_ro_or_rwe();</span><br><span class="line">    <span class="keyword">if</span> (fastpath(v.is&lt;<span class="keyword">class_rw_ext_t</span> *&gt;())) &#123;</span><br><span class="line">          <span class="keyword">return</span> v.<span class="built_in">get</span>&lt;<span class="keyword">class_rw_ext_t</span> *&gt;(&amp;ro_or_rw_ext);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> extAlloc(v.<span class="built_in">get</span>&lt;<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *&gt;(&amp;ro_or_rw_ext));</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class_rw_ext_t</span> *</span><br><span class="line"><span class="keyword">class_rw_t</span>::extAlloc(<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro, <span class="keyword">bool</span> deepCopy)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> rwe = objc::zalloc&lt;<span class="keyword">class_rw_ext_t</span>&gt;();</span><br><span class="line"></span><br><span class="line">    rwe-&gt;version = (ro-&gt;flags &amp; RO_META) ? <span class="number">7</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">method_list_t</span> *<span class="built_in">list</span> = ro-&gt;baseMethods();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deepCopy) <span class="built_in">list</span> = <span class="built_in">list</span>-&gt;duplicate();</span><br><span class="line">        rwe-&gt;methods.attachLists(&amp;<span class="built_in">list</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See comments in objc_duplicateClass</span></span><br><span class="line">    <span class="comment">// property lists and protocol lists historically</span></span><br><span class="line">    <span class="comment">// have not been deep-copied</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This is probably wrong and ought to be fixed some day</span></span><br><span class="line">    <span class="keyword">property_list_t</span> *proplist = ro-&gt;baseProperties;</span><br><span class="line">    <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">        rwe-&gt;properties.attachLists(&amp;proplist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protocol_list_t</span> *protolist = ro-&gt;baseProtocols;</span><br><span class="line">    <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">        rwe-&gt;protocols.attachLists(&amp;protolist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set_ro_or_rwe(rwe, ro);</span><br><span class="line">    <span class="keyword">return</span> rwe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>auto rwe = cls-&gt;data()-&gt;extAllocIfNeeded();</code>是进行rwe的创建,那么为什么要在这里进行<code>rwe的初始化</code>？？因为我们现在要做一件事：往<code>本类</code>中<code>添加属性、方法、协议</code>等,即对原来的 clean memory要进行处理了</p>
<ul>
<li>进入<code>extAllocIfNeeded</code>方法的源码实现，判断rwe是否存在，如果存在则直接获取，如果不存在则开辟</li>
<li>进入<code>extAlloc</code>源码实现，即对rwe 0-1的过程，在此过程中，就将<code>本类的data数据</code>加载进去了</li>
<li>其中关键代码是<code>rwe-&gt;methods.attachLists(mlists + ATTACH_BUFSIZ - mcount, mcount);</code>即存入mlists的末尾，<code>mlists</code>的数据来源前面的<code>for循环</code></li>
<li>在调试运行时，发现<code>category_t</code>中的<code>name</code>编译时是<code>JSPerson</code>（参考clang编译时的那么），运行时是<code>TestLoad</code>即分类的名字</li>
<li>代码<code>mlists[ATTACH_BUFSIZ - ++mcount] = mlist;</code>，经过调试发现此时的<code>mcount</code>等于<code>1</code>，即可以理解为 <code>倒序插入</code>,<code>64</code>的原因是允许容纳64个（最多64个分类）</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>本类 中 需要添加属性、方法等，所以需要<code>初始化rwe</code>,rwe的初始化主要涉及：<code>分类、addMethod、addProperty、addprotocol</code> ， 即<code>对原始类进行修改或者处理时(运行时)，才会进行rwe的初始化</code></p>
<h3 id="attachCategories"><a href="#attachCategories" class="headerlink" title="attachCategories"></a>attachCategories</h3><p>通过<code>attachCategories</code>反推<code>分类的加载</code>，我们<code>libobjc</code>源码全局搜索<code>attachCategories</code>的调用，发现有两个地方调用：<code>attachToClass</code>和<code>load_categories_nolock</code>。</p>
<p>####attachToClass</p>
<p>调用<code>attachToClass</code>的方法只有一个<code>methodizeClass</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodizeClass</span><span class="params">(Class cls, Class previously)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">///省略代码</span></span><br><span class="line">    <span class="keyword">if</span> (previously) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) &#123;</span><br><span class="line">            objc::unattachedCategories.attachToClass(cls, previously,</span><br><span class="line">                                                     ATTACH_METACLASS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// When a class relocates, categories with class methods</span></span><br><span class="line">            <span class="comment">// may be registered on the class itself rather than on</span></span><br><span class="line">            <span class="comment">// the metaclass. Tell attachToClass to look for those.</span></span><br><span class="line">            objc::unattachedCategories.attachToClass(cls, previously,</span><br><span class="line">                                                     ATTACH_CLASS_AND_METACLASS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    objc::unattachedCategories.attachToClass(cls, cls,</span><br><span class="line">                                             isMeta ? ATTACH_METACLASS : ATTACH_CLASS);</span><br><span class="line">		<span class="comment">///省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个<code>previously</code>执行条件，我们依次网上查找调用链，发现<code>previously==nil</code>,<code>previously</code>参数只是方便动态化调试，所以实际调用的只有下面这一处代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc::unattachedCategories.attachToClass(cls, cls,</span><br><span class="line">                                             isMeta ? ATTACH_METACLASS : ATTACH_CLASS);</span><br></pre></td></tr></table></figure>

<h4 id="load-categories-nolock"><a href="#load-categories-nolock" class="headerlink" title="load_categories_nolock"></a>load_categories_nolock</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load_categories_nolock</span><span class="params">(header_info *hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    <span class="keyword">auto</span> processCatlist = [&amp;](<span class="keyword">category_t</span> * <span class="keyword">const</span> *catlist) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">category_t</span> *cat = catlist[i];</span><br><span class="line">            Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">            <span class="keyword">locstamped_category_t</span> lc&#123;cat, hi&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">                <span class="comment">// Category's target class is missing (probably weak-linked).</span></span><br><span class="line">                <span class="comment">// Ignore the category.</span></span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"CLASS: IGNORING category \?\?\?(%s) %p with "</span></span><br><span class="line">                                 <span class="string">"missing weak-linked target class"</span>,</span><br><span class="line">                                 cat-&gt;name, cat);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process this category.</span></span><br><span class="line">            <span class="keyword">if</span> (cls-&gt;isStubClass()) &#123;</span><br><span class="line">                <span class="comment">// Stub classes are never realized. Stub classes</span></span><br><span class="line">                <span class="comment">// don't know their metaclass until they're</span></span><br><span class="line">                <span class="comment">// initialized, so we have to add categories with</span></span><br><span class="line">                <span class="comment">// class methods or properties to the stub itself.</span></span><br><span class="line">                <span class="comment">// methodizeClass() will find them and add them to</span></span><br><span class="line">                <span class="comment">// the metaclass as appropriate.</span></span><br><span class="line">                <span class="keyword">if</span> (cat-&gt;instanceMethods ||</span><br><span class="line">                    cat-&gt;protocols ||</span><br><span class="line">                    cat-&gt;instanceProperties ||</span><br><span class="line">                    cat-&gt;classMethods ||</span><br><span class="line">                    cat-&gt;protocols ||</span><br><span class="line">                    (hasClassProperties &amp;&amp; cat-&gt;_classProperties))</span><br><span class="line">                &#123;</span><br><span class="line">                    objc::unattachedCategories.addForClass(lc, cls);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// First, register the category with its target class.</span></span><br><span class="line">                <span class="comment">// Then, rebuild the class's method lists (etc) if</span></span><br><span class="line">                <span class="comment">// the class is realized.</span></span><br><span class="line">                <span class="keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols</span><br><span class="line">                    ||  cat-&gt;instanceProperties)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cls-&gt;isRealized()) &#123;</span><br><span class="line">                        attachCategories(cls, &amp;lc, <span class="number">1</span>, ATTACH_EXISTING);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        objc::unattachedCategories.addForClass(lc, cls);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols</span><br><span class="line">                    ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">                        attachCategories(cls-&gt;ISA(), &amp;lc, <span class="number">1</span>, ATTACH_EXISTING | ATTACH_METACLASS);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        objc::unattachedCategories.addForClass(lc, cls-&gt;ISA());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    processCatlist(hi-&gt;catlist(&amp;count));</span><br><span class="line">    processCatlist(hi-&gt;catlist2(&amp;count));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局搜素<code>load_categories_nolock</code>,发现调用<code>load_categories_nolock</code>的地方有两处</p>
<ul>
<li><code>loadAllCategories</code></li>
<li><code>_read_images</code></li>
</ul>
<p>但是经过调试发现，是不会走<code>_read_images</code>方法中的if流程的，而是走的<code>loadAllCategories</code>方法中的。</p>
<h4 id="attachLists"><a href="#attachLists" class="headerlink" title="attachLists"></a>attachLists</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachLists</span><span class="params">(List* <span class="keyword">const</span> * addedLists, <span class="keyword">uint32_t</span> addedCount)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">         <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">         <span class="keyword">uint32_t</span> oldCount = <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">         <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">         <span class="keyword">array_t</span> *newArray = (<span class="keyword">array_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">array_t</span>::byteSize(newCount));</span><br><span class="line">         newArray-&gt;count = newCount;</span><br><span class="line">         <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                newArray-&gt;lists[i + addedCount] = <span class="built_in">array</span>()-&gt;lists[i];</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; addedCount; i++)</span><br><span class="line">             newArray-&gt;lists[i] = addedLists[i];</span><br><span class="line">         <span class="built_in">free</span>(<span class="built_in">array</span>());</span><br><span class="line">         setArray(newArray);</span><br><span class="line">         validate();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">list</span>  &amp;&amp;  addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">         <span class="comment">// 0 lists -&gt; 1 list</span></span><br><span class="line">         <span class="built_in">list</span> = addedLists[<span class="number">0</span>];</span><br><span class="line">         validate();</span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 1 list -&gt; many lists</span></span><br><span class="line">         Ptr&lt;List&gt; oldList = <span class="built_in">list</span>;</span><br><span class="line">         <span class="keyword">uint32_t</span> oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">         setArray((<span class="keyword">array_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">         <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">         <span class="keyword">if</span> (oldList) <span class="built_in">array</span>()-&gt;lists[addedCount] = oldList;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; addedCount; i++)</span><br><span class="line">             <span class="built_in">array</span>()-&gt;lists[i] = addedLists[i];</span><br><span class="line">         validate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个函数一共三部分我们分别看：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">list</span>  &amp;&amp;  addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 0 lists -&gt; 1 list</span></span><br><span class="line">      <span class="built_in">list</span> = addedLists[<span class="number">0</span>];</span><br><span class="line">       validate();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>把<code>addedLists[0]</code>赋值给<code>list</code>,<code>list</code>是一维数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 1 list -&gt; many lists</span></span><br><span class="line">      Ptr&lt;List&gt; oldList = <span class="built_in">list</span>;</span><br><span class="line">      <span class="keyword">uint32_t</span> oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">      setArray((<span class="keyword">array_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">      <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">      <span class="keyword">if</span> (oldList) <span class="built_in">array</span>()-&gt;lists[addedCount] = oldList;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; addedCount; i++)</span><br><span class="line">          <span class="built_in">array</span>()-&gt;lists[i] = addedLists[i];</span><br><span class="line">      validate();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这个情况是<code>list</code>不为空，新建一个扩容的数组，将之前的数据放在<code>lists[addedCount]</code>位置，新元素放到之前<code>list</code>的前面。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">    <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">    <span class="keyword">uint32_t</span> oldCount = <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">    <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">    <span class="keyword">array_t</span> *newArray = (<span class="keyword">array_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">array_t</span>::byteSize(newCount));</span><br><span class="line">    newArray-&gt;count = newCount;</span><br><span class="line">    <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">           newArray-&gt;lists[i + addedCount] = <span class="built_in">array</span>()-&gt;lists[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; addedCount; i++)</span><br><span class="line">        newArray-&gt;lists[i] = addedLists[i];</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">array</span>());</span><br><span class="line">    setArray(newArray);</span><br><span class="line">    validate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段其实和上次类似，依然将新数组插入到前面，新数组中的新元素在数组首部。</p>
<h3 id="分类加载的四种情况"><a href="#分类加载的四种情况" class="headerlink" title="分类加载的四种情况"></a>分类加载的四种情况</h3><p>根据<code>类</code>和<code>分类</code>是否实现<code>+load()</code>方法分为四种情况。</p>
<p>我们先定义<code>JSPerson</code>及它的<code>分类</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@interface JSPerson : NSObject</span><br><span class="line"></span><br><span class="line">- (void)sayHello;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">#import &quot;JSPerson.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation JSPerson</span><br><span class="line"></span><br><span class="line">- (void)sayHello&#123;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;JSPerson say : Hello!!!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)load&#123;&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@interface JSPerson (Test)</span><br><span class="line"></span><br><span class="line">- (void)saySomething;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">#import &quot;JSPerson+Test.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation JSPerson (Test)</span><br><span class="line"></span><br><span class="line">- (void)saySomething&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)load&#123;&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>



<h4 id="非懒加载分类和非懒加载类"><a href="#非懒加载分类和非懒加载类" class="headerlink" title="非懒加载分类和非懒加载类"></a>非懒加载分类和非懒加载类</h4><p>我们在<code>JSPerson</code>类和分类中都实现<code>load</code>，我们在<code>realizeClassWithoutSwift</code>添加断点</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbe0d82210524777a295602d1a33f6f7~tplv-k3u1fbpfcp-watermark.image" alt="类和分类都是非懒加载分类加载"></p>
<p>我们用<code>lldb</code>打印当前<code>ro</code>的方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">readClass JSPerson....</span><br><span class="line">_read_images JSPerson....</span><br><span class="line">(lldb) p ro</span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *) $<span class="number">0</span> = <span class="number">0x0000000100004280</span></span><br><span class="line">(lldb) p *$<span class="number">0</span></span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">class_ro_t</span>) $<span class="number">1</span> = &#123;</span><br><span class="line">  flags = <span class="number">0</span></span><br><span class="line">  instanceStart = <span class="number">8</span></span><br><span class="line">  instanceSize = <span class="number">8</span></span><br><span class="line">  reserved = <span class="number">0</span></span><br><span class="line">   = &#123;</span><br><span class="line">    ivarLayout = <span class="number">0x0000000000000000</span></span><br><span class="line">    nonMetaclass = nil</span><br><span class="line">  &#125;</span><br><span class="line">  name = &#123;</span><br><span class="line">    <span class="built_in">std</span>::__1::atomic&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; = <span class="string">"JSPerson"</span> &#123;</span><br><span class="line">      Value = <span class="number">0x0000000100003bbc</span> <span class="string">"JSPerson"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  baseMethodList = <span class="number">0x00000001000042c8</span></span><br><span class="line">  baseProtocols = <span class="number">0x0000000000000000</span></span><br><span class="line">  ivars = <span class="number">0x0000000000000000</span></span><br><span class="line">  weakIvarLayout = <span class="number">0x0000000000000000</span></span><br><span class="line">  baseProperties = <span class="number">0x0000000000000000</span></span><br><span class="line">  _swiftMetadataInitializer_NEVER_USE = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">1.b</span>aseMethods()</span><br><span class="line">(<span class="keyword">method_list_t</span> *) $<span class="number">2</span> = <span class="number">0x00000001000042c8</span></span><br><span class="line">(lldb) p *$<span class="number">2</span></span><br><span class="line">(<span class="keyword">method_list_t</span>) $<span class="number">3</span> = &#123;</span><br><span class="line">  entsize_list_tt&lt;<span class="keyword">method_t</span>, <span class="keyword">method_list_t</span>, <span class="number">4294901763</span>, <span class="keyword">method_t</span>::pointer_modifier&gt; = (entsizeAndFlags = <span class="number">24</span>, count = <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">3.</span><span class="built_in">get</span>(<span class="number">0</span>).big()</span><br><span class="line">(<span class="keyword">method_t</span>::big) $<span class="number">4</span> = &#123;</span><br><span class="line">  name = <span class="string">"sayHello"</span></span><br><span class="line">  types = <span class="number">0x0000000100003cfd</span> <span class="string">"v16@0:8"</span></span><br><span class="line">  imp = <span class="number">0x00000001000036b0</span> (KCObjcBuild`-[JSPerson sayHello])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现此时只有<code>类</code>的方法，并没有<code>分类</code>的方法，说明<code>分类</code>目前还没有加载。</p>
<p>我们在<code>attachCategories</code>添加断点，继续执行代码：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1dd3596aa214f329bc1ad2d90806c03~tplv-k3u1fbpfcp-watermark.image" alt="非懒加载分类"></p>
<p>继续用<code>lldb</code>调试程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p mlist</span><br><span class="line">(<span class="keyword">method_list_t</span> *) $<span class="number">5</span> = <span class="number">0x0000000100004420</span></span><br><span class="line">(lldb) p *$<span class="number">5</span></span><br><span class="line">(<span class="keyword">method_list_t</span>) $<span class="number">6</span> = &#123;</span><br><span class="line">  entsize_list_tt&lt;<span class="keyword">method_t</span>, <span class="keyword">method_list_t</span>, <span class="number">4294901763</span>, <span class="keyword">method_t</span>::pointer_modifier&gt; = (entsizeAndFlags = <span class="number">24</span>, count = <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">6.</span><span class="built_in">get</span>(<span class="number">0</span>).big()</span><br><span class="line">(<span class="keyword">method_t</span>::big) $<span class="number">7</span> = &#123;</span><br><span class="line">  name = <span class="string">"saySomething"</span></span><br><span class="line">  types = <span class="number">0x0000000100003cfd</span> <span class="string">"v16@0:8"</span></span><br><span class="line">  imp = <span class="number">0x00000001000037f0</span> (KCObjcBuild`-[JSPerson(Test) saySomething])</span><br><span class="line">&#125;</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>说明现在分类被加载了，被加载到了<code>rwe</code>中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rwe-&gt;methods.attachLists(mlists + ATTACH_BUFSIZ - mcount, mcount);</span><br></pre></td></tr></table></figure>

<p>注意：<code>ATTACH_BUFSIZ=64</code>也就是说<code>分类</code>的方法个数不能大于64。</p>
<h4 id="非懒加载分类和懒加载类"><a href="#非懒加载分类和懒加载类" class="headerlink" title="非懒加载分类和懒加载类"></a>非懒加载分类和懒加载类</h4><p>我们删除<code>JSPerson</code>类的<code>load</code>方法，重新运行程序。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbe0d82210524777a295602d1a33f6f7~tplv-k3u1fbpfcp-watermark.image" alt="类和分类都是非懒加载分类加载"></p>
<p>继续在我们第一个断点位置使用<code>lldb</code>调试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">_read_images JSPerson....</span><br><span class="line">(lldb) p ro</span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *) $<span class="number">0</span> = <span class="number">0x00000001000042a8</span></span><br><span class="line">(lldb) p *$<span class="number">0</span></span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">class_ro_t</span>) $<span class="number">1</span> = &#123;</span><br><span class="line">  flags = <span class="number">0</span></span><br><span class="line">  instanceStart = <span class="number">8</span></span><br><span class="line">  instanceSize = <span class="number">8</span></span><br><span class="line">  reserved = <span class="number">0</span></span><br><span class="line">   = &#123;</span><br><span class="line">    ivarLayout = <span class="number">0x0000000000000000</span></span><br><span class="line">    nonMetaclass = nil</span><br><span class="line">  &#125;</span><br><span class="line">  name = &#123;</span><br><span class="line">    <span class="built_in">std</span>::__1::atomic&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; = <span class="string">"JSPerson"</span> &#123;</span><br><span class="line">      Value = <span class="number">0x0000000100003bbc</span> <span class="string">"JSPerson"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  baseMethodList = <span class="number">0x0000000100004178</span></span><br><span class="line">  baseProtocols = <span class="number">0x0000000000000000</span></span><br><span class="line">  ivars = <span class="number">0x0000000000000000</span></span><br><span class="line">  weakIvarLayout = <span class="number">0x0000000000000000</span></span><br><span class="line">  baseProperties = <span class="number">0x0000000000000000</span></span><br><span class="line">  _swiftMetadataInitializer_NEVER_USE = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">1.b</span>aseMethods()</span><br><span class="line">(<span class="keyword">method_list_t</span> *) $<span class="number">2</span> = <span class="number">0x0000000100004178</span></span><br><span class="line">(lldb) p *$<span class="number">2</span></span><br><span class="line">(<span class="keyword">method_list_t</span>) $<span class="number">3</span> = &#123;</span><br><span class="line">  entsize_list_tt&lt;<span class="keyword">method_t</span>, <span class="keyword">method_list_t</span>, <span class="number">4294901763</span>, <span class="keyword">method_t</span>::pointer_modifier&gt; = (entsizeAndFlags = <span class="number">24</span>, count = <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">3.</span><span class="built_in">get</span>(<span class="number">0</span>).big()</span><br><span class="line">(<span class="keyword">method_t</span>::big) $<span class="number">4</span> = &#123;</span><br><span class="line">  name = <span class="string">"saySomething"</span></span><br><span class="line">  types = <span class="number">0x0000000100003cfd</span> <span class="string">"v16@0:8"</span></span><br><span class="line">  imp = <span class="number">0x00000001000037f0</span> (KCObjcBuild`-[JSPerson(Test) saySomething])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">3.</span><span class="built_in">get</span>(<span class="number">1</span>).big()</span><br><span class="line">(<span class="keyword">method_t</span>::big) $<span class="number">5</span> = &#123;</span><br><span class="line">  name = <span class="string">"sayHello"</span></span><br><span class="line">  types = <span class="number">0x0000000100003cfd</span> <span class="string">"v16@0:8"</span></span><br><span class="line">  imp = <span class="number">0x00000001000036b0</span> (KCObjcBuild`-[JSPerson sayHello])</span><br><span class="line">&#125;</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>发现<code>分类</code>已经加载了,<code>类</code>也加载了，说明<code>非懒加载类</code>会使<code>懒加载的类</code>在启动时提前加载（如果没有分类是第一次调用时加载），说明加载的时机是<code>编译期</code>。</p>
<h4 id="懒加载分类和非懒加载类"><a href="#懒加载分类和非懒加载类" class="headerlink" title="懒加载分类和非懒加载类"></a>懒加载分类和非懒加载类</h4><p>我们删除<code>JSPerson</code>分类的<code>load</code>方法，重新运行程序。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/faaa15082c19440daa4b8200bd9e935d~tplv-k3u1fbpfcp-watermark.image" alt="类和分类都是非懒加载分类加载"></p>
<p>使用<code>lldb</code>调试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p ro</span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *) $<span class="number">0</span> = <span class="number">0x00000001000042a8</span></span><br><span class="line">(lldb) p *$<span class="number">0</span></span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">class_ro_t</span>) $<span class="number">1</span> = &#123;</span><br><span class="line">  flags = <span class="number">0</span></span><br><span class="line">  instanceStart = <span class="number">8</span></span><br><span class="line">  instanceSize = <span class="number">8</span></span><br><span class="line">  reserved = <span class="number">0</span></span><br><span class="line">   = &#123;</span><br><span class="line">    ivarLayout = <span class="number">0x0000000000000000</span></span><br><span class="line">    nonMetaclass = nil</span><br><span class="line">  &#125;</span><br><span class="line">  name = &#123;</span><br><span class="line">    <span class="built_in">std</span>::__1::atomic&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; = <span class="string">"JSPerson"</span> &#123;</span><br><span class="line">      Value = <span class="number">0x0000000100003bbc</span> <span class="string">"JSPerson"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  baseMethodList = <span class="number">0x0000000100004158</span></span><br><span class="line">  baseProtocols = <span class="number">0x0000000000000000</span></span><br><span class="line">  ivars = <span class="number">0x0000000000000000</span></span><br><span class="line">  weakIvarLayout = <span class="number">0x0000000000000000</span></span><br><span class="line">  baseProperties = <span class="number">0x0000000000000000</span></span><br><span class="line">  _swiftMetadataInitializer_NEVER_USE = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">1.b</span>aseMethods()</span><br><span class="line">(<span class="keyword">method_list_t</span> *) $<span class="number">2</span> = <span class="number">0x0000000100004158</span></span><br><span class="line">(lldb) p *$<span class="number">2</span></span><br><span class="line">(<span class="keyword">method_list_t</span>) $<span class="number">3</span> = &#123;</span><br><span class="line">  entsize_list_tt&lt;<span class="keyword">method_t</span>, <span class="keyword">method_list_t</span>, <span class="number">4294901763</span>, <span class="keyword">method_t</span>::pointer_modifier&gt; = (entsizeAndFlags = <span class="number">24</span>, count = <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">3.</span><span class="built_in">get</span>(<span class="number">0</span>).big()</span><br><span class="line">(<span class="keyword">method_t</span>::big) $<span class="number">4</span> = &#123;</span><br><span class="line">  name = <span class="string">"saySomething"</span></span><br><span class="line">  types = <span class="number">0x0000000100003cfd</span> <span class="string">"v16@0:8"</span></span><br><span class="line">  imp = <span class="number">0x00000001000037f0</span> (KCObjcBuild`-[JSPerson(Test) saySomething])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">3.</span><span class="built_in">get</span>(<span class="number">1</span>).big()</span><br><span class="line">(<span class="keyword">method_t</span>::big) $<span class="number">5</span> = &#123;</span><br><span class="line">  name = <span class="string">"sayHello"</span></span><br><span class="line">  types = <span class="number">0x0000000100003cfd</span> <span class="string">"v16@0:8"</span></span><br><span class="line">  imp = <span class="number">0x00000001000036c0</span> (KCObjcBuild`-[JSPerson sayHello])</span><br><span class="line">&#125;</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>发现<code>分类</code>和<code>类</code>都已经加载了，说明加载的时机也是<code>编译期</code>。</p>
<h4 id="懒加载分类和懒加载类"><a href="#懒加载分类和懒加载类" class="headerlink" title="懒加载分类和懒加载类"></a>懒加载分类和懒加载类</h4><p>我们把<code>类</code>和<code>分类</code>的<code>load</code>方法都删除，重新运行程序</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61f7e74b7b9243e79e0e0037a439df38~tplv-k3u1fbpfcp-watermark.image" alt="懒加载分类第一次调用"></p>
<p>依然走到断点，注意观察左边的调用栈，发现是从<code>lookUpImpOrForward</code>,说明是在第一次调用方法的时候加载的。</p>
<h3 id="One-More-Condition"><a href="#One-More-Condition" class="headerlink" title="One More Condition"></a>One More Condition</h3><p>前面四种情况基本能包括了<code>分类</code>,但是还有种情况就是：有多个分类，部分分类实现了<code>load</code>方法主类也实现了<code>load</code>。我们就探索一下这个情况，新建一个<code>JSPerson</code>的分类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@interface JSPerson (Test2)</span><br><span class="line"></span><br><span class="line">- (void)saySomething2;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation JSPerson (Test2)</span><br><span class="line"></span><br><span class="line">- (void)saySomething2&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>根据前面我们其实应清楚，就是实现<code>load</code>的分类肯定会在运行时加载，我们关注的点就在于没有实现<code>load</code>方法的分类是什么时候加载的呢也就是<code>attachCategories</code>是否会加载未实现<code>load</code>方法的分类，运行程序</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5733fd8764141f1937743cd459a0382~tplv-k3u1fbpfcp-watermark.image" alt="多个分类加载"></p>
<p>使用<code>lldb</code>调试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">lldb) p cat</span><br><span class="line">(<span class="keyword">category_t</span> *) $<span class="number">1</span> = <span class="number">0x0000000100004448</span></span><br><span class="line">(lldb) p *$<span class="number">1</span></span><br><span class="line">(<span class="keyword">category_t</span>) $<span class="number">2</span> = &#123;</span><br><span class="line">  name = <span class="number">0x0000000100003b8f</span> <span class="string">"Test2"</span></span><br><span class="line">  cls = <span class="number">0x00000001000049a0</span></span><br><span class="line">  instanceMethods = &#123;</span><br><span class="line">    ptr = <span class="number">0x0000000100004428</span></span><br><span class="line">  &#125;</span><br><span class="line">  classMethods = &#123;</span><br><span class="line">    ptr = <span class="number">0x0000000000000000</span></span><br><span class="line">  &#125;</span><br><span class="line">  protocols = <span class="number">0x0000000000000000</span></span><br><span class="line">  instanceProperties = <span class="number">0x0000000000000000</span></span><br><span class="line">  _classProperties = <span class="number">0x0000000000000000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">operator</span>() -JSPerson....</span><br><span class="line">attachCategories -JSPerson....</span><br><span class="line">(lldb) p cat</span><br><span class="line">(<span class="keyword">category_t</span> *) $<span class="number">3</span> = <span class="number">0x00000001000044c8</span></span><br><span class="line">(lldb) p *$<span class="number">3</span></span><br><span class="line">(<span class="keyword">category_t</span>) $<span class="number">4</span> = &#123;</span><br><span class="line">  name = <span class="number">0x0000000100003b95</span> <span class="string">"Test"</span></span><br><span class="line">  cls = <span class="number">0x00000001000049a0</span></span><br><span class="line">  instanceMethods = &#123;</span><br><span class="line">    ptr = <span class="number">0x0000000100004488</span></span><br><span class="line">  &#125;</span><br><span class="line">  classMethods = &#123;</span><br><span class="line">    ptr = <span class="number">0x00000001000044a8</span></span><br><span class="line">  &#125;</span><br><span class="line">  protocols = <span class="number">0x0000000000000000</span></span><br><span class="line">  instanceProperties = <span class="number">0x0000000000000000</span></span><br><span class="line">  _classProperties = <span class="number">0x0000000000000000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调试我们发现，两个分类都加载了，也就是只要有一个分类实现了<code>load</code>，其他分类都会在<code>启动时</code>加载。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇主要是探索了<code>分类</code>的加载，主要分为5种情况</p>
<ul>
<li>非懒加载类和非懒加载分类：此时分类是在<code>运行时</code>,也就是<code>程序启动</code>的时候加载的。</li>
<li>懒加载类和非懒加载分类：此时分类是在<code>编译时</code>加载</li>
<li>非懒加载类和懒加载分类：此时分类也是在<code>编译时</code>加载</li>
<li>懒加载类和懒加载分类：此时分类在第一次调用时加载。</li>
<li>非懒加载类，多个分类，部分是非懒加载分类：此时所有分类都是在<code>程序启动</code>时加载。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/07/17/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD-%E4%B8%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/17/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD-%E4%B8%AD/" class="post-title-link" itemprop="url">iOS底层探索-类的加载（中）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-17 16:45:27" itemprop="dateCreated datePublished" datetime="2021-07-17T16:45:27+08:00">2021-07-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-18 14:10:11" itemprop="dateModified" datetime="2021-07-18T14:10:11+08:00">2021-07-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一篇我们探索到了<code>readClass</code>函数，只是对函数名字进行了赋值，并没有对<code>ro</code>和<code>rw</code>进行操作，本篇我们就继续探索<code>_read_images</code>函数剩下的调用。</p>
<h3 id="realizeClass的引入"><a href="#realizeClass的引入" class="headerlink" title="realizeClass的引入"></a>realizeClass的引入</h3><p>因为我们探索的目的是<code>类</code>的加载，我们先忽略<code>protocol</code>和<code>categories</code>的地方。为了调试代码，我们首先还是先创建一个<code>JSPerson</code>类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@interface JSPerson : NSObject</span><br><span class="line">@property (nonatomic, strong) NSString *nickName;</span><br><span class="line"></span><br><span class="line">- (void)say1;</span><br><span class="line">- (void)say2;</span><br><span class="line"></span><br><span class="line">+ (void)sayHappy;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;JSPerson.h&quot;</span><br><span class="line">@implementation JSPerson</span><br><span class="line"></span><br><span class="line">- (void)say1&#123;</span><br><span class="line">    NSLog(@&quot;JSPerson say : %s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">- (void)say2&#123;</span><br><span class="line">    NSLog(@&quot;JSPerson say : %s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    NSLog(@&quot;load&quot;);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)sayHappy&#123;</span><br><span class="line">    NSLog(@&quot;JSPerson say : %s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>接下来我们继续看<code>_read_images</code>函数，发现和类相关的地方有两个地方，<code>realize non-lazy classes</code>和<code>realize future classes</code>，我们在两段代码中加入我们调试的代码，为了观察我们自定义类的加载情况:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Realize non-lazy classes (for +load methods and static instances)</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist = hi-&gt;nlclslist(&amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Class cls = remapClass(classlist[i]);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">///调试代码 确定是我们自定义的类</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *mangledName = cls-&gt;nonlazyMangledName();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *customerClassName = <span class="string">"JSPerson"</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(mangledName, customerClassName) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//打印类名</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s -: non-lazy classes要研究的类: - %s\n"</span>,__func__,mangledName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addClassTableEntry(cls);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;isSwiftStable()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cls-&gt;swiftMetadataInitializer()) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">"Swift class %s with a metadata initializer "</span></span><br><span class="line">                            <span class="string">"is not allowed to be non-lazy"</span>,</span><br><span class="line">                            cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// fixme also disallow relocatable classes</span></span><br><span class="line">            <span class="comment">// We can't disallow all Swift classes because of</span></span><br><span class="line">            <span class="comment">// classes like Swift.__EmptyArrayStorage</span></span><br><span class="line">        &#125;</span><br><span class="line">        realizeClassWithoutSwift(cls, nil);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: realize non-lazy classes"</span>);</span><br><span class="line"><span class="comment">// Realize newly-resolved future classes, in case CF manipulates them</span></span><br><span class="line"><span class="keyword">if</span> (resolvedFutureClasses) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; resolvedFutureClassCount; i++) &#123;</span><br><span class="line">        Class cls = resolvedFutureClasses[i];</span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;isSwiftStable()) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">"Swift class is not allowed to be future"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">///调试代码 确定是我们自定义的类</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *mangledName = cls-&gt;nonlazyMangledName();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *customerClassName = <span class="string">"JSPerson"</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(mangledName, customerClassName) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//打印类名</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s -: realize future classes要研究的类: - %s\n"</span>,__func__,mangledName);</span><br><span class="line">        &#125;</span><br><span class="line">        realizeClassWithoutSwift(cls, nil);</span><br><span class="line">        cls-&gt;setInstancesRequireRawIsaRecursively(<span class="literal">false</span><span class="comment">/*inherited*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(resolvedFutureClasses);</span><br><span class="line">&#125;</span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: realize future classes"</span>);</span><br></pre></td></tr></table></figure>

<p>在两行<code>printf</code>的地方打断点，运行源码程序，看是否执行到断点位置。发现打印了<code>_read_images -: non-lazy classes要研究的类: - JSPerson</code>，代码执行到了<code>non-lazy classes</code>,里面类加载的核心代码在<code>realizeClassWithoutSwift</code>函数，我们继续探索<code>realizeClassWithoutSwift</code>函数。</p>
<h3 id="realizeClassWithoutSwift分析"><a href="#realizeClassWithoutSwift分析" class="headerlink" title="realizeClassWithoutSwift分析"></a>realizeClassWithoutSwift分析</h3><h4 id="操作之前的ro"><a href="#操作之前的ro" class="headerlink" title="操作之前的ro"></a>操作之前的ro</h4><p>我们从上到下依次阅读代码，定位到<code>auto ro = (const class_ro_t )cls-&gt;data();</code>,因为<code>ro</code>是<code>clean Memory</code>里的数据我们比较敏感，我们在图示位置打断点：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8991c702c2f6482999995e0ba0d1d7c1~tplv-k3u1fbpfcp-watermark.image" alt="ro赋值之前"></p>
<p>使用<code>LLDB</code>调试程序，查看<code>ro</code>里的信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p ro</span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *) $<span class="number">0</span> = <span class="number">0x00000001000080c0</span></span><br><span class="line">(lldb) p *$<span class="number">0</span></span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">class_ro_t</span>) $<span class="number">1</span> = &#123;</span><br><span class="line">  flags = <span class="number">0</span></span><br><span class="line">  instanceStart = <span class="number">8</span></span><br><span class="line">  instanceSize = <span class="number">16</span></span><br><span class="line">  reserved = <span class="number">0</span></span><br><span class="line">   = &#123;</span><br><span class="line">    ivarLayout = <span class="number">0x0000000000000000</span></span><br><span class="line">    nonMetaclass = nil</span><br><span class="line">  &#125;</span><br><span class="line">  name = &#123;</span><br><span class="line">    <span class="built_in">std</span>::__1::atomic&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; = <span class="string">"JSPerson"</span> &#123;</span><br><span class="line">      Value = <span class="number">0x0000000100003db0</span> <span class="string">"JSPerson"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  baseMethodList = <span class="number">0x0000000100008108</span></span><br><span class="line">  baseProtocols = <span class="number">0x0000000000000000</span></span><br><span class="line">  ivars = <span class="number">0x0000000100008170</span></span><br><span class="line">  weakIvarLayout = <span class="number">0x0000000000000000</span></span><br><span class="line">  baseProperties = <span class="number">0x0000000100008198</span></span><br><span class="line">  _swiftMetadataInitializer_NEVER_USE = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">1.b</span>aseMethodList</span><br><span class="line">(<span class="keyword">void</span> *<span class="keyword">const</span>) $<span class="number">2</span> = <span class="number">0x0000000100008108</span></span><br><span class="line">(lldb) p *$<span class="number">2</span></span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>通过打印我们发现此时<code>ro</code>里的<code>baseMethodList</code>为空，目前还不清楚什么时候赋值的，我们继续探索。</p>
<h4 id="rw的赋值"><a href="#rw的赋值" class="headerlink" title="rw的赋值"></a>rw的赋值</h4><p>接下来就是对<code>rw</code>的赋值，注意<code>rw</code>是<code>dirty Memory</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ro-&gt;flags &amp; RO_FUTURE) &#123;</span><br><span class="line">     <span class="comment">// This was a future class. rw data is already allocated.</span></span><br><span class="line">     rw = cls-&gt;data();</span><br><span class="line">     ro = cls-&gt;data()-&gt;ro();</span><br><span class="line">     ASSERT(!isMeta);</span><br><span class="line">     cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// Normal class. Allocate writeable class data.</span></span><br><span class="line">     rw = objc::zalloc&lt;<span class="keyword">class_rw_t</span>&gt;();</span><br><span class="line">     rw-&gt;set_ro(ro);</span><br><span class="line">     rw-&gt;flags = RW_REALIZED|RW_REALIZING|isMeta;</span><br><span class="line">     cls-&gt;setData(rw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="isa和superClass赋值"><a href="#isa和superClass赋值" class="headerlink" title="isa和superClass赋值"></a>isa和superClass赋值</h4><p>后面的代码就是对<code>isa</code>和<code>superClass</code>的赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">supercls = realizeClassWithoutSwift(remapClass(cls-&gt;getSuperclass()), nil);</span><br><span class="line">metacls = realizeClassWithoutSwift(remapClass(cls-&gt;ISA()), nil);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    <span class="keyword">if</span> (isMeta) &#123;</span><br><span class="line">        <span class="comment">// Metaclasses do not need any features from non pointer ISA</span></span><br><span class="line">        <span class="comment">// This allows for a faspath for classes in objc_retain/objc_release.</span></span><br><span class="line">        <span class="comment">///元类 不是non pointer ISA</span></span><br><span class="line">        cls-&gt;setInstancesRequireRawIsa();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Disable non-pointer isa for some classes and/or platforms.</span></span><br><span class="line">        <span class="comment">// Set instancesRequireRawIsa.</span></span><br><span class="line">        <span class="keyword">bool</span> instancesRequireRawIsa = cls-&gt;instancesRequireRawIsa();</span><br><span class="line">        <span class="keyword">bool</span> rawIsaIsInherited = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">bool</span> hackedDispatch = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DisableNonpointerIsa) &#123;</span><br><span class="line">            <span class="comment">//如果我们设置变量不使用 non pointer ISA 也会是纯的isa</span></span><br><span class="line">            <span class="comment">// Non-pointer isa disabled by environment or app SDK version</span></span><br><span class="line">            instancesRequireRawIsa = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!hackedDispatch  &amp;&amp;  <span class="number">0</span> == <span class="built_in">strcmp</span>(ro-&gt;getName(), <span class="string">"OS_object"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// hack for libdispatch et al - isa also acts as vtable pointer</span></span><br><span class="line">            hackedDispatch = <span class="literal">true</span>;</span><br><span class="line">            instancesRequireRawIsa = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (supercls  &amp;&amp;  supercls-&gt;getSuperclass()  &amp;&amp;</span><br><span class="line">                 supercls-&gt;instancesRequireRawIsa())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// This is also propagated by addSubclass()</span></span><br><span class="line">            <span class="comment">// but nonpointer isa setup needs it earlier.</span></span><br><span class="line">            <span class="comment">// Special case: instancesRequireRawIsa does not propagate</span></span><br><span class="line">            <span class="comment">// from root class to root metaclass</span></span><br><span class="line">            instancesRequireRawIsa = <span class="literal">true</span>;</span><br><span class="line">            rawIsaIsInherited = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (instancesRequireRawIsa) &#123;</span><br><span class="line">            cls-&gt;setInstancesRequireRawIsaRecursively(rawIsaIsInherited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// SUPPORT_NONPOINTER_ISA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// Update superclass and metaclass in case of remapping</span></span><br><span class="line">    cls-&gt;setSuperclass(supercls);</span><br><span class="line">    cls-&gt;initClassIsa(metacls);</span><br></pre></td></tr></table></figure>

<p>在<code>realizeClassWithoutSwift</code>函数最后会调用<code>methodizeClass</code>,我们下一小节探索<code>methodizeClass</code>。</p>
<h3 id="methodizeClass分析"><a href="#methodizeClass分析" class="headerlink" title="methodizeClass分析"></a>methodizeClass分析</h3><p><code>methodizeClass</code>顾名思义就是对方法的处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodizeClass</span><span class="params">(Class cls, Class previously)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    <span class="keyword">bool</span> isMeta = cls-&gt;isMetaClass();</span><br><span class="line">    <span class="keyword">auto</span> rw = cls-&gt;data();</span><br><span class="line">    <span class="keyword">auto</span> ro = rw-&gt;ro();</span><br><span class="line">    <span class="keyword">auto</span> rwe = rw-&gt;ext();</span><br><span class="line">    <span class="comment">// Methodizing for the first time</span></span><br><span class="line">    <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">        _objc_inform(<span class="string">"CLASS: methodizing class '%s' %s"</span>, </span><br><span class="line">                     cls-&gt;nameForLogging(), isMeta ? <span class="string">"(meta)"</span> : <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">///调试代码 确定是我们自定义的类</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mangledName = cls-&gt;nonlazyMangledName();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *customerClassName = <span class="string">"JSPerson"</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(mangledName, customerClassName) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//打印类名</span></span><br><span class="line">        <span class="keyword">if</span> (!isMeta) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s -: non-lazy classes要研究的类: - %s\n"</span>,__func__,mangledName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Install methods and properties that the class implements itself.</span></span><br><span class="line">    <span class="comment">//取出方法列表</span></span><br><span class="line">    <span class="keyword">method_list_t</span> *<span class="built_in">list</span> = ro-&gt;baseMethods();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">        prepareMethodLists(cls, &amp;<span class="built_in">list</span>, <span class="number">1</span>, YES, isBundleClass(cls), <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">if</span> (rwe) rwe-&gt;methods.attachLists(&amp;<span class="built_in">list</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">property_list_t</span> *proplist = ro-&gt;baseProperties;</span><br><span class="line">    <span class="keyword">if</span> (rwe &amp;&amp; proplist) &#123;</span><br><span class="line">        rwe-&gt;properties.attachLists(&amp;proplist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protocol_list_t</span> *protolist = ro-&gt;baseProtocols;</span><br><span class="line">    <span class="keyword">if</span> (rwe &amp;&amp; protolist) &#123;</span><br><span class="line">        rwe-&gt;protocols.attachLists(&amp;protolist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Root classes get bonus method implementations if they don't have </span></span><br><span class="line">    <span class="comment">// them already. These apply before category replacements.</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;isRootMetaclass()) &#123;</span><br><span class="line">        <span class="comment">// root metaclass</span></span><br><span class="line">        addMethod(cls, @selector(initialize), (IMP)&amp;objc_noop_imp, <span class="string">""</span>, NO);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Attach categories.</span></span><br><span class="line">    <span class="keyword">if</span> (previously) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) &#123;</span><br><span class="line">            objc::unattachedCategories.attachToClass(cls, previously,</span><br><span class="line">                                                     ATTACH_METACLASS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// When a class relocates, categories with class methods</span></span><br><span class="line">            <span class="comment">// may be registered on the class itself rather than on</span></span><br><span class="line">            <span class="comment">// the metaclass. Tell attachToClass to look for those.</span></span><br><span class="line">            objc::unattachedCategories.attachToClass(cls, previously,</span><br><span class="line">                                                     ATTACH_CLASS_AND_METACLASS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    objc::unattachedCategories.attachToClass(cls, cls,</span><br><span class="line">                                             isMeta ? ATTACH_METACLASS : ATTACH_CLASS);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">    <span class="comment">// Debug: sanity-check all SELs; log method list contents</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; meth : rw-&gt;methods()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"METHOD %c[%s %s]"</span>, isMeta ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(meth.name()));</span><br><span class="line">        &#125;</span><br><span class="line">        ASSERT(sel_registerName(sel_getName(meth.name())) == meth.name());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>断点进入图示位置，此时方法列表还是不能打印</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4210312aca44f2fa97bee1f1e2d6e3c~tplv-k3u1fbpfcp-watermark.image" alt="methodList打印"></p>
<h4 id="prepareMethodLists"><a href="#prepareMethodLists" class="headerlink" title="prepareMethodLists"></a>prepareMethodLists</h4><p>我们继续探索，后面执行<code>prepareMethodLists</code>函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> </span><br><span class="line">prepareMethodLists(Class cls, <span class="keyword">method_list_t</span> **addedLists, <span class="keyword">int</span> addedCount,</span><br><span class="line">                   <span class="keyword">bool</span> baseMethods, <span class="keyword">bool</span> methodsFromBundle, <span class="keyword">const</span> <span class="keyword">char</span> *why)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// There exist RR/AWZ/Core special cases for some class's base methods.</span></span><br><span class="line">    <span class="comment">// But this code should never need to scan base methods for RR/AWZ/Core:</span></span><br><span class="line">    <span class="comment">// default RR/AWZ/Core cannot be set before setInitialized().</span></span><br><span class="line">    <span class="comment">// Therefore we need not handle any special cases here.</span></span><br><span class="line">    <span class="keyword">if</span> (baseMethods) &#123;</span><br><span class="line">        ASSERT(cls-&gt;hasCustomAWZ() &amp;&amp; cls-&gt;hasCustomRR() &amp;&amp; cls-&gt;hasCustomCore());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cls-&gt;cache.isConstantOptimizedCache()) &#123;</span><br><span class="line">        cls-&gt;setDisallowPreoptCachesRecursively(why);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cls-&gt;allowsPreoptInlinedSels()) &#123;</span><br><span class="line">#<span class="keyword">if</span> CONFIG_USE_PREOPT_CACHES</span><br><span class="line">        SEL *sels = (SEL *)objc_opt_offsets[OBJC_OPT_INLINED_METHODS_START];</span><br><span class="line">        SEL *sels_end = (SEL *)objc_opt_offsets[OBJC_OPT_INLINED_METHODS_END];</span><br><span class="line">        <span class="keyword">if</span> (method_lists_contains_any(addedLists, addedLists + addedCount, sels, sels_end - sels)) &#123;</span><br><span class="line">            cls-&gt;setDisallowPreoptInlinedSelsRecursively(why);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add method lists to array.</span></span><br><span class="line">    <span class="comment">// Reallocate un-fixed method lists.</span></span><br><span class="line">    <span class="comment">// The new methods are PREPENDED to the method list array.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; addedCount; i++) &#123;</span><br><span class="line">        <span class="keyword">method_list_t</span> *mlist = addedLists[i];</span><br><span class="line">        ASSERT(mlist);</span><br><span class="line">        <span class="comment">// Fixup selectors if necessary</span></span><br><span class="line">        <span class="keyword">if</span> (!mlist-&gt;isFixedUp()) &#123;</span><br><span class="line">            <span class="comment">//核心代码</span></span><br><span class="line">            fixupMethodList(mlist, methodsFromBundle, <span class="literal">true</span><span class="comment">/*sort*/</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the class is initialized, then scan for method implementations</span></span><br><span class="line">    <span class="comment">// tracked by the class's flags. If it's not initialized yet,</span></span><br><span class="line">    <span class="comment">// then objc_class::setInitialized() will take care of it.</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;isInitialized()) &#123;</span><br><span class="line">        objc::AWZScanner::scanAddedMethodLists(cls, addedLists, addedCount);</span><br><span class="line">        objc::RRScanner::scanAddedMethodLists(cls, addedLists, addedCount);</span><br><span class="line">        objc::CoreScanner::scanAddedMethodLists(cls, addedLists, addedCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心调用是<code>fixupMethodList</code>函数。</p>
<h4 id="fixupMethodList"><a href="#fixupMethodList" class="headerlink" title="fixupMethodList"></a>fixupMethodList</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> </span><br><span class="line">fixupMethodList(<span class="keyword">method_list_t</span> *mlist, <span class="keyword">bool</span> bundleCopy, <span class="keyword">bool</span> sort)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    ASSERT(!mlist-&gt;isFixedUp());</span><br><span class="line">    <span class="comment">// fixme lock less in attachMethodLists ?</span></span><br><span class="line">    <span class="comment">// dyld3 may have already uniqued, but not sorted, the list</span></span><br><span class="line">    <span class="keyword">if</span> (!mlist-&gt;isUniqued()) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(selLock)</span></span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Unique selectors in list.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; meth : *mlist) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *name = sel_cname(meth.name());</span><br><span class="line">            meth.setName(sel_registerNameNoLock(name, bundleCopy));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Sort by selector address.</span></span><br><span class="line">    <span class="comment">// Don't try to sort small lists, as they're immutable.</span></span><br><span class="line">    <span class="comment">// Don't try to sort big lists of nonstandard size, as stable_sort</span></span><br><span class="line">    <span class="comment">// won't copy the entries properly.</span></span><br><span class="line">    <span class="keyword">if</span> (sort &amp;&amp; !mlist-&gt;isSmallList() &amp;&amp; mlist-&gt;entsize() == <span class="keyword">method_t</span>::bigSize) &#123;</span><br><span class="line">        <span class="keyword">method_t</span>::SortBySELAddress sorter;</span><br><span class="line">        <span class="built_in">std</span>::stable_sort(&amp;mlist-&gt;<span class="built_in">begin</span>()-&gt;big(), &amp;mlist-&gt;<span class="built_in">end</span>()-&gt;big(), sorter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Mark method list as uniqued and sorted.</span></span><br><span class="line">    <span class="comment">// Can't mark small lists, since they're immutable.</span></span><br><span class="line">    <span class="keyword">if</span> (!mlist-&gt;isSmallList()) &#123;</span><br><span class="line">        mlist-&gt;setFixedUp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心的代码是<code>stable_sort</code>，我们分别打印排序前后方法列表，如图示</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08916e32cc124e5e95fdeb0723a5ad4d~tplv-k3u1fbpfcp-watermark.image" alt="打印前后排序"></p>
<p>注意：这里一定要先在<code>realizeClassWithoutSwift</code>判断好是我们要研究的<code>JSPerson</code>类，然后再看打印结果，否则系统类也会有很多打印，影响我们分析。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">methodizeClass -: non-lazy classes要研究的类: - JSPerson</span><br><span class="line">****************sort之前 : say1 - <span class="number">0x100003dda</span></span><br><span class="line">sort之前 : say2 - <span class="number">0x100003ddf</span></span><br><span class="line">sort之前 : nickName - <span class="number">0x7fff73fb8a1c</span></span><br><span class="line">sort之前 : setNickName: - <span class="number">0x7fff73fb8362</span></span><br><span class="line">****************sort之后 : say1 - <span class="number">0x100003dda</span></span><br><span class="line">sort之后 : say2 - <span class="number">0x100003ddf</span></span><br><span class="line">sort之后 : setNickName: - <span class="number">0x7fff73fb8362</span></span><br><span class="line">sort之后 : nickName - <span class="number">0x7fff73fb8a1c</span></span><br></pre></td></tr></table></figure>

<p>通过上面打印结果：</p>
<ul>
<li>排序前：<code>say1 - 0x100003dda</code>、<code>say2 - 0x100003ddf</code>、<code>nickName - 0x7fff73fb8a1c</code>、<code>setNickName: - 0x7fff73fb8362</code></li>
<li>排序后：<code>say1 - 0x100003dda</code>、<code>say2 - 0x100003ddf</code>、<code>setNickName: - 0x7fff73fb8362</code>、<code>nickName - 0x7fff73fb8a1c</code></li>
<li>排序是根据地址由低到高排序的。</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>到目前为止，类的加载流程是：<code>_read_images</code>-&gt;<code>realizeClassWithoutSwift</code>-&gt;<code>methodizeClass</code>-&gt;<code>prepareMethodLists</code>-&gt;<code>fixupMethodList</code>。</p>
<h3 id="懒加载类和非懒加载类"><a href="#懒加载类和非懒加载类" class="headerlink" title="懒加载类和非懒加载类"></a>懒加载类和非懒加载类</h3><p>我们前面探索的其实都是<code>非懒加载的类</code>，<code>懒加载类</code>和<code>非懒加载的类</code>的区别就是<strong><em>是否实现了<code>load</code>方法</em></strong>。</p>
<h4 id="非懒加载"><a href="#非懒加载" class="headerlink" title="非懒加载"></a>非懒加载</h4><p>通过上面的分析，我们已经很清楚了，是在<code>_objc_init</code>方法里加载的，也就是程序启动的时候。这也就是为什么<code>load</code>方法过多，会影响我们应用的<code>启动速度</code>。</p>
<h4 id="懒加载类"><a href="#懒加载类" class="headerlink" title="懒加载类"></a>懒加载类</h4><p>因为<code>非懒加载类</code>效率低，会影响我们的启动速度，那<code>懒加载类</code>是什么时候加载的呢？我们删掉<code>JSPerson</code>类的<code>load</code>方法，然后在<code>main</code>函数中实例化一个<code>JSPerson</code>实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        JSPerson *p &#x3D; [JSPerson alloc];</span><br><span class="line">        [p say1];</span><br><span class="line">        NSLog(@&quot;Hello, World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先在<code>main</code>方法里添加断点，执行程序。走到<code>main</code>函数之后，然后再在<code>realizeClassWithoutSwift</code>添加断点：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5701b96b7a04b4ba9a69677f9034593~tplv-k3u1fbpfcp-watermark.image" alt="懒加载类断点"></p>
<p>断点走进来之后我们<code>bt</code>打印调用栈信息：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cd935a4a37144f29ec9af1d6a14f2ff~tplv-k3u1fbpfcp-watermark.image" alt="懒加载类"></p>
<p>发现调用是从<code>lookUpImpOrForward</code>开始。</p>
<p>所以我们的结论是<code>懒加载的类</code>是在第一次被使用的时候加载的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>非懒加载类：程序运行时加载，<code>_read_images</code>-&gt;<code>realizeClassWithoutSwift</code>-&gt;<code>methodizeClass</code>-&gt;<code>prepareMethodLists</code>-&gt;<code>fixupMethodList</code>。</li>
<li>懒加载类：第一次使用时加载，<code>lookUpImpOrForward</code>-&gt;<code>realizeClassWithoutSwift</code>-&gt;<code>methodizeClass</code>-&gt;<code>prepareMethodLists</code>-&gt;<code>fixupMethodList</code></li>
</ul>
<p>我们开发中经常会写<code>分类</code>，它是什么时候加载的及加载的流程，我们下一篇再探索。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/07/15/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD-%E4%B8%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/15/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD-%E4%B8%8A/" class="post-title-link" itemprop="url">iOS底层探索-类的加载（上）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-15 22:11:42" itemprop="dateCreated datePublished" datetime="2021-07-15T22:11:42+08:00">2021-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-17 16:54:52" itemprop="dateModified" datetime="2021-07-17T16:54:52+08:00">2021-07-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一篇我们主要探索了<code>dyld</code>的链接加载，本篇开始我们探索运行时类的加载过程，本篇只是引子。</p>
<h3 id="objc-init"><a href="#objc-init" class="headerlink" title="_objc_init"></a>_objc_init</h3><p>首先看一下<code>_objc_init</code>方法的源码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    <span class="comment">//读取影响运行时的环境变量 </span></span><br><span class="line">    environ_init();</span><br><span class="line">    <span class="comment">//关于线程key的绑定</span></span><br><span class="line">    tls_init();</span><br><span class="line">    <span class="comment">//运行C ++静态构造函数</span></span><br><span class="line">    static_init();</span><br><span class="line">  	<span class="comment">//runtime运行时环境初始化</span></span><br><span class="line">    runtime_init();</span><br><span class="line">    <span class="comment">//初始化libobjc的异常处理系统</span></span><br><span class="line">    exception_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">  	<span class="comment">//缓存条件初始化</span></span><br><span class="line">    <span class="keyword">cache_t</span>::init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//启动回调机制</span></span><br><span class="line">    _imp_implementationWithBlock_init();</span><br><span class="line">		<span class="comment">//dyld 注册的地方</span></span><br><span class="line">    <span class="comment">//map_images:dyld将image镜像文件加载进内存时，会触发该函数</span></span><br><span class="line">    <span class="comment">//load_images：dyld初始化image会触发该函数</span></span><br><span class="line">    <span class="comment">//unmap_image：dyld将image移除时会触发该函数</span></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    didCallDyldNotifyRegister = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，<code>_objc_init</code>主要是执行一些初始化方法，包括</p>
<ul>
<li><code>environ_init()</code>:读取影响运行时的环境变量,如果需要可以打印环境变量提供帮助。</li>
<li><code>tls_init()</code>:关于线程key的绑定,例如每线程数据的析构函数。</li>
<li><code>static_init()</code>:运行<code>C++</code>静态构造函数。</li>
<li><code>runtime_init()</code>:runtime运行时环境的初始化，后面我们详细分析。</li>
<li><code>exception_init()</code>:初始化<code>libobjc</code>的异常处理系统。</li>
<li><code>cache_t::init()</code>:缓存条件初始化。</li>
<li><code>_imp_implementationWithBlock_init()</code>:启动回调机制。</li>
<li><code>_dyld_objc_notify_register</code>：dyld的注册。</li>
</ul>
<p>####environ_init 环境变量初始化</p>
<p><code>environ_init</code>的源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">environ_init</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">///省略代码</span></span><br><span class="line">   <span class="comment">// Print OBJC_HELP and OBJC_PRINT_OPTIONS output.</span></span><br><span class="line">    <span class="keyword">if</span> (PrintHelp  ||  PrintOptions) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintHelp) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"Objective-C runtime debugging. Set variable=YES to enable."</span>);</span><br><span class="line">            _objc_inform(<span class="string">"OBJC_HELP: describe available environment variables"</span>);</span><br><span class="line">            <span class="keyword">if</span> (PrintOptions) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"OBJC_HELP is set"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            _objc_inform(<span class="string">"OBJC_PRINT_OPTIONS: list which options are set"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (PrintOptions) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"OBJC_PRINT_OPTIONS is set"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">			  <span class="comment">///这里如果满足条件 会打印所有的环境变量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(Settings)/<span class="keyword">sizeof</span>(Settings[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">option_t</span> *opt = &amp;Settings[i];            </span><br><span class="line">            <span class="keyword">if</span> (PrintHelp) _objc_inform(<span class="string">"%s: %s"</span>, opt-&gt;env, opt-&gt;help);</span><br><span class="line">            <span class="keyword">if</span> (PrintOptions &amp;&amp; *opt-&gt;var) _objc_inform(<span class="string">"%s is set"</span>, opt-&gt;env);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出来就是一些环境变量的初始化，参看这段代码，我们可以打印环境变量。</p>
<ul>
<li><p>将条件去掉直接调用<code>for</code>循环</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(Settings)/<span class="keyword">sizeof</span>(Settings[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">option_t</span> *opt = &amp;Settings[i];</span><br><span class="line">     _objc_inform(<span class="string">"%s: %s"</span>, opt-&gt;env, opt-&gt;help);</span><br><span class="line">     _objc_inform(<span class="string">"%s is set"</span>, opt-&gt;env);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过终端命令<code>export OBJC_hrlp = 1</code>,打印环境变量</p>
</li>
</ul>
<p>我们平时项目中可能会有几个环境变量可以在我们的xcode配置（<code>target -- Edit Scheme -- Run --Arguments -- Environment Variables</code>）一下对应的值，达到修改环境变量的目的：</p>
<ul>
<li><code>DYLD_PRINT_STATISTICS</code>：设置 <code>DYLD_PRINT_STATISTICS</code> 为<code>YES</code>，控制台就会打印 App 的加载时长，包括整体加载时长和动态库加载时长，即<code>main函数之前的启动时间（查看pre-main耗时）</code>，可以通过设置了解其耗时部分，这个我们做<code>启动优化</code>会用到。</li>
<li><code>OBJC_DISABLE_NONPOINTER_ISA</code>：不使用<code>nonpointer isa</code>（nonpointer isa指针地址 <code>末尾为1</code> ），生成的都是普通的isa，这个我们项目里一般不会改，探索源码的时候可以尝试查看两种<code>isa</code>结构的区别。</li>
<li><code>OBJC_PRINT_LOAD_METHODS</code>：打印 <code>Class</code> 及 <code>Category</code> 的 <code>+ (void)load</code> 方法的调用信息，<code>启动优化</code>也可以参考，因为<code>load</code>方法过多也会使启动变慢。</li>
</ul>
<h4 id="tls-init：线程key的绑定"><a href="#tls-init：线程key的绑定" class="headerlink" title="tls_init：线程key的绑定"></a>tls_init：线程key的绑定</h4><p>主要作用是本地线程池的初始化以及析构，源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tls_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line">    pthread_key_init_np(TLS_DIRECT_KEY, &amp;_objc_pthread_destroyspecific);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    _objc_pthread_key = tls_create(&amp;_objc_pthread_destroyspecific);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="static-init-运行系统级别的C-静态构造函数"><a href="#static-init-运行系统级别的C-静态构造函数" class="headerlink" title="static_init 运行系统级别的C++静态构造函数"></a>static_init 运行系统级别的C++静态构造函数</h4><p>主要是运行系统级别的C++静态构造函数，在<code>dyld</code>调用我们的静态构造函数之前，<code>libc</code>调用<code>_objc_init</code>方法，即<code>系统级别的C++构造函数 先于 自定义的C++构造函数 运行</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">static_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    <span class="keyword">auto</span> inits = getLibobjcInitializers(&amp;_mh_dylib_header, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        inits[i]();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> offsets = getLibobjcInitializerOffsets(&amp;_mh_dylib_header, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="function">UnsignedInitializer <span class="title">init</span><span class="params">(offsets[i])</span></span>;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="runtime-init-运行时环境初始化"><a href="#runtime-init-运行时环境初始化" class="headerlink" title="runtime_init 运行时环境初始化"></a>runtime_init 运行时环境初始化</h4><p>主要是运行时的初始化，主要分为两部分：<code>分类初始化</code>、<code>类的表初始化</code>,我们下一篇会详细探索。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runtime_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    objc::unattachedCategories.init(<span class="number">32</span>);</span><br><span class="line">    objc::allocatedClasses.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="exception-init-异常初始化"><a href="#exception-init-异常初始化" class="headerlink" title="exception_init 异常初始化"></a>exception_init 异常初始化</h4><p>主要是<code>初始化libobjc的异常处理系统，注册异常处理的回调，从而监控异常的处理</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* exception_init</span></span><br><span class="line"><span class="comment">* Initialize libobjc's exception handling system.</span></span><br><span class="line"><span class="comment">* Called by map_images().</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exception_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    old_terminate = <span class="built_in">std</span>::set_terminate(&amp;_objc_terminate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>_objc_terminate</code>的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _objc_terminate(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PrintExceptions) &#123;</span><br><span class="line">        _objc_inform(<span class="string">"EXCEPTIONS: terminating"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! __cxa_current_exception_type()) &#123;</span><br><span class="line">        <span class="comment">// No current exception.</span></span><br><span class="line">        (*old_terminate)();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// There is a current exception. Check if it's an objc exception.</span></span><br><span class="line">        @<span class="keyword">try</span> &#123;</span><br><span class="line">            __cxa_rethrow();</span><br><span class="line">        &#125; @<span class="keyword">catch</span> (id e) &#123;</span><br><span class="line">            <span class="comment">// It's an objc object. Call Foundation's handler, if any.</span></span><br><span class="line">            (*uncaught_handler)((id)e);</span><br><span class="line">            (*old_terminate)();</span><br><span class="line">        &#125; @<span class="keyword">catch</span> (...) &#123;</span><br><span class="line">            <span class="comment">// It's not an objc object. Continue to C++ terminate.</span></span><br><span class="line">            (*old_terminate)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>crash</code>的时候会执行<code>_objc_terminate</code>方法,最后会执行<code>uncaught_handler</code>抛出异常。</p>
</li>
<li><p><code>uncaught_handler</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">objc_uncaught_exception_handler </span><br><span class="line">objc_setUncaughtExceptionHandler(objc_uncaught_exception_handler fn)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    fn为设置的异常句柄 传入的函数，为外界给的</span></span><br><span class="line">    objc_uncaught_exception_handler result = uncaught_handler;</span><br><span class="line">    uncaught_handler = fn; <span class="comment">//赋值</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要用来处理异常，在我们的App中可以添加一个异常句柄<code>NSSetUncaughtExceptionHandler</code>来处理异常。</p>
</li>
</ul>
<h4 id="cache-init：缓存初始化"><a href="#cache-init：缓存初始化" class="headerlink" title="cache_init：缓存初始化"></a>cache_init：缓存初始化</h4><p>主要就是缓存初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_t::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> HAVE_TASK_RESTARTABLE_RANGES</span></span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (objc_restartableRanges[count].location) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kr = task_restartable_ranges_register(mach_task_self(),</span><br><span class="line">                                          objc_restartableRanges, count);</span><br><span class="line">    <span class="keyword">if</span> (kr == KERN_SUCCESS) <span class="keyword">return</span>;</span><br><span class="line">    _objc_fatal(<span class="string">"task_restartable_ranges_register failed (result 0x%x: %s)"</span>,</span><br><span class="line">                kr, mach_error_string(kr));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// HAVE_TASK_RESTARTABLE_RANGES</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="imp-implementationWithBlock-init：启动回调机制"><a href="#imp-implementationWithBlock-init：启动回调机制" class="headerlink" title="_imp_implementationWithBlock_init：启动回调机制"></a>_imp_implementationWithBlock_init：启动回调机制</h4><p>该方法主要是<code>启动回调机制</code>，看代码<code>iOS</code>端没做任何处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_imp_implementationWithBlock_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_OSX</span></span><br><span class="line">    <span class="comment">// Eagerly load libobjc-trampolines.dylib in certain processes. Some</span></span><br><span class="line">    <span class="comment">// programs (most notably QtWebEngineProcess used by older versions of</span></span><br><span class="line">    <span class="comment">// embedded Chromium) enable a highly restrictive sandbox profile which</span></span><br><span class="line">    <span class="comment">// blocks access to that dylib. If anything calls</span></span><br><span class="line">    <span class="comment">// imp_implementationWithBlock (as AppKit has started doing) then we'll</span></span><br><span class="line">    <span class="comment">// crash trying to load it. Loading it here sets it up before the sandbox</span></span><br><span class="line">    <span class="comment">// profile is enabled and blocks it.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This fixes EA Origin (rdar://problem/50813789)</span></span><br><span class="line">    <span class="comment">// and Steam (rdar://problem/55286131)</span></span><br><span class="line">    <span class="keyword">if</span> (__progname &amp;&amp;</span><br><span class="line">        (<span class="built_in">strcmp</span>(__progname, <span class="string">"QtWebEngineProcess"</span>) == <span class="number">0</span> ||</span><br><span class="line">         <span class="built_in">strcmp</span>(__progname, <span class="string">"Steam Helper"</span>) == <span class="number">0</span>)) &#123;</span><br><span class="line">        Trampolines.Initialize();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dyld-objc-notify-register：dyld注册"><a href="#dyld-objc-notify-register：dyld注册" class="headerlink" title="_dyld_objc_notify_register：dyld注册"></a>_dyld_objc_notify_register：dyld注册</h4><p>这个方法我们上一篇有提到过，主要是</p>
<ul>
<li>仅供<code>objc运行时</code>使用</li>
<li><code>注册处理程序</code>，以便在映射、取消映射和初始化objc图像时调用</li>
<li><code>dyld</code>将会通过一个包含objc-image-info的镜像文件的数组回调<code>mapped</code>函数</li>
</ul>
<p>三个参数的作用：</p>
<p><code>map_images</code>：dyld将image（镜像文件）加载进内存时，会触发该函数</p>
<p><code>load_image</code>：dyld初始化image会触发该函数</p>
<p><code>unmap_image</code>：dyld将image移除时，会触发该函数</p>
<p>我们<code>_objc_init</code>调用的方法有了初步认识，接下来我们开始探索类的加载。</p>
<h3 id="read-images"><a href="#read-images" class="headerlink" title="_read_images"></a>_read_images</h3><h4 id="read-images的引入"><a href="#read-images的引入" class="headerlink" title="_read_images的引入"></a>_read_images的引入</h4><p><code>_dyld_objc_notify_register</code>第一个参数是<code>&amp;map_images</code>,所以我们从<code>map_images</code>开始探索。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">map_images(<span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> paths[],</span><br><span class="line">           <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> map_images_nolock(count, paths, mhdrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>map_images</code>比较简单，调用<code>map_images_nolock</code>,我们继续探索。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">map_images_nolock(<span class="keyword">unsigned</span> mhCount, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> mhPaths[],</span><br><span class="line">                  <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> firstTime = YES;</span><br><span class="line">    header_info *hList[mhCount];</span><br><span class="line">    <span class="keyword">uint32_t</span> hCount;</span><br><span class="line">    <span class="keyword">size_t</span> selrefCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform first-time initialization if necessary.</span></span><br><span class="line">    <span class="comment">// This function is called before ordinary library initializers. </span></span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    <span class="keyword">if</span> (firstTime) &#123;</span><br><span class="line">        preopt_init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintImages) &#123;</span><br><span class="line">        _objc_inform(<span class="string">"IMAGES: processing %u newly-mapped images...\n"</span>, mhCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find all images with Objective-C metadata.</span></span><br><span class="line">    hCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Count classes. Size various table based on the total.</span></span><br><span class="line">    <span class="keyword">int</span> totalClasses = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> unoptimizedTotalClasses = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> i = mhCount;</span><br><span class="line">        <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">            <span class="keyword">const</span> headerType *mhdr = (<span class="keyword">const</span> headerType *)mhdrs[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> hi = addHeader(mhdr, mhPaths[i], totalClasses, unoptimizedTotalClasses);</span><br><span class="line">            <span class="keyword">if</span> (!hi) &#123;</span><br><span class="line">                <span class="comment">// no objc data in this entry</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (mhdr-&gt;filetype == MH_EXECUTE) &#123;</span><br><span class="line">                <span class="comment">// Size some data structures based on main executable's size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">                <span class="comment">// If dyld3 optimized the main executable, then there shouldn't</span></span><br><span class="line">                <span class="comment">// be any selrefs needed in the dynamic map so we can just init</span></span><br><span class="line">                <span class="comment">// to a 0 sized map</span></span><br><span class="line">                <span class="keyword">if</span> ( !hi-&gt;hasPreoptimizedSelectors() ) &#123;</span><br><span class="line">                  <span class="keyword">size_t</span> count;</span><br><span class="line">                  _getObjc2SelectorRefs(hi, &amp;count);</span><br><span class="line">                  selrefCount += count;</span><br><span class="line">                  _getObjc2MessageRefs(hi, &amp;count);</span><br><span class="line">                  selrefCount += count;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                _getObjcSelectorRefs(hi, &amp;selrefCount);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_GC_COMPAT</span></span><br><span class="line">                <span class="comment">// Halt if this is a GC app.</span></span><br><span class="line">                <span class="keyword">if</span> (shouldRejectGCApp(hi)) &#123;</span><br><span class="line">                    _objc_fatal_with_reason</span><br><span class="line">                        (OBJC_EXIT_REASON_GC_NOT_SUPPORTED, </span><br><span class="line">                         OS_REASON_FLAG_CONSISTENT_FAILURE, </span><br><span class="line">                         <span class="string">"Objective-C garbage collection "</span> </span><br><span class="line">                         <span class="string">"is no longer supported."</span>);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            hList[hCount++] = hi;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (PrintImages) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"IMAGES: loading image for %s%s%s%s%s\n"</span>, </span><br><span class="line">                             hi-&gt;fname(),</span><br><span class="line">                             mhdr-&gt;filetype == MH_BUNDLE ? <span class="string">" (bundle)"</span> : <span class="string">""</span>,</span><br><span class="line">                             hi-&gt;info()-&gt;isReplacement() ? <span class="string">" (replacement)"</span> : <span class="string">""</span>,</span><br><span class="line">                             hi-&gt;info()-&gt;hasCategoryClassProperties() ? <span class="string">" (has class properties)"</span> : <span class="string">""</span>,</span><br><span class="line">                             hi-&gt;info()-&gt;optimizedByDyld()?<span class="string">" (preoptimized)"</span>:<span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform one-time runtime initialization that must be deferred until </span></span><br><span class="line">    <span class="comment">// the executable itself is found. This needs to be done before </span></span><br><span class="line">    <span class="comment">// further initialization.</span></span><br><span class="line">    <span class="comment">// (The executable may not be present in this infoList if the </span></span><br><span class="line">    <span class="comment">// executable does not contain Objective-C code but Objective-C </span></span><br><span class="line">    <span class="comment">// is dynamically loaded later.</span></span><br><span class="line">    <span class="keyword">if</span> (firstTime) &#123;</span><br><span class="line">        sel_init(selrefCount);</span><br><span class="line">        arr_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_GC_COMPAT</span></span><br><span class="line">        <span class="comment">// Reject any GC images linked to the main executable.</span></span><br><span class="line">        <span class="comment">// We already rejected the app itself above.</span></span><br><span class="line">        <span class="comment">// Images loaded after launch will be rejected by dyld.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; hCount; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> hi = hList[i];</span><br><span class="line">            <span class="keyword">auto</span> mh = hi-&gt;mhdr();</span><br><span class="line">            <span class="keyword">if</span> (mh-&gt;filetype != MH_EXECUTE  &amp;&amp;  shouldRejectGCImage(mh)) &#123;</span><br><span class="line">                _objc_fatal_with_reason</span><br><span class="line">                    (OBJC_EXIT_REASON_GC_NOT_SUPPORTED, </span><br><span class="line">                     OS_REASON_FLAG_CONSISTENT_FAILURE, </span><br><span class="line">                     <span class="string">"%s requires Objective-C garbage collection "</span></span><br><span class="line">                     <span class="string">"which is no longer supported."</span>, hi-&gt;fname());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_OSX</span></span><br><span class="line">        <span class="comment">// Disable +initialize fork safety if the app is too old (&lt; 10.13).</span></span><br><span class="line">        <span class="comment">// Disable +initialize fork safety if the app has a</span></span><br><span class="line">        <span class="comment">//   __DATA,__objc_fork_ok section.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        if (!dyld_program_sdk_at_least(dyld_platform_version_macOS_10_13)) &#123;</span></span><br><span class="line"><span class="comment">//            DisableInitializeForkSafety = true;</span></span><br><span class="line"><span class="comment">//            if (PrintInitializing) &#123;</span></span><br><span class="line"><span class="comment">//                _objc_inform("INITIALIZE: disabling +initialize fork "</span></span><br><span class="line"><span class="comment">//                             "safety enforcement because the app is "</span></span><br><span class="line"><span class="comment">//                             "too old.)");</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; hCount; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> hi = hList[i];</span><br><span class="line">            <span class="keyword">auto</span> mh = hi-&gt;mhdr();</span><br><span class="line">            <span class="keyword">if</span> (mh-&gt;filetype != MH_EXECUTE) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line">            <span class="keyword">if</span> (getsectiondata(hi-&gt;mhdr(), <span class="string">"__DATA"</span>, <span class="string">"__objc_fork_ok"</span>, &amp;<span class="built_in">size</span>)) &#123;</span><br><span class="line">                DisableInitializeForkSafety = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (PrintInitializing) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"INITIALIZE: disabling +initialize fork "</span></span><br><span class="line">                                 <span class="string">"safety enforcement because the app has "</span></span><br><span class="line">                                 <span class="string">"a __DATA,__objc_fork_ok section"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// assume only one MH_EXECUTE image</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">///核心方法</span></span><br><span class="line">        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    firstTime = NO;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Call image load funcs after everything is set up.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> func : loadImageFuncs) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; mhCount; i++) &#123;</span><br><span class="line">            func(mhdrs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>map_images_nolock</code>方法比较长，很大一部分代码是读取镜像的准备，核心调用是<code>_read_images</code>方法。</p>
<h4 id="read-images分析"><a href="#read-images分析" class="headerlink" title="_read_images分析"></a>_read_images分析</h4><p><code>_read_images</code>有三百多行代码，一行行读容易迷失，我们先将方法内的<code>{}</code>语句隐藏，从全局看这个方法都做了什么：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb4ae662921c4152b253cff8c4042a2a~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-07-17 12.56.13"></p>
<p>这个方法有个特点就是没执行完一个代码块都会执行<code>ts.log()</code>函数打印代码段都做了什么，这样子我们大体知道<code>_read_images</code>的主流程：</p>
<ul>
<li>条件控制进⾏⼀次的加载</li>
<li>修复预编译阶段的 @selector 的混乱问题</li>
<li>错误混乱的类处理</li>
<li>修复重映射⼀些没有被镜像⽂件加载进来的类</li>
<li>修复⼀些消息</li>
<li>当我们类⾥⾯有协议的时候 : readProtocol</li>
<li>修复没有被加载的协议</li>
<li>分类处理</li>
<li>类的加载处理</li>
<li>没有被处理的类 优化那些被侵犯的类</li>
</ul>
<h4 id="first-time-tasks即：条件控制进⾏⼀次的加载"><a href="#first-time-tasks即：条件控制进⾏⼀次的加载" class="headerlink" title="first time tasks即：条件控制进⾏⼀次的加载"></a>first time tasks即：条件控制进⾏⼀次的加载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!doneOnce) &#123;</span><br><span class="line">        doneOnce = YES;</span><br><span class="line">        launchTime = YES;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">        <span class="comment">// Disable non-pointer isa under some conditions.</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class="line">        <span class="comment">// Disable nonpointer isa if any image contains old Swift code</span></span><br><span class="line">        <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hi-&gt;info()-&gt;containsSwift()  &amp;&amp;</span><br><span class="line">                hi-&gt;info()-&gt;swiftUnstableVersion() &lt; objc_image_info::SwiftVersion3)</span><br><span class="line">            &#123;</span><br><span class="line">                DisableNonpointerIsa = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (PrintRawIsa) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"RAW ISA: disabling non-pointer isa because "</span></span><br><span class="line">                                 <span class="string">"the app or a framework contains Swift code "</span></span><br><span class="line">                                 <span class="string">"older than Swift 3.0"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> TARGET_OS_OSX</span></span><br><span class="line">        <span class="comment">// Disable non-pointer isa if the app is too old</span></span><br><span class="line">        <span class="comment">// (linked before OS X 10.11)</span></span><br><span class="line"><span class="comment">//        if (!dyld_program_sdk_at_least(dyld_platform_version_macOS_10_11)) &#123;</span></span><br><span class="line"><span class="comment">//            DisableNonpointerIsa = true;</span></span><br><span class="line"><span class="comment">//            if (PrintRawIsa) &#123;</span></span><br><span class="line"><span class="comment">//                _objc_inform("RAW ISA: disabling non-pointer isa because "</span></span><br><span class="line"><span class="comment">//                             "the app is too old.");</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Disable non-pointer isa if the app has a __DATA,__objc_rawisa section</span></span><br><span class="line">        <span class="comment">// New apps that load old extensions may need this.</span></span><br><span class="line">        <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hi-&gt;mhdr()-&gt;filetype != MH_EXECUTE) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line">            <span class="keyword">if</span> (getsectiondata(hi-&gt;mhdr(), <span class="string">"__DATA"</span>, <span class="string">"__objc_rawisa"</span>, &amp;<span class="built_in">size</span>)) &#123;</span><br><span class="line">                DisableNonpointerIsa = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (PrintRawIsa) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"RAW ISA: disabling non-pointer isa because "</span></span><br><span class="line">                                 <span class="string">"the app has a __DATA,__objc_rawisa section"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// assume only one MH_EXECUTE image</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DisableTaggedPointers) &#123;</span><br><span class="line">            disableTaggedPointers();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">///初始化TaggedPointer混淆</span></span><br><span class="line">        initializeTaggedPointerObfuscator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"CLASS: found %d classes during launch"</span>, totalClasses);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// namedClasses</span></span><br><span class="line">        <span class="comment">// Preoptimized classes don't go in this table.</span></span><br><span class="line">        <span class="comment">// 4/3 is NXMapTable's load factor</span></span><br><span class="line">        <span class="comment">// objc::unattachedCategories.init(32);</span></span><br><span class="line">        <span class="comment">// objc::allocatedClasses.init();</span></span><br><span class="line">        <span class="comment">//负载因子</span></span><br><span class="line">        <span class="keyword">int</span> namedClassesSize = </span><br><span class="line">            (isPreoptimized() ? unoptimizedTotalClasses : totalClasses) * <span class="number">4</span> / <span class="number">3</span>;</span><br><span class="line">  	    <span class="comment">//创建一张类的总表，包含所有的类</span></span><br><span class="line">        gdb_objc_realized_classes =</span><br><span class="line">            NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);</span><br><span class="line">        ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: first time tasks"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>主要做了两件事情</p>
<ul>
<li>初始化小对象(<code>TaggedPointer</code>)</li>
<li>创建所有类的总表,注意这个表和<code>runtime_init</code>中<code>allocatedClassess</code>的表不一样，这里是所有类的表，而<code>allocatedClassess</code>是已经实现(<code>allocated</code>)的类的表。</li>
</ul>
<h4 id="fix-up-selector-references即：修复预编译阶段的-selector-的混乱问题"><a href="#fix-up-selector-references即：修复预编译阶段的-selector-的混乱问题" class="headerlink" title="fix up selector references即：修复预编译阶段的 @selector 的混乱问题"></a>fix up selector references即：修复预编译阶段的 @selector 的混乱问题</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> UnfixedSelectors;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(selLock)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hi-&gt;hasPreoptimizedSelectors()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> isBundle = hi-&gt;isBundle();</span><br><span class="line">        SEL *sels = _getObjc2SelectorRefs(hi, &amp;count);</span><br><span class="line">        UnfixedSelectors += count;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *name = sel_cname(sels[i]);</span><br><span class="line">            SEL sel = sel_registerNameNoLock(name, isBundle);</span><br><span class="line">            <span class="keyword">if</span> (sels[i] != sel) &#123;</span><br><span class="line">                sels[i] = sel;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: fix up selector references"</span>);</span><br></pre></td></tr></table></figure>

<p><code>selecotr</code>是类的名字+地址。</p>
<ul>
<li><code>SEL *sels = _getObjc2SelectorRefs(hi, &amp;count);</code>是从<code>Mach-o</code>文件读取的</li>
<li><code>SEL sel = sel_registerNameNoLock(name, isBundle);</code>是从<code>dyld</code>链接之后获取的</li>
<li>如果两个<code>sel</code>名字相等，地址不同就需要<code>fix up</code>。</li>
</ul>
<h4 id="discover-classes即：错误混乱的类处理"><a href="#discover-classes即：错误混乱的类处理" class="headerlink" title="discover classes即：错误混乱的类处理"></a>discover classes即：错误混乱的类处理</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discover classes. Fix up unresolved future classes. Mark bundle classes.</span></span><br><span class="line"><span class="keyword">bool</span> hasDyldRoots = dyld_shared_cache_some_image_overridden();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="keyword">if</span> (! mustReadClasses(hi, hasDyldRoots)) &#123;</span><br><span class="line">        <span class="comment">// Image is sufficiently optimized that we need not call readClass()</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从mach-o读取类</span></span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist = _getObjc2ClassList(hi, &amp;count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> headerIsBundle = hi-&gt;isBundle();</span><br><span class="line">    <span class="keyword">bool</span> headerIsPreoptimized = hi-&gt;hasPreoptimizedClasses();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">//cls 目前没有名字</span></span><br><span class="line">        Class cls = (Class)classlist[i];</span><br><span class="line">      	<span class="comment">//关联类cls的名字</span></span><br><span class="line">        Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newCls != cls  &amp;&amp;  newCls) &#123;</span><br><span class="line">            <span class="comment">// Class was moved but not deleted. Currently this occurs </span></span><br><span class="line">            <span class="comment">// only when the new class resolved a future class.</span></span><br><span class="line">            <span class="comment">// Non-lazily realize the class below.</span></span><br><span class="line">            resolvedFutureClasses = (Class *)</span><br><span class="line">                <span class="built_in">realloc</span>(resolvedFutureClasses, </span><br><span class="line">                        (resolvedFutureClassCount+<span class="number">1</span>) * <span class="keyword">sizeof</span>(Class));</span><br><span class="line">            resolvedFutureClasses[resolvedFutureClassCount++] = newCls;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: discover classes"</span>);</span><br></pre></td></tr></table></figure>

<p>修复未处理的将来的类。给类关联上名字。下面我们重点探索一下<code>readClass</code>:</p>
<h4 id="readClass"><a href="#readClass" class="headerlink" title="readClass"></a>readClass</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Class <span class="title">readClass</span><span class="params">(Class cls, <span class="keyword">bool</span> headerIsBundle, <span class="keyword">bool</span> headerIsPreoptimized)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mangledName = cls-&gt;nonlazyMangledName();</span><br><span class="line">    <span class="comment">///以下代码 为笔者添加 方便调试到自定义的类（因为所以类都会执行这里，我们只关心我们定义的类）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *customerClassName = <span class="string">"JSPerson"</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(mangledName, LGPersonName) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//打印类名</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s -: 要研究的类: - %s\n"</span>,__func__,mangledName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (missingWeakSuperclass(cls)) &#123;</span><br><span class="line">        <span class="comment">// No superclass (probably weak-linked). </span></span><br><span class="line">        <span class="comment">// Disavow any knowledge of this subclass.</span></span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"CLASS: IGNORING class '%s' with "</span></span><br><span class="line">                         <span class="string">"missing weak-linked superclass"</span>, </span><br><span class="line">                         cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        addRemappedClass(cls, nil);</span><br><span class="line">        cls-&gt;setSuperclass(nil);</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cls-&gt;fixupBackwardDeployingStableSwift();</span><br><span class="line"></span><br><span class="line">    Class replacing = nil;</span><br><span class="line">    <span class="keyword">if</span> (mangledName != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Class newCls = popFutureNamedClass(mangledName)) &#123;</span><br><span class="line">            <span class="comment">//断点调试 这里并没有执行</span></span><br><span class="line">            <span class="comment">// This name was previously allocated as a future class.</span></span><br><span class="line">            <span class="comment">// Copy objc_class to future class's struct.</span></span><br><span class="line">            <span class="comment">// Preserve future's rw data block.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newCls-&gt;isAnySwift()) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">"Can't complete future class request for '%s' "</span></span><br><span class="line">                            <span class="string">"because the real class is too big."</span>,</span><br><span class="line">                            cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">class_rw_t</span> *rw = newCls-&gt;data();</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *old_ro = rw-&gt;ro();</span><br><span class="line">            <span class="built_in">memcpy</span>(newCls, cls, <span class="keyword">sizeof</span>(objc_class));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Manually set address-discriminated ptrauthed fields</span></span><br><span class="line">            <span class="comment">// so that newCls gets the correct signatures.</span></span><br><span class="line">            newCls-&gt;setSuperclass(cls-&gt;getSuperclass());</span><br><span class="line">            newCls-&gt;initIsa(cls-&gt;getIsa());</span><br><span class="line"></span><br><span class="line">            rw-&gt;set_ro((<span class="keyword">class_ro_t</span> *)newCls-&gt;data());</span><br><span class="line">            newCls-&gt;setData(rw);</span><br><span class="line">            freeIfMutable((<span class="keyword">char</span> *)old_ro-&gt;getName());</span><br><span class="line">            <span class="built_in">free</span>((<span class="keyword">void</span> *)old_ro);</span><br><span class="line"></span><br><span class="line">            addRemappedClass(cls, newCls);</span><br><span class="line"></span><br><span class="line">            replacing = cls;</span><br><span class="line">            cls = newCls;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (headerIsPreoptimized  &amp;&amp;  !replacing) &#123;</span><br><span class="line">        <span class="comment">// class list built in shared cache</span></span><br><span class="line">        <span class="comment">// fixme strict assert doesn't work because of duplicates</span></span><br><span class="line">        <span class="comment">// ASSERT(cls == getClass(name));</span></span><br><span class="line">        ASSERT(mangledName == <span class="literal">nullptr</span> || getClassExceptSomeSwift(mangledName));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mangledName) &#123; <span class="comment">//some Swift generic classes can lazily generate their names</span></span><br><span class="line">            <span class="comment">///给类添加名字</span></span><br><span class="line">            addNamedClass(cls, mangledName, replacing);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	<span class="comment">///元类也处理</span></span><br><span class="line">            Class meta = cls-&gt;ISA();</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *metaRO = meta-&gt;bits.safe_ro();</span><br><span class="line">            ASSERT(metaRO-&gt;getNonMetaclass() &amp;&amp; <span class="string">"Metaclass with lazy name must have a pointer to the corresponding nonmetaclass."</span>);</span><br><span class="line">            ASSERT(metaRO-&gt;getNonMetaclass() == cls &amp;&amp; <span class="string">"Metaclass nonmetaclass pointer must equal the original class."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">///添加到class表</span></span><br><span class="line">        addClassTableEntry(cls);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for future reference: shared cache never contains MH_BUNDLEs</span></span><br><span class="line">    <span class="keyword">if</span> (headerIsBundle) &#123;</span><br><span class="line">        cls-&gt;data()-&gt;flags |= RO_FROM_BUNDLE;</span><br><span class="line">        cls-&gt;ISA()-&gt;data()-&gt;flags |= RO_FROM_BUNDLE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们从返回值开始看<code>cls</code>,<code>cls</code>也是入参，经过<code>readClass</code>之后有了名字，主要作用就是对类及元类赋值名字并放入方法表中。</p>
<h4 id="addNamedClass-添加方法名字"><a href="#addNamedClass-添加方法名字" class="headerlink" title="addNamedClass 添加方法名字"></a>addNamedClass 添加方法名字</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addNamedClass</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, Class replacing = nil)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    Class old;</span><br><span class="line">    <span class="keyword">if</span> ((old = getClassExceptSomeSwift(name))  &amp;&amp;  old != replacing) &#123;</span><br><span class="line">        inform_duplicate(name, old, cls);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// getMaybeUnrealizedNonMetaClass uses name lookups.</span></span><br><span class="line">        <span class="comment">// Classes not found by name lookup must be in the</span></span><br><span class="line">        <span class="comment">// secondary meta-&gt;nonmeta table.</span></span><br><span class="line">        addNonMetaClass(cls);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        NXMapInsert(gdb_objc_realized_classes, name, cls);</span><br><span class="line">    &#125;</span><br><span class="line">    ASSERT(!(cls-&gt;data()-&gt;flags &amp; RO_META));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wrong: constructed classes are already realized when they get here</span></span><br><span class="line">    <span class="comment">// ASSERT(!cls-&gt;isRealized());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="addClassTableEntry"><a href="#addClassTableEntry" class="headerlink" title="addClassTableEntry"></a>addClassTableEntry</h4><p>将类添加到表里面，如果addMeta为真，并且将当前类的元类也添加到所有的表中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">addClassTableEntry(Class cls, <span class="keyword">bool</span> addMeta = <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This class is allowed to be a known class via the shared cache or via</span></span><br><span class="line">    <span class="comment">// data segments, but it is not allowed to be in the dynamic table already.</span></span><br><span class="line">    <span class="comment">//// 该类允许通过共享缓存或数据段成为已知类，但不允许已经在动态表中。</span></span><br><span class="line">    <span class="keyword">auto</span> &amp;<span class="built_in">set</span> = objc::allocatedClasses.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    ASSERT(<span class="built_in">set</span>.<span class="built_in">find</span>(cls) == <span class="built_in">set</span>.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isKnownClass(cls))</span><br><span class="line">        <span class="built_in">set</span>.insert(cls);</span><br><span class="line">    <span class="keyword">if</span> (addMeta)</span><br><span class="line">        <span class="comment">//元类插入到所有类表中</span></span><br><span class="line">        addClassTableEntry(cls-&gt;ISA(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇我们主要是对<code>objc_init</code>的流程做了一个简单的梳理，分析了<code>readClass</code>方法的作用，下一篇我们开始详细分析类的加载过程。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/07/08/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-dyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/08/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-dyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">iOS底层探索 - dyld加载流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-08 21:00:24" itemprop="dateCreated datePublished" datetime="2021-07-08T21:00:24+08:00">2021-07-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-11 00:43:08" itemprop="dateModified" datetime="2021-07-11T00:43:08+08:00">2021-07-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文我们主要探索应用程序的加载流程，也就是<code>main</code>方法之前，链接器都做了什么。了解这些对我们项目的<code>启动优化</code>有很大帮助。</p>
<h3 id="编译过程和库"><a href="#编译过程和库" class="headerlink" title="编译过程和库"></a>编译过程和库</h3><h4 id="编译的过程"><a href="#编译的过程" class="headerlink" title="编译的过程"></a>编译的过程</h4><p>我们知道库是一种<code>可执行文件</code>,从源代码到可执行文件工经历了下面几个步骤：</p>
<ul>
<li><code>源文件</code>：主要就是我们写的代码，.h、.m、.cpp等文件。</li>
<li><code>预编译</code>：主要处理哪些源代码文件中以<code>#</code>开始的预编译指令，比如<code>#include</code>、<code>#define</code>、删除所有的注释<code>//</code>和<code>/* */</code>、添加行号和文件名标识、保留所有的<code>#pragma</code>编译期指令、产生<code>.i</code>文件。</li>
<li><code>编译</code>：将<code>预处理</code>完的文件进行<code>词法分析</code>、<code>语义分析</code>及优化后输出汇编代码文件即<code>.s</code>文件。</li>
<li><code>汇编</code>：将<code>汇编代码</code>转变成机器可以执行的指令即<code>.o</code>文件。</li>
<li><code>链接</code>：对.o文件中引用其他库的地方进行引用，生成最后的可执行文件</li>
</ul>
<h4 id="动态库和静态库"><a href="#动态库和静态库" class="headerlink" title="动态库和静态库"></a>动态库和静态库</h4><p>我们项目中经常会使用到<code>动态库</code>和<code>静态库</code>,它们的区别是：</p>
<ul>
<li>静态库：在链接阶段会将汇编生成的目标文件和引用的库一起链接打包到可执行文件中。即静态库在<code>链接</code>阶段就被载入了。<ul>
<li>优点：编译完成之后的目标程序没有<code>外部依赖</code>,可以直接运行。</li>
<li>缺点：静态库可以会有多份，会导致<code>目标程序</code>体积增加，对内存、性能、速度消耗较大。</li>
</ul>
</li>
<li>动态库：程序编译并不会链接到目标代码中，在程序可执行文件里面会保留对动态库的引用，在程序<code>运行时</code>才被载入，苹果大部分官方的库都是<code>动态库</code>。<ul>
<li>优点：<ol>
<li>可以减少<code>App</code>包体积大小：因为不需要拷贝到<code>目标程序</code>中，所以不会影响<code>目标程序</code>的体积.</li>
<li>共享内存，节约资源：同一份库可以被多个程序使用。</li>
<li>可以更新动态库，而目标程序不需要重新编译：这是因为动态库<code>运行时</code>才载入，可以随时对库进行替换，而·不需要重新编译代码。</li>
</ol>
</li>
<li>缺点：由于是<code>运行时</code>载入会带来一部分性能损失，使用动态库使得程序依赖于外部环境，如果环境缺少了动态库程序就无法运行。</li>
</ul>
</li>
</ul>
<h3 id="dyld是什么"><a href="#dyld是什么" class="headerlink" title="dyld是什么"></a>dyld是什么</h3><p><code>dyld</code>是<code>动态链接器</code>,目前最新的版本是<code>dyld3</code>,我们首先看一下<code>dyld</code>的版本演变。在<code>dyld</code>之前，<code>NeXT</code>使用的是<code>静态二进制</code>数据。</p>
<h4 id="dyld版本演变"><a href="#dyld版本演变" class="headerlink" title="dyld版本演变"></a><code>dyld</code>版本演变</h4><ul>
<li><code>dyld1.0</code>(1996-2004)<ul>
<li>包含在<code>NeXTStep 3.3</code>中</li>
<li>历史早于标准化<code>POSIX dlopen()</code>的调用</li>
<li><code>macOS 10</code>之前编写第三方包装器用来以支持标准<code>Unix</code>软件，但是这些包装器并不能完美的支持相同的语义，在边界情况不能正常工作。</li>
<li>在大多数使用<code>C++</code>动态库的系统之前编写的。</li>
<li>在<code>mac OS 10.0</code>增加了<code>预绑定</code>。使用<code>预绑定</code>技术为系统中所有的<code>dylib</code>和我们的程序找到<code>固定地址</code>,<code>动态加载器</code>将会加载这些地址的所有内容。</li>
</ul>
</li>
<li><code>dyld2.0</code>(2004-2007)<ul>
<li>包含在<code>macOS Tiger</code>中</li>
<li>相比<code>1.0</code>版本是完全重写(Complete rewrite)的。</li>
<li>支持了<code>C++</code>初始化语义，扩展了<code>mach-o</code>格式。</li>
<li>有完整的本地(native)<code>dlopen</code>和<code>dlsym</code>的实现。</li>
<li><code>2.0</code>版本设计的目标是<code>提高速度</code>，仅进行有限的及安全性检查。</li>
<li>提高了安全性。</li>
<li>减少<code>预编译</code>的工作量(时长)</li>
</ul>
</li>
<li><code>dyld2.x</code>(2007-2017)<ul>
<li>增加了更多的基础架构和平台，比如<code>x86</code>、<code>x86_64</code>、<code>arm</code>、<code>arm64</code>、<code>iOS</code>、<code>tvOS</code>、<code>watchOS</code>。</li>
<li>增强了安全性。增加<code>代码签名</code>和<code>ASLR</code>(地址空间配置随机加载)，增加了<code>mach-o</code>头文件中的项目<code>边界检查</code>功能它可以避免恶意二进制数据的加入。</li>
<li>增强了性能：用<code>共享缓存</code>代替了<code>预绑定</code>。<code>共享缓存</code>是一个包含大部分<code>系统dylib</code>的单文件(Single file)，可以节省大量内存，它实际是<code>预链接</code>库。</li>
</ul>
</li>
<li><code>dyld3</code>（2017-至今）<ul>
<li>完全改变<code>动态链接器</code>的概念</li>
<li>默认适用于大部分<code>Apple OS</code>系统应用。</li>
<li>完全替代了<code>dyld2.x</code>。</li>
<li>提高了性能，尽量提高启动速度和运行速度。</li>
<li>提高安全性：将大多数<code>dyld</code>移出进程，允许部分<code>dyld</code>驻留在进程之中，驻留部分尽可能小，从而减少受攻击的面积。</li>
<li>可测试性和可靠性</li>
</ul>
</li>
</ul>
<h4 id="dyld-2和dyld-3加载过程的区别"><a href="#dyld-2和dyld-3加载过程的区别" class="headerlink" title="dyld 2和dyld 3加载过程的区别"></a><code>dyld 2</code>和<code>dyld 3</code>加载过程的区别</h4><ul>
<li><p><code>dyld 2</code>的加载过程</p>
<ol>
<li><code>Parse mach-o headers</code>:分析<code>mach-o</code>文件，通过分析<code>mach-o</code>文件弄清楚需要那些库，这些库可能需要其他库，所以会进行递归分析，直到获得所有<code>dylib</code>的完整图。一般普通<code>iOS</code>程序需要3-600个<code>dylib</code>，数据庞大，需要进行大量的处理。</li>
<li><code>Map mach-o files</code>:映射所有<code>mach-o</code>文件，将它们放入地址空间</li>
<li><code>Perform symbol lookups</code>：执行符号查找，例如程序使用了<code>printf</code>函数，将会查找<code>printf</code>是否在库系统中，然后找到它的地址，将它复制到你的程序中的函数指针。</li>
<li><code>Bind and rebase</code>:绑定和基址重置，复制<code>3</code>步的指针，由于使用随机地址，所有指针必须使用基址。</li>
<li><code>Run initializers</code>:运行初始化器，接下来准备执行<code>main</code>函数。</li>
</ol>
<p>流程图如下图，其中红色表示影响性能和安全性的步骤：</p>
</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/073f41507a9245fca094630f0fceb1e3~tplv-k3u1fbpfcp-watermark.image" alt="dyld2process"></p>
<ul>
<li><p><code>dyld3</code>加载过程</p>
<p><code>dyld3</code>包括三个部分：</p>
<ul>
<li><p><code>An out of process MachO parser/compiler</code>：进程外<code>mach-o</code>分析器和编译器。</p>
<ol>
<li><code>Resolves all search paths, @rpaths, environment variables</code>:解析所有搜索路径、<code>rpaths</code>、环境变量。</li>
<li><code>Parses the mach-o binaries</code>:分析<code>mach-o</code>二进制数据</li>
<li><code>Perform symbol lookups</code>：执行符号查找，例如程序使用了<code>printf</code>函数，将会查找<code>printf</code>是否在库系统中，然后找到它的地址，将它复制到你的程序中的函数指针。</li>
<li><code>Creates a launch closure with results</code>：创建收尾处理</li>
</ol>
</li>
<li><p><code>An in-process engine that runs launch</code>：进程内引擎执行启动收尾处理，进驻在内存中。</p>
<ol start="5">
<li><code>Validates launch closure</code>：检查启动收尾处理是否正确。</li>
<li><code>Maps in all dylibs</code>：映射到所有的<code>dylib</code>中</li>
<li><code>Applies fixups</code>：应用修正</li>
<li><code>Run initializers</code>:运行初始化器，接下来准备执行<code>main</code>函数。</li>
</ol>
</li>
<li><p><code>A launch closure caching service</code>：启动收尾缓存服务。大部分程序启动会使用缓存但始终不需要调用进程外<code>mach-o</code>分析器和编译器，启动收尾比<code>mach-o</code>更简单，启动收尾文件是内存映射文件，不需要用复杂的方法进行分析从而提高速度。</p>
<p>流程图(来源WWDC ppt)如下：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8aecf047e2548d9b1940488215457e1~tplv-k3u1fbpfcp-watermark.image" alt="dyld3"></p>
</li>
</ul>
</li>
</ul>
<p>注：本小节内容来源于<a href="https://developer.apple.com/videos/play/wwdc2017/413" target="_blank" rel="noopener">WWDC2017 App Startup Time: Past, Present, and Future</a>感兴趣的童鞋可以查看视频。</p>
<h3 id="dyld加载流程分析"><a href="#dyld加载流程分析" class="headerlink" title="dyld加载流程分析"></a>dyld加载流程分析</h3><p>通过上一小节我们其实对<code>dyld</code>的加载有一个初步的了解了，本小节主要通过看源码来探索一下加载流程。本小节需要的源码有：</p>
<ul>
<li><code>dyld</code></li>
<li><code>libobjc</code></li>
<li><code>libSystem</code></li>
<li><code>libdispatch</code></li>
</ul>
<p>源码可直接去<a href="https://opensource.apple.com/tarballs/" target="_blank" rel="noopener">苹果<code>Source Browser</code></a>下载</p>
<h4 id="dyldstart探索"><a href="#dyldstart探索" class="headerlink" title="dyldstart探索"></a><code>dyld</code>start探索</h4><ul>
<li><p>通过<code>main</code>函数</p>
<p>因为我们程序的入口是<code>main</code>函数，<code>dyld</code>是在<code>main</code>之前执行的，我们很容易想到在<code>main</code>函数打一个断点，然后查看调用堆栈信息来查看<code>dyld</code>的具体调用方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) bt</span><br><span class="line">* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1</span><br><span class="line">  * frame #<span class="number">0</span>: <span class="number">0x000000010000339b</span> DyldTest`main(argc=<span class="number">3</span>, argv=<span class="number">0x00007ffeefbff500</span>) at main.m:<span class="number">13</span>:<span class="number">5</span></span><br><span class="line">    frame #<span class="number">1</span>: <span class="number">0x00007fff6e7d3cc9</span> libdyld.dylib`start + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>通过这个方式我们看到了<code>start</code>,但是通过打符号断点并没有找到<code>start</code>方法，所以这种方式无效。</p>
</li>
<li><p>通过<code>load</code>方法</p>
<p>根据我们的经验，我们知道<code>load</code>方法是在<code>main</code>函数之前执行的，我们通过<code>load</code>方法能不能找到<code>dyld</code>的入口呢，心动不如行动，我们试一下，在<code>ViewController</code>类加入<code>load</code>方法，打上断点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(lldb) bt</span><br><span class="line">* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1</span><br><span class="line">  * frame #<span class="number">0</span>: <span class="number">0x00000001000032d7</span> DyldTest`+[ViewController load](self=ViewController, _cmd=<span class="string">"load"</span>) at ViewController.m:<span class="number">19</span>:<span class="number">5</span></span><br><span class="line">    frame #<span class="number">1</span>: <span class="number">0x00007fff6d61e560</span> libobjc.A.dylib`load_images + <span class="number">1529</span></span><br><span class="line">    frame #<span class="number">2</span>: <span class="number">0x000000010001626c</span> dyld`dyld::notifySingle(dyld_image_states, ImageLoader <span class="keyword">const</span>*, ImageLoader::InitializerTimingList*) + <span class="number">418</span></span><br><span class="line">    frame #<span class="number">3</span>: <span class="number">0x0000000100029fe9</span> dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext <span class="keyword">const</span>&amp;, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">char</span> <span class="keyword">const</span>*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class="number">475</span></span><br><span class="line">    frame #<span class="number">4</span>: <span class="number">0x00000001000280b4</span> dyld`ImageLoader::processInitializers(ImageLoader::LinkContext <span class="keyword">const</span>&amp;, <span class="keyword">unsigned</span> <span class="keyword">int</span>, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class="number">188</span></span><br><span class="line">    frame #<span class="number">5</span>: <span class="number">0x0000000100028154</span> dyld`ImageLoader::runInitializers(ImageLoader::LinkContext <span class="keyword">const</span>&amp;, ImageLoader::InitializerTimingList&amp;) + <span class="number">82</span></span><br><span class="line">    frame #<span class="number">6</span>: <span class="number">0x00000001000166a8</span> dyld`dyld::initializeMainExecutable() + <span class="number">199</span></span><br><span class="line">    frame #<span class="number">7</span>: <span class="number">0x000000010001bbba</span> dyld`dyld::_main(macho_header <span class="keyword">const</span>*, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">int</span>, <span class="keyword">char</span> <span class="keyword">const</span>**, <span class="keyword">char</span> <span class="keyword">const</span>**, <span class="keyword">char</span> <span class="keyword">const</span>**, <span class="keyword">unsigned</span> <span class="keyword">long</span>*) + <span class="number">6667</span></span><br><span class="line">    frame #<span class="number">8</span>: <span class="number">0x0000000100015227</span> dyld`dyldbootstrap::start(dyld3::MachOLoaded <span class="keyword">const</span>*, <span class="keyword">int</span>, <span class="keyword">char</span> <span class="keyword">const</span>**, dyld3::MachOLoaded <span class="keyword">const</span>*, <span class="keyword">unsigned</span> <span class="keyword">long</span>*) + <span class="number">453</span></span><br><span class="line">    frame #<span class="number">9</span>: <span class="number">0x0000000100015025</span> dyld`_dyld_start + <span class="number">37</span></span><br></pre></td></tr></table></figure>

<p>通过这个堆栈我们看到了<code>_dyld_start</code>就是<code>dyld</code>开始的函数，我们依次探讨堆栈里的方法。</p>
</li>
</ul>
<h4 id="dyld-start"><a href="#dyld-start" class="headerlink" title="_dyld_start"></a>_dyld_start</h4><p>我们首先在<code>dyld</code>源码中搜索<code>_dyld_start</code>,发现是一段汇编代码</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bfcb961c63f48f781b22bf363917866~tplv-k3u1fbpfcp-watermark.image" alt="dyld_start汇编"></p>
<p>通过注释我们可以看到，调用的是<code>dyldbootstrap</code>的<code>start</code>函数。</p>
<h4 id="dyldbootstrap-start"><a href="#dyldbootstrap-start" class="headerlink" title="dyldbootstrap::start"></a>dyldbootstrap::start</h4><p>我们在源码中搜索<code>dyldbootstrap</code>找到<code>命名空间</code>，继续查找<code>start</code>函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  This is code to bootstrap dyld.  This work in normally done for a program by dyld and crt.</span></span><br><span class="line"><span class="comment">//  In dyld we have to do this manually.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">uintptr_t</span> <span class="title">start</span><span class="params">(<span class="keyword">const</span> dyld3::MachOLoaded* appsMachHeader, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[],</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">const</span> dyld3::MachOLoaded* dyldsMachHeader, <span class="keyword">uintptr_t</span>* startGlue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">///省略代码</span></span><br><span class="line">	<span class="comment">// now that we are done bootstrapping dyld, call dyld's main</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> appsSlide = appsMachHeader-&gt;getSlide();</span><br><span class="line">	<span class="keyword">return</span> dyld::_main((macho_header*)appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数关键是最后一行，调用了<code>dyld::_main</code>。</p>
<h4 id="dyld-main"><a href="#dyld-main" class="headerlink" title="dyld::_main"></a><code>dyld::_main</code></h4><p>这个方法很长(900+行)，可以从返回值倒退看这个方法都做了什么。方法太长我们省略大部分代码(因为返回值和<code>mainExecutable</code>相关，所以截取的代码基本都和<code>mainExecutable</code>相关)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">		<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">		<span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">///省略代码</span></span><br><span class="line">  <span class="comment">// Grab the cdHash of the main executable from the environment</span></span><br><span class="line">  <span class="comment">// 创建主程序cdHash的空间</span></span><br><span class="line">	<span class="keyword">uint8_t</span> mainExecutableCDHashBuffer[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">uint8_t</span>* mainExecutableCDHash = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">if</span> ( <span class="keyword">const</span> <span class="keyword">char</span>* mainExeCdHashStr = _simple_getenv(apple, <span class="string">"executable_cdhash"</span>) ) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> bufferLenUsed;</span><br><span class="line">		<span class="keyword">if</span> ( hexStringToBytes(mainExeCdHashStr, mainExecutableCDHashBuffer, <span class="keyword">sizeof</span>(mainExecutableCDHashBuffer), bufferLenUsed) )</span><br><span class="line">			mainExecutableCDHash = mainExecutableCDHashBuffer;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/////配置信息，获取主程序的mach-o header、silder（ASLR的偏移值）</span></span><br><span class="line">	getHostInfo(mainExecutableMH, mainExecutableSlide);</span><br><span class="line">  <span class="comment">///通过silder+ASLR可以找到信息</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> result = <span class="number">0</span>;</span><br><span class="line">	sMainExecutableMachHeader = mainExecutableMH;</span><br><span class="line">	sMainExecutableSlide = mainExecutableSlide;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">///省略代码</span></span><br><span class="line">  <span class="comment">//设置上下文，将这里所有的变量放到了gLinkContext中了，保存起来</span></span><br><span class="line">  setContext(mainExecutableMH, argc, argv, envp, apple);</span><br><span class="line">  <span class="comment">//配置进程是否受限，envp是环境变量</span></span><br><span class="line">  configureProcessRestrictions(mainExecutableMH, envp);</span><br><span class="line">      configureProcessRestrictions(mainExecutableMH, envp);</span><br><span class="line">	<span class="comment">///检测是否强制dyld3</span></span><br><span class="line">	<span class="comment">// Check if we should force dyld3.  Note we have to do this outside of the regular env parsing due to AMFI</span></span><br><span class="line">	<span class="keyword">if</span> ( dyld3::internalInstall() ) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">const</span> <span class="keyword">char</span>* useClosures = _simple_getenv(envp, <span class="string">"DYLD_USE_CLOSURES"</span>)) &#123;</span><br><span class="line">			<span class="keyword">if</span> ( <span class="built_in">strcmp</span>(useClosures, <span class="string">"0"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">				sClosureMode = ClosureMode::Off;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(useClosures, <span class="string">"1"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">	#<span class="keyword">if</span> !__i386__ <span class="comment">// don't support dyld3 for 32-bit macOS</span></span><br><span class="line">				sClosureMode = ClosureMode::On;</span><br><span class="line">				sClosureKind = ClosureKind::full;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(useClosures, <span class="string">"2"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">				sClosureMode = ClosureMode::On;</span><br><span class="line">				sClosureKind = ClosureKind::minimal;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				dyld::warn(<span class="string">"unknown option to DYLD_USE_CLOSURES.  Valid options are: 0 and 1\n"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_OSX</span></span><br><span class="line">    <span class="comment">///受限制的进程，环境变量可能会变化，需要重新设置</span></span><br><span class="line">    <span class="keyword">if</span> ( !gLinkContext.allowEnvVarsPrint &amp;&amp; !gLinkContext.allowEnvVarsPath &amp;&amp; !gLinkContext.allowEnvVarsSharedCache ) &#123;</span><br><span class="line">		pruneEnvironmentVariables(envp, &amp;apple);</span><br><span class="line">		<span class="comment">// set again because envp and apple may have changed or moved</span></span><br><span class="line">		setContext(mainExecutableMH, argc, argv, envp, apple);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">#endif</span><br><span class="line">	&#123;</span><br><span class="line">    <span class="comment">///检查环境变量</span></span><br><span class="line">		checkEnvironmentVariables(envp);</span><br><span class="line">    <span class="comment">///default value for DYLD_FALLBACK_FRAMEWORK_PATH, if not set in environment</span></span><br><span class="line">    <span class="comment">///如果没有环境变量 设置默认值</span></span><br><span class="line">		defaultUninitializedFallbackPaths(envp);</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// load shared cache 加载共享缓存</span></span><br><span class="line">	checkSharedRegionDisable((dyld3::MachOLoaded*)mainExecutableMH, mainExecutableSlide)</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> !TARGET_OS_SIMULATOR</span></span><br><span class="line">  <span class="comment">///是否有启动闭包 dyld3有闭包</span></span><br><span class="line">	<span class="keyword">if</span> ( sClosureMode == ClosureMode::Off ) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( gLinkContext.verboseWarnings )</span><br><span class="line">			dyld::<span class="built_in">log</span>(<span class="string">"dyld: not using closures\n"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">///dyld3有闭包</span></span><br><span class="line">    <span class="comment">///设置加载启动模式</span></span><br><span class="line">		sLaunchModeUsed = DYLD_LAUNCH_MODE_USING_CLOSURE;</span><br><span class="line">    <span class="comment">///配置闭包</span></span><br><span class="line">		<span class="keyword">const</span> dyld3::closure::LaunchClosure* mainClosure = <span class="literal">nullptr</span>;</span><br><span class="line">		dyld3::closure::LoadedFileInfo mainFileInfo;</span><br><span class="line">		mainFileInfo.fileContent = mainExecutableMH;</span><br><span class="line">		mainFileInfo.path = sExecPath;</span><br><span class="line">    <span class="comment">// check for closure in cache first</span></span><br><span class="line">    <span class="comment">// 判断缓存中是否已经有闭包</span></span><br><span class="line">		<span class="keyword">if</span> ( sSharedCacheLoadInfo.loadAddress != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">			mainClosure = sSharedCacheLoadInfo.loadAddress-&gt;findClosure(sExecPath);</span><br><span class="line">			<span class="keyword">if</span> ( gLinkContext.verboseWarnings &amp;&amp; (mainClosure != <span class="literal">nullptr</span>) )</span><br><span class="line">				dyld::<span class="built_in">log</span>(<span class="string">"dyld: found closure %p (size=%lu) in dyld shared cache\n"</span>, mainClosure, mainClosure-&gt;<span class="built_in">size</span>());</span><br><span class="line">			<span class="keyword">if</span> ( mainClosure != <span class="literal">nullptr</span> )</span><br><span class="line">				sLaunchModeUsed |= DYLD_LAUNCH_MODE_CLOSURE_FROM_OS;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">///如果闭包已失效</span></span><br><span class="line">    <span class="keyword">if</span> ( (mainClosure != <span class="literal">nullptr</span>) &amp;&amp; !closureValid(mainClosure, mainFileInfo, mainExecutableCDHash, <span class="literal">true</span>, envp) ) &#123;</span><br><span class="line">			mainClosure = <span class="literal">nullptr</span>;</span><br><span class="line">			sLaunchModeUsed &amp;= ~DYLD_LAUNCH_MODE_CLOSURE_FROM_OS;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">///没有闭包创建一个</span></span><br><span class="line">    <span class="keyword">if</span> ( (mainClosure == <span class="literal">nullptr</span>) &amp;&amp; allowClosureRebuilds ) &#123;</span><br><span class="line">			<span class="comment">// if forcing closures, and no closure in cache, or it is invalid, check for cached closure</span></span><br><span class="line">			<span class="keyword">if</span> ( !sForceInvalidSharedCacheClosureFormat )</span><br><span class="line">				mainClosure = findCachedLaunchClosure(mainExecutableCDHash, mainFileInfo, envp, bootToken);</span><br><span class="line">			<span class="keyword">if</span> ( mainClosure == <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">				<span class="comment">// if  no cached closure found, build new one</span></span><br><span class="line">				mainClosure = buildLaunchClosure(mainExecutableCDHash, mainFileInfo, envp, bootToken);</span><br><span class="line">				<span class="keyword">if</span> ( mainClosure != <span class="literal">nullptr</span> )</span><br><span class="line">					sLaunchModeUsed |= DYLD_LAUNCH_MODE_BUILT_CLOSURE_AT_LAUNCH;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// try using launch closure 使用启动闭包</span></span><br><span class="line">		<span class="keyword">if</span> ( mainClosure != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">			CRSetCrashLogMessage(<span class="string">"dyld3: launch started"</span>);</span><br><span class="line">			<span class="keyword">if</span> ( mainClosure-&gt;topImage()-&gt;fixupsNotEncoded() )</span><br><span class="line">				sLaunchModeUsed |= DYLD_LAUNCH_MODE_MINIMAL_CLOSURE;</span><br><span class="line">      <span class="keyword">bool</span> closureOutOfDate;</span><br><span class="line">			<span class="keyword">bool</span> recoverable;</span><br><span class="line">      <span class="comment">///启动闭包</span></span><br><span class="line">			<span class="keyword">bool</span> launched = launchWithClosure(mainClosure, sSharedCacheLoadInfo.loadAddress, (dyld3::MachOLoaded*)mainExecutableMH,</span><br><span class="line">											  mainExecutableSlide, argc, argv, envp, apple, diag, &amp;result, startGlue, &amp;closureOutOfDate, &amp;recoverable);</span><br><span class="line">      <span class="comment">/// 如果启动失败</span></span><br><span class="line">      <span class="keyword">if</span> ( !launched &amp;&amp; closureOutOfDate &amp;&amp; allowClosureRebuilds ) &#123;</span><br><span class="line">				<span class="comment">// closure is out of date, build new one</span></span><br><span class="line">				mainClosure = buildLaunchClosure(mainExecutableCDHash, mainFileInfo, envp, bootToken);</span><br><span class="line">        <span class="comment">///重新启动</span></span><br><span class="line">        launched = launchWithClosure(mainClosure, sSharedCacheLoadInfo.loadAddress, (dyld3::MachOLoaded*)mainExecutableMH,</span><br><span class="line">												 mainExecutableSlide, argc, argv, envp, apple, diag, &amp;result, startGlue, &amp;closureOutOfDate, &amp;recoverable);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">///启动成功 返回main函数</span></span><br><span class="line">      <span class="keyword">if</span> ( launched ) &#123;</span><br><span class="line">				gLinkContext.startedInitializingMainExecutable = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">if</span> (sSkipMain)</span><br><span class="line">					result = (<span class="keyword">uintptr_t</span>)&amp;fake_main;</span><br><span class="line">				<span class="keyword">return</span> result;</span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">///不是dyld3的省略代码</span></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   <span class="comment">///省略代码</span></span><br><span class="line">   <span class="comment">// load any inserted libraries插入动态库</span></span><br><span class="line">		<span class="keyword">if</span>	( sEnv.DYLD_INSERT_LIBRARIES != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class="literal">NULL</span>; ++lib) </span><br><span class="line">				loadInsertedDylib(*lib);</span><br><span class="line">		&#125;</span><br><span class="line">   <span class="comment">///弱引用绑定主程序</span></span><br><span class="line">   sMainExecutable-&gt;weakBind(gLinkContext);</span><br><span class="line">    <span class="comment">// run all initializers</span></span><br><span class="line">    <span class="comment">// 运行所有initializers</span></span><br><span class="line">		initializeMainExecutable(); </span><br><span class="line">    <span class="comment">// notify any montoring proccesses that this process is about to enter main()</span></span><br><span class="line">    <span class="comment">/// 通知可以进入main函数了</span></span><br><span class="line">		notifyMonitoringDyldMain();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大体流程就是：</p>
<ul>
<li>配置环境变量</li>
<li>检查共享缓存是否开启，以及共享缓存是否映射到共享区域</li>
<li>主程序初始化即<code>instantiateFromLoadedImage</code></li>
<li>插入动态库</li>
<li>link主程序</li>
<li>link动态库</li>
<li>弱符号绑定</li>
<li>执行初始化方法</li>
<li>主程序入口</li>
</ul>
<h4 id="dyld-initializeMainExecutable"><a href="#dyld-initializeMainExecutable" class="headerlink" title="dyld::initializeMainExecutable"></a>dyld::initializeMainExecutable</h4><p>主要是循环遍历执行<code>runInitializers</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initializeMainExecutable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// record that we've reached this step</span></span><br><span class="line">	gLinkContext.startedInitializingMainExecutable = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// run initialzers for any inserted dylibs</span></span><br><span class="line">	ImageLoader::InitializerTimingList initializerTimes[allImagesCount()];</span><br><span class="line">	initializerTimes[<span class="number">0</span>].count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">size_t</span> rootCount = sImageRoots.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> ( rootCount &gt; <span class="number">1</span> ) &#123;</span><br><span class="line">    <span class="comment">///遍历 执行</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">1</span>; i &lt; rootCount; ++i) &#123;</span><br><span class="line">			sImageRoots[i]-&gt;runInitializers(gLinkContext, initializerTimes[<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// run initializers for main executable and everything it brings up </span></span><br><span class="line">	sMainExecutable-&gt;runInitializers(gLinkContext, initializerTimes[<span class="number">0</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// register cxa_atexit() handler to run static terminators in all loaded images when this process exits</span></span><br><span class="line">	<span class="keyword">if</span> ( gLibSystemHelpers != <span class="literal">NULL</span> ) </span><br><span class="line">		(*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// dump info if requested</span></span><br><span class="line">	<span class="keyword">if</span> ( sEnv.DYLD_PRINT_STATISTICS )</span><br><span class="line">		ImageLoader::printStatistics((<span class="keyword">unsigned</span> <span class="keyword">int</span>)allImagesCount(), initializerTimes[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">if</span> ( sEnv.DYLD_PRINT_STATISTICS_DETAILS )</span><br><span class="line">		ImageLoaderMachO::printStatisticsDetails((<span class="keyword">unsigned</span> <span class="keyword">int</span>)allImagesCount(), initializerTimes[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ImageLoader-runInitializers"><a href="#ImageLoader-runInitializers" class="headerlink" title="ImageLoader::runInitializers"></a>ImageLoader::runInitializers</h4><p>核心代码是调用<code>processInitializers</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageLoader::runInitializers</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context, InitializerTimingList&amp; timingInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line">	<span class="keyword">mach_port_t</span> thisThread = mach_thread_self();</span><br><span class="line">	ImageLoader::UninitedUpwards up;</span><br><span class="line">	up.count = <span class="number">1</span>;</span><br><span class="line">	up.imagesAndPaths[<span class="number">0</span>] = &#123; <span class="keyword">this</span>, <span class="keyword">this</span>-&gt;getPath() &#125;;</span><br><span class="line">  <span class="comment">///调用</span></span><br><span class="line">	processInitializers(context, thisThread, timingInfo, up);</span><br><span class="line">	context.notifyBatch(dyld_image_state_initialized, <span class="literal">false</span>);</span><br><span class="line">	mach_port_deallocate(mach_task_self(), thisThread);</span><br><span class="line">	<span class="keyword">uint64_t</span> t2 = mach_absolute_time();</span><br><span class="line">	fgTotalInitTime += (t2 - t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ImageLoader-processInitializers"><a href="#ImageLoader-processInitializers" class="headerlink" title="ImageLoader::processInitializers"></a>ImageLoader::processInitializers</h4><p>对镜像列表调用<code>recursiveInitialization</code>函数进行递归实例化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageLoader::processInitializers</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context, <span class="keyword">mach_port_t</span> thisThread,</span></span></span><br><span class="line"><span class="function"><span class="params">									 InitializerTimingList&amp; timingInfo, ImageLoader::UninitedUpwards&amp; images)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> maxImageCount = context.imageCount()+<span class="number">2</span>;</span><br><span class="line">	ImageLoader::UninitedUpwards upsBuffer[maxImageCount];</span><br><span class="line">	ImageLoader::UninitedUpwards&amp; ups = upsBuffer[<span class="number">0</span>];</span><br><span class="line">	ups.count = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// Calling recursive init on all images in images list, building a new list of</span></span><br><span class="line">	<span class="comment">// uninitialized upward dependencies.</span></span><br><span class="line">  <span class="comment">// 递归实例化</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">uintptr_t</span> i=<span class="number">0</span>; i &lt; images.count; ++i) &#123;</span><br><span class="line">		images.imagesAndPaths[i].first-&gt;recursiveInitialization(context, thisThread, images.imagesAndPaths[i].second, timingInfo, ups);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// If any upward dependencies remain, init them.</span></span><br><span class="line">	<span class="keyword">if</span> ( ups.count &gt; <span class="number">0</span> )</span><br><span class="line">		processInitializers(context, thisThread, timingInfo, ups);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ImageLoader-recursiveInitialization"><a href="#ImageLoader-recursiveInitialization" class="headerlink" title="ImageLoader::recursiveInitialization"></a>ImageLoader::recursiveInitialization</h4><p>主要是加载完镜像后通知出去</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageLoader::recursiveInitialization</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context, <span class="keyword">mach_port_t</span> this_thread, <span class="keyword">const</span> <span class="keyword">char</span>* pathToInitialize,</span></span></span><br><span class="line"><span class="function"><span class="params">										  InitializerTimingList&amp; timingInfo, UninitedUpwards&amp; uninitUps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">///递归锁</span></span><br><span class="line">	<span class="function">recursive_lock <span class="title">lock_info</span><span class="params">(this_thread)</span></span>;</span><br><span class="line">	recursiveSpinLock(lock_info);</span><br><span class="line">	<span class="keyword">if</span> ( fState &lt; dyld_image_state_dependents_initialized<span class="number">-1</span> ) &#123;</span><br><span class="line">		<span class="keyword">uint8_t</span> oldState = fState;</span><br><span class="line">		<span class="comment">// break cycles 结束递归</span></span><br><span class="line">		fState = dyld_image_state_dependents_initialized<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// initialize lower level libraries first</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; libraryCount(); ++i) &#123;</span><br><span class="line">				ImageLoader* dependentImage = libImage(i);</span><br><span class="line">				<span class="keyword">if</span> ( dependentImage != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">					<span class="comment">// don't try to initialize stuff "above" me yet</span></span><br><span class="line">					<span class="keyword">if</span> ( libIsUpward(i) ) &#123;</span><br><span class="line">						uninitUps.imagesAndPaths[uninitUps.count] = &#123; dependentImage, libPath(i) &#125;;</span><br><span class="line">						uninitUps.count++;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> ( dependentImage-&gt;fDepth &gt;= fDepth ) &#123;</span><br><span class="line">						dependentImage-&gt;recursiveInitialization(context, this_thread, libPath(i), timingInfo, uninitUps);</span><br><span class="line">					&#125;</span><br><span class="line">                &#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// record termination order</span></span><br><span class="line">			<span class="keyword">if</span> ( <span class="keyword">this</span>-&gt;needsTermination() )</span><br><span class="line">				context.terminationRecorder(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// let objc know we are about to initialize this image</span></span><br><span class="line">      <span class="comment">// 让objc知道我们要初始化此镜像</span></span><br><span class="line">			<span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line">			fState = dyld_image_state_dependents_initialized;</span><br><span class="line">			oldState = fState;</span><br><span class="line">			context.notifySingle(dyld_image_state_dependents_initialized, <span class="keyword">this</span>, &amp;timingInfo);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// initialize this image</span></span><br><span class="line">      <span class="comment">/// 初始化镜像</span></span><br><span class="line">			<span class="keyword">bool</span> hasInitializers = <span class="keyword">this</span>-&gt;doInitialization(context);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// let anyone know we finished initializing this image</span></span><br><span class="line">      <span class="comment">/// 让任何人都知道我们完成了这个镜像的初始化</span></span><br><span class="line">			fState = dyld_image_state_initialized;</span><br><span class="line">			oldState = fState;</span><br><span class="line">			context.notifySingle(dyld_image_state_initialized, <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> ( hasInitializers ) &#123;</span><br><span class="line">				<span class="keyword">uint64_t</span> t2 = mach_absolute_time();</span><br><span class="line">				timingInfo.addTime(<span class="keyword">this</span>-&gt;getShortName(), t2-t1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line">			<span class="comment">// this image is not initialized</span></span><br><span class="line">			fState = oldState;</span><br><span class="line">			recursiveSpinUnLock();</span><br><span class="line">			<span class="keyword">throw</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	recursiveSpinUnLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dyld-notifySingle"><a href="#dyld-notifySingle" class="headerlink" title="dyld::notifySingle"></a>dyld::notifySingle</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notifySingle</span><span class="params">(dyld_image_states state, <span class="keyword">const</span> ImageLoader* <span class="built_in">image</span>, ImageLoader::InitializerTimingList* timingInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//dyld::log("notifySingle(state=%d, image=%s)\n", state, image-&gt;getPath());</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;dyld_image_state_change_handler&gt;* handlers = stateToHandlers(state, sSingleHandlers);</span><br><span class="line">	<span class="keyword">if</span> ( handlers != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">		dyld_image_info info;</span><br><span class="line">		info.imageLoadAddress	= <span class="built_in">image</span>-&gt;machHeader();</span><br><span class="line">		info.imageFilePath		= <span class="built_in">image</span>-&gt;getRealPath();</span><br><span class="line">		info.imageFileModDate	= <span class="built_in">image</span>-&gt;lastModified();</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;dyld_image_state_change_handler&gt;::iterator it = handlers-&gt;<span class="built_in">begin</span>(); it != handlers-&gt;<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">char</span>* result = (*it)(state, <span class="number">1</span>, &amp;info);</span><br><span class="line">			<span class="keyword">if</span> ( (result != <span class="literal">NULL</span>) &amp;&amp; (state == dyld_image_state_mapped) ) &#123;</span><br><span class="line">				<span class="comment">//fprintf(stderr, "  image rejected by handler=%p\n", *it);</span></span><br><span class="line">				<span class="comment">// make copy of thrown string so that later catch clauses can free it</span></span><br><span class="line">				<span class="keyword">const</span> <span class="keyword">char</span>* str = strdup(result);</span><br><span class="line">				<span class="keyword">throw</span> str;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ( state == dyld_image_state_mapped ) &#123;</span><br><span class="line">		<span class="comment">// &lt;rdar://problem/7008875&gt; Save load addr + UUID for images from outside the shared cache</span></span><br><span class="line">		<span class="comment">// &lt;rdar://problem/50432671&gt; Include UUIDs for shared cache dylibs in all image info when using private mapped shared caches</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">image</span>-&gt;inSharedCache()</span><br><span class="line">			|| (gLinkContext.sharedRegionMode == ImageLoader::kUsePrivateSharedRegion)) &#123;</span><br><span class="line">			dyld_uuid_info info;</span><br><span class="line">			<span class="keyword">if</span> ( <span class="built_in">image</span>-&gt;getUUID(info.imageUUID) ) &#123;</span><br><span class="line">				info.imageLoadAddress = <span class="built_in">image</span>-&gt;machHeader();</span><br><span class="line">				addNonSharedCacheImageUUID(info);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ( (state == dyld_image_state_dependents_initialized) &amp;&amp; (sNotifyObjCInit != <span class="literal">NULL</span>) &amp;&amp; <span class="built_in">image</span>-&gt;notifyObjC() ) &#123;</span><br><span class="line">		<span class="keyword">uint64_t</span> t0 = mach_absolute_time();</span><br><span class="line">		<span class="function">dyld3::ScopedTimer <span class="title">timer</span><span class="params">(DBG_DYLD_TIMING_OBJC_INIT, (<span class="keyword">uint64_t</span>)<span class="built_in">image</span>-&gt;machHeader(), <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">///重点操作</span></span><br><span class="line">		(*sNotifyObjCInit)(<span class="built_in">image</span>-&gt;getRealPath(), <span class="built_in">image</span>-&gt;machHeader());</span><br><span class="line">		<span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line">		<span class="keyword">uint64_t</span> t2 = mach_absolute_time();</span><br><span class="line">		<span class="keyword">uint64_t</span> timeInObjC = t1-t0;</span><br><span class="line">		<span class="keyword">uint64_t</span> emptyTime = (t2-t1)*<span class="number">100</span>;</span><br><span class="line">		<span class="keyword">if</span> ( (timeInObjC &gt; emptyTime) &amp;&amp; (timingInfo != <span class="literal">NULL</span>) ) &#123;</span><br><span class="line">			timingInfo-&gt;addTime(<span class="built_in">image</span>-&gt;getShortName(), timeInObjC);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// mach message csdlc about dynamically unloaded images</span></span><br><span class="line">	<span class="keyword">if</span> ( <span class="built_in">image</span>-&gt;addFuncNotified() &amp;&amp; (state == dyld_image_state_terminated) ) &#123;</span><br><span class="line">		notifyKernel(*<span class="built_in">image</span>, <span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mach_header</span>* <span class="title">loadAddress</span>[] = &#123;</span> <span class="built_in">image</span>-&gt;machHeader() &#125;;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span>* loadPath[] = &#123; <span class="built_in">image</span>-&gt;getPath() &#125;;</span><br><span class="line">		notifyMonitoringDyld(<span class="literal">true</span>, <span class="number">1</span>, loadAddress, loadPath);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其重点是<code>(*sNotifyObjCInit)(image-&gt;getRealPath(), image-&gt;machHeader());</code>，我们全局搜索<code>sNotifyObjCInit</code>并没有实现，但是有赋值操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerObjCNotifiers</span><span class="params">(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// record functions to call</span></span><br><span class="line">	sNotifyObjCMapped	= mapped;</span><br><span class="line">  <span class="comment">///赋值操作</span></span><br><span class="line">	sNotifyObjCInit		= init;</span><br><span class="line">	sNotifyObjCUnmapped = unmapped;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// call 'mapped' function with all images mapped so far</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		notifyBatchPartial(dyld_image_state_bound, <span class="literal">true</span>, <span class="literal">NULL</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line">		<span class="comment">// ignore request to abort during registration</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// &lt;rdar://problem/32209809&gt; call 'init' function on all images already init'ed (below libSystem)</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ImageLoader*&gt;::iterator it=sAllImages.<span class="built_in">begin</span>(); it != sAllImages.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		ImageLoader* <span class="built_in">image</span> = *it;</span><br><span class="line">		<span class="keyword">if</span> ( (<span class="built_in">image</span>-&gt;getState() == dyld_image_state_initialized) &amp;&amp; <span class="built_in">image</span>-&gt;notifyObjC() ) &#123;</span><br><span class="line">			<span class="function">dyld3::ScopedTimer <span class="title">timer</span><span class="params">(DBG_DYLD_TIMING_OBJC_INIT, (<span class="keyword">uint64_t</span>)<span class="built_in">image</span>-&gt;machHeader(), <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">			(*sNotifyObjCInit)(<span class="built_in">image</span>-&gt;getRealPath(), <span class="built_in">image</span>-&gt;machHeader());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>registerObjCNotifiers</code>是在<code>_dyld_objc_notify_register</code>调用，而<code>_dyld_objc_notify_register</code>函数是在<code>libobjc</code>源码<code>_objc_init</code>代用的，所以<code>sNotifyObjCInit</code>的<code>赋值</code>的就是<code>objc</code>中的<code>load_images</code>，而<code>load_images</code>会调用所有的<code>+load</code>方法。所以综上所述，<code>notifySingle</code>是一个<code>回调函数</code>,所以我们继续看<code>load_images</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    runtime_init();</span><br><span class="line">    exception_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    <span class="keyword">cache_t</span>::init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    _imp_implementationWithBlock_init();</span><br><span class="line"></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    didCallDyldNotifyRegister = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="load-images"><a href="#load-images" class="headerlink" title="load_images"></a>load_images</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">load_images(<span class="keyword">const</span> <span class="keyword">char</span> *path __unused, <span class="keyword">const</span> struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!didInitialAttachCategories &amp;&amp; didCallDyldNotifyRegister) &#123;</span><br><span class="line">        didInitialAttachCategories = <span class="literal">true</span>;</span><br><span class="line">        loadAllCategories();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return without taking locks if there are no +load methods here.</span></span><br><span class="line">    <span class="keyword">if</span> (!hasLoadMethods((<span class="keyword">const</span> headerType *)mh)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">recursive_mutex_locker_t</span> <span class="title">lock</span><span class="params">(loadMethodLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Discover load methods</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock2</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">        prepare_load_methods((<span class="keyword">const</span> headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class="line"> 		<span class="comment">// 调用了load方法</span></span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法比较简单，主要调用了<code>call_load_methods</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = NO;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = YES;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>call_load_methods</code>方法的核心就是循环调用<code>load</code>方法。</p>
<p>###总结</p>
<p>load的源码链为：<code>_dyld_start</code> –&gt; <code>dyldbootstrap::start</code> –&gt; <code>dyld::_main</code> –&gt; <code>dyld::initializeMainExecutable</code> –&gt; <code>ImageLoader::runInitializers</code> –&gt; <code>ImageLoader::processInitializers</code> –&gt; <code>ImageLoader::recursiveInitialization</code> –&gt; <code>dyld::notifySingle</code>(是一个回调处理) –&gt; <code>sNotifyObjCInit</code> –&gt; <code>load_images(libobjc.A.dylib)</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/07/04/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/04/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/" class="post-title-link" itemprop="url">iOS底层探索 - 消息转发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-04 17:14:03" itemprop="dateCreated datePublished" datetime="2021-07-04T17:14:03+08:00">2021-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-05 17:22:46" itemprop="dateModified" datetime="2021-07-05T17:22:46+08:00">2021-07-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一篇中我们探索了消息发送找不到方法的一个流程<code>动态方法决议</code>，本篇探索<code>动态方法决议</code>也找不到<code>imp</code>的下一步，也就是<code>消息转发</code>。</p>
<p>和前面的流程不同的是，<code>消息转发</code>的源码并不在<code>libobjc</code>库里，而是在<code>CFFoundtion</code>框架里，<code>CFFoundtion</code>框已经开源的代码里没有找到消息转发的内容，所以我们必须找其它方式探索这个流程。</p>
<h3 id="通过instrumentObjcMessageSends打印消息日志方式"><a href="#通过instrumentObjcMessageSends打印消息日志方式" class="headerlink" title="通过instrumentObjcMessageSends打印消息日志方式"></a>通过instrumentObjcMessageSends打印消息日志方式</h3><h4 id="instrumentObjcMessageSends的由来"><a href="#instrumentObjcMessageSends的由来" class="headerlink" title="instrumentObjcMessageSends的由来"></a>instrumentObjcMessageSends的由来</h4><p>通过方法调用这条链路<code>lookUpImpOrForward --&gt; log_and_fill_cache --&gt; logMessageSend</code>,我们在<code>logMessageSend</code>方法源码下方找到<code>instrumentObjcMessageSends</code>的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">instrumentObjcMessageSends</span><span class="params">(BOOL flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> enable = flag;</span><br><span class="line">    <span class="comment">// Shortcut NOP</span></span><br><span class="line">    <span class="keyword">if</span> (objcMsgLogEnabled == enable)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// If enabling, flush all method caches so we get some traces</span></span><br><span class="line">    <span class="keyword">if</span> (enable)</span><br><span class="line">        _objc_flush_caches(Nil);</span><br><span class="line">    <span class="comment">// Sync our log file</span></span><br><span class="line">    <span class="keyword">if</span> (objcMsgLogFD != <span class="number">-1</span>)</span><br><span class="line">        fsync (objcMsgLogFD);</span><br><span class="line">  	<span class="comment">//赋值是否需要打印message log</span></span><br><span class="line">    objcMsgLogEnabled = enable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>log</code>文件存储的路径我们从<code>logMessageSend</code>方法里可以看到，为<code>/tmp/msgSends</code>目录：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">logMessageSend</span><span class="params">(<span class="keyword">bool</span> isClassMethod,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">char</span> *objectsClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">char</span> *implementingClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                    SEL selector)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>	buf[ <span class="number">1024</span> ];</span><br><span class="line">    <span class="comment">// Create/open the log file</span></span><br><span class="line">    <span class="keyword">if</span> (objcMsgLogFD == (<span class="number">-1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">///日志文件打印路径</span></span><br><span class="line">        <span class="built_in">snprintf</span> (buf, <span class="keyword">sizeof</span>(buf), <span class="string">"/tmp/msgSends-%d"</span>, (<span class="keyword">int</span>) getpid ());</span><br><span class="line">        objcMsgLogFD = secure_open (buf, O_WRONLY | O_CREAT, geteuid());</span><br><span class="line">        <span class="keyword">if</span> (objcMsgLogFD &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// no log file - disable logging</span></span><br><span class="line">            objcMsgLogEnabled = <span class="literal">false</span>;</span><br><span class="line">            objcMsgLogFD = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Make the log entry</span></span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"%c %s %s %s\n"</span>,</span><br><span class="line">            isClassMethod ? <span class="string">'+'</span> : <span class="string">'-'</span>,</span><br><span class="line">            objectsClass,</span><br><span class="line">            implementingClass,</span><br><span class="line">            sel_getName(selector));</span><br><span class="line"></span><br><span class="line">    objcMsgLogLock.lock();</span><br><span class="line">    <span class="built_in">write</span> (objcMsgLogFD, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    objcMsgLogLock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell caller to not cache the method</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="instrumentObjcMessageSends的使用"><a href="#instrumentObjcMessageSends的使用" class="headerlink" title="instrumentObjcMessageSends的使用"></a>instrumentObjcMessageSends的使用</h4><ol>
<li>在<code>main.m</code>文件里，通过<code>extern</code>声明<code>instrumentObjcMessageSends</code>方法。</li>
<li>在调用方法前打开日志，调用方法后关闭日志。代码如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extern void instrumentObjcMessageSends(BOOL flag);</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        instrumentObjcMessageSends(YES);</span><br><span class="line">        JSPerson *person &#x3D; [JSPerson alloc];</span><br><span class="line">        [person saySomething];</span><br><span class="line">        instrumentObjcMessageSends(NO);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>运行代码，查看日志文件</li>
</ol>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/131e13fdd8ba4e9c851035e04011c6ce~tplv-k3u1fbpfcp-watermark.image" alt="1625403519834"></p>
<p>通过日志文件可以清楚的看到都执行了哪些方法：</p>
<ul>
<li><code>resolveInstanceMethod</code>方法，即<code>动态方法决议</code></li>
<li><code>forwardingTargetForSelector</code>方法，即<code>快速消息转发</code></li>
<li><code>methodSignatureForSelector</code>方法，即<code>慢速消息转发</code></li>
<li><code>resolveInstanceMethod</code>方法。即第二次<code>动态方法决议</code></li>
<li>最后执行<code>doesNotRecognizeSelector</code>,抛出异常。</li>
</ul>
<p>这种方式我们就可以清楚的看到方法的调用流程，下面我们换一种方式验证一下。</p>
<h3 id="反编译方式探索"><a href="#反编译方式探索" class="headerlink" title="反编译方式探索"></a>反编译方式探索</h3><p><a href="https://www.hopperapp.com/" target="_blank" rel="noopener">Hopper</a>是一款帮助我们静态分析可执行文件的工具。有了工具后我们还缺少两个东西才能继续探索：</p>
<ol>
<li><p>反编译之后，搜索代码的<code>关键字</code></p>
<p>我们执行运行下面的代码，注意：<code>sayNB</code>方法是没有实现的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        JSPerson *person &#x3D; [JSPerson alloc];</span><br><span class="line">        [person sayNB];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之后会直接崩溃，我们使用<code>bt</code>命令查看调用栈信息</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7445c42269564c2b860969ccd4794c70~tplv-k3u1fbpfcp-watermark.image" alt="1625404761976"></p>
<p>可以看到这里方法调用的起点是<code>CoreFoundation</code>_<em>forwarding_prep_0__</em> + 120`,所以我们搜索反编译代码的关键字就是<strong>forwarding_prep_0</strong></p>
</li>
<li><p>怎么获取我们需要反编译的可执行文件</p>
<p>通过<code>1</code>步，我们知道<code>__forwarding_prep_0___</code>在<code>CoreFoundation</code>框架中,我们通过<code>lldb</code>的<code>image list</code>命令，找到<code>CoreFoundation</code>可执行文件的位置。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8930d06b559e46309e32738c99056d77~tplv-k3u1fbpfcp-watermark.image" alt="1625405481311"></p>
<p>通过上图中目录我们找到<code>CoreFoundation</code>文件。</p>
</li>
<li><p>前面两个必要条件明确之后，我们打开<code>Hooper</code>软件，选择<code>Try The Demo</code>(主要因为软件太贵，土豪请直接购买正版)，然后将上一步的可执行文件拖入<code>Hooper</code>进行反编译，选择<code>x86(64 bit)</code></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4999c11756d04c9dae3e524b3e288e5b~tplv-k3u1fbpfcp-watermark.image" alt="1625405841994"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9d4ad3ee4f94c3999a30b4309cdd2ab~tplv-k3u1fbpfcp-watermark.image" alt="1625406148399"></p>
<p><code>Hooper</code>软件我们用到的工具栏的示意图如下图：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7921490cdb4c421089f3a83d2c4d1763~tplv-k3u1fbpfcp-watermark.image" alt="Hopperc菜单示意图"></p>
</li>
<li><p>在<code>搜索框</code>位置搜索<code>__forwarding_prep_0___</code>,选择<code>伪代码</code>视图，发现和我们打印的堆栈信息一致，调用了<code>____forwarding___</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ___forwarding_prep_0___(<span class="keyword">int</span> arg0, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, <span class="keyword">int</span> arg3, <span class="keyword">int</span> arg4, <span class="keyword">int</span> arg5) &#123;</span><br><span class="line">    var_20 = rax;</span><br><span class="line">    var_30 = zero_extend_64(xmm7);</span><br><span class="line">    var_40 = zero_extend_64(xmm6);</span><br><span class="line">    var_50 = zero_extend_64(xmm5);</span><br><span class="line">    var_60 = zero_extend_64(xmm4);</span><br><span class="line">    var_70 = zero_extend_64(xmm3);</span><br><span class="line">    var_80 = zero_extend_64(xmm2);</span><br><span class="line">    var_90 = zero_extend_64(xmm1);</span><br><span class="line">    var_A0 = zero_extend_64(xmm0);</span><br><span class="line">    var_A8 = arg5;</span><br><span class="line">    var_B0 = arg4;</span><br><span class="line">    var_B8 = arg3;</span><br><span class="line">    var_C0 = arg2;</span><br><span class="line">    var_C8 = arg1;</span><br><span class="line">  	<span class="comment">///和我们打印的调用栈一致 </span></span><br><span class="line">    rax = ____forwarding___(&amp;var_D0, <span class="number">0x0</span>);</span><br><span class="line">    <span class="keyword">if</span> (rax != <span class="number">0x0</span>) &#123;</span><br><span class="line">            rax = *rax;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">            rax = objc_msgSend(var_D0, var_C8);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>继续看<code>____forwarding___</code>方法的伪代码，首先是判断是否实现<code>快速转发</code>方法<code>forwardingTargetForSelector</code>,如果没有跳转到<code>loc_64a67</code>走<code>慢速转发流程</code></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40aabbc8d5924e3999abef17c93a76bd~tplv-k3u1fbpfcp-watermark.image" alt="1625407414541"></p>
</li>
<li><p>goto <code>loc_64a67</code>查看<code>慢速转发</code></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef890803c42b4154916182dbd36a3b03~tplv-k3u1fbpfcp-watermark.image" alt="1625407939155"></p>
</li>
<li><p>如果没有实现则跳转，直接报错。</p>
</li>
</ol>
<p>通过使用反编译的方式我们也验证了<code>消息转发</code>的流程。</p>
<h3 id="消息转发实例"><a href="#消息转发实例" class="headerlink" title="消息转发实例"></a>消息转发实例</h3><p>在前面的例子中，我们补充一下<code>消息转发</code>的部分.</p>
<h4 id="快速消息转发"><a href="#快速消息转发" class="headerlink" title="快速消息转发"></a>快速消息转发</h4><ul>
<li>我们先定义一个<code>JSProxy</code>类，它实现了<code>sayNB</code>方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@interface JSPerson : NSObject</span><br><span class="line"></span><br><span class="line">- (void)sayNB;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation JSProxy</span><br><span class="line"></span><br><span class="line">- (void)sayNB&#123;</span><br><span class="line">    NSLog(@&quot;%@ - %s&quot;,self , __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>JSPerson</code>类中添加<code>forwardingTargetForSelector</code>方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;JSProxy.h&quot;</span><br><span class="line">@implementation JSPerson</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">    NSLog(@&quot;forwardingTargetForSelector :%@-%@&quot;,self,NSStringFromSelector(aSelector));</span><br><span class="line">    return [JSProxy alloc];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<ul>
<li>运行代码程序可以正常运行，打印<code>log</code>如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span><span class="number">-07</span><span class="number">-04</span> <span class="number">22</span>:<span class="number">24</span>:<span class="number">49.089260</span>+<span class="number">0800</span> ResolveMethodTest[<span class="number">7682</span>:<span class="number">442095</span>] resolveInstanceMethod :JSPerson-sayNB</span><br><span class="line"><span class="number">2021</span><span class="number">-07</span><span class="number">-04</span> <span class="number">22</span>:<span class="number">24</span>:<span class="number">49.090863</span>+<span class="number">0800</span> ResolveMethodTest[<span class="number">7682</span>:<span class="number">442095</span>] resolveInstanceMethod :JSPerson-encodeWithOSLogCoder:options:maxLength:</span><br><span class="line"><span class="number">2021</span><span class="number">-07</span><span class="number">-04</span> <span class="number">22</span>:<span class="number">24</span>:<span class="number">49.091431</span>+<span class="number">0800</span> ResolveMethodTest[<span class="number">7682</span>:<span class="number">442095</span>] forwardingTargetForSelector :&lt;JSPerson: <span class="number">0x600000010160</span>&gt;-sayNB</span><br><span class="line"><span class="number">2021</span><span class="number">-07</span><span class="number">-04</span> <span class="number">22</span>:<span class="number">24</span>:<span class="number">49.091571</span>+<span class="number">0800</span> ResolveMethodTest[<span class="number">7682</span>:<span class="number">442095</span>] &lt;JSProxy: <span class="number">0x6000000080d0</span>&gt; - -[JSProxy sayNB]</span><br></pre></td></tr></table></figure>

<h4 id="慢速消息转发"><a href="#慢速消息转发" class="headerlink" title="慢速消息转发"></a>慢速消息转发</h4><p>我们在上面例子基础上，在<code>JSPerson</code>类里实现<code>methodSignatureForSelector</code>和<code>forwardInvocation</code>,<code>forwardingTargetForSelector</code>方法返回<code>nil</code>标示不进行<code>快速消息转发</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@implementation JSPerson</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">    NSLog(@&quot;forwardingTargetForSelector :%@-%@&quot;,self,NSStringFromSelector(aSelector));</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123;</span><br><span class="line">    NSLog(@&quot;methodSignatureForSelector :%@-%@&quot;,self,NSStringFromSelector(aSelector));</span><br><span class="line">    if (aSelector &#x3D;&#x3D; @selector(sayNB)) &#123;</span><br><span class="line">        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)forwardInvocation:(NSInvocation *)anInvocation&#123;</span><br><span class="line">    NSLog(@&quot;%@ - %s&quot;,self , __func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>我们运行代码，发现运行正常，打印结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span><span class="number">-07</span><span class="number">-04</span> <span class="number">22</span>:<span class="number">34</span>:<span class="number">32.163137</span>+<span class="number">0800</span> ResolveMethodTest[<span class="number">7780</span>:<span class="number">447311</span>] resolveInstanceMethod :JSPerson-sayNB</span><br><span class="line"><span class="number">2021</span><span class="number">-07</span><span class="number">-04</span> <span class="number">22</span>:<span class="number">34</span>:<span class="number">32.163803</span>+<span class="number">0800</span> ResolveMethodTest[<span class="number">7780</span>:<span class="number">447311</span>] resolveInstanceMethod :JSPerson-encodeWithOSLogCoder:options:maxLength:</span><br><span class="line"><span class="number">2021</span><span class="number">-07</span><span class="number">-04</span> <span class="number">22</span>:<span class="number">34</span>:<span class="number">32.164673</span>+<span class="number">0800</span> ResolveMethodTest[<span class="number">7780</span>:<span class="number">447311</span>] forwardingTargetForSelector :&lt;JSPerson: <span class="number">0x600000008070</span>&gt;-sayNB</span><br><span class="line"><span class="number">2021</span><span class="number">-07</span><span class="number">-04</span> <span class="number">22</span>:<span class="number">34</span>:<span class="number">32.165289</span>+<span class="number">0800</span> ResolveMethodTest[<span class="number">7780</span>:<span class="number">447311</span>] resolveInstanceMethod :JSPerson-encodeWithOSLogCoder:options:maxLength:</span><br><span class="line"><span class="number">2021</span><span class="number">-07</span><span class="number">-04</span> <span class="number">22</span>:<span class="number">34</span>:<span class="number">32.165436</span>+<span class="number">0800</span> ResolveMethodTest[<span class="number">7780</span>:<span class="number">447311</span>] methodSignatureForSelector :&lt;JSPerson: <span class="number">0x600000008070</span>&gt;-sayNB</span><br><span class="line"><span class="number">2021</span><span class="number">-07</span><span class="number">-04</span> <span class="number">22</span>:<span class="number">34</span>:<span class="number">32.165551</span>+<span class="number">0800</span> ResolveMethodTest[<span class="number">7780</span>:<span class="number">447311</span>] resolveInstanceMethod :JSPerson-_forwardStackInvocation:</span><br><span class="line"><span class="number">2021</span><span class="number">-07</span><span class="number">-04</span> <span class="number">22</span>:<span class="number">34</span>:<span class="number">32.165634</span>+<span class="number">0800</span> ResolveMethodTest[<span class="number">7780</span>:<span class="number">447311</span>] resolveInstanceMethod :JSPerson-encodeWithOSLogCoder:options:maxLength:</span><br><span class="line"><span class="number">2021</span><span class="number">-07</span><span class="number">-04</span> <span class="number">22</span>:<span class="number">34</span>:<span class="number">32.165986</span>+<span class="number">0800</span> ResolveMethodTest[<span class="number">7780</span>:<span class="number">447311</span>] &lt;JSPerson: <span class="number">0x600000008070</span>&gt; - -[JSPerson forwardInvocation:]</span><br></pre></td></tr></table></figure>

<p>这里可能有人对添加<code>forwardInvocation</code>方法有因为，可以查看<a href="https://developer.apple.com/documentation/objectivec/nsobject/1571955-forwardinvocation" target="_blank" rel="noopener">苹果官方文档</a>查看原因</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>到这里我们就就把整个<code>objc_msgSend</code>的流程探索完了。</p>
<ol>
<li>汇编代码快速查找缓存</li>
<li><code>loopUpImpForward</code>慢速递归查找类以及父类(包括缓存)的方法列表</li>
<li>动态方法解析处理消息</li>
<li>快速消息转发流程</li>
<li>慢速消息转发流程</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/07/04/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/04/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">iOS底层探索 - 动态方法决议</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-04 09:12:56" itemprop="dateCreated datePublished" datetime="2021-07-04T09:12:56+08:00">2021-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-05 17:22:29" itemprop="dateModified" datetime="2021-07-05T17:22:29+08:00">2021-07-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前面两篇文章我们探索了消息查找的流程，包括快速查找和慢速查找，本文开始探索消息查找未找到时候的处理流程。</p>
<h3 id="unrecognized-selector"><a href="#unrecognized-selector" class="headerlink" title="unrecognized selector"></a>unrecognized selector</h3><p><code>unrecognized selector</code>是我们开发中很熟悉的一种错误，就是找不到方法的时候报错的提示，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;  JSPerson.h</span><br><span class="line">@interface JSPerson : NSObject</span><br><span class="line"></span><br><span class="line">- (void)sayNB;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">&#x2F;&#x2F;  JSPerson.m</span><br><span class="line">@implementation JSPerson</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">&#x2F;&#x2F;  main.m</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        JSPerson *person &#x3D; [JSPerson alloc];</span><br><span class="line">        [person sayNB];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义一个<code>JSPerson</code>类，声明一个<code>sayNB</code>方法，但是并没有实现，因为<code>oc</code>是一种动态语言，可以在运行时添加方法实现，所以没有实现编译期并不会报错。在<code>main</code>函数里实例化一个<code>JSPerson</code>对象，调用<code>sayNB</code>方法，这个时候程序就会崩溃，报错：</p>
<p><code>Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;-[JSPerson sayNB]: unrecognized selector sent to instance 0x101844590&#39;</code>。</p>
<p>这个错误是怎么来的呢，我们从上一节最后方法找不到的地方开始看，当没有找到方法实现时，<code>lookUpImpOrForward</code>方法返回值是<code>imp = forward_imp;</code>即<code>_objc_msgForward_impcache</code>。<code>objc</code>源码工程里全局搜索这个关键字，在<code>objc-msg-arm64.s</code>文件的<code>745</code>行找到实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgForward_impcache</span><br><span class="line">	&#x2F;&#x2F; No stret specialization.</span><br><span class="line">	b	__objc_msgForward</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgForward_impcache</span><br><span class="line">	</span><br><span class="line">ENTRY __objc_msgForward</span><br><span class="line"></span><br><span class="line">	adrp	x17, __objc_forward_handler@PAGE</span><br><span class="line">	ldr	p17, [x17, __objc_forward_handler@PAGEOFF]</span><br><span class="line">	&#x2F;&#x2F;&#x2F;返回x17 </span><br><span class="line">	TailCallFunctionPointer x17</span><br><span class="line">	</span><br><span class="line">END_ENTRY __objc_msgForward</span><br></pre></td></tr></table></figure>

<p>这段代码比较简单，调用了<code>__objc_forward_handler</code>方法，继续搜索<code>__objc_forward_handler</code>方法，并没有找到方法实现，根据前面的经验，去掉<code>_</code>继续搜索<code>objc_forward_handler</code>,在<code>objc_runtime.mm</code>文件中找到了实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Default forward handler halts the process.</span></span><br><span class="line">__attribute__((noreturn, cold)) <span class="keyword">void</span></span><br><span class="line">objc_defaultForwardHandler(id self, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    _objc_fatal(<span class="string">"%c[%s %s]: unrecognized selector sent to instance %p "</span></span><br><span class="line">                <span class="string">"(no message forward handler is installed)"</span>, </span><br><span class="line">                class_isMetaClass(object_getClass(self)) ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                object_getClassName(self), sel_getName(sel), self);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> *_objc_forward_handler = (<span class="keyword">void</span>*)objc_defaultForwardHandler;</span><br></pre></td></tr></table></figure>

<p>这段代码就显而易见了，找不到方法的时候会执行<code>unrecognized selector</code>报错。</p>
<h3 id="动态方法决议"><a href="#动态方法决议" class="headerlink" title="动态方法决议"></a>动态方法决议</h3><p>了解了<code>unrecognized selector</code>后我们回到<code>lookUpImpOrForward</code>的流程，当递归完查找所有父类流程没有找到方法实现会继续执行方法后面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</span><br><span class="line">     behavior ^= LOOKUP_RESOLVER;</span><br><span class="line">     <span class="keyword">return</span> resolveMethod_locked(inst, sel, cls, behavior);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>behavior</code>是<code>lookUpImpOrForward</code>方法的最后一个参数，通过找到方法的调用<code>behavior=LOOKUP_INITIALIZE | LOOKUP_RESOLVER</code>=<code>3</code>。<code>LOOKUP_RESOLVER=2</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// lookUpImpOrForward(obj, sel, cls, LOOKUP_INITIALIZE | LOOKUP_RESOLVER)</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    LOOKUP_INITIALIZE = <span class="number">1</span>,</span><br><span class="line">    LOOKUP_RESOLVER = <span class="number">2</span>,</span><br><span class="line">    LOOKUP_NIL = <span class="number">4</span>,</span><br><span class="line">    LOOKUP_NOCACHE = <span class="number">8</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个<code>if</code>代码块其实是巧妙的使用了<code>单例</code>思想只会执行一次:</p>
<ul>
<li>初始behavior &amp; LOOKUP_RESOLVER = <code>3 &amp; 2</code> = <code>2</code>,条件为<code>true</code>执行</li>
<li><code>behavior ^= LOOKUP_RESOLVER = 3 ^ 2 = 1</code></li>
<li>如果后面再次进行<code>if</code>判断，<code>behavior &amp; LOOKUP_RESOLVER = 1 &amp; 2 = 0</code>,条件为<code>false</code>就不会执行代码块。</li>
</ul>
<p>前面<code>if</code>代码块会执行方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> NEVER_INLINE IMP</span><br><span class="line">resolveMethod_locked(id inst, SEL sel, Class cls, <span class="keyword">int</span> behavior)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line">    <span class="comment">//判断是否是元类</span></span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">      	<span class="comment">//实例方法 解析</span></span><br><span class="line">        <span class="comment">// try [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        resolveInstanceMethod(inst, sel, cls);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// try [nonMetaClass resolveClassMethod:sel]</span></span><br><span class="line">        <span class="comment">// and [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        <span class="comment">//类方法 解析</span></span><br><span class="line">        resolveClassMethod(inst, sel, cls);</span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNilTryCache(inst, sel, cls)) &#123;</span><br><span class="line">            resolveInstanceMethod(inst, sel, cls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// chances are that calling the resolver have populated the cache</span></span><br><span class="line">    <span class="comment">// so attempt using it</span></span><br><span class="line">    <span class="comment">// 如果前面处理了 重新进行查找</span></span><br><span class="line">    <span class="keyword">return</span> lookUpImpOrForwardTryCache(inst, sel, cls, behavior);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实例方法流程"><a href="#实例方法流程" class="headerlink" title="实例方法流程"></a>实例方法流程</h4><p>我们先看实例方法，实例方法会调用<code>resolveInstanceMethod</code>方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">resolveInstanceMethod</span><span class="params">(id inst, SEL sel, Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line">    <span class="comment">//resolveInstanceMethod 类方法</span></span><br><span class="line">    SEL resolve_sel = @selector(resolveInstanceMethod:);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!lookUpImpOrNilTryCache(cls, resolve_sel, cls-&gt;ISA(<span class="comment">/*authenticated*/</span><span class="literal">true</span>))) &#123;</span><br><span class="line">        <span class="comment">// Resolver not implemented.</span></span><br><span class="line">      	<span class="comment">// 因为系统有默认实现这里不会执行到</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</span><br><span class="line">    <span class="keyword">bool</span> resolved = msg(cls, resolve_sel, sel);<span class="comment">//resolved 表示方法返回值</span></span><br><span class="line">    <span class="comment">// Cache the result (good or bad) so the resolver doesn't fire next time.</span></span><br><span class="line">    <span class="comment">// +resolveInstanceMethod adds to self a.k.a. cls</span></span><br><span class="line">    <span class="comment">// 继续查找 一次</span></span><br><span class="line">    IMP imp = lookUpImpOrNilTryCache(inst, sel, cls);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">            <span class="comment">//找到了imp</span></span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: method %c[%s %s] "</span></span><br><span class="line">                         <span class="string">"dynamically resolved to %p"</span>, </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// resolved = true 但是不没有对应的处理方法</span></span><br><span class="line">            <span class="comment">// Method resolver didn't add anything?</span></span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: +[%s resolveInstanceMethod:%s] returned YES"</span></span><br><span class="line">                         <span class="string">", but no new implementation of %c[%s %s] was found"</span>,</span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，其实是在类中添加一个<code>resolveInstanceMethod:</code>进行处理，我们在前面例子的基础上给<code>JSPerson</code>类添加一个<code>resolveInstanceMethod:</code>方法处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@implementation JSPerson</span><br><span class="line"></span><br><span class="line">- (void)saySomethingDefalut&#123;</span><br><span class="line">    NSLog(@&quot;%@ - %s&quot;,self , __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line">        NSLog(@&quot;resolveInstanceMethod :%@-%@&quot;,self,NSStringFromSelector(sel));</span><br><span class="line">        if (sel &#x3D;&#x3D; @selector(sayNB)) &#123;</span><br><span class="line">            IMP sayDefalutImp &#x3D; class_getMethodImplementation(self, @selector(saySomethingDefalut));</span><br><span class="line">            Method method     &#x3D; class_getInstanceMethod(self, @selector(saySomethingDefalut));</span><br><span class="line">            const char *type  &#x3D; method_getTypeEncoding(method);</span><br><span class="line">            return class_addMethod(self, sel, sayDefalutImp, type);</span><br><span class="line">        &#125;</span><br><span class="line">        return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>重新运行<code>main</code>方法，发现程序可以正常运行了，控制台打印结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolveInstanceMethod :JSPerson-sayNB</span><br><span class="line">resolveInstanceMethod :JSPerson-encodeWithOSLogCoder:options:maxLength:</span><br><span class="line"> &lt;JSPerson: <span class="number">0x10194fab0</span>&gt; - -[JSPerson saySomethingDefalut]</span><br></pre></td></tr></table></figure>

<p>通过打印结果我们看到确实进入了<code>resolveInstanceMethod</code>,而且最终执行了<code>saySomethingDefalut</code>方法，实例方法的动态方法解析正常流程就是这样了。</p>
<p>还有一个<strong>异常情况</strong>就是，如果我们不添加方法处理，只是打印执行<code>NSLog</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line">        NSLog(@&quot;resolveInstanceMethod :%@-%@&quot;,self,NSStringFromSelector(sel));</span><br><span class="line">        return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候程序崩溃是毋庸置疑的，因为这样写相当于没有处理，但是这时候控制台的打印结果是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolveInstanceMethod :JSPerson-sayNB</span><br><span class="line">resolveInstanceMethod :JSPerson-sayNB</span><br><span class="line">-[JSPerson sayNB]: unrecognized selector sent to instance <span class="number">0x10193a810</span></span><br></pre></td></tr></table></figure>

<p><code>resolveInstanceMethod</code>执行了<strong>两次</strong>,这是为什么呢,我们在<code>resolveInstanceMethod</code>方法添加断点，使用<code>bt</code>命令查看调用栈：</p>
<ul>
<li><p>第一次调用，就是我们刚刚探索的来源是<code>libobjc</code>框架的<code>_objc_msgSend_uncached</code>方法。调用信息如下图</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82d0a5d1f1044e129b5a92cc2dc99429~tplv-k3u1fbpfcp-watermark.image" alt="1625382251804"></p>
</li>
<li><p>第二次调用，消息的来源是<code>CoreFoundation</code>的<code>___forwarding___</code>方法，下一篇我们会探索，调用信息如下图</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a634df8fa05945829cdae9c99022496c~tplv-k3u1fbpfcp-watermark.image" alt="1625382659258"></p>
</li>
</ul>
<h4 id="类方法流程"><a href="#类方法流程" class="headerlink" title="类方法流程"></a>类方法流程</h4><p>类方法的流程就是在<code>resolveClassMethod</code>实现，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">resolveClassMethod</span><span class="params">(id inst, SEL sel, Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line">    ASSERT(cls-&gt;isMetaClass());</span><br><span class="line">    <span class="keyword">if</span> (!lookUpImpOrNilTryCache(inst, @selector(resolveClassMethod:), cls)) &#123;</span><br><span class="line">        <span class="comment">// Resolver not implemented.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Class nonmeta;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">      	<span class="comment">//入参是元类 返回是当前类</span></span><br><span class="line">        nonmeta = getMaybeUnrealizedNonMetaClass(cls, inst);</span><br><span class="line">        <span class="comment">// +initialize path should have realized nonmeta already</span></span><br><span class="line">        <span class="keyword">if</span> (!nonmeta-&gt;isRealized()) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">"nonmeta class %s (%p) unexpectedly not realized"</span>,</span><br><span class="line">                        nonmeta-&gt;nameForLogging(), nonmeta);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</span><br><span class="line"> 		<span class="comment">//向当前类发送消息</span></span><br><span class="line">    <span class="keyword">bool</span> resolved = msg(nonmeta, @selector(resolveClassMethod:), sel);</span><br><span class="line">    <span class="comment">// Cache the result (good or bad) so the resolver doesn't fire next time.</span></span><br><span class="line">    <span class="comment">// +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls</span></span><br><span class="line">    IMP imp = lookUpImpOrNilTryCache(inst, sel, cls);</span><br><span class="line">    <span class="keyword">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: method %c[%s %s] "</span></span><br><span class="line">                         <span class="string">"dynamically resolved to %p"</span>, </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Method resolver didn't add anything?</span></span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: +[%s resolveClassMethod:%s] returned YES"</span></span><br><span class="line">                         <span class="string">", but no new implementation of %c[%s %s] was found"</span>,</span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个流程和实例方法很相似，在类中添加一个<code>resolveClassMethod:</code>的类方法处理，同样前面的例子我们验证一下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@interface JSPerson : NSObject</span><br><span class="line"></span><br><span class="line">+ (void)sayHowAreYou;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">@implementation JSPerson</span><br><span class="line"></span><br><span class="line">+ (void)sayAndYou&#123;</span><br><span class="line">    NSLog(@&quot;%@ - %s&quot;,self , __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveClassMethod:(SEL)sel&#123;</span><br><span class="line">    NSLog(@&quot;resolveClassMethod :%@-%@&quot;,self,NSStringFromSelector(sel));</span><br><span class="line">        if (sel &#x3D;&#x3D; @selector(sayHowAreYou)) &#123;</span><br><span class="line">            IMP sayAndYouImp &#x3D; class_getMethodImplementation(objc_getMetaClass(&quot;JSPerson&quot;), @selector(sayAndYou));</span><br><span class="line">            Method method     &#x3D; class_getInstanceMethod(objc_getMetaClass(&quot;JSPerson&quot;), @selector(sayAndYou));</span><br><span class="line">            const char *type  &#x3D; method_getTypeEncoding(method);</span><br><span class="line">            return class_addMethod(objc_getMetaClass(&quot;JSPerson&quot;), sel, sayAndYouImp, type);</span><br><span class="line">        &#125;</span><br><span class="line">    return [super resolveClassMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [JSPerson sayHowAreYou];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行发现程序正常运行了，打印结果为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resolveClassMethod :JSPerson-sayHowAreYou</span><br><span class="line">JSPerson - +[JSPerson sayAndYou]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">else&#123;</span><br><span class="line">       &#x2F;&#x2F; try [nonMetaClass resolveClassMethod:sel]</span><br><span class="line">       &#x2F;&#x2F; and [cls resolveInstanceMethod:sel]</span><br><span class="line">       &#x2F;&#x2F;类方法 解析</span><br><span class="line">       resolveClassMethod(inst, sel, cls);</span><br><span class="line">       if (!lookUpImpOrNilTryCache(inst, sel, cls)) &#123;</span><br><span class="line">           resolveInstanceMethod(inst, sel, cls);</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>细心地我们现在会发现在上面这段代码也就是类方法解析这个流程还有一个<code>resolveInstanceMethod(inst, sel, cls);</code>解析，这个原因是类方法在元类里是以实例方法的形式存在的，所以元类里<code>resolveInstanceMethod</code>对方法做了处理也会正常运行。</p>
<h3 id="AOP思想处理动态方法决议"><a href="#AOP思想处理动态方法决议" class="headerlink" title="AOP思想处理动态方法决议"></a>AOP思想处理动态方法决议</h3><p>通过上面的动态方法解析流程，和前面我们探索的<a href="https://juejin.cn/post/6975781940519501861" target="_blank" rel="noopener"><code>isa</code>走位图和继承链</a>,我们可以使用<code>AOP</code>的思想，全局处理类的动态方法解析。具体实现就是在<code>NSObject</code>的分类中添加<code>resolveInstanceMethod:</code>类方法，处理方法的动态解析，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject (JS)</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation NSObject (LG)</span><br><span class="line"></span><br><span class="line">- (void)saySomethingDefalut&#123;</span><br><span class="line">    NSLog(@&quot;%@ - %s&quot;,self , __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line">        NSLog(@&quot;resolveInstanceMethod :%@-%@&quot;,self,NSStringFromSelector(sel));</span><br><span class="line">        if (sel &#x3D;&#x3D; @selector(sayNB)) &#123;</span><br><span class="line">            IMP sayDefalutImp &#x3D; class_getMethodImplementation(self, @selector(saySomethingDefalut));</span><br><span class="line">            Method method     &#x3D; class_getInstanceMethod(self, @selector(saySomethingDefalut));</span><br><span class="line">            const char *type  &#x3D; method_getTypeEncoding(method);</span><br><span class="line">            return class_addMethod(self, sel, sayDefalutImp, type);</span><br><span class="line">        &#125;</span><br><span class="line">        return NO;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">@interface JSPerson : NSObject</span><br><span class="line"></span><br><span class="line">- (void)sayNB;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation JSPerson</span><br><span class="line">  </span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        JSPerson *person &#x3D; [JSPerson alloc];</span><br><span class="line">        [person sayNB];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行项目发现正常运行，打印结果为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resolveInstanceMethod :JSPerson-sayNB</span><br><span class="line">&lt;JSPerson: <span class="number">0x100593ed0</span>&gt; - -[NSObject(LG) saySomethingDefalut]</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本节我们主要探讨了动态方法解析流程，分实例方法和类方法两种情况</p>
<ul>
<li>实例方法是在类中实现<code>resolveInstanceMethod:</code>的类方法，处理方法得动态绑定到异常处理的方法。</li>
<li>类方法分两部分查找<ol>
<li>搜索当前类的<code>resolveClassMethod:</code>方法。</li>
<li>搜索类的元类的<code>resolveInstanceMethod:</code>方法</li>
</ol>
</li>
<li>我们可以利用AOP思想在根类的<code>分类</code>中实现<code>resolveInstanceMethod:</code>从而完成全局方法的动态解析。</li>
</ul>
<p>如果没有进行动态方法解析，接下来就会进入消息转发的流程，我们下一节探索。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/06/30/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-objc-msgSend-%E4%B8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/30/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-objc-msgSend-%E4%B8%8B/" class="post-title-link" itemprop="url">iOS底层探索 - objc_msgSend（下）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-30 11:14:56" itemprop="dateCreated datePublished" datetime="2021-06-30T11:14:56+08:00">2021-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-18 20:42:56" itemprop="dateModified" datetime="2021-07-18T20:42:56+08:00">2021-07-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一篇文章中我们探索了消息的快速查找(缓存)，本文我们探索慢速查找。</p>
<h3 id="汇编探索回到C-探索"><a href="#汇编探索回到C-探索" class="headerlink" title="汇编探索回到C++探索"></a>汇编探索回到<code>C++</code>探索</h3><p>上一篇我们已经知道当快速查找找不到的时候会执行到<code>__objc_msgSend_uncached</code>方法，我们先看一下这个方法的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">	STATIC_ENTRY __objc_msgSend_uncached</span><br><span class="line">	UNWIND __objc_msgSend_uncached, FrameWithNoSaves</span><br><span class="line">	&#x2F;&#x2F; THIS IS NOT A CALLABLE C FUNCTION</span><br><span class="line">	&#x2F;&#x2F; Out-of-band p15 is the class to search</span><br><span class="line">	&#x2F;&#x2F; imp</span><br><span class="line">	&#x2F;&#x2F;方法表查找</span><br><span class="line">	MethodTableLookup</span><br><span class="line">	&#x2F;&#x2F;调用返回 x17</span><br><span class="line">	TailCallFunctionPointer x17</span><br><span class="line">	END_ENTRY __objc_msgSend_uncached</span><br><span class="line">	</span><br><span class="line">	.macro MethodTableLookup</span><br><span class="line">	&#x2F;&#x2F;&#x2F;</span><br><span class="line">	SAVE_REGS MSGSEND</span><br><span class="line">	&#x2F;&#x2F; lookUpImpOrForward(obj, sel, cls, LOOKUP_INITIALIZE | LOOKUP_RESOLVER)</span><br><span class="line">	&#x2F;&#x2F; receiver and selector already in x0 and x1</span><br><span class="line">	mov	x2, x16</span><br><span class="line">	mov	x3, #3</span><br><span class="line">	&#x2F;&#x2F;方法查找</span><br><span class="line">	bl	_lookUpImpOrForward</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; IMP in x0 --</span><br><span class="line">	&#x2F;&#x2F;将查找到的方法传给 x17</span><br><span class="line">	mov	x17, x0</span><br><span class="line">	RESTORE_REGS MSGSEND</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>

<p>因为<code>x17</code>是反回值，<code>mov    x17, x0</code>是将查找结果传给<code>x17</code>,必然前面的代码是查找过程，或者通过名字我们也很容易猜到<code>_lookUpImpOrForward</code>就是具体查找的方法。我们在<code>objc</code>源码中全局搜索<code>_lookUpImpOrForward</code>,发现并没有搜索到定义方法的代码。因为汇编的方法相比<code>c++</code>会有前缀<code>_</code>，所以我们尝试去掉下划线看有没有对应<code>c++</code>的方法，在<code>objc-runtime-new.mm</code>文件的<code>6400</code>行，找到了方法的定义。</p>
<h3 id="lookUpImpOrForward"><a href="#lookUpImpOrForward" class="headerlink" title="lookUpImpOrForward"></a>lookUpImpOrForward</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE</span><br><span class="line"><span class="function">IMP <span class="title">lookUpImpOrForward</span><span class="params">(id inst, SEL sel, Class cls, <span class="keyword">int</span> behavior)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">///省略代码</span></span><br><span class="line">    <span class="comment">//判断类是否已加载</span></span><br><span class="line">    checkIsKnownClass(cls);</span><br><span class="line">    <span class="comment">///加载类 本文不探讨</span></span><br><span class="line">    cls = realizeAndInitializeIfNeeded_locked(inst, cls, behavior &amp; LOOKUP_INITIALIZE);</span><br><span class="line">    <span class="comment">// runtimeLock may have been dropped but is now locked again</span></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    curClass = cls;</span><br><span class="line">    <span class="comment">// The code used to lookup the class's cache again right after</span></span><br><span class="line">    <span class="comment">// we take the lock but for the vast majority of the cases</span></span><br><span class="line">    <span class="comment">// evidence shows this is a miss most of the time, hence a time loss.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The only codepath calling into this without having performed some</span></span><br><span class="line">    <span class="comment">// kind of cache lookup is class_getInstanceMethod().</span></span><br><span class="line">    <span class="comment">///循环查找方法实现</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> attempts = unreasonableClassCount();;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curClass-&gt;cache.isConstantOptimizedCache(<span class="comment">/* strict */</span><span class="literal">true</span>)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_USE_PREOPT_CACHES</span></span><br><span class="line">            <span class="comment">///共享缓存查找</span></span><br><span class="line">            imp = cache_getImp(curClass, sel);</span><br><span class="line">            <span class="keyword">if</span> (imp) <span class="keyword">goto</span> done_unlock;</span><br><span class="line">            curClass = curClass-&gt;cache.preoptFallbackClass();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// curClass method list.</span></span><br><span class="line">            <span class="comment">// 二分法 查找当前类的方法列表</span></span><br><span class="line">            Method meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">            <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">                <span class="comment">///找到方法 结束循环跳转到done:</span></span><br><span class="line">                imp = meth-&gt;imp(<span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (slowpath((curClass = curClass-&gt;getSuperclass()) == nil)) &#123;</span><br><span class="line">                <span class="comment">// No implementation found, and method resolver didn't help.</span></span><br><span class="line">                <span class="comment">// Use forwarding.</span></span><br><span class="line">              	<span class="comment">/// 找到根类也没找到方法实现  进行下一步操作forward_imp 下一篇探索</span></span><br><span class="line">                imp = forward_imp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Halt if there is a cycle in the superclass chain.</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(--attempts == <span class="number">0</span>)) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">"Memory corruption in class list."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Superclass cache.</span></span><br><span class="line">      	<span class="comment">// 查找父类缓存</span></span><br><span class="line">        imp = cache_getImp(curClass, sel);</span><br><span class="line">        <span class="keyword">if</span> (slowpath(imp == forward_imp)) &#123;</span><br><span class="line">            <span class="comment">// Found a forward:: entry in a superclass.</span></span><br><span class="line">            <span class="comment">// Stop searching, but don't cache yet; call method</span></span><br><span class="line">            <span class="comment">// resolver for this class first.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fastpath(imp)) &#123;</span><br><span class="line">            <span class="comment">//找到done</span></span><br><span class="line">            <span class="comment">// Found the method in a superclass. Cache it in this class.</span></span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//父类缓存没找到继续for循环 现在curClass实际是superclass</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No implementation found. Try method resolver once.</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</span><br><span class="line">        behavior ^= LOOKUP_RESOLVER;</span><br><span class="line">        <span class="keyword">return</span> resolveMethod_locked(inst, sel, cls, behavior);</span><br><span class="line">    &#125;</span><br><span class="line"> done:</span><br><span class="line">    <span class="keyword">if</span> (fastpath((behavior &amp; LOOKUP_NOCACHE) == <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_USE_PREOPT_CACHES</span></span><br><span class="line">        <span class="keyword">while</span> (cls-&gt;cache.isConstantOptimizedCache(<span class="comment">/* strict */</span><span class="literal">true</span>)) &#123;</span><br><span class="line">            cls = cls-&gt;cache.preoptFallbackClass();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">//查找成功 添加到缓存</span></span><br><span class="line">        log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">    &#125;</span><br><span class="line"> done_unlock:</span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line">    <span class="keyword">if</span> (slowpath((behavior &amp; LOOKUP_NIL) &amp;&amp; imp == forward_imp)) &#123;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看代码和注释，我们可以清楚的看到方法实现的<code>递归</code>查找流程</p>
<ol>
<li>查找共享缓存是否有实现</li>
<li>查找当前类是否有方法，如果有查找有没有分类方法有实现，如果分类有实现就返回分类的实现即<code>imp</code>,如果分类没有实现返回查找到的实现<code>imp</code></li>
<li>如果当前类没有实现方法，继续查找父类的缓存是否有实现</li>
<li>如果父类缓存有实现，则到<code>done:</code>插入查找的类（注意不是父类）的缓存</li>
<li>如果父类没有缓存实现，就继续<code>for</code>循环查找父类的方法列表</li>
<li>最后如果找到根类还是没找到，就执行<code>imp = forward_imp;</code>也就是动态方法解析，动态方法解析我们下一篇探索。</li>
</ol>
<h3 id="二分法查找"><a href="#二分法查找" class="headerlink" title="二分法查找"></a>二分法查找</h3><p><code>getMethodNoSuper_nolock</code>一步步跟进查找，我们可以看到查找遍历方法列表的方法是<code>findMethodInSortedMethodList</code>,它巧妙的使用了<code>二分查找</code>的方式遍历方法列表，源码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_INLINE <span class="keyword">static</span> <span class="keyword">method_t</span> *</span><br><span class="line">findMethodInSortedMethodList(SEL key, <span class="keyword">const</span> <span class="keyword">method_list_t</span> *<span class="built_in">list</span>, <span class="keyword">const</span> getNameFunc &amp;getName)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> first = <span class="built_in">list</span>-&gt;<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">auto</span> base = first;</span><br><span class="line">    <span class="keyword">decltype</span>(first) probe;</span><br><span class="line">    <span class="keyword">uintptr_t</span> keyValue = (<span class="keyword">uintptr_t</span>)key;</span><br><span class="line">    <span class="keyword">uint32_t</span> count;</span><br><span class="line">    <span class="keyword">for</span> (count = <span class="built_in">list</span>-&gt;count; count != <span class="number">0</span>; count &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        probe = base + (count &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">uintptr_t</span> probeValue = (<span class="keyword">uintptr_t</span>)getName(probe);</span><br><span class="line">        <span class="comment">//当前sel==要查找的sel</span></span><br><span class="line">        <span class="keyword">if</span> (keyValue == probeValue) &#123;</span><br><span class="line">            <span class="comment">// `probe` is a match.</span></span><br><span class="line">            <span class="comment">// Rewind looking for the *first* occurrence of this value.</span></span><br><span class="line">            <span class="comment">// This is required for correct category overrides.</span></span><br><span class="line">            <span class="comment">// 可能有同名方法 分类里的实现优先</span></span><br><span class="line">            <span class="keyword">while</span> (probe &gt; first &amp;&amp; keyValue == (<span class="keyword">uintptr_t</span>)getName((probe - <span class="number">1</span>))) &#123;</span><br><span class="line">                probe--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> &amp;*probe;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (keyValue &gt; probeValue) &#123;</span><br><span class="line">            base = probe + <span class="number">1</span>;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二分查找可能不是很容易发现，我们举个例子验证一下：</p>
<ul>
<li>1、假设<code>count</code>初始值是9，要查找的<code>sel</code>在6号位，<code>count != 0</code>执行<code>for</code>循环</li>
<li>2、<code>probe</code> = <code>base</code>(0) + <code>4</code>(9&gt;&gt;1=4) = 4</li>
<li>3、<code>keyValue == probeValue</code>标示找到<code>sel</code>退出</li>
<li>4、<code>keyValue &gt; probeValue == true</code>，此时<code>base</code> = 4+1 = 5 ,<code>count</code>=<code>count--</code>=8</li>
<li>5、<code>count</code> = <code>count &gt;&gt;1</code> = 4</li>
<li>6、第二次进入<code>for</code>循环，<code>probe</code> = <code>base</code>(5) + <code>2</code>（4&gt;&gt;1=2) = 7</li>
<li>7、<code>keyValue &gt; probeValue == false</code>,<code>count</code> = <code>count &gt;&gt;1</code> = 2</li>
<li>8、第三次进入<code>for</code>循环,<code>probe</code> = <code>base</code>(5) + <code>1</code>（1&gt;&gt;1=2) = 6</li>
<li>9、此时<code>keyValue == probeValue</code>找到了方法返回，循环了3次找到实现。</li>
</ul>
<p>我们这个例子是<code>sel</code>实际的位置大于中间值的情况，小于中间值的情况也类似，就不举例验证了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本节我们探索了消息的慢速查找流程，具体流程上面已列出，大体流程就是递归查找类以及其父类的<code>sel</code>，如果找到就添加到缓存后返回<code>imp</code>,如果找到根类也没有找到就是走<code>动态方法解析</code>过程，我们下一篇继续探索。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/06/27/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-objc_msgSend-%E4%B8%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/27/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-objc_msgSend-%E4%B8%8A/" class="post-title-link" itemprop="url">iOS底层探索 - objc_msgSend(上)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-27 20:14:59" itemprop="dateCreated datePublished" datetime="2021-06-27T20:14:59+08:00">2021-06-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-05 17:23:37" itemprop="dateModified" datetime="2021-07-05T17:23:37+08:00">2021-07-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一篇探究了<code>catch_t</code>的结构和<code>insert</code>流程，<code>insert</code>的调用方法还不清楚，我们本篇就从<code>insert</code>的调用开始探索。 在探索之前我们首先看一下<code>runtime</code>的概念。</p>
<h3 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h3><p><code>runtime</code>翻译过来就是<code>运行时</code>，与其对应的一个词是<code>编译时</code>，它们的区别是：</p>
<ul>
<li><p><strong>编译时</strong> 顾名思义就是正在编译的时候 . 那啥叫编译呢?就是编译器帮你把源代码翻译成机器能识别的代码，(当然只是一般意义上这么说，实际上可能只是翻译成某个中间状态的语言）</p>
<p>编译时就是简单的作一些翻译工作,词法分析,语法分析之类的过程。如果发现错误编译器就告诉你，这时的错误就叫编译时错误。这个过程中做的类型检查也就叫编译时类型检查或静态类型检查。(所谓静态就是没有真把代码放内存中运行起来，而只是把代码当作文本来扫描)。</p>
</li>
<li><p><strong>运行时</strong>：代码跑起来了被装载到内存中了(代码保存在磁盘上没装入内存之前是个死代码，只有跑到内 存中才变成活的)。运行时类型检查与编译时类型检查(静态类型检查)不一样，不是简单的扫描代码而是在内存中做些操作以及判断。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSObjcet *obj &#x3D; [[NSObjcet alloc] init];</span><br><span class="line">[obj performSelector:@selector(saySomething)];</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="insert的调用"><a href="#insert的调用" class="headerlink" title="insert的调用"></a><code>insert</code>的调用</h3><p>前面文章我们知道在调用一个方法的时候会添加缓存，所以我们实例化一个<code>JSPerson</code>实例，调用<code>saySomething</code>方法，查看调用栈的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;  JSPerson.h</span><br><span class="line">@interface JSPerson : NSObject</span><br><span class="line">- (void)saySomething;</span><br><span class="line">@end</span><br><span class="line">&#x2F;&#x2F;  JSPerson.m</span><br><span class="line">#import &quot;JSPerson.h&quot;</span><br><span class="line">@implementation JSPerson</span><br><span class="line">- (void)saySomething&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        JSPerson *person &#x3D; [JSPerson alloc];</span><br><span class="line">        [person saySomething];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看编译器的调用栈：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/032c3133cdd64837a8759f8db9819a4b~tplv-k3u1fbpfcp-watermark.image" alt="WeChat9862144aabb8df7479fd49bc79b7f67f"></p>
<p>可以清楚的看到，<code>insert</code>方法之前的调用栈从<code>main</code>执行到<code>_objc_msgSend_uncached</code>最后执行到<code>insert</code>。即前面没有找到缓存会执行到这里。查找缓存的流程是什么样的呢？我们其实都知道OC里调用方法的本质是消息发送，通过<code>clang</code>命令将<code>main.m</code>转换成<code>main.cpp</code>文件也能验证这一点：</p>
<p><code>clang -rewrite-objc main.m</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">        JSPerson *person = ((JSPerson *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"JSPerson"</span>), sel_registerName(<span class="string">"alloc"</span>));</span><br><span class="line">        ((<span class="keyword">void</span> (*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)person, sel_registerName(<span class="string">"saySomething"</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们的代码其实就是向<code>person</code>对象发送了一个<code>sel_registerName(&quot;saySomething&quot;)</code>的消息，在到达<code>_objc_msgSend_uncached</code>之前做了缓存的查找。所以我们从<code>objc_msgSend</code>开始探索缓存查找的过程。</p>
<h3 id="快速查找方法-缓存"><a href="#快速查找方法-缓存" class="headerlink" title="快速查找方法(缓存)"></a>快速查找方法(缓存)</h3><p><code>objc</code>源码中搜索<code>objc_msgSend</code>,在<code>objc-msg-arm64.s</code>文件中找到了实现<code>END_ENTRY _objc_msgSend</code></p>
<h4 id="ENTRY-objc-msgSend"><a href="#ENTRY-objc-msgSend" class="headerlink" title="ENTRY _objc_msgSend"></a>ENTRY _objc_msgSend</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">	ENTRY _objc_msgSend</span><br><span class="line">	UNWIND _objc_msgSend, NoFrame</span><br><span class="line"> &#x2F;&#x2F; 判断 p0是否为空，p0是第一个参数 - 消息接收者receiver</span><br><span class="line">	cmp	p0, #0			&#x2F;&#x2F; nil check and tagged pointer check</span><br><span class="line"> &#x2F;&#x2F; 支持taggedpointer（小对象类型）的流程</span><br><span class="line">#if SUPPORT_TAGGED_POINTERS</span><br><span class="line">	b.le	LNilOrTagged		&#x2F;&#x2F;  (MSB tagged pointer looks negative)</span><br><span class="line">#else</span><br><span class="line">  &#x2F;&#x2F;p0 等于 0 时，直接返回 空</span><br><span class="line">	b.eq	LReturnZero</span><br><span class="line">#endif</span><br><span class="line">  &#x2F;&#x2F;根据对象拿出isa ，即从x0寄存器指向的地址 取出 isa，存入 p13寄存器</span><br><span class="line">  &#x2F;&#x2F;取isa的原因是，不论是对象方法还是类方法，都需要在类或元类的缓存或者方法列表中查找。</span><br><span class="line">	ldr	p13, [x0]		&#x2F;&#x2F; p13 &#x3D; isa </span><br><span class="line">  &#x2F;&#x2F;在64位架构下通过 p16 &#x3D; isa（p13） &amp; ISA_MASK，拿出shiftcls信息，得到class信息</span><br><span class="line">	GetClassFromIsa_p16 p13, 1, x0	&#x2F;&#x2F; p16 &#x3D; class </span><br><span class="line">LGetIsaDone:&#x2F;&#x2F;找到isa之后执行</span><br><span class="line">	&#x2F;&#x2F; calls imp or objc_msgSend_uncached</span><br><span class="line">	&#x2F;&#x2F;如果有isa，走到CacheLookup 即查找方法缓存，也就是所谓的sel imp快速查找流程 否则走__objc_msgSend_uncached</span><br><span class="line">	CacheLookup NORMAL, _objc_msgSend, __objc_msgSend_uncached</span><br><span class="line">#if SUPPORT_TAGGED_POINTERS &#x2F;&#x2F;</span><br><span class="line">LNilOrTagged:</span><br><span class="line">	b.eq	LReturnZero		&#x2F;&#x2F; nil check</span><br><span class="line">	GetTaggedClass</span><br><span class="line">	b	LGetIsaDone</span><br><span class="line">&#x2F;&#x2F; SUPPORT_TAGGED_POINTERS</span><br><span class="line">#endif</span><br><span class="line">LReturnZero:</span><br><span class="line">	&#x2F;&#x2F; x0 is already zero</span><br><span class="line">	mov	x1, #0</span><br><span class="line">	movi	d0, #0</span><br><span class="line">	movi	d1, #0</span><br><span class="line">	movi	d2, #0</span><br><span class="line">	movi	d3, #0</span><br><span class="line">	ret</span><br><span class="line">	END_ENTRY _objc_msgSend</span><br></pre></td></tr></table></figure>

<h4 id="GetClassFromIsa-p16获取isa"><a href="#GetClassFromIsa-p16获取isa" class="headerlink" title="GetClassFromIsa_p16获取isa"></a>GetClassFromIsa_p16获取<code>isa</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">.macro GetClassFromIsa_p16 src, needs_auth, auth_address &#x2F;* note: auth_address is not required if !needs_auth *&#x2F;</span><br><span class="line">&#x2F;&#x2F; __ARM_ARCH_7K__ &gt;&#x3D; 2  ||  (__arm64__ &amp;&amp; !__LP64__) 优化的isa</span><br><span class="line">#if SUPPORT_INDEXED_ISA </span><br><span class="line">	&#x2F;&#x2F; Indexed isa</span><br><span class="line">	&#x2F;&#x2F; 将 isa 存入p16寄存器</span><br><span class="line">	mov	p16, \src			&#x2F;&#x2F; optimistically set dst &#x3D; src</span><br><span class="line">	&#x2F;&#x2F;判断是否是 not nonapointer</span><br><span class="line">	tbz	p16, #ISA_INDEX_IS_NPI_BIT, 1f	&#x2F;&#x2F; done if not non-pointer isa</span><br><span class="line">	&#x2F;&#x2F; 将_objc_indexed_classes所在的页的基址 读入x10寄存器 isa in p16 is indexed</span><br><span class="line">	adrp	x10, _objc_indexed_classes@PAGE</span><br><span class="line">	&#x2F;&#x2F;x10 &#x3D; x10 + _objc_indexed_classes(page中的偏移量) --x10基址 根据 偏移量 进行 内存偏移</span><br><span class="line">	add	x10, x10, _objc_indexed_classes@PAGEOFF</span><br><span class="line">	&#x2F;&#x2F;从p16的第ISA_INDEX_SHIFT位开始，提取 ISA_INDEX_BITS 位 到 p16寄存器，剩余的高位用0补充</span><br><span class="line">	ubfx	p16, p16, #ISA_INDEX_SHIFT, #ISA_INDEX_BITS  &#x2F;&#x2F; extract index</span><br><span class="line">	&#x2F;&#x2F;</span><br><span class="line">	ldr	p16, [x10, p16, UXTP #PTRSHIFT]	&#x2F;&#x2F; load class from array</span><br><span class="line">1:</span><br><span class="line">&#x2F;&#x2F;64位 </span><br><span class="line">#elif __LP64__</span><br><span class="line">.if \needs_auth &#x3D;&#x3D; 0 &#x2F;&#x2F; _cache_getImp takes an authed class already</span><br><span class="line">	mov	p16, \src</span><br><span class="line">.else</span><br><span class="line">	&#x2F;&#x2F; 64-bit packed isa</span><br><span class="line">	&#x2F;&#x2F;p16 &#x3D; class &#x3D; isa &amp; ISA_MASK(位运算 &amp; 即获取isa中的shiftcls信息)</span><br><span class="line">	ExtractISA p16, \src, \auth_address</span><br><span class="line">.endif</span><br><span class="line">#else</span><br><span class="line">	&#x2F;&#x2F; 32-bit raw isa 32位系统</span><br><span class="line">	mov	p16, \src</span><br><span class="line">#endif</span><br><span class="line">.endmacro</span><br><span class="line">.macro ExtractISA</span><br><span class="line">&#x2F;&#x2F;p16 &#x3D; class &#x3D; isa &amp; ISA_MASK(位运算 &amp; 即获取isa中的shiftcls信息)</span><br><span class="line">	and    $0, $1, #ISA_MASK</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>

<h4 id="CacheLookup-缓存查找汇编源码"><a href="#CacheLookup-缓存查找汇编源码" class="headerlink" title="CacheLookup 缓存查找汇编源码"></a>CacheLookup 缓存查找汇编源码</h4><p>缓存查找执行的是<code>CacheLookup</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">.macro CacheLookup Mode, Function, MissLabelDynamic, MissLabelConstant</span><br><span class="line">	&#x2F;&#x2F;</span><br><span class="line">	&#x2F;&#x2F; Restart protocol:</span><br><span class="line">	&#x2F;&#x2F;</span><br><span class="line">	&#x2F;&#x2F;   As soon as we&#39;re past the LLookupStart\Function label we may have</span><br><span class="line">	&#x2F;&#x2F;   loaded an invalid cache pointer or mask.</span><br><span class="line">	&#x2F;&#x2F;</span><br><span class="line">	&#x2F;&#x2F;   When task_restartable_ranges_synchronize() is called,</span><br><span class="line">	&#x2F;&#x2F;   (or when a signal hits us) before we&#39;re past LLookupEnd\Function,</span><br><span class="line">	&#x2F;&#x2F;   then our PC will be reset to LLookupRecover\Function which forcefully</span><br><span class="line">	&#x2F;&#x2F;   jumps to the cache-miss codepath which have the following</span><br><span class="line">	&#x2F;&#x2F;   requirements:</span><br><span class="line">	&#x2F;&#x2F;</span><br><span class="line">	&#x2F;&#x2F;   GETIMP:</span><br><span class="line">	&#x2F;&#x2F;     The cache-miss is just returning NULL (setting x0 to 0)</span><br><span class="line">	&#x2F;&#x2F;</span><br><span class="line">	&#x2F;&#x2F;   NORMAL and LOOKUP:</span><br><span class="line">	&#x2F;&#x2F;   - x0 contains the receiver</span><br><span class="line">	&#x2F;&#x2F;   - x1 contains the selector</span><br><span class="line">	&#x2F;&#x2F;   - x16 contains the isa</span><br><span class="line">	&#x2F;&#x2F;   - other registers are set as per calling conventions</span><br><span class="line">	&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">	mov	x15, x16			&#x2F;&#x2F; stash the original isa</span><br><span class="line">LLookupStart\Function:</span><br><span class="line">	&#x2F;&#x2F; p1 &#x3D; SEL, p16 &#x3D; isa</span><br><span class="line">#if CACHE_MASK_STORAGE &#x3D;&#x3D; CACHE_MASK_STORAGE_HIGH_16_BIG_ADDRS</span><br><span class="line">	ldr	p10, [x16, #CACHE]				&#x2F;&#x2F; p10 &#x3D; mask|buckets</span><br><span class="line">	lsr	p11, p10, #48			&#x2F;&#x2F; p11 &#x3D; mask</span><br><span class="line">	and	p10, p10, #0xffffffffffff	&#x2F;&#x2F; p10 &#x3D; buckets</span><br><span class="line">	and	w12, w1, w11			&#x2F;&#x2F; x12 &#x3D; _cmd &amp; mask</span><br><span class="line">&#x2F;&#x2F;64位真机</span><br><span class="line">#elif CACHE_MASK_STORAGE &#x3D;&#x3D; CACHE_MASK_STORAGE_HIGH_16</span><br><span class="line">	&#x2F;&#x2F;将x16 平移 CACHE大小 16位 CACHE &#x3D; (2 * __SIZEOF_POINTER__)2个指针大小</span><br><span class="line">	&#x2F;&#x2F;也就是isa 平移 0x10 找到cache p11 &#x3D; cache</span><br><span class="line">	ldr	p11, [x16, #CACHE]			&#x2F;&#x2F; p11 &#x3D; mask|buckets</span><br><span class="line">&#x2F;&#x2F;64位真机</span><br><span class="line">#if CONFIG_USE_PREOPT_CACHES </span><br><span class="line">&#x2F;&#x2F;arm64e A12(iPhone X)及之后机型</span><br><span class="line">#if __has_feature(ptrauth_calls)</span><br><span class="line">	&#x2F;&#x2F;判断p11(cache)是否存在 不存在跳转LLookupPreopt 存在继续执行</span><br><span class="line">	tbnz	p11, #0, LLookupPreopt\Function</span><br><span class="line">	&#x2F;&#x2F;p10 &#x3D; cahce&amp;mask &#x3D; buckets</span><br><span class="line">	and	p10, p11, #0x0000ffffffffffff	&#x2F;&#x2F; p10 &#x3D; buckets</span><br><span class="line">#else</span><br><span class="line">	and	p10, p11, #0x0000fffffffffffe	&#x2F;&#x2F; p10 &#x3D; buckets</span><br><span class="line">	tbnz	p11, #0, LLookupPreopt\Function</span><br><span class="line">#endif</span><br><span class="line">	&#x2F;&#x2F; p12 &#x3D; p1^(p1&gt;&gt;7) p1 &#x3D; _cmd</span><br><span class="line">	eor	p12, p1, p1, LSR #7</span><br><span class="line">	&#x2F;&#x2F; p12 &#x3D; p12&amp;(p11&gt;&gt;48) 哈希编码index</span><br><span class="line">	and	p12, p12, p11, LSR #48		&#x2F;&#x2F; x12 &#x3D; (_cmd ^ (_cmd &gt;&gt; 7)) &amp; mask</span><br><span class="line">#else</span><br><span class="line">	and	p10, p11, #0x0000ffffffffffff	&#x2F;&#x2F; p10 &#x3D; buckets</span><br><span class="line">	and	p12, p1, p11, LSR #48		&#x2F;&#x2F; x12 &#x3D; _cmd &amp; mask</span><br><span class="line">#endif &#x2F;&#x2F; CONFIG_USE_PREOPT_CACHES</span><br><span class="line">#elif CACHE_MASK_STORAGE &#x3D;&#x3D; CACHE_MASK_STORAGE_LOW_4</span><br><span class="line">	ldr	p11, [x16, #CACHE]				&#x2F;&#x2F; p11 &#x3D; mask|buckets</span><br><span class="line">	and	p10, p11, #~0xf			&#x2F;&#x2F; p10 &#x3D; buckets</span><br><span class="line">	and	p11, p11, #0xf			&#x2F;&#x2F; p11 &#x3D; maskShift</span><br><span class="line">	mov	p12, #0xffff</span><br><span class="line">	lsr	p11, p12, p11			&#x2F;&#x2F; p11 &#x3D; mask &#x3D; 0xffff &gt;&gt; p11</span><br><span class="line">	and	p12, p1, p11			&#x2F;&#x2F; x12 &#x3D; _cmd &amp; mask</span><br><span class="line">#else</span><br><span class="line">#error Unsupported cache mask storage for ARM64.</span><br><span class="line">#endif</span><br><span class="line">  &#x2F;&#x2F; 根据index找到对应的地址 p13 &#x3D; bukects[index] PTRSHIFT&#x3D;3</span><br><span class="line">	add	p13, p10, p12, LSL #(1+PTRSHIFT)</span><br><span class="line">						&#x2F;&#x2F; p13 &#x3D; buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT))</span><br><span class="line"></span><br><span class="line">						&#x2F;&#x2F; do &#123;</span><br><span class="line">&#x2F;&#x2F; 从p13取出imp和sel p17&#x3D;imp p9&#x3D;sel bucket--</span><br><span class="line">1:	ldp	p17, p9, [x13], #-BUCKET_SIZE	&#x2F;&#x2F;     &#123;imp, sel&#125; &#x3D; *bucket--</span><br><span class="line">	&#x2F;&#x2F;判断p9是否等于传入的cmd</span><br><span class="line">	cmp	p9, p1				&#x2F;&#x2F;     if (sel !&#x3D; _cmd) &#123;</span><br><span class="line">	&#x2F;&#x2F;不相等，跳转到 3f</span><br><span class="line">	b.ne	3f				&#x2F;&#x2F;         scan more</span><br><span class="line">						&#x2F;&#x2F;     &#125; else &#123;</span><br><span class="line">&#x2F;&#x2F;缓存命中</span><br><span class="line">2:	CacheHit \Mode				&#x2F;&#x2F; hit:    call or return imp</span><br><span class="line">						&#x2F;&#x2F;     &#125;</span><br><span class="line">&#x2F;&#x2F;p9为空  </span><br><span class="line">3:	cbz	p9, \MissLabelDynamic		&#x2F;&#x2F;     if (sel &#x3D;&#x3D; 0) goto Miss;</span><br><span class="line">	&#x2F;&#x2F;p13&gt;p10(首地址) 循环查找buckets</span><br><span class="line">	cmp	p13, p10			&#x2F;&#x2F; &#125; while (bucket &gt;&#x3D; buckets)</span><br><span class="line">	b.hs	1b</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; wrap-around:</span><br><span class="line">	&#x2F;&#x2F;   p10 &#x3D; first bucket</span><br><span class="line">	&#x2F;&#x2F;   p11 &#x3D; mask (and maybe other bits on LP64)</span><br><span class="line">	&#x2F;&#x2F;   p12 &#x3D; _cmd &amp; mask</span><br><span class="line">	&#x2F;&#x2F;</span><br><span class="line">	&#x2F;&#x2F; A full cache can happen with CACHE_ALLOW_FULL_UTILIZATION.</span><br><span class="line">	&#x2F;&#x2F; So stop when we circle back to the first probed bucket</span><br><span class="line">	&#x2F;&#x2F; rather than when hitting the first bucket again.</span><br><span class="line">	&#x2F;&#x2F;</span><br><span class="line">	&#x2F;&#x2F; Note that we might probe the initial bucket twice</span><br><span class="line">	&#x2F;&#x2F; when the first probed slot is the last entry.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#if CACHE_MASK_STORAGE &#x3D;&#x3D; CACHE_MASK_STORAGE_HIGH_16_BIG_ADDRS</span><br><span class="line">	add	p13, p10, w11, UXTW #(1+PTRSHIFT)</span><br><span class="line">						&#x2F;&#x2F; p13 &#x3D; buckets + (mask &lt;&lt; 1+PTRSHIFT)</span><br><span class="line">&#x2F;&#x2F;64位真机 </span><br><span class="line">#elif CACHE_MASK_STORAGE &#x3D;&#x3D; CACHE_MASK_STORAGE_HIGH_16</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">	add	p13, p10, p11, LSR #(48 - (1+PTRSHIFT))</span><br><span class="line">						&#x2F;&#x2F; p13 &#x3D; buckets + (mask &lt;&lt; 1+PTRSHIFT)</span><br><span class="line">						&#x2F;&#x2F; see comment about maskZeroBits</span><br><span class="line">#elif CACHE_MASK_STORAGE &#x3D;&#x3D; CACHE_MASK_STORAGE_LOW_4</span><br><span class="line">	add	p13, p10, p11, LSL #(1+PTRSHIFT)</span><br><span class="line">						&#x2F;&#x2F; p13 &#x3D; buckets + (mask &lt;&lt; 1+PTRSHIFT)</span><br><span class="line">#else</span><br><span class="line">#error Unsupported cache mask storage for ARM64.</span><br><span class="line">#endif</span><br><span class="line">	add	p12, p10, p12, LSL #(1+PTRSHIFT)</span><br><span class="line">						&#x2F;&#x2F; p12 &#x3D; first probed bucket</span><br><span class="line"></span><br><span class="line">						&#x2F;&#x2F; do &#123;</span><br><span class="line">4:	ldp	p17, p9, [x13], #-BUCKET_SIZE	&#x2F;&#x2F;     &#123;imp, sel&#125; &#x3D; *bucket--</span><br><span class="line">	cmp	p9, p1				&#x2F;&#x2F;     if (sel &#x3D;&#x3D; _cmd)</span><br><span class="line">	b.eq	2b				&#x2F;&#x2F;         goto hit</span><br><span class="line">	cmp	p9, #0				&#x2F;&#x2F; &#125; while (sel !&#x3D; 0 &amp;&amp;</span><br><span class="line">	ccmp	p13, p12, #0, ne		&#x2F;&#x2F;     bucket &gt; first_probed)</span><br><span class="line">	b.hi	4b</span><br><span class="line"></span><br><span class="line">LLookupEnd\Function:</span><br><span class="line">LLookupRecover\Function:</span><br><span class="line">	b	\MissLabelDynamic</span><br></pre></td></tr></table></figure>

<p>宏的定义参考定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__arm64__) &amp;&amp; __LP64__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_OSX || TARGET_OS_SIMULATOR</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CACHE_MASK_STORAGE CACHE_MASK_STORAGE_HIGH_16_BIG_ADDRS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CACHE_MASK_STORAGE CACHE_MASK_STORAGE_HIGH_16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__arm64__) &amp;&amp; !__LP64__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CACHE_MASK_STORAGE CACHE_MASK_STORAGE_LOW_4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CACHE_MASK_STORAGE CACHE_MASK_STORAGE_OUTLINED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="CashHit"><a href="#CashHit" class="headerlink" title="CashHit"></a>CashHit</h4><p>找到缓存就是执行<code>Cashit</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; CacheHit: x17 &#x3D; cached IMP, x10 &#x3D; address of buckets, x1 &#x3D; SEL, x16 &#x3D; isa</span><br><span class="line">.macro CacheHit</span><br><span class="line">.if $0 &#x3D;&#x3D; NORMAL</span><br><span class="line">	TailCallCachedImp x17, x10, x1, x16	&#x2F;&#x2F; authenticate and call imp</span><br><span class="line">.elseif $0 &#x3D;&#x3D; GETIMP</span><br><span class="line">	mov	p0, p17</span><br><span class="line">	cbz	p0, 9f			&#x2F;&#x2F; don&#39;t ptrauth a nil imp</span><br><span class="line">	AuthAndResignAsIMP x0, x10, x1, x16	&#x2F;&#x2F; authenticate imp and re-sign as IMP</span><br><span class="line">9:	ret				&#x2F;&#x2F; return IMP</span><br><span class="line">.elseif $0 &#x3D;&#x3D; LOOKUP</span><br><span class="line">	&#x2F;&#x2F; No nil check for ptrauth: the caller would crash anyway when they</span><br><span class="line">	&#x2F;&#x2F; jump to a nil IMP. We don&#39;t care if that jump also fails ptrauth.</span><br><span class="line">	AuthAndResignAsIMP x17, x10, x1, x16	&#x2F;&#x2F; authenticate imp and re-sign as IMP</span><br><span class="line">	cmp	x16, x15</span><br><span class="line">	cinc	x16, x16, ne			&#x2F;&#x2F; x16 +&#x3D; 1 when x15 !&#x3D; x16 (for instrumentation ; fallback to the parent class)</span><br><span class="line">	ret				&#x2F;&#x2F; return imp via x17</span><br><span class="line">.else</span><br><span class="line">.abort oops</span><br><span class="line">.endif</span><br><span class="line">.endmacro</span><br><span class="line"></span><br><span class="line">.macro TailCallCachedImp</span><br><span class="line">	&#x2F;&#x2F; $0 &#x3D; cached imp, $1 &#x3D; address of cached imp, $2 &#x3D; SEL, $3 &#x3D; isa</span><br><span class="line">	&#x2F;&#x2F; $0 &#x3D; imp ^ isa &#x3D; 哈希编码index</span><br><span class="line">	eor	$0, $0, $3</span><br><span class="line">	&#x2F;&#x2F; 执行imp</span><br><span class="line">	br	$0</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>

<p>###总结</p>
<p>通过代码的注释可以看出<code>_objc_msgSend</code>查找缓存的步骤是</p>
<ul>
<li>判断消息接收者(<code>receiver</code>)是否为空</li>
<li>根据对象首地址找到<code>isa</code></li>
<li>对象的<code>isa</code>指向<code>类</code>找到类<code>class</code>即<code>p16</code></li>
<li><code>class</code>内存平移<code>16</code>找到<code>cache</code>。</li>
<li>cache&amp;mask -&gt; buckets</li>
<li>(_cmd ^ (_cmd &gt;&gt; 7)) &amp; mask得到<code>index</code></li>
<li>通过<code>buckets[index]</code>找到<code>index</code>的<code>bucket</code></li>
<li>根据<code>bucket取到</code>imp<code>和</code>sel</li>
<li>比较<code>sel</code>是否是传入的<code>_cmd</code></li>
<li>如果是 执行<code>Cashit</code> 执行<code>imp</code></li>
<li>如果不是 循环查找</li>
<li>找不到的话执行<code>_objc_msgSend_uncached</code>流程</li>
</ul>
<p>下一篇我们继续探索找不到的情况也就是<code>_objc_msgSend_uncached</code>的流程。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jason</p>
  <div class="site-description" itemprop="description">个人技术博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
