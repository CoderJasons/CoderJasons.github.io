<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yujiusheng.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="个人技术博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Jason的博客">
<meta property="og:url" content="http://yujiusheng.com/page/2/index.html">
<meta property="og:site_name" content="Jason的博客">
<meta property="og:description" content="个人技术博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yujiusheng.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Jason的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jason的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/06/06/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-alloc%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/06/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-alloc%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">iOS底层探索-alloc方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-06 16:23:12" itemprop="dateCreated datePublished" datetime="2021-06-06T16:23:12+08:00">2021-06-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-11 00:27:14" itemprop="dateModified" datetime="2021-07-11T00:27:14+08:00">2021-07-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>alloc</code>是我们日常开发中经常遇到，下面我们从源码层面分析一下，<code>alloc</code>方法的底层。</p>
<h3 id="准备工作-获取源码"><a href="#准备工作-获取源码" class="headerlink" title="准备工作-获取源码"></a>准备工作-获取源码</h3><ul>
<li>从苹果<a href="https://opensource.apple.com/tarballs/" target="_blank" rel="noopener">开源网站</a>下载<code>objc</code>的源码。</li>
<li>根据<a href="https://juejin.cn/post/6914265121183236104" target="_blank" rel="noopener">这个教程</a>将源码调试成可编译的状态<h3 id="开始探究"><a href="#开始探究" class="headerlink" title="开始探究"></a>开始探究</h3>我们新建一个类JSPerson<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;.h</span><br><span class="line">@interface JSPerson : NSObject</span><br><span class="line">@end</span><br><span class="line">&#x2F;&#x2F;.m</span><br><span class="line">@implementation JSPerson</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
在<code>main</code>方法中初始化<code>JSPerson</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        JSPerson *person &#x3D; [JSPerson alloc];</span><br><span class="line">        NSLog(@&quot;%@&quot;,person);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在<code>JSPerson *person = [JSPerson alloc];</code>这行添加断点运行。<br>按<code>control</code>键发现断点走到了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KCObjcBuild&#96;objc_alloc:</span><br><span class="line">-&gt;  0x100003f44 &lt;+0&gt;: jmpq   *0x40be(%rip)             ; (void *)0x0000000100003f76</span><br></pre></td></tr></table></figure>
说明这个时候调用了<code>objc_alloc</code>方法，我们打一个<code>objc_alloc</code>的符号断点，继续执行程序，发现断点来到了<code>objc_alloc</code>的源码部分。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Calls [cls alloc].</span><br><span class="line">id</span><br><span class="line">objc_alloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    return callAlloc(cls, true&#x2F;*checkNil*&#x2F;, false&#x2F;*allocWithZone*&#x2F;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们继续进入<code>callAlloc</code>方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE id</span><br><span class="line">callAlloc(Class cls, bool checkNil, bool allocWithZone&#x3D;false)</span><br><span class="line">&#123;</span><br><span class="line">#if __OBJC2__</span><br><span class="line">    if (slowpath(checkNil &amp;&amp; !cls)) return nil;</span><br><span class="line">    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        return _objc_rootAllocWithZone(cls, nil);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; No shortcuts available.</span><br><span class="line">    if (allocWithZone) &#123;</span><br><span class="line">        return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil);</span><br><span class="line">    &#125;</span><br><span class="line">    return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们继续走断点，发现走到了<code>return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc));</code>即又调用了alloc方法，也就是说<code>callAlloc</code>也会再次调用。<br>继续调试这次走到了<code>return _objc_rootAllocWithZone(cls, nil);</code>,断点进入<code>_objc_rootAllocWithZone</code>方法看一下源码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone __unused)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; allocWithZone under __OBJC2__ ignores the zone parameter</span><br><span class="line">    return _class_createInstanceFromZone(cls, 0, nil,</span><br><span class="line">                                         OBJECT_CONSTRUCT_CALL_BADALLOC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
代码很简单，我们继续跟进到<code>_class_createInstanceFromZone</code>方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE id</span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,</span><br><span class="line">                              int construct_flags &#x3D; OBJECT_CONSTRUCT_NONE,</span><br><span class="line">                              bool cxxConstruct &#x3D; true,</span><br><span class="line">                              size_t *outAllocatedSize &#x3D; nil)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line">    &#x2F;&#x2F; Read class&#39;s info bits all at once for performance</span><br><span class="line">    bool hasCxxCtor &#x3D; cxxConstruct &amp;&amp; cls-&gt;hasCxxCtor();</span><br><span class="line">    bool hasCxxDtor &#x3D; cls-&gt;hasCxxDtor();</span><br><span class="line">    bool fast &#x3D; cls-&gt;canAllocNonpointer();</span><br><span class="line">    size_t size;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;获取实例大小</span><br><span class="line">    size &#x3D; cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    if (outAllocatedSize) *outAllocatedSize &#x3D; size;</span><br><span class="line">    id obj;</span><br><span class="line">    if (zone) &#123;</span><br><span class="line">        obj &#x3D; (id)malloc_zone_calloc((malloc_zone_t *)zone, 1, size);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;分配内存</span><br><span class="line">        obj &#x3D; (id)calloc(1, size);</span><br><span class="line">    &#125;</span><br><span class="line">    if (slowpath(!obj)) &#123;</span><br><span class="line">        if (construct_flags &amp; OBJECT_CONSTRUCT_CALL_BADALLOC) &#123;</span><br><span class="line">            return _objc_callBadAllocHandler(cls);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;关联isa指针</span><br><span class="line">    if (!zone &amp;&amp; fast) &#123;</span><br><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; Use raw pointer isa on the assumption that they might be</span><br><span class="line">        &#x2F;&#x2F; doing something weird with the zone or RR.</span><br><span class="line">        obj-&gt;initIsa(cls);</span><br><span class="line">    &#125;</span><br><span class="line">    if (fastpath(!hasCxxCtor)) &#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">    construct_flags |&#x3D; OBJECT_CONSTRUCT_FREE_ONFAILURE;</span><br><span class="line">    return object_cxxConstructFromClass(obj, cls, construct_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>_class_createInstanceFromZone</code>方法有三个关键的点，我们下面分别分析：<h4 id="获取实例大小-size-cls-gt-instanceSize-extraBytes"><a href="#获取实例大小-size-cls-gt-instanceSize-extraBytes" class="headerlink" title="获取实例大小 size = cls-&gt;instanceSize(extraBytes)"></a>获取实例大小 <code>size = cls-&gt;instanceSize(extraBytes)</code></h4>内联函数<code>instanceSize</code>的作用是获取实例的大小，对象的大小取决于其<code>ivars</code>(成员变量)的大小。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; May be unaligned depending on class&#39;s ivars.</span><br><span class="line">uint32_t unalignedInstanceSize() const &#123;</span><br><span class="line">    ASSERT(isRealized());</span><br><span class="line">    return data()-&gt;ro()-&gt;instanceSize;</span><br><span class="line">&#125;</span><br><span class="line">inline size_t instanceSize(size_t extraBytes) const &#123;</span><br><span class="line">    if (fastpath(cache.hasFastInstanceSize(extraBytes))) &#123;</span><br><span class="line">        return cache.fastInstanceSize(extraBytes);</span><br><span class="line">    &#125;</span><br><span class="line">    size_t size &#x3D; alignedInstanceSize() + extraBytes;</span><br><span class="line">    &#x2F;&#x2F; CF requires all objects be at least 16 bytes.</span><br><span class="line">    if (size &lt; 16) size &#x3D; 16;</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
根据<code>if (size &lt; 16) size = 16;</code>可以看出，对象最小大小为16，这个就是内存对齐的概念，上面的<code>alignedInstanceSize()</code>函数,会继续调用内联函数<code>word_align</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; __LP64__</span><br><span class="line">#   define WORD_MASK 7UL</span><br><span class="line">static inline uint32_t word_align(uint32_t x) &#123;</span><br><span class="line">    return (x + WORD_MASK) &amp; ~WORD_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里就引入一个概念就是字节对齐。可以看到<code>WORD_MASK=7</code>,它的作用是保证字节的大小为8的倍数。<h4 id="给对象分配内存空间"><a href="#给对象分配内存空间" class="headerlink" title="给对象分配内存空间"></a>给对象分配内存空间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (zone) &#123;</span><br><span class="line">    obj &#x3D; (id)malloc_zone_calloc((malloc_zone_t *)zone, 1, size);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    obj &#x3D; (id)calloc(1, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="给对象关联isa指针"><a href="#给对象关联isa指针" class="headerlink" title="给对象关联isa指针"></a>给对象关联isa指针</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (!zone &amp;&amp; fast) &#123;</span><br><span class="line">    obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; Use raw pointer isa on the assumption that they might be</span><br><span class="line">    &#x2F;&#x2F; doing something weird with the zone or RR.</span><br><span class="line">    obj-&gt;initIsa(cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>总结来看<code>alloc</code>的流程图即为下图所示：</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62281d7404a940a9bcf2390166545e97~tplv-k3u1fbpfcp-watermark.image" alt="alloc流程.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/06/01/Swift-RxSwift%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/01/Swift-RxSwift%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Swift - RxSwift源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-01 15:35:58" itemprop="dateCreated datePublished" datetime="2021-06-01T15:35:58+08:00">2021-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-03 21:54:22" itemprop="dateModified" datetime="2021-06-03T21:54:22+08:00">2021-06-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="RxSwift简介"><a href="#RxSwift简介" class="headerlink" title="RxSwift简介"></a>RxSwift简介</h3><p><code>RxSwift</code> 是 <a href="http://reactivex.io/" target="_blank" rel="noopener"><code>ReactiveX</code></a> 家族的重要一员, <code>ReactiveX</code> 是 <code>Reactive Extensions</code> 的缩写，一般简写为 <code>Rx</code>。<code>ReactiveX</code> 官方给<code>Rx</code>的定义是：<strong>Rx是一个使用可观察数据流进行异步编程的编程接口。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactiveX&#96; 不仅仅是一个编程接口，它是一种编程思想的突破，它影响了许多其它的程序库和框架以及编程语言。它拓展了&#96;观察者模式&#96;，使你能够&#96;自由组合多个异步事件&#96;，而&#96;不需要去关心线程&#96;，&#96;同步，线程安全&#96;，&#96;并发数据以及I&#x2F;O阻塞</span><br></pre></td></tr></table></figure>

<p><code>RxSwift</code> 是 <code>Rx</code> 为 <code>Swift</code> 语言开发的一门函数响应式编程语言， 它可以代替iOS系统的 <code>Target Action</code> / <code>代理</code> / <code>闭包</code> / <code>通知</code> / <code>KVO</code>,同时还提供<code>网络</code>、<code>数据绑定</code>、<code>UI事件处理</code>、<code>UI的展示和更新</code>、<code>多线程</code>……</p>
<p><code>Swift</code>为值类型，在传值与方法回调上有影响，<code>RxSwift</code>一定程度上弥补<code>Swift</code>的灵活性</p>
<ul>
<li><code>RxSwift</code>使得代码复用性较强，减少代码量</li>
<li><code>RxSwift</code>因为声明都是不可变更，增加代码可读性</li>
<li><code>RxSwift</code>使得更易于理解业务代码，抽象异步编程，统一代码风格</li>
<li><code>RxSwift</code>使得代码更易于编写集成单元测试，增加代码稳定性</li>
</ul>
<h3 id="RxSwift核心流程"><a href="#RxSwift核心流程" class="headerlink" title="RxSwift核心流程"></a>RxSwift核心流程</h3><p>RxSwift的api设计非常精简，流程就是：</p>
<p>1、创建序列（）</p>
<p>2、订阅序列</p>
<p>3、发送信号</p>
<p>4、销毁</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1: 创建序列</span></span><br><span class="line"><span class="number">_</span> = <span class="type">Observable</span>&lt;<span class="type">String</span>&gt;.create &#123; (obserber) -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// 3:发送信号</span></span><br><span class="line">    obserber.onNext(<span class="string">"RxSwift 研究"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create()  <span class="comment">// 4、销毁</span></span><br><span class="line">    <span class="comment">// 2: 订阅序列</span></span><br><span class="line">    &#125;.subscribe(onNext: &#123; (text) <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"订阅到:\(text)"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台打印：“订阅到:RxSwift 研究”</span></span><br></pre></td></tr></table></figure>

<h3 id="创建序列"><a href="#创建序列" class="headerlink" title="创建序列"></a>创建序列</h3><p>我们先看Create.swift文件的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ObservableType</span> </span>&#123;</span><br><span class="line">    <span class="comment">// MARK: create</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     Creates an observable sequence from a specified subscribe method implementation.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     - seealso: [create operator on reactivex.io](http://reactivex.io/documentation/operators/create.html)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     - parameter subscribe: Implementation of the resulting observable sequence's `subscribe` method.</span></span><br><span class="line"><span class="comment">     - returns: The observable sequence with the specified implementation for the `subscribe` method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(<span class="number">_</span> subscribe: @escaping <span class="params">(AnyObserver&lt;Element&gt;)</span></span></span> -&gt; <span class="type">Disposable</span>) -&gt; <span class="type">Observable</span>&lt;<span class="type">Element</span>&gt; &#123;</span><br><span class="line">        <span class="type">AnonymousObservable</span>(subscribe)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousObservable</span>&lt;<span class="title">Element</span>&gt;: <span class="title">Producer</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">SubscribeHandler</span> = (<span class="type">AnyObserver</span>&lt;<span class="type">Element</span>&gt;) -&gt; <span class="type">Disposable</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> subscribeHandler: <span class="type">SubscribeHandler</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> subscribeHandler: @escaping <span class="type">SubscribeHandler</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.subscribeHandler = subscribeHandler</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">run</span>&lt;Observer: ObserverType&gt;<span class="params">(<span class="number">_</span> observer: Observer, cancel: Cancelable)</span></span> -&gt; (sink: <span class="type">Disposable</span>, subscription: <span class="type">Disposable</span>) <span class="keyword">where</span> <span class="type">Observer</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> sink = <span class="type">AnonymousObservableSink</span>(observer: observer, cancel: cancel)</span><br><span class="line">        <span class="keyword">let</span> subscription = sink.run(<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">return</span> (sink: sink, subscription: subscription)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，可观察序列的创建是利用扩展<code>ObservableType</code>协议的<code>create</code>方法实现的,里面创建了<code>AnonymousObservable</code>(匿名可观察序列) ，这个命名体现了作者的思维，这是一个内部类，具备一些通用特性（具有自己功能的类才会命名）可以总结一下：</p>
<ul>
<li><code>create</code>方法的时候创建了一个内部对象<code>AnonymousObservable</code></li>
<li><code>AnonymousObservable</code>保存了外界传入的闭包</li>
<li><code>AnonymousObservable</code>继承了<code>Producer</code></li>
</ul>
<p>接下来我们看一下<code>Producer</code>类</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span>&lt;<span class="title">Element</span>&gt;: <span class="title">Observable</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span>&lt;Observer: ObserverType&gt;<span class="params">(<span class="number">_</span> observer: Observer)</span></span> -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">Observer</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !<span class="type">CurrentThreadScheduler</span>.isScheduleRequired &#123;</span><br><span class="line">            <span class="comment">// The returned disposable needs to release all references once it was disposed.</span></span><br><span class="line">            <span class="keyword">let</span> disposer = <span class="type">SinkDisposer</span>()</span><br><span class="line">            <span class="keyword">let</span> sinkAndSubscription = <span class="keyword">self</span>.run(observer, cancel: disposer)</span><br><span class="line">            disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink, subscription: sinkAndSubscription.subscription)</span><br><span class="line">            <span class="keyword">return</span> disposer</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">CurrentThreadScheduler</span>.instance.schedule(()) &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">let</span> disposer = <span class="type">SinkDisposer</span>()</span><br><span class="line">                <span class="keyword">let</span> sinkAndSubscription = <span class="keyword">self</span>.run(observer, cancel: disposer)</span><br><span class="line">                disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink, subscription: sinkAndSubscription.subscription)</span><br><span class="line">                <span class="keyword">return</span> disposer</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span>&lt;Observer: ObserverType&gt;<span class="params">(<span class="number">_</span> observer: Observer, cancel: Cancelable)</span></span> -&gt; (sink: <span class="type">Disposable</span>, subscription: <span class="type">Disposable</span>) <span class="keyword">where</span> <span class="type">Observer</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">        rxAbstractMethod()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到Producer有一个很重要的方法<code>subscribe</code>(订阅)，<code>subscribe</code>方法最后返回一个<code>Disposable</code>对象。</p>
<h3 id="订阅序列"><a href="#订阅序列" class="headerlink" title="订阅序列"></a>订阅序列</h3><p>我们看一下<code>ObservableType</code>拓展（ObservableType+Extensions.swift）的功能，订阅的方法<code>subscribe</code>（注意这个方法和<code>Producer</code>的<code>subscribe</code>不是同一个）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     Subscribes an element handler, an error handler, a completion handler and disposed handler to an observable sequence.</span></span><br><span class="line"><span class="comment">     - parameter onNext: Action to invoke for each element in the observable sequence.</span></span><br><span class="line"><span class="comment">     - parameter onError: Action to invoke upon errored termination of the observable sequence.</span></span><br><span class="line"><span class="comment">     - parameter onCompleted: Action to invoke upon graceful termination of the observable sequence.</span></span><br><span class="line"><span class="comment">     - parameter onDisposed: Action to invoke upon any type of termination of sequence (if the sequence has</span></span><br><span class="line"><span class="comment">     gracefully completed, errored, or if the generation is canceled by disposing subscription).</span></span><br><span class="line"><span class="comment">     - returns: Subscription object used to unsubscribe from the observable sequence.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        onNext: <span class="params">(<span class="params">(Element)</span></span></span></span> -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span>,</span><br><span class="line">        onError: ((<span class="type">Swift</span>.<span class="type">Error</span>) -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span>,</span><br><span class="line">        onCompleted: (() -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span>,</span><br><span class="line">        onDisposed: (() -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span></span><br><span class="line">    ) -&gt; <span class="type">Disposable</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> disposable: <span class="type">Disposable</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> disposed = onDisposed &#123;</span><br><span class="line">                disposable = <span class="type">Disposables</span>.create(with: disposed)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                disposable = <span class="type">Disposables</span>.create()</span><br><span class="line">            &#125;</span><br><span class="line">            #<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line">                <span class="keyword">let</span> synchronizationTracker = <span class="type">SynchronizationTracker</span>()</span><br><span class="line">            #endif</span><br><span class="line">            <span class="keyword">let</span> callStack = <span class="type">Hooks</span>.recordCallStackOnError ? <span class="type">Hooks</span>.customCaptureSubscriptionCallstack() : []</span><br><span class="line">      			<span class="comment">///以下重点关注的代码 创建匿名观察者</span></span><br><span class="line">            <span class="keyword">let</span> observer = <span class="type">AnonymousObserver</span>&lt;<span class="type">Element</span>&gt; &#123; event <span class="keyword">in</span> </span><br><span class="line">                #<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line">                    synchronizationTracker.register(synchronizationErrorMessage: .<span class="keyword">default</span>)</span><br><span class="line">                    <span class="keyword">defer</span> &#123; synchronizationTracker.unregister() &#125;</span><br><span class="line">                #endif</span><br><span class="line">                <span class="keyword">switch</span> event &#123;</span><br><span class="line">                <span class="keyword">case</span> .next(<span class="keyword">let</span> value):</span><br><span class="line">                    onNext?(value)</span><br><span class="line">                <span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> onError = onError &#123;</span><br><span class="line">                        onError(error)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="type">Hooks</span>.defaultErrorHandler(callStack, error)</span><br><span class="line">                    &#125;</span><br><span class="line">                    disposable.dispose()</span><br><span class="line">                <span class="keyword">case</span> .completed:</span><br><span class="line">                    onCompleted?()</span><br><span class="line">                    disposable.dispose()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Disposables</span>.create(</span><br><span class="line">                <span class="keyword">self</span>.asObservable().subscribe(observer),</span><br><span class="line">                disposable</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码说明：</p>
<ul>
<li><p><code>E</code>是<code>Swift</code>的关联类型，这个如果仔细看过可观察序列的继承链源码应该不难得出：这个<code>E</code> 就是我们的 序列类型，我们这里就是<code>String</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span>&lt;<span class="title">Element</span>&gt; : <span class="title">ObservableType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Type of elements in sequence.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">E</span> = <span class="type">Element</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建<code>AnonymousObserver</code>对象，可以类比前面<code>create</code>的<code>AnonymousObservable</code>对象，初始化参数为闭包，保存了外界传入的<code>onNext</code>,<code>onError</code>,<code>onComplete</code>,<code>onDisposed</code>的处理回调闭包。</p>
</li>
<li><p><code>self.asObservable()</code>是我们的<code>RxSwift</code>为了保持一致性的写法。</p>
</li>
<li><p><code>self.asObservable().subscribe(observer)</code>其实本质就是<code>self.</code>subscribe(observer),通过可观察序列的继承关系，我们可以快速定位到<code>Producer</code>订阅代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span>&lt;Observer: ObserverType&gt;<span class="params">(<span class="number">_</span> observer: Observer)</span></span> -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">Observer</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !<span class="type">CurrentThreadScheduler</span>.isScheduleRequired &#123;</span><br><span class="line">        <span class="comment">// The returned disposable needs to release all references once it was disposed.</span></span><br><span class="line">        <span class="keyword">let</span> disposer = <span class="type">SinkDisposer</span>()</span><br><span class="line">        <span class="keyword">let</span> sinkAndSubscription = <span class="keyword">self</span>.run(observer, cancel: disposer)</span><br><span class="line">        disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink, subscription: sinkAndSubscription.subscription)</span><br><span class="line">        <span class="keyword">return</span> disposer</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CurrentThreadScheduler</span>.instance.schedule(()) &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> disposer = <span class="type">SinkDisposer</span>()</span><br><span class="line">            <span class="keyword">let</span> sinkAndSubscription = <span class="keyword">self</span>.run(observer, cancel: disposer)</span><br><span class="line">            disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink, subscription: sinkAndSubscription.subscription)</span><br><span class="line">            <span class="keyword">return</span> disposer</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>销毁代码后面在分析</p>
</li>
<li><p><code>self.run</code>这个代码最终由我们生产者<code>Producer</code>(抽象方法找子类)延伸到具体事务代码<code>AnonymousObservable.run</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">run</span>&lt;Observer: ObserverType&gt;<span class="params">(<span class="number">_</span> observer: Observer, cancel: Cancelable)</span></span> -&gt; (sink: <span class="type">Disposable</span>, subscription: <span class="type">Disposable</span>) <span class="keyword">where</span> <span class="type">Observer</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> sink = <span class="type">AnonymousObservableSink</span>(observer: observer, cancel: cancel)</span><br><span class="line">      <span class="keyword">let</span> subscription = sink.run(<span class="keyword">self</span>)</span><br><span class="line">      <span class="keyword">return</span> (sink: sink, subscription: subscription)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里调用了<code>sink.run(self)</code>方法，将业务处理下沉，分工更加明确。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(<span class="number">_</span> parent: Parent)</span></span> -&gt; <span class="type">Disposable</span> &#123;</span><br><span class="line">    parent.subscribeHandler(<span class="type">AnyObserver</span>(<span class="keyword">self</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>parent</code>是上面传入进来的<code>AnonymousObservable</code>对象</p>
</li>
<li><p>这个地方我们可以看到调用了<code>AnonymousObservable</code>对象的<code>subscribeHandler</code>方法，这里我们清楚了，为什么<code>序列订阅</code>的时候流程会执行我们的<code>序列闭包</code>，然后去执行<code>发送响应</code></p>
</li>
<li><p>发送响应的代码后面再分析，下面还有个点是<code>AnyObserver(self)</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Construct an instance whose `on(event)` calls `observer.on(event)`</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - parameter observer: Observer that receives sequence events.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">Observer</span>: <span class="type">ObserverType</span>&gt;(<span class="number">_</span> observer: <span class="type">Observer</span>) <span class="keyword">where</span> <span class="type">Observer</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">     <span class="keyword">self</span>.observer = observer.on</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个构造方法里面，我们创建了一个结构体<code>AnyObserver</code>保存了一个信息<code>AnonymousObservableSink.on</code>函数。注意不是<code>AnonymousObservableSink</code></p>
</li>
</ul>
<h3 id="发送响应"><a href="#发送响应" class="headerlink" title="发送响应"></a>发送响应</h3><p>通过上面的分析，我们清楚了<code>observer.onNext(&quot;&quot;)</code>本质是<code>AnyObserver.onNext(&quot;&quot;)</code>,我们发现AnyObserver没有这个方法，顺着思路找父类，找<code>ObserverType</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Convenience API extensions to provide alternate next, error, completed events</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ObserverType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Convenience method equivalent to `on(.next(element: Element))`</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - parameter element: Next element to send to observer(s)</span></span><br><span class="line">  	<span class="comment">///这里是我们关注的点 AnyObserver.onNext("")实际调用这里</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">onNext</span><span class="params">(<span class="number">_</span> element: Element)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.on(.next(element))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Convenience method equivalent to `on(.completed)`</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">onCompleted</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.on(.completed)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Convenience method equivalent to `on(.error(Swift.Error))`</span></span><br><span class="line">    <span class="comment">/// - parameter error: Swift.Error to send to observer(s)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">onError</span><span class="params">(<span class="number">_</span> error: Swift.Error)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.on(.error(error))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>外界调用的<code>observer.onNext(&quot;&quot;)</code>再次变形：<code>AnyObserver.on(.next(&quot;&quot;))</code>,<code>AnyObserver</code>调用了<code>on</code>里面的<code>.next</code>函数，<code>.next</code>函数带有我们最终的参数</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Construct an instance whose `on(event)` calls `observer.on(event)`</span></span><br><span class="line"><span class="comment">/// - parameter observer: Observer that receives sequence events.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">Observer</span>: <span class="type">ObserverType</span>&gt;(<span class="number">_</span> observer: <span class="type">Observer</span>) <span class="keyword">where</span> <span class="type">Observer</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.observer = observer.on</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// Send `event` to this observer.</span></span><br><span class="line"><span class="comment">/// - parameter event: Event instance.</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">on</span><span class="params">(<span class="number">_</span> event: Event&lt;Element&gt;)</span></span> &#123;</span><br><span class="line">     <span class="keyword">self</span>.observer(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>self.observer</code> 构造初始化就是：<code>AnonymousObservableSink .on 函数</code></p>
</li>
<li><p><code>self.observer(event)</code> -&gt; <code>AnonymousObservableSink .on(event)</code> 其中 <code>event = .next(&quot;&quot;)</code> 最终我们的核心逻辑又回到了 <code>sink</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousObservableSink</span>&lt;<span class="title">Observer</span>: <span class="title">ObserverType</span>&gt;: <span class="title">Sink</span>&lt;<span class="title">Observer</span>&gt;, <span class="title">ObserverType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">on</span><span class="params">(<span class="number">_</span> event: Event&lt;Element&gt;)</span></span> &#123;</span><br><span class="line">        #<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line">            <span class="keyword">self</span>.synchronizationTracker.register(synchronizationErrorMessage: .<span class="keyword">default</span>)</span><br><span class="line">            <span class="keyword">defer</span> &#123; <span class="keyword">self</span>.synchronizationTracker.unregister() &#125;</span><br><span class="line">        #endif</span><br><span class="line">        <span class="keyword">switch</span> event &#123;</span><br><span class="line">        <span class="keyword">case</span> .next:</span><br><span class="line">            <span class="keyword">if</span> load(<span class="keyword">self</span>.isStopped) == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.forwardOn(event)</span><br><span class="line">        <span class="keyword">case</span> .error, .completed:</span><br><span class="line">            <span class="keyword">if</span> fetchOr(<span class="keyword">self</span>.isStopped, <span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.forwardOn(event)</span><br><span class="line">                <span class="keyword">self</span>.dispose()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>self.forwardOn(event)</code> 这也是执行的核心代码，因为 <code>AnonymousObservableSink</code> 继承 <code>Sink</code> 这里还有封装，请看下面的代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sink</span>&lt;<span class="title">Observer</span>: <span class="title">ObserverType</span>&gt;: <span class="title">Disposable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="function"><span class="keyword">func</span> <span class="title">forwardOn</span><span class="params">(<span class="number">_</span> event: Event&lt;Observer.Element&gt;)</span></span> &#123;</span><br><span class="line">        #<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line">            <span class="keyword">self</span>.synchronizationTracker.register(synchronizationErrorMessage: .<span class="keyword">default</span>)</span><br><span class="line">            <span class="keyword">defer</span> &#123; <span class="keyword">self</span>.synchronizationTracker.unregister() &#125;</span><br><span class="line">        #endif</span><br><span class="line">        <span class="keyword">if</span> isFlagSet(<span class="keyword">self</span>.disposed, <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.observer.on(event)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其中 <code>self.observer</code> 就是我们初始化保存的 <code>观察者：AnonymousObserver</code></p>
</li>
<li><p>到这里我们得出了发送序列的本质就是<code>AnonymousObserver.on（.next(&quot;&quot;)）</code>,这个逻辑又回到了我们<code>订阅序列</code>时候创建的<code>AnonymousObserver</code>参数闭包的调用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="type">AnonymousObserver</span>&lt;<span class="type">E</span>&gt; &#123; event <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> event &#123;</span><br><span class="line">    <span class="keyword">case</span> .next(<span class="keyword">let</span> value):</span><br><span class="line">        onNext?(value)</span><br><span class="line">    <span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> onError = onError &#123;</span><br><span class="line">            onError(error)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Hooks</span>.defaultErrorHandler(callStack, error)</span><br><span class="line">        &#125;</span><br><span class="line">        disposable.dispose()</span><br><span class="line">    <span class="keyword">case</span> .completed:</span><br><span class="line">        onCompleted?()</span><br><span class="line">        disposable.dispose()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断<code>event</code>进而调用<code>onNext?(value)</code>,因为枚举的关联值<code>value=&quot;&quot;</code>,接下来外界<code>onNext</code>的调用参数。</p>
</li>
</ul>
<h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><p>我们先看一下创建序列到销毁的执行代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建序列</span></span><br><span class="line"><span class="keyword">let</span> ob = <span class="type">Observable</span>&lt;<span class="type">Any</span>&gt;.create &#123; (observer) -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">    observer.onNext(<span class="string">"Jason"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"销毁释放了"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 序列订阅</span></span><br><span class="line"><span class="keyword">let</span> dispose = ob.subscribe(onNext: &#123; (anything) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"订阅到了:\(anything)"</span>)</span><br><span class="line">&#125;, onError: &#123; (error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"订阅到了:\(error)"</span>)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"完成了"</span>)</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"销毁回调"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这段代码里面关于销毁相关的代码就是<code>Disposables.create {print(&quot;销毁释放了&quot;)}</code>,所以我们直接定位到<code>Disposables</code>类（AnonymousDisposable.swift文件）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Disposables</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Constructs a new disposable with the given action used for disposal.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - parameter dispose: Disposal action which will be run upon calling `dispose`.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(with dispose: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Cancelable</span> &#123;</span><br><span class="line">        <span class="type">AnonymousDisposable</span>(disposeAction: dispose)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以看出，这里创建了一个匿名销毁序列<code>AnonymousDisposable</code>,和订阅一样的手法。继续看<code>AnonymousDisposable</code>代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// When dispose method is called, disposal action will be dereferenced.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousDisposable</span> : <span class="title">DisposeBase</span>, <span class="title">Cancelable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Non-deprecated version of the constructor, used by `Disposables.create(with:)`</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">init</span>(disposeAction: @escaping <span class="type">DisposeAction</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.disposeAction = disposeAction</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Calls the disposal action if and only if the current instance hasn't been disposed yet.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// After invoking disposal action, disposal action will be dereferenced.</span></span><br><span class="line">    <span class="comment">///销毁核心的逻辑</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">dispose</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> fetchOr(<span class="keyword">self</span>.disposed, <span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> action = <span class="keyword">self</span>.disposeAction &#123;</span><br><span class="line">                <span class="keyword">self</span>.disposeAction = <span class="literal">nil</span></span><br><span class="line">                action()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上我们看到，初始化方法里保存了销毁响应闭包，什么时候调用，我们看下面的<code>dispose()</code>方法。</p>
</li>
<li><p>fetchOr(self.disposed, 1)是一个单项标记手段，这里利用了牛逼的算法标记可以降低依赖和更加快速。</p>
</li>
<li><p>主要就是保证只会销毁一次</p>
</li>
<li><p>销毁会首先<code>self.disposeAction = nil</code>,将回调闭包置空</p>
</li>
<li><p>最后调用闭包调用<code>action()</code>,这里是一个局部变量不需要再置空</p>
</li>
</ul>
<p>下面我们看一下<code>dispose()</code>是什么时候调用的</p>
<p>上面的流程，我们再序列的回调闭包：<code>subscriberHandle</code>里面，这个流程之前有一个重要的流程就是订阅<code>subscriber</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> disposed = onDisposed &#123;</span><br><span class="line">  disposable = <span class="type">Disposables</span>.create(with: disposed)  </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  disposable = <span class="type">Disposables</span>.create()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这里保存外界传入的销毁闭包</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> event &#123;</span><br><span class="line"><span class="keyword">case</span> .next(<span class="keyword">let</span> value):</span><br><span class="line">    onNext?(value)</span><br><span class="line"><span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">  <span class="comment">// 响应外界调回闭包</span></span><br><span class="line">    disposable.dispose()</span><br><span class="line"><span class="keyword">case</span> .completed:</span><br><span class="line">  <span class="comment">// 响应外界调回闭包</span></span><br><span class="line">    disposable.dispose()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>观察者回调里面调用， 响应外界调回闭包</p>
</li>
</ul>
<ul>
<li><code>return Disposables.create(self.asObservable().subscribe(observer),disposable)</code> 综合来看，我们的重点必然在这句代码，沟通下面流程的 <code>subscribe</code>, 外界订阅返回的销毁者（可以随时随地进行 <code>dispose.dispose()</code> ）</li>
<li>上面代码跟进去看到<code>BinaryDisposable(disposable1, disposable2)</code> 原来创建的二元销毁者！</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dispose</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> fetchOr(<span class="keyword">self</span>._isDisposed, <span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>._disposable1?.dispose()</span><br><span class="line">        <span class="keyword">self</span>._disposable2?.dispose()</span><br><span class="line">        <span class="keyword">self</span>._disposable1 = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>._disposable2 = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>二元销毁者的 <code>dispose</code> 方法也在预料之中，分别销毁</p>
</li>
<li><p>那么我们的重点就应该探索，在 <code>subscribe</code> 这里面创建的关键销毁者是什么?</p>
</li>
<li><p>下面我们进入非常熟悉的：<code>Producer</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> disposer = <span class="type">SinkDisposer</span>()</span><br><span class="line"><span class="keyword">let</span> sinkAndSubscription = <span class="keyword">self</span>.run(observer, cancel: disposer)</span><br><span class="line">disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink,</span><br><span class="line"> subscription: sinkAndSubscription.subscription)</span><br><span class="line"><span class="comment">// 返回销毁者</span></span><br><span class="line"><span class="keyword">return</span> disposer</span><br></pre></td></tr></table></figure>
</li>
<li><p>看到 <code>SinkDisposer</code> 就熟悉了，普通销毁者：<code>AnonymousDisposable</code> , 关键销毁者： <code>SinkDisposer</code></p>
</li>
<li><p>先看什么东西进入了 <code>SinkDisposer</code></p>
</li>
<li><p><code>self.run(observer, cancel: disposer)</code> 证明里面需要用到 <code>SinkDisposer</code></p>
</li>
<li><p><code>disposer.setSinkAndSubscription</code> 常规操作</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setSinkAndSubscription</span><span class="params">(sink: Disposable, subscription: Disposable)</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>._sink = sink</span><br><span class="line">    <span class="keyword">self</span>._subscription = subscription</span><br><span class="line"><span class="comment">// 获取状态 </span></span><br><span class="line">    <span class="keyword">let</span> previousState = fetchOr(<span class="keyword">self</span>._state, </span><br><span class="line"><span class="type">DisposeState</span>.sinkAndSubscriptionSet.rawValue)</span><br><span class="line"><span class="comment">// 如果状态满足就销毁</span></span><br><span class="line">    <span class="keyword">if</span> (previousState &amp; <span class="type">DisposeState</span>.disposed.rawValue) != <span class="number">0</span> &#123;</span><br><span class="line">        sink.dispose()</span><br><span class="line">        subscription.dispose()</span><br><span class="line">        <span class="keyword">self</span>._sink = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>._subscription = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>保存了两个属性 : <code>sink</code> 和 <code>subscription</code>(就是外界创建序列的闭包的返回销毁者)</p>
</li>
<li><p>取了某一个状态：<code>previousState</code>,判断状态的条件，然后执行 这两个保存属性的销毁和置空释放销毁 ： <code>.dispose() + = nil</code></p>
</li>
<li><p>其实是可以理解，就是我们在加入的东西其实需要销毁的，不应该保留的，那么没必要给它继续保留生命迹象</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 sink 保存了销毁者</span></span><br><span class="line"><span class="keyword">let</span> sink = <span class="type">AnonymousObservableSink</span>(observer: observer, cancel: cancel)</span><br><span class="line"><span class="comment">// 省略不相管代码。。。。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">on</span><span class="params">(<span class="number">_</span> event: Event&lt;Element&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> event &#123;</span><br><span class="line">    <span class="keyword">case</span> .next:</span><br><span class="line">        <span class="keyword">self</span>.forwardOn(event)</span><br><span class="line">    <span class="keyword">case</span> .error, .completed:</span><br><span class="line">        <span class="keyword">if</span> fetchOr(<span class="keyword">self</span>._isStopped, <span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.forwardOn(event)</span><br><span class="line">            <span class="comment">// 关键点：完成和错误信号的响应式必然会直接开启销毁的</span></span><br><span class="line">            <span class="keyword">self</span>.dispose()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>完成和错误信号的响应式必然会直接开启销毁的 ： <code>self.dispose()</code>! 这里也解释了：一旦我们的序列发出完成或者错误就无法再次响应了！</p>
</li>
<li><p>剩下一个问题： <strong>到底我们的销毁的是什么</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dispose</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> previousState = fetchOr(<span class="keyword">self</span>._state, <span class="type">DisposeState</span>.disposed.rawValue)</span><br><span class="line">    <span class="keyword">if</span> (previousState &amp; <span class="type">DisposeState</span>.sinkAndSubscriptionSet.rawValue) != <span class="number">0</span> &#123;</span><br><span class="line">        sink.dispose()</span><br><span class="line">        subscription.dispose()</span><br><span class="line">        <span class="keyword">self</span>._sink = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>._subscription = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>无论我们直接销毁还是系统帮助我们销毁必然会调用：<code>dispose()</code></p>
</li>
<li><p>我们查看 <code>dispose()</code> 得出: 就是在初始化初期我们保留的两个属性的操作</p>
</li>
<li><p><code>sink.dispose() + self._sink = nil</code> &amp; <code>subscription.dispose() + self._subscription = nil</code> 执行相关释放和销毁</p>
</li>
</ul>
<h4 id="总结一下销毁"><a href="#总结一下销毁" class="headerlink" title="总结一下销毁"></a>总结一下销毁</h4><p>第一：内部创建的临时序列和观察者都会随着对外的观察者和序列的生命周期而销毁释放。</p>
<p>第二：外界观察者和序列会随着他们的作用域空间而释放</p>
<p>第三：释放不了只是对象的释放有问题，常规内存管理问题</p>
<p>第四：最为一个再牛逼的框架也不能对程序员写的代码直接管理控制</p>
<p>第五：<code>RxSwift</code> 的观察和序列以及销毁者就是普通对象。</p>
<p>到这里RxSwift从创建序列-&gt;订阅序列-&gt;发送信号-&gt;销毁的源码解析就结束了，里面的精妙还是需要细细品味的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/28/GitHub-s-file-size-limit-of-100-00-MB%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/28/GitHub-s-file-size-limit-of-100-00-MB%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/" class="post-title-link" itemprop="url">GitHub's file size limit of 100.00 MB解决办法(转)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-28 14:42:48 / 修改时间：17:32:00" itemprop="dateCreated datePublished" datetime="2021-05-28T14:42:48+08:00">2021-05-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">遇到的问题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上传github发现不给上传100m以上文件的错误,按着提示进行了,用到一个叫lfs的工具专门用来上传大文件的！附<a href="https://github.com/git-lfs/git-lfs" target="_blank" rel="noopener">git-lfs</a> 1.安装 mac</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install git-lfs</span><br><span class="line">git lfs install</span><br></pre></td></tr></table></figure>

<p>找出超过100m的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 目标项目path</span><br><span class="line">find .&#x2F; -size +100M</span><br></pre></td></tr></table></figure>

<p>大文件加入git large file storage上面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git lfs track &quot;name_of_a_giant_file&quot;</span><br><span class="line">#example:</span><br><span class="line">git lfs track &quot;.&#x2F;&#x2F;huanxin&#x2F;HXTest&#x2F;Hyphenate.framework&#x2F;Hyphenate&quot;</span><br></pre></td></tr></table></figure>

<p>添加到git上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add path_of_a_giant_file</span><br><span class="line">#example:</span><br><span class="line">git add .&#x2F;&#x2F;huanxin&#x2F;HXTest&#x2F;Hyphenate.framework&#x2F;Hyphenate</span><br></pre></td></tr></table></figure>

<p>仅供记录以后遇到类似问题查找。</p>
<p><a href="https://juejin.cn/post/6844904205476478989" target="_blank" rel="noopener">原文地址</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/21/flutter%E6%8E%A2%E7%B4%A2-%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/21/flutter%E6%8E%A2%E7%B4%A2-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">flutter探索  - 多线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-21 10:36:00 / 修改时间：16:06:28" itemprop="dateCreated datePublished" datetime="2021-05-21T10:36:00+08:00">2021-05-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Flutter默认是单线程任务处理的，如果不开启新的线程，任务默认在主线程中处理。</p>
<h3 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a>事件队列</h3><p>和iOS应用很像，在<code>Dart</code>的线程中也存在事件循环和消息队列的概念，但在<code>Dart</code>中线程叫做<code>isolate</code>。应用程序启动后，开始执行<code>main</code>函数并运行<code>main isolate</code>。</p>
<p>每个<code>isolate</code>包含一个事件循环以及两个事件队列，<code>event loop</code>事件循环，以及<code>event queue</code>和<code>microtask queue</code>事件队列，<code>event</code>和<code>microtask</code>队列有点类似iOS的<code>source0</code>和<code>source1</code>。</p>
<ul>
<li>event queue：负责处理I/O事件、绘制事件、手势事件、接收其他<code>isolate</code>消息等外部事件。</li>
<li>microtask queue：可以自己向<code>isolate</code>内部添加事件，事件的优先级比<code>event queue</code>高。</li>
</ul>
<p>这两个队列也是有优先级的，当<code>isolate</code>开始执行后，会先处理<code>microtask</code>的事件，当<code>microtask</code>队列中没有事件后，才会处理<code>event</code>队列中的事件，并按照这个顺序反复执行。但需要注意的是，当执行<code>microtask</code>事件时，会阻塞<code>event</code>队列的事件执行，这样就会导致渲染、手势响应等<code>event</code>事件响应延时。为了保证渲染和手势响应，应该尽量将耗时操作放在<code>event</code>队列中。</p>
<h3 id="async、await"><a href="#async、await" class="headerlink" title="async、await"></a>async、await</h3><p>在异步调用中有三个关键词，<code>async</code>、<code>await</code>、<code>Future</code>，其中<code>async</code>和<code>await</code>需要一起使用。在<code>Dart</code>中可以通过<code>async</code>和<code>await</code>进行异步操作，<code>async</code>表示开启一个异步操作，也可以返回一个<code>Future</code>结果。如果没有返回值，则默认返回一个返回值为<code>null</code>的<code>Future</code>。</p>
<p><code>async</code>、<code>await</code>本质上就是<code>Dart</code>对异步操作的一个语法糖，可以减少异步调用的嵌套调用，并且由<code>async</code>修饰后返回一个<code>Future</code>，外界可以以链式调用的方式调用。这个语法是<code>JS</code>的<code>ES7</code>标准中推出的，<code>Dart</code>的设计和<code>JS</code>相同。</p>
<p>下面封装了一个网络请求的异步操作，并且将请求后的<code>Response</code>类型的<code>Future</code>返回给外界，外界可以通过<code>await</code>调用这个请求，并获取返回数据。从代码中可以看到，即便直接返回一个字符串，<code>Dart</code>也会对其进行包装并成为一个<code>Future</code>。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Response&gt; dataReqeust() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="built_in">String</span> requestURL = <span class="string">'https://jsonplaceholder.typicode.com/posts'</span>;</span><br><span class="line">    Client client = Client();</span><br><span class="line">    Future&lt;Response&gt; response = client.<span class="keyword">get</span>(requestURL);</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; loadData() <span class="keyword">async</span> &#123;</span><br><span class="line">    Response response = <span class="keyword">await</span> dataReqeust();</span><br><span class="line">    <span class="keyword">return</span> response.body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码示例中，执行到<code>loadData</code>方法时，会同步进入方法内部进行执行，当执行到<code>await</code>时就会停止<code>async</code>内部的执行，从而继续执行外面的代码。当<code>await</code>有返回后，会继续从<code>await</code>的位置继续执行。所以<code>await</code>的操作，不会影响后面代码的执行。</p>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p><code>Future</code>就是延时操作的一个封装，可以将异步任务封装为<code>Future</code>对象。获取到<code>Future</code>对象后，最简单的方法就是用<code>await</code>修饰，并等待返回结果继续向下执行。正如上面<code>async、await</code>中讲到的，使用<code>await</code>修饰时需要配合<code>async</code>一起使用。</p>
<p>在<code>Dart</code>中，和时间相关的操作基本都和<code>Future</code>有关，例如延时操作、异步操作等。下面是一个很简单的延时操作，通过<code>Future</code>的<code>delayed</code>方法实现。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">loadData() &#123;</span><br><span class="line">    <span class="comment">// DateTime.now()，获取当前时间</span></span><br><span class="line">    <span class="built_in">DateTime</span> now = <span class="built_in">DateTime</span>.now();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'request begin <span class="subst">$now</span>'</span>);</span><br><span class="line">    Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">1</span>), ()&#123;</span><br><span class="line">      now = <span class="built_in">DateTime</span>.now();</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'request response <span class="subst">$now</span>'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Dart</code>还支持对<code>Future</code>的链式调用，通过追加一个或多个<code>then</code>方法来实现，这个特性非常实用。例如一个延时操作完成后，会调用<code>then</code>方法，并且可以传递一个参数给<code>then</code>。调用方式是链式调用，也就代表可以进行很多层的处理。这有点类似于iOS的<code>RAC</code>框架，链式调用进行信号处理。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">1</span>), ()&#123;</span><br><span class="line">  <span class="built_in">int</span> age = <span class="number">18</span>;</span><br><span class="line">  <span class="keyword">return</span> age;</span><br><span class="line">&#125;).then((onValue)&#123;</span><br><span class="line">  onValue++;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'age <span class="subst">$onValue</span>'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>如果想要了解<code>async</code>、<code>await</code>的原理，就要先了解协程的概念，<code>async</code>、<code>await</code>本质上就是协程的一种语法糖。协程，也叫作<code>coroutine</code>，是一种比线程更小的单元。如果从单元大小来说，基本可以理解为进程-&gt;线程-&gt;协程。</p>
<h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>在弄懂协程之前，首先要明白并发和并行的概念，并发指的是由系统来管理多个IO的切换，并交由CPU去处理。并行指的是多核CPU在同一时间里执行多个任务。</p>
<p>并发的实现由非阻塞操作+事件通知来完成，事件通知也叫做“中断”。操作过程分为两种，一种是CPU对IO进行操作，在操作完成后发起中断告诉IO操作完成。另一种是IO发起中断，告诉CPU可以进行操作。</p>
<p>线程本质上也是依赖于中断来进行调度的，线程还有一种叫做“阻塞式中断”，就是在执行IO操作时将线程阻塞，等待执行完成后再继续执行。但线程的消耗是很大的，并不适合大量并发操作的处理，而通过单线程并发可以进行大量并发操作。当多核CPU出现后，单个线程就无法很好的利用多核CPU的优势了，所以又引入了线程池的概念，通过线程池来管理大量线程。</p>
<h3 id="协程-1"><a href="#协程-1" class="headerlink" title="协程"></a>协程</h3><p>在程序执行过程中，离开当前的调用位置有两种方式，继续调用其他函数和<code>return</code>返回离开当前函数。但是执行<code>return</code>时，当前函数在调用栈中的局部变量、形参等状态则会被销毁。</p>
<p>协程分为无线协程和有线协程，无线协程在离开当前调用位置时，会将当前变量放在堆区，当再次回到当前位置时，还会继续从堆区中获取到变量。所以，一般在执行当前函数时就会将变量直接分配到堆区，而<code>async</code>、<code>await</code>就属于无线协程的一种。有线协程则会将变量继续保存在栈区，在回到指针指向的离开位置时，会继续从栈中取出调用。</p>
<h3 id="async、await原理"><a href="#async、await原理" class="headerlink" title="async、await原理"></a>async、await原理</h3><p>以<code>async</code>、<code>await</code>为例，协程在执行时，执行到<code>async</code>则表示进入一个协程，会同步执行<code>async</code>的代码块。<code>async</code>的代码块本质上也相当于一个函数，并且有自己的上下文环境。当执行到<code>await</code>时，则表示有任务需要等待，CPU则去调度执行其他IO，也就是后面的代码或其他协程代码。过一段时间CPU就会轮训一次，看某个协程是否任务已经处理完成，有返回结果可以被继续执行，如果可以被继续执行的话，则会沿着上次离开时指针指向的位置继续执行，也就是<code>await</code>标志的位置。</p>
<p>由于并没有开启新的线程，只是进行IO中断改变CPU调度，所以网络请求这样的异步操作可以使用<code>async</code>、<code>await</code>，但如果是执行大量耗时同步操作的话，应该使用<code>isolate</code>开辟新的线程去执行。</p>
<p>如果用协程和iOS的<code>dispatch_async</code>进行对比，可以发现二者是比较相似的。从结构定义来看，协程需要将当前<code>await</code>的代码块相关的变量进行存储，<code>dispatch_async</code>也可以通过<code>block</code>来实现临时变量的存储能力。</p>
<p>我之前还在想一个问题，苹果为什么不引入协程的特性呢？后来想了一下，<code>await</code>和<code>dispatch_async</code>都可以简单理解为异步操作，OC的线程是基于<code>Runloop</code>实现的，<code>Dart</code>本质上也是有事件循环的，而且二者都有自己的事件队列，只是队列数量和分类不同。</p>
<p>我觉得当执行到<code>await</code>时，保存当前的上下文，并将当前位置标记为待处理任务，用一个指针指向当前位置，并将待处理任务放入当前<code>isolate</code>的队列中。在每个事件循环时都去询问这个任务，如果需要进行处理，就恢复上下文进行任务处理。</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>这里想提一下<code>JS</code>里的<code>Promise</code>语法，在iOS中会出现很多<code>if</code>判断或者其他的嵌套调用，而<code>Promise</code>可以把之前横向的嵌套调用，改成纵向链式调用。如果能把<code>Promise</code>引入到OC里，可以让代码看起来更简洁，直观。</p>
<h3 id="isolate"><a href="#isolate" class="headerlink" title="isolate"></a>isolate</h3><p><code>isolate</code>是<code>Dart</code>平台对线程的实现方案，但和普通<code>Thread</code>不同的是，<code>isolate</code>拥有独立的内存，<code>isolate</code>由线程和独立内存构成。正是由于<code>isolate</code>线程之间的内存不共享，所以<code>isolate</code>线程之间并不存在资源抢夺的问题，所以也不需要锁。</p>
<p>通过<code>isolate</code>可以很好的利用多核CPU，来进行大量耗时任务的处理。<code>isolate</code>线程之间的通信主要通过<code>port</code>来进行，这个<code>port</code>消息传递的过程是异步的。通过<code>Dart</code>源码也可以看出，实例化一个<code>isolate</code>的过程包括，实例化<code>isolate</code>结构体、在堆中分配线程内存、配置<code>port</code>等过程。</p>
<p><code>isolate</code>看起来其实和进程比较相似，之前请教阿里架构师宗心问题时，宗心也说过“<code>isolate</code>的整体模型我自己的理解其实更像进程，而<code>async</code>、<code>await</code>更像是线程”。如果对比一下<code>isolate</code>和进程的定义，会发现确实<code>isolate</code>很像是进程。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>下面是一个<code>isolate</code>的例子，例子中新创建了一个<code>isolate</code>，并且绑定了一个方法进行网络请求和数据解析的处理，并通过<code>port</code>将处理好的数据返回给调用方。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">loadData() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// 通过spawn新建一个isolate，并绑定静态方法</span></span><br><span class="line">    ReceivePort receivePort =ReceivePort();</span><br><span class="line">    <span class="keyword">await</span> Isolate.spawn(dataLoader, receivePort.sendPort);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取新isolate的监听port</span></span><br><span class="line">    SendPort sendPort = <span class="keyword">await</span> receivePort.first;</span><br><span class="line">    <span class="comment">// 调用sendReceive自定义方法</span></span><br><span class="line">    <span class="built_in">List</span> dataList = <span class="keyword">await</span> sendReceive(sendPort, <span class="string">'https://jsonplaceholder.typicode.com/posts'</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'dataList <span class="subst">$dataList</span>'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// isolate的绑定方法</span></span><br><span class="line"><span class="keyword">static</span> dataLoader(SendPort sendPort) <span class="keyword">async</span>&#123;</span><br><span class="line">    <span class="comment">// 创建监听port，并将sendPort传给外界用来调用</span></span><br><span class="line">    ReceivePort receivePort =ReceivePort();</span><br><span class="line">    sendPort.send(receivePort.sendPort);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 监听外界调用</span></span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> msg <span class="keyword">in</span> receivePort) &#123;</span><br><span class="line">      <span class="built_in">String</span> requestURL =msg[<span class="number">0</span>];</span><br><span class="line">      SendPort callbackPort =msg[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">      Client client = Client();</span><br><span class="line">      Response response = <span class="keyword">await</span> client.<span class="keyword">get</span>(requestURL);</span><br><span class="line">      <span class="built_in">List</span> dataList = json.decode(response.body);</span><br><span class="line">      <span class="comment">// 回调返回值给调用者</span></span><br><span class="line">      callbackPort.send(dataList);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建自己的监听port，并且向新isolate发送消息</span></span><br><span class="line">Future sendReceive(SendPort sendPort, <span class="built_in">String</span> url) &#123;</span><br><span class="line">    ReceivePort receivePort =ReceivePort();</span><br><span class="line">    sendPort.send([url, receivePort.sendPort]);</span><br><span class="line">    <span class="comment">// 接收到返回值，返回给调用者</span></span><br><span class="line">    <span class="keyword">return</span> receivePort.first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>isolate</code>和iOS中的线程还不太一样，<code>isolate</code>的线程更偏底层。当生成一个<code>isolate</code>后，其内存是各自独立的，相互之间并不能进行访问。但<code>isolate</code>提供了基于<code>port</code>的消息机制，通过建立通信双方的<code>sendPort</code>和<code>receiveport</code>，进行相互的消息传递，在<code>Dart</code>中叫做消息传递。</p>
<p>从上面例子中可以看出，在进行<code>isolate</code>消息传递的过程中，本质上就是进行<code>port</code>的传递。将<code>port</code>传递给其他<code>isolate</code>，其他<code>isolate</code>通过<code>port</code>拿到<code>sendPort</code>，向调用方发送消息来进行相互的消息传递。</p>
<h3 id="Embedder"><a href="#Embedder" class="headerlink" title="Embedder"></a>Embedder</h3><p>正如其名，<code>Embedder</code>是一个嵌入层，将<code>Flutter</code>嵌入到各个平台上。<code>Embedder</code>负责范围包括原生平台插件、线程管理、事件循环等。</p>
<p><code>Embedder</code>中存在四个<code>Runner</code>，四个<code>Runner</code>分别如下。其中每个<code>Flutter Engine</code>各自对应一个<code>UI Runner</code>、<code>GPU Runner</code>、<code>IO Runner</code>，但所有<code>Engine</code>共享一个<code>Platform Runner</code>。</p>
<p><code>Runner</code>和<code>isolate</code>并不是一码事，彼此相互独立。以iOS平台为例，<code>Runner</code>的实现就是<code>CFRunLoop</code>，以一个事件循环的方式不断处理任务。并且<code>Runner</code>不只处理<code>Engine</code>的任务，还有<code>Native Plugin</code>带来的原生平台的任务。而<code>isolate</code>则由<code>Dart VM</code>进行管理，和原生平台线程并无关系。</p>
<h3 id="Platform-Runner"><a href="#Platform-Runner" class="headerlink" title="Platform Runner"></a>Platform Runner</h3><p><code>Platform Runner</code>和iOS平台的<code>Main Thread</code>非常相似，在<code>Flutter</code>中除耗时操作外，所有任务都应该放在<code>Platform</code>中，<code>Flutter</code>中的很多API并不是线程安全的，放在其他线程中可能会导致一些bug。</p>
<p>但例如IO之类的耗时操作，应该放在其他线程中完成，否则会影响<code>Platform</code>的正常执行，甚至于被<code>watchdog</code>干掉。但需要注意的是，由于<code>Embedder Runner</code>的机制，<code>Platform</code>被阻塞后并不会导致页面卡顿。</p>
<p>不只是<code>Flutter Engine</code>的代码在<code>Platform</code>中执行，<code>Native Plugin</code>的任务也会派发到<code>Platform</code>中执行。实际上，在原生侧的代码运行在<code>Platform Runner</code>中，而<code>Flutter</code>侧的代码运行在<code>Root Isolate</code>中，如果在<code>Platform</code>中执行耗时代码，则会卡原生平台的主线程。 </p>
<h3 id="UI-Runner"><a href="#UI-Runner" class="headerlink" title="UI Runner"></a>UI Runner</h3><p><code>UI Runner</code>负责为<code>Flutter Engine</code>执行<code>Root Isolate</code>的代码，除此之外，也处理来自<code>Native Plugin</code>的任务。<code>Root Isolate</code>为了处理自身事件，绑定了很多函数方法。程序启动时，<code>Flutter Engine</code>会为<code>Root</code>绑定<code>UI Runner</code>的处理函数，使<code>Root Isolate</code>具备提交渲染帧的能力。</p>
<p>当<code>Root Isolate</code>向<code>Engine</code>提交一次渲染帧时，<code>Engine</code>会等待下次vsync，当下次vsync到来时，由<code>Root Isolate</code>对<code>Widgets</code>进行布局操作，并生成页面的显示信息的描述，并将信息交给<code>Engine</code>去处理。</p>
<p>由于对<code>widgets</code>进行<code>layout</code>并生成<code>layer tree</code>是<code>UI Runner</code>进行的，如果在<code>UI Runner</code>中进行大量耗时处理，会影响页面的显示，所以应该将耗时操作交给其他<code>isolate</code>处理，例如来自<code>Native Plugin</code>的事件。</p>
<h3 id="GPU-Runner"><a href="#GPU-Runner" class="headerlink" title="GPU Runner"></a>GPU Runner</h3><p><code>GPU Runner</code>并不直接负责渲染操作，其负责GPU相关的管理和调度。当<code>layer tree</code>信息到来时，<code>GPU Runner</code>将其提交给指定的渲染平台，渲染平台是Skia配置的，不同平台可能有不同的实现。</p>
<p><code>GPU Runner</code>相对比较独立，除了<code>Embedder</code>外其他线程均不可向其提交渲染信息。</p>
<h3 id="IO-Runner"><a href="#IO-Runner" class="headerlink" title="IO Runner"></a>IO Runner</h3><p>一些<code>GPU Runner</code>中比较耗时的操作，就放在<code>IO Runner</code>中进行处理，例如图片读取、解压、渲染等操作。但是只有<code>GPU Runner</code>才能对GPU提交渲染信息，为了保证<code>IO Runner</code>也具备这个能力，所以<code>IO Runner</code>会引用<code>GPU Runner</code>的<code>context</code>，这样就具备向GPU提交渲染信息的能力</p>
<p><a href="https://www.jianshu.com/p/54da18ed1a9e" target="_blank" rel="noopener">本文地址</a></p>
<p><a href="https://www.jianshu.com/p/aaa6a8b1d6b0" target="_blank" rel="noopener">闲鱼讲解</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/19/flutter%E6%8E%A2%E7%B4%A2-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/19/flutter%E6%8E%A2%E7%B4%A2-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Flutter探索  - 状态管理分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-19 16:05:48" itemprop="dateCreated datePublished" datetime="2021-05-19T16:05:48+08:00">2021-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-20 09:57:51" itemprop="dateModified" datetime="2021-05-20T09:57:51+08:00">2021-05-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="状态管理是什么"><a href="#状态管理是什么" class="headerlink" title="状态管理是什么"></a>状态管理是什么</h3><p>我们知道最基本的程序是什么</p>
<ul>
<li><p>程序 = 算法 + 数据结构</p>
<p>数据是程序的中心。数据结构和算法两个概念间的逻辑关系贯穿整个程序世界，首先两者表现为不可分割的关系。flutter也是一个程序。由此得出</p>
</li>
<li><p>Flutter = 算法 + 数据结构</p>
<p>那状态管理是什么？我们也用公式表示一下：</p>
</li>
<li><p>Flutter状态管理 = 算法 + 数据结构 + UI绑定</p>
<p>来看一段代码例子：</p>
</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThemeBloc</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> _themeStreamController = StreamController&lt;AppTheme&gt;();</span><br><span class="line">  <span class="keyword">get</span> changeTheTheme =&gt; _themeStreamController.sink.add;</span><br><span class="line">  <span class="keyword">get</span> darkThemIsEnABLE =&gt; _themeStreamController.stream;</span><br><span class="line">  dispose()&#123;</span><br><span class="line">    _themStreamController.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> bloc = ThemeBloc();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppTheme</span> </span>&#123;</span><br><span class="line">  ThemeData themeData;</span><br><span class="line">  AppTheme(<span class="keyword">this</span>.themeData);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//绑定到UI</span></span><br><span class="line">StreamBulder&lt;AppTheme&gt;(</span><br><span class="line">	initialData:AppTheme.LIGHT_THEME,</span><br><span class="line">  stream:bloc.dartThemeIsEnabled,</span><br><span class="line">  builder:(contenxt,AsyncSnapshot&lt;AppTheme&gt; snapshot)&#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title:<span class="string">"Jason"</span>,</span><br><span class="line">      theme:snapshot.data.themeData,</span><br><span class="line">      home:PageHome(),</span><br><span class="line">      routes:&lt;<span class="built_in">String</span>,WidgetBuilder&gt;&#123;</span><br><span class="line">        <span class="string">"/pageChatGroup"</span>:(context) =&gt; PageChatGroup(),</span><br><span class="line">        <span class="string">"/laoYu"</span>:(context) =&gt; LaoYu(),</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>AppTheme 是数据结构</li>
<li>changeTheTheme 是算法</li>
<li>StreamBuilder 是绑定UI</li>
</ul>
<p>这样一整套代码的逻辑就是我们所说的Flutter状态管理。算法就是我们如何管理，数据结构是数据状态，状态管理的本质还是如何通过合理的算法管理数据，如何取，如何接收等，最终展示在UI上，通过UI的变更来提现状态的管理逻辑。</p>
<h3 id="为什么需要状态管理"><a href="#为什么需要状态管理" class="headerlink" title="为什么需要状态管理"></a>为什么需要状态管理</h3><p>状态管理可以实现组件通信、跨组件数据储存。原生的状态变更是通过具体的组件直接复制，如果页面全部变更，是不是需要每一个都设置一遍，而Flutter的变更就简单粗暴 ，setState搞定，它背后的逻辑是重新build整个页面，发现有变更，再将新的数据复制。其实原生开发与Flutter的本质的区别就是数据与视图完全分离，目前原生也出现了UI绑定框架。说明flutter的设计的先进性。这样设计的弊端是什么？</p>
<p>答案就是<code>页面如何刷新才是Flutter的关键</code>，原生也面临这个问题，页面的重绘导致丢帧问题，为了效果更好，我们很多时候都选择局部刷新，原生已经很明确的告诉UI要刷新什么更新什么，而对于Flutter来说，这一点恨不清晰，虽然Flutter也做了类似虚拟Dom优化重绘逻辑，但这远远不够，如何合理的更新UI才是最主要的，这个时候一大堆的状态管理就出来了，当然状态管理也不是仅仅为了解决更新问题。我们再思考一个问题，如果我有一个widget A，我想在另外一个widget B中改变widget A的一个状态，或者从网络、数据库取到数据，然后刷新它。</p>
<p>一个糟糕的写法是，A widget的 state为全局的，当B widget 需要刷新的时候 直接调用 AState对象的 <code>setState</code> 方法.</p>
<p>这样写有几个问题：</p>
<p>1、违背了封装的概念，其他所有类都可以拿到A的state对象。</p>
<p>2、A和B强耦合了。</p>
<p>3、每次都是重绘整个widget A 性能变差。</p>
<p>4、不利于测试。</p>
<p>如何变好了，这就需要我们选择一种合适的状态管理方式。</p>
<h4 id="状态管理的目标"><a href="#状态管理的目标" class="headerlink" title="状态管理的目标"></a>状态管理的目标</h4><p>其实我们做状态管理，不仅仅是因为它的特点，也是更好地架构。</p>
<ul>
<li>代码层次分明，易维护，易阅读。</li>
<li>可扩展，可以动态替换UI而不影响算法逻辑。</li>
<li>安全可靠，保持数据的稳定伸缩</li>
<li>性能佳，局部刷新。</li>
</ul>
<p>这不仅仅是状态管理的目的，也是我们做一款优秀应用的基础架构。</p>
<h3 id="状态管理的基本分类"><a href="#状态管理的基本分类" class="headerlink" title="状态管理的基本分类"></a>状态管理的基本分类</h3><ul>
<li>局部管理 官方也称Ephemeral State，意思是短暂的状态，这种状态根本不需要做全局处理，StatefulWidget处理即可完成。</li>
<li>全局管理 官方称App state ，即应用状态，非短暂状态，你要在应用程序的许多部分之间共享，以及希望在用户会话之间保持的状态，就是我们所说的应用程序状态（也称共享状态）。例如：<ul>
<li>用户偏好</li>
<li>登录信息</li>
<li>购物车</li>
<li>新闻阅读状态</li>
</ul>
</li>
</ul>
<p>总之，任何Flutter应用程序中都有两种概念性的状态类型。临时状态可以使用State和setState来事项，并且通常是单个窗口小部件的本地状态。剩下的就是应用的状态。两种类型在任何Flutter应用程序中都有自己的位置，两者之间的划分取决于你自己的喜好和应用程序的复杂性。没有最好的管理方式，只有最合适的管理方式。</p>
<h3 id="底层逻辑"><a href="#底层逻辑" class="headerlink" title="底层逻辑"></a>底层逻辑</h3><p>底层逻辑主要讲，Flutter中目前有哪些可以做到状态管理，有什么缺点，适合做什么不适合做什么，完全明白底层逻辑才不会畏惧复杂的逻辑，即使逻辑复杂也能选择合理的方式去管理状态。</p>
<ul>
<li><p>State</p>
<p>StatefulWidget、SteamBuilder状态管理方式。</p>
</li>
<li><p>InheritedWidget</p>
<p>专门负责Widget树种数据共享的功能型Widget，如Provider、scoped_model就是基于它开发</p>
</li>
<li><p>Notification</p>
<p>与InheritedWidget正好相反，InheritedWidget是从上往下传递数据，Notification是从下往上，但两者都是在自己的Widget树种传递，无法跨越树传递。</p>
</li>
<li><p>Stream</p>
<p>数据流 如Bloc、flutter_redux、fish_redux等也都基于它来做实现。</p>
</li>
</ul>
<p>下面一一分析</p>
<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>State是我们常用而且使用最频繁的一个状态管理类，它必须结合StatefulWidget一起使用，StreamBuilder继承自StatefulWidget，同样使用setState来管理状态。</p>
<p>为什么用State管理状态，而不是Widget本身。Flutter设计时让Widget本身是不变的，类似固定的配置信息，那么就需要一个角色来控制它，State就出现了，但State的任何更改都会强制整个Widget重新构建，当然也可以覆盖必要的方法自己控制逻辑。</p>
<p>注意：setState是整个Widget重新构建（子Widget也会销毁重建），这个点也是为什么不推荐大量使用StatefulWidget的原因。如果页面足够复杂，就会导致严重的性能损耗。建议使用StreamBuilder，它原理上是State，但它做到了子Widget的局部刷新，不会导致整个页面的重建。</p>
<h4 id="State的缺点"><a href="#State的缺点" class="headerlink" title="State的缺点"></a>State的缺点</h4><ul>
<li>无法做到夸组件共享数据（这个夸是无关联的，如果是直接的父子关系，不算是跨组件）。一般我们将State的子类设置为私有，所以无法做到让别的组件调用State的setState函数来刷新。</li>
<li>setState会成为维护的难点，因为到处都有。随着页面状态的增多，可能调用的setState的地方会越来越多，不能统一管理。</li>
<li>处理数据逻辑和视图混合在一起，违反代码设计原则。比如网络的数据取出来setState的UI上，这样编写代码，导致状态和UI耦合在一起，不利于测试和复用。</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>反过来讲，State简单高效，当复杂到需要更好地管理的时候再重构，一个基本原则就是，状态是否需要跨组件使用，如果需要那就用别的方法管理状态而不是State管理。</p>
<h3 id="InheritedWidget"><a href="#InheritedWidget" class="headerlink" title="InheritedWidget"></a>InheritedWidget</h3><p>InheritedWidget是一个无私的Widget，它可以把自己的状态数据，无私交给所有的子Widget，所有的子Widget可以无条件的继承它的状态。它的数据是只读的，子widget不能修改。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>缺点：</p>
<ul>
<li>容易造成不必要的刷新。</li>
<li>不支持跨页面（router）的状态，不是同一个树的状态无法获取。</li>
<li>数据不可变，必须结合StatefulWidget、ChangeNotifier或者Steam使用。</li>
</ul>
<p>比较适合在一个属性Widget中，抽象出公有状态，每一个子Widget或者孙Widget都可以获取该状态，我们可以通过手段控制rebuild的粒度来优化重绘逻辑，但它更适合从上往下传递，如果从下往上传递，如何做，下面解答。</p>
<h3 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h3><p>它是flutter中跨层数据共享的一种机制，它不是widget，它提供了dispatch方法，来让我们沿着context对应的Element节点向上逐层发送通知。</p>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p>缺点</p>
<ul>
<li>不支持跨页面的状态，准确的说不支持NotificationListener同级或者父级Widget的状态通知</li>
<li>本身不支持刷新UI,需要结合State使用</li>
<li>如果结合State，会导致整个UI的重绘，效率低下不科学。</li>
</ul>
<p>使用起来简单，如果页面复杂度高不推荐。</p>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p>Stream其实是一个生产者消费者模型，一端负责生产，一端负责消费，而且是纯Dart的实现，跟Flutter没什么关系，扯上关系的就是StreamBuilder来构建一个Stream通道的Widget，像知名的rxdart、Bloc、flutter_redux全都用到了Stream的api。所以学习它才是我们掌握状态管理的关键。</p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>缺点</p>
<ul>
<li>api生涩，不好理解。</li>
<li>需要定制化，才能满足更复杂的场景。</li>
<li>没有自动dispose逻辑。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上所有的状态更新都离不开State的支持。</p>
<h3 id="状态管理的使用原则"><a href="#状态管理的使用原则" class="headerlink" title="状态管理的使用原则"></a>状态管理的使用原则</h3><h4 id="局部管理优于全局"><a href="#局部管理优于全局" class="headerlink" title="局部管理优于全局"></a>局部管理优于全局</h4><p>这个原则来源于，Flutter的性能优化，局部刷新肯定比全局刷新要好很多，那么我们在管理状态的同时，也要考虑该状态到底是局部还是全局，从而编写正确的逻辑。</p>
<h4 id="保持数据安全性"><a href="#保持数据安全性" class="headerlink" title="保持数据安全性"></a>保持数据安全性</h4><p>用<code>_</code>私有化状态，因为当开发人员众多，当别人看到你的变量的时候，第一反应可能不是找你提供的方法，而是直接对变量操作，那就有可能出现想不到的后果，如果他只能调用你提供的方法，那他就要遵循你方法的逻辑，避免数据被处理错误。</p>
<h4 id="考虑页面重新build带来的影响"><a href="#考虑页面重新build带来的影响" class="headerlink" title="考虑页面重新build带来的影响"></a>考虑页面重新build带来的影响</h4><p>很多时候页面的重建都会调用build函数，也就是说，在一个生命周期内，build函数是多次被调用的，所以你就要考虑数据的初始化或者刷新怎么样才能合理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/19/iOS%E6%8E%A2%E7%B4%A2-Block/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/19/iOS%E6%8E%A2%E7%B4%A2-Block/" class="post-title-link" itemprop="url">iOS探索 - Block</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-19 11:06:45" itemprop="dateCreated datePublished" datetime="2021-05-19T11:06:45+08:00">2021-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-11 00:31:12" itemprop="dateModified" datetime="2021-07-11T00:31:12+08:00">2021-07-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在Objective-C中，block是一个很常见的东西，说白了就是个匿名函数，网上有很多关于block如何使用的文章，讲的都非常精彩，这里主要探讨下block的实现原理。</p>
<h3 id="先看一个例子"><a href="#先看一个例子" class="headerlink" title="先看一个例子"></a>先看一个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">void blockFunc1() &#123;</span><br><span class="line">    int num &#x3D; 100;</span><br><span class="line">    void (^block)(void) &#x3D; ^() &#123;</span><br><span class="line">        NSLog(@&quot;num &#x3D; %d\n&quot;, num);</span><br><span class="line">    &#125;;</span><br><span class="line">    num &#x3D; 200;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void blockFunc2() &#123;</span><br><span class="line">    __block int num &#x3D; 100;</span><br><span class="line">    void (^block)(void) &#x3D; ^() &#123;</span><br><span class="line">        NSLog(@&quot;num &#x3D; %d\n&quot;, num);</span><br><span class="line">    &#125;;</span><br><span class="line">    num &#x3D; 200;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int num &#x3D; 100;</span><br><span class="line">void blockFunc3() &#123;</span><br><span class="line">    void (^block)(void) &#x3D; ^() &#123;</span><br><span class="line">        NSLog(@&quot;num &#x3D; %d\n&quot;, num);</span><br><span class="line">    &#125;;</span><br><span class="line">    num &#x3D; 200;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void blockFunc4()</span><br><span class="line">&#123;</span><br><span class="line">    static int num &#x3D; 100;</span><br><span class="line">    void (^block)(void) &#x3D; ^&#123;</span><br><span class="line">        NSLog(@&quot;num &#x3D; %d&quot;, num);</span><br><span class="line">    &#125;;</span><br><span class="line">    num &#x3D; 200;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        ^&#123; printf(&quot;Hello, World!\n&quot;); &#125; ();</span><br><span class="line">        blockFunc1();</span><br><span class="line">        blockFunc2();</span><br><span class="line">        blockFunc3();</span><br><span class="line">        blockFunc4();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-19</span> <span class="number">11</span>:<span class="number">25</span>:<span class="number">19.532572</span>+<span class="number">0800</span> OCDemo[<span class="number">60496</span>:<span class="number">2272335</span>] num = <span class="number">100</span></span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-19</span> <span class="number">11</span>:<span class="number">25</span>:<span class="number">19.534041</span>+<span class="number">0800</span> OCDemo[<span class="number">60496</span>:<span class="number">2272335</span>] num = <span class="number">200</span></span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-19</span> <span class="number">11</span>:<span class="number">25</span>:<span class="number">19.534166</span>+<span class="number">0800</span> OCDemo[<span class="number">60496</span>:<span class="number">2272335</span>] num = <span class="number">200</span></span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-19</span> <span class="number">11</span>:<span class="number">25</span>:<span class="number">19.534292</span>+<span class="number">0800</span> OCDemo[<span class="number">60496</span>:<span class="number">2272335</span>] num = <span class="number">200</span></span><br></pre></td></tr></table></figure>

<p>我们先简单解释一下：</p>
<p>1、”Hello, World!”应该很简单，执行block直接打印。</p>
<p>2、<code>blockFunc1</code>里面,<code>num</code>是以值传递的方式被block获取，所以尽管后面更改了<code>num</code>的值，但是在block里面还是保持保持原来的值。</p>
<p>3、<code>blockFunc2</code>里面，num由<code>__block</code>修饰，<code>num</code>在block变成了外部的一个引用（后面会通过源码解释），所以在block外部改变<code>num</code>的值时，block里面的<code>num</code>也随着改变。</p>
<p>4、<code>blockFunc3</code>里面，block引用的是一个全局的num，所以，num改变的时候也会改变block内部num的值。</p>
<p>5、<code>blockFunc3</code>里面，block引用的是一个static的num，所以，num改变也会改变block内部的num的值。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>也许大家看到上面的解释还是不知道为啥会这样，所以接下，我通过源码来分析下其中的缘由，我们先把这段先转换成c++文件，cd到main.m所在的目录，并执行这条命令<code>clang -rewrite-objc main.m</code>，</p>
<p>如果上面的命令报错<code>&#39;UIKit/UIKit.h&#39; file not found</code>,可以使用下面命令</p>
<p><code>clang -x objective-c -rewrite-objc -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk main.m</code></p>
<p>通过这条命令可以把main.m文件转换成cpp文件，里面可以看到block的结构。我们打开这份文件，这个文件比较长，直接拉到最后。可以看到在文件的最后是main函数的入口，代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA)) ();</span><br><span class="line">        blockFunc1();</span><br><span class="line">        blockFunc2();</span><br><span class="line"></span><br><span class="line">        blockFunc3();</span><br><span class="line">        blockFunc4();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看第一行代码，构造了一个<strong>main_block_impl_0对象，</strong>main_block_impl_0是一个结构体。相关代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从代码可知，最后block会转化成一个__block_impl对象，而block执行的代码会转化成一个静态函数，__block_impl里面的FuncPtr会指向这个静态函数。在这里<code>printf(&quot;Hello, World!\n&quot;);</code>这个block转换后的静态函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以整个过程是这样的：<br>1、先构造一个<code>__main_block_impl_0</code>对象，构造的时候把<code>__main_block_func_0</code>传进去，当然还有别的参数，这里先不考虑。</p>
<p>2、在<code>__main_block_impl_0</code>的构造方法中，再把<code>__main_block_func_0</code>赋给<code>__block_impl</code>的FuncPtr。</p>
<p>3、调用FuncPtr。</p>
<p>所以，从上面可以看出，block实际上是转化为了一个<code>__block_impl</code>对象，这个对象有isa指针，用来表示block的类型，上面的block的isa指向&amp;_NSConcreteStackBlock。同时block对象还有一个FuncPtr指针，用来指向block执行的方法（转换后的静态函数）。</p>
<p>再来看看blockFunc1相关的内容</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc1_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc1_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  __blockFunc1_block_impl_0(<span class="keyword">void</span> *fp, struct __blockFunc1_block_desc_0 *desc, <span class="keyword">int</span> _num, <span class="keyword">int</span> flags=<span class="number">0</span>) : num(_num) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __blockFunc1_block_func_0(struct __blockFunc1_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> num = __cself-&gt;num; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders__s_l_p47fxn36j8d2_n75spyb7c0000gn_T_main_324f63_mi_0, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc1_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __blockFunc1_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __blockFunc1_block_impl_0)&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blockFunc1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">void</span> (*block)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__blockFunc1_block_impl_0((<span class="keyword">void</span> *)__blockFunc1_block_func_0, &amp;__blockFunc1_block_desc_0_DATA, num));</span><br><span class="line">    num = <span class="number">200</span>;</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个函数里面，构造block的时候把num传了进去，而且是普通值传递，这样的话其实是拷贝了一份num。然后在执行block方法的时候，使用的是拷贝的那份num，从<code>int num = __cself-&gt;num; // bound by copy</code>可以看出。这个block也是_NSConcreteStackBlock类型的。</p>
<p>再来看看__block修饰过的num在block里面是怎么传递的，我们看看blockFunc2相关的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_num_0</span> &#123;</span></span><br><span class="line"> <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_num_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc2_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc2_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __Block_byref_num_0 *num; <span class="comment">// by ref</span></span><br><span class="line">  __blockFunc2_block_impl_0(<span class="keyword">void</span> *fp, struct __blockFunc2_block_desc_0 *desc, __Block_byref_num_0 *_num, <span class="keyword">int</span> flags=<span class="number">0</span>) : num(_num-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __blockFunc2_block_func_0(struct __blockFunc2_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_num_0 *num = __cself-&gt;num; <span class="comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders__s_l_p47fxn36j8d2_n75spyb7c0000gn_T_main_324f63_mi_1, (num-&gt;__forwarding-&gt;num));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __blockFunc2_block_copy_0(struct __blockFunc2_block_impl_0*dst, struct __blockFunc2_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;num, (<span class="keyword">void</span>*)src-&gt;num, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __blockFunc2_block_dispose_0(struct __blockFunc2_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;num, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc2_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*copy)(struct __blockFunc2_block_impl_0*, struct __blockFunc2_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(struct __blockFunc2_block_impl_0*);</span><br><span class="line">&#125; __blockFunc2_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __blockFunc2_block_impl_0), __blockFunc2_block_copy_0, __blockFunc2_block_dispose_0&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blockFunc2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_num_0 num = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_num_0 *)&amp;num, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_num_0), <span class="number">100</span>&#125;;</span><br><span class="line">    <span class="keyword">void</span> (*block)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__blockFunc2_block_impl_0((<span class="keyword">void</span> *)__blockFunc2_block_func_0, &amp;__blockFunc2_block_desc_0_DATA, (__Block_byref_num_0 *)&amp;num, <span class="number">570425344</span>));</span><br><span class="line">    (num.__forwarding-&gt;num) = <span class="number">200</span>;</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看到，__block修饰的num在内部被包装成一个__Block_byref_num_0的对象，假设叫a，原来num的值100存储在对象a的num字段中，同时这个对象a有一个<strong>forwarding字段，指向a本身。当改变num的值的时候（源代码是<code>num = 200;</code>），这段代码变为`(num.</strong>forwarding-&gt;num) = 200;<code>，也就是说把对象a里面的num字段的值变为了200。同时，在block的执行函数__blockFunc2_block_func_0中，打印出来的取值是从</code><strong>Block_byref_num_0 *num = __cself-&gt;num;`取出，也就是取得是改变后的值，所以打印结果是200。这就是为什么用</strong>block修饰的变量可以在block内部被修改。</p>
<p>那当num为全局变量的时候，block又是怎样的呢？请看代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc3_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc3_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __blockFunc3_block_impl_0(<span class="keyword">void</span> *fp, struct __blockFunc3_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __blockFunc3_block_func_0(struct __blockFunc3_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders__s_l_p47fxn36j8d2_n75spyb7c0000gn_T_main_324f63_mi_2, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc3_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __blockFunc3_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __blockFunc3_block_impl_0)&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blockFunc3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (*block)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__blockFunc3_block_impl_0((<span class="keyword">void</span> *)__blockFunc3_block_func_0, &amp;__blockFunc3_block_desc_0_DATA));</span><br><span class="line">    num = <span class="number">200</span>;</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码里可以看出，这种情况很简单，block对象根本没有num字段，也就是打印的时候直接取得全局的num。</p>
<p>最后一种情况也很简单，当num时static的时候，构造block对象的时候直接用引用传值的方式把num放到block对象中。所以，当外部改变num的值的时候，也能反映到block内部。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc4_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc4_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> *num;</span><br><span class="line">  __blockFunc4_block_impl_0(<span class="keyword">void</span> *fp, struct __blockFunc4_block_desc_0 *desc, <span class="keyword">int</span> *_num, <span class="keyword">int</span> flags=<span class="number">0</span>) : num(_num) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __blockFunc4_block_func_0(struct __blockFunc4_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> *num = __cself-&gt;num; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders__s_l_p47fxn36j8d2_n75spyb7c0000gn_T_main_324f63_mi_3, (*num));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc4_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __blockFunc4_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __blockFunc4_block_impl_0)&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blockFunc4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">void</span> (*block)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__blockFunc4_block_impl_0((<span class="keyword">void</span> *)__blockFunc4_block_func_0, &amp;__blockFunc4_block_desc_0_DATA, &amp;num));</span><br><span class="line">    num = <span class="number">200</span>;</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章主要从源码的角度讲述了block的实现机制，并针对四种情况分析了block是如何引用外部变量的，分别是:<br>1、当引用局部变量的时候，如果没有__block修饰，那么在block内部获取的是外部变量的一份拷贝，改变外部变量不影响block内部的那份拷贝。</p>
<p>2、当引用局部变量的时候，同时局部变量用__block修饰，那么在block内部使用的实际上是外部变量的一个引用，所以改变外部变量会影响block内部变量的值。</p>
<p>3、当引用全局变量的时候，block并不持有这个变量。</p>
<p>4、当引用static变量的时候，block会以引用的方式持有这个变量。当在外部修改这个变量的时候，会影响block内部持有的这个变量的值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/18/iOS-Runloop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/18/iOS-Runloop/" class="post-title-link" itemprop="url">iOS  - Runloop</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-18 15:33:42" itemprop="dateCreated datePublished" datetime="2021-05-18T15:33:42+08:00">2021-05-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/17/iOS-%E5%BA%95%E5%B1%82-%E7%B1%BB%E6%8B%93%E5%B1%95%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/17/iOS-%E5%BA%95%E5%B1%82-%E7%B1%BB%E6%8B%93%E5%B1%95%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">iOS 底层 - 类拓展和关联对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-17 13:39:24 / 修改时间：14:02:24" itemprop="dateCreated datePublished" datetime="2021-05-17T13:39:24+08:00">2021-05-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/17/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E5%88%86%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/17/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E5%88%86%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/" class="post-title-link" itemprop="url">iOS 底层探索 - 分类的加载</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-17 11:20:09 / 修改时间：13:38:57" itemprop="dateCreated datePublished" datetime="2021-05-17T11:20:09+08:00">2021-05-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="初探懒加载类"><a href="#初探懒加载类" class="headerlink" title="初探懒加载类"></a>初探懒加载类</h3><p>上一章我们探索了 <code>iOS</code> 中类的加载，让我们简单回顾一下大概的流程。</p>
<h4 id="类的加载回顾"><a href="#类的加载回顾" class="headerlink" title="类的加载回顾"></a>类的加载回顾</h4><ul>
<li><code>libObjc</code> 向 <code>dyld</code> 注册了回调 <code>_dyld_objc_notify_register</code>，当 <code>dyld</code> 把 <code>App</code> 以及 <code>App</code> 所依赖的一系列 <code>Mach-O</code> 镜像加载到当前 <code>App</code> 被分配的内存空间之后，<code>dyld</code> 会通过 <code>_dyld_objc_notify_mapped</code> 也就是 <code>map_images</code> 来通知 <code>libObjc</code> 来完成具体的加载工作，<code>map_images</code> 被调用之后会来到 <code>_read_images</code></li>
<li><code>_read_images</code><ul>
<li>主要会进行类的加载工作，会插入 <strong>所有的类</strong> 到 <code>gdb_objc_realized_classes</code> 哈希表中（插入方式为 类名为 <code>key</code>，类对象为<code>value</code>, 不包括通过 <em>共享缓存</em> 里面的类），同时还会把类插入到 <code>allocatedClasses</code> 这个集合里面，注意，<code>allocatedClasses</code> 的类型为 <code>NXHashTable</code>，可以类比为 <code>NSSet</code>，而 <code>gdb_objc_realized_classes</code> 的类型为 <code>NXMapTable</code>，可以类比为 <code>NSDictionary</code></li>
<li>对所有的类进行重映射</li>
<li>将所有的 <code>SEL</code> 插入到 <code>namedSelectors</code> 哈希表中(插入方式为：<code>SEL</code> 名称为 <code>key</code>，<code>SEL</code> 为<code>value</code>)</li>
<li>修复函数指针遗留</li>
<li>将所有的 <code>Protocol</code> 插入到 <code>readProtocol</code> 哈希表中(插入方式为：<code>Protocol</code> 名称为 <code>key</code>，<code>Protocol</code> 为 <code>value</code>)</li>
<li>对所有的 <code>Protocol</code> 做重映射</li>
<li>初始化所有的<strong>非懒加载类</strong>，包括 <code>rw</code> 和 <code>ro</code> 的初始化操作</li>
<li>处理所有的分类(包括类的分类和元类的分类)</li>
</ul>
</li>
</ul>
<h4 id="懒加载类的发现"><a href="#懒加载类的发现" class="headerlink" title="懒加载类的发现"></a>懒加载类的发现</h4><p>我们这个时候观察 <code>_read_images</code> 源码这部分的注释:</p>
<blockquote>
<p>Realize non-lazy classes (for +load methods and static instances)</p>
<p>实现<strong>非懒加载</strong>类(实现了 <code>+load</code> 方法和静态实例)</p>
</blockquote>
<p>什么意思呢，我们这里其实打印的都是所谓的<strong>非懒加载类</strong>，这里除了我们自己实现了 <code>+load</code> 方法的两个类之外，其他的内容都是系统内置的类，包括我们十分熟悉的 <code>NSObject</code> 类。通过这里其实反过来推论，我们没有实现 <code>+load</code> 方法就是所谓的懒加载类，这种类并不会在 <code>_read_images</code>环节被加载，那么应该是在哪里加载呢？我们稍微思考一下，我们一般第一次操作一个类是不是在初始化这个类的时候，而初始化类不就是发送<code>alloc</code>消息吗，而根据我们前面探索消息查找的知识，在第一次发送某个消息的时候，是没有缓存的，所以会来到一个非常重要的方法叫<code>lookUpImpOrForward</code>，我们在<code>main.m</code>中<code>LGPerson</code>类初始化的地方和<code>lookUpImpOrForward</code> 入口处打上断点:</p>
<p>Tips: 这里有个小技巧，我们先打开 <code>main.m</code> 文件中的断点，等断点来到了我们想要探索的 <code>LGPerson</code> 初始化的位置的时候，我们再打开 <code>lookUpImpOrForward</code> 处的断点，这样才能确保当前执行 <code>lookUpImpOrForward</code> 的是我们的研究对象 <code>LGPerson</code></p>
<p>因为我们断点的位置是 <code>LGPerson</code> 类发送 <code>alloc</code> 消息，而显然 <code>alloc</code> 作为类方法是存储在元类上的，也就是说 <code>lookUpImpOrForward</code> 的 <code>cls</code> 其实是 <code>LGPerson</code> 元类。那么 <code>inst</code> 就应该是真正的对象.</p>
<p>我们总结一下，如果类没有实现 <code>load</code> 方法，那么这个类就是<strong>懒加载类</strong>，反之、这个类如果实现了 <code>load</code> 方法，那么这个类就是<strong>非懒加载类</strong>。</p>
<h4 id="懒加载类的流程"><a href="#懒加载类的流程" class="headerlink" title="懒加载类的流程"></a>懒加载类的流程</h4><p>关于<strong>非懒加载类</strong>的加载流程我们已经很熟悉了，我们总结下<strong>懒加载类</strong>的流程：</p>
<ul>
<li>类第一次发送消息的时候是没有缓存的，所以会来到 <code>_class_lookupMethodAndLoadCache3</code> ，关于这个方法我们在前面的消息查找章节已经介绍过了，不熟悉的同学可以去查阅一下。</li>
<li><code>_class_lookupMethodAndLoadCache3</code> 会调用 <code>lookUpImpOrForward</code> ，这个方法的重要性在我们学习 <code>Runtime</code> 的过程中不言而喻</li>
<li><code>lookUpImpOrForward</code> 内部会进行一下判断，如果 <code>cls</code> 没有被实现，会调用 <code>realizeClassMaybeSwiftAndLeaveLocked</code> 方法</li>
<li><code>realizeClassMaybeSwiftAndLeaveLocked</code> 方法又会调用 <code>realizeClassMaybeSwiftMaybeRelock</code> 方法</li>
<li><code>realizeClassMaybeSwiftMaybeRelock</code> 方法内部会进行一下是否是 <code>Swift</code> 的判断，如果不是 <code>Swift</code> 环境的话，就会来到 <code>realizeClassWithoutSwift</code> ，也就是最终的类的加载的地方</li>
</ul>
<h3 id="分类的底层实现"><a href="#分类的底层实现" class="headerlink" title="分类的底层实现"></a>分类的底层实现</h3><p>分类作为 <code>Objective-C</code> 中常见的特性，相信大家都不会陌生，不过在底层它是怎么实现的呢？</p>
<h4 id="分类的定义"><a href="#分类的定义" class="headerlink" title="分类的定义"></a>分类的定义</h4><p>我们根据 <code>_category_t</code> 来到 <code>libObjc</code> 源码中进行查找，不过我们需要去掉一下 <code>_category_t</code> 的下划线，然后不难找到分类真正的定义所在：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">classref_t</span> cls;</span><br><span class="line">    WrappedPtr&lt;<span class="keyword">method_list_t</span>, PtrauthStrip&gt; instanceMethods;</span><br><span class="line">    WrappedPtr&lt;<span class="keyword">method_list_t</span>, PtrauthStrip&gt; classMethods;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span></span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *_<span class="title">classProperties</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">method_list_t</span> *<span class="title">methodsForMeta</span><span class="params">(<span class="keyword">bool</span> isMeta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">property_list_t</span> *<span class="title">propertiesForMeta</span><span class="params">(<span class="keyword">bool</span> isMeta, struct header_info *hi)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protocol_list_t</span> *<span class="title">protocolsForMeta</span><span class="params">(<span class="keyword">bool</span> isMeta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> protocols;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据刚才 <code>clang</code> 重写之后的内容，我们不难看出</p>
<ul>
<li><p><code>name</code> : 是分类所关联的类，也就是类的名字，而不是分类的名字</p>
</li>
<li><p><code>cls</code> : 我们在前面可以看到 <code>clang</code> 重写后这个值为 0，但是后面有注释为 <code>&amp;OBJC_CLASS_$_LGTeacher</code> ，也就是我们的类对象的定义，所以这里其实就是我们要扩展的类对象，只是在编译期这个值并不存在</p>
</li>
<li><p><code>instanceMethods</code> : 分类上存储的实例方法</p>
</li>
<li><p><code>classMethods</code> ：分类上存储的类方法</p>
</li>
<li><p><code>protocols</code> ：分类所实现的协议</p>
</li>
<li><p><code>instanceProperties</code> ：分类所定义的实例属性，不过我们一般在分类中添加属性都是通过关联对象来实现的</p>
</li>
<li><p><code>_classProperties</code>：分类所定义的类属性。这里有一行注释：</p>
<blockquote>
<p>Fields below this point are not always present on disk.<br>下面的内容并不是一直在磁盘上保存</p>
</blockquote>
</li>
</ul>
<p>也就是说 <code>_classProperties</code> 其实是一个私有属性，但并不是一直都存在的。</p>
<h3 id="分类的加载"><a href="#分类的加载" class="headerlink" title="分类的加载"></a>分类的加载</h3><p>我们现在知道了类分为了 <code>懒加载类</code> 和 <code>非懒加载类</code> ，它们的加载时机是不一样的，那么分类的加载又是怎么样的呢？我们还是同样的先分析没有实现 <code>load</code> 方法的分类的情况:</p>
<p>但是我们在分析前，还要搞清楚一点，分类必须依附于类而存在，如果只有分类，没有类，那么从逻辑上是说不通的，就算实现了，编译器也会忽略掉。而关于类是懒加载还是非懒加载的，所以这里我们还要再细分一次。</p>
<ul>
<li>懒加载分类与懒加载类</li>
<li>懒加载分类和非懒加载类</li>
</ul>
<h4 id="没有实现-load-的分类"><a href="#没有实现-load-的分类" class="headerlink" title="没有实现 load 的分类"></a>没有实现 load 的分类</h4><h5 id="与懒加载类配合加载"><a href="#与懒加载类配合加载" class="headerlink" title="与懒加载类配合加载"></a>与懒加载类配合加载</h5><p>我们先分析第一种情况，也就是类和分类都不实现 <code>load</code> 方法的情况。<br>首先，懒加载类的流程上面我们已经探索过了，在向类<strong>第一次发送消息</strong>的时候，懒加载类才会开始加载，而根据我们上一章类的加载探索内容，在 <code>realizeClassWithoutSwift</code> 方法的最后有一个 <code>methodizeClass</code> 方法，在这个方法里面会有一个 <code>Attach categories</code> 的地方：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Attach categories.</span></span><br><span class="line"><span class="keyword">if</span> (previously) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isMeta) &#123;</span><br><span class="line">        objc::unattachedCategories.attachToClass(cls, previously,</span><br><span class="line">                                                 ATTACH_METACLASS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// When a class relocates, categories with class methods</span></span><br><span class="line">        <span class="comment">// may be registered on the class itself rather than on</span></span><br><span class="line">        <span class="comment">// the metaclass. Tell attachToClass to look for those.</span></span><br><span class="line">        objc::unattachedCategories.attachToClass(cls, previously,</span><br><span class="line">                                                 ATTACH_CLASS_AND_METACLASS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">objc::unattachedCategories.attachToClass(cls, cls,</span><br><span class="line">                                         isMeta ? ATTACH_METACLASS : ATTACH_CLASS);</span><br></pre></td></tr></table></figure>

<p>我们进入<code>unattachedCategories</code>的<code>attachToClass</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachToClass</span><span class="params">(Class cls, Class previously, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    ASSERT((flags &amp; ATTACH_CLASS) ||</span><br><span class="line">           (flags &amp; ATTACH_METACLASS) ||</span><br><span class="line">           (flags &amp; ATTACH_CLASS_AND_METACLASS));</span><br><span class="line">    <span class="keyword">auto</span> &amp;<span class="built_in">map</span> = <span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">map</span>.<span class="built_in">find</span>(previously);</span><br><span class="line">    <span class="keyword">if</span> (it != <span class="built_in">map</span>.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        category_list &amp;<span class="built_in">list</span> = it-&gt;second;</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; ATTACH_CLASS_AND_METACLASS) &#123;</span><br><span class="line">            <span class="keyword">int</span> otherFlags = flags &amp; ~ATTACH_CLASS_AND_METACLASS;</span><br><span class="line">            attachCategories(cls, <span class="built_in">list</span>.<span class="built_in">array</span>(), <span class="built_in">list</span>.count(), otherFlags | ATTACH_CLASS);</span><br><span class="line">            attachCategories(cls-&gt;ISA(), <span class="built_in">list</span>.<span class="built_in">array</span>(), <span class="built_in">list</span>.count(), otherFlags | ATTACH_METACLASS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            attachCategories(cls, <span class="built_in">list</span>.<span class="built_in">array</span>(), <span class="built_in">list</span>.count(), flags);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>.erase(it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们断点之后发现这个时候通过 <code>unattachedCategoriesForClass</code> 方法并没有取到分类，我们此时不妨通过 <code>LLDB</code> 打印一下当前类里面是否已经把分类的内容附加上了。<br>前面的流程大家都很熟悉了，我们直接看 <code>cls</code> 的 <code>rw</code> 中的 <code>methods</code> 是否有内容：</p>
<p>这样进一步证明了，如果是懒加载类，并且分类也是懒加载，那么分类的加载并不会来到 <code>unattachedCategoriesForClass</code> ，而是直接在编译时加载到了类的 <code>ro</code> 里面，然后在运行时被拷贝到了类的 <code>rw</code> 里面。这一点可以通过下面的 <code>LLDB</code> 打印来证明。</p>
<h5 id="与非懒加载类配合加载"><a href="#与非懒加载类配合加载" class="headerlink" title="与非懒加载类配合加载"></a>与非懒加载类配合加载</h5><p>同样的道理，当类为非懒加载类的时候，走的是 <code>_read_images</code> 里面的流程，这个时候我们的懒加载分类是在哪加载的呢？</p>
<p>分类还是不在这，同时通过 <code>LLDB</code> 打印，发现分类的方法已经在类的 <code>ro</code> 里面了，所以说分类的加载其实跟类的懒加载与否并没有关系，也就是说懒加载的分类都是在编译时期被加载的。</p>
<h4 id="实现了-load-的分类"><a href="#实现了-load-的分类" class="headerlink" title="实现了 load 的分类"></a>实现了 load 的分类</h4><p>我们再接着分下下面两种情况：</p>
<ul>
<li>非懒加载分类与懒加载类</li>
<li>非懒加载分类和非懒加载类</li>
</ul>
<h5 id="与懒加载类配合加载-1"><a href="#与懒加载类配合加载-1" class="headerlink" title="与懒加载类配合加载"></a>与懒加载类配合加载</h5><p>其实懒加载和非懒加载的最大区别就是加载是否提前，而实现了 <code>+load</code> 方法的分类，面对的是懒加载的类，<br>而懒加载的类我们前面已经知道了，是在第一次发送消息的时候才会被加载的，那我们直接在<br><code>lookupImpOrForward</code> =&gt; <code>realizeClassMaybeSwiftAndLeaveLocked</code> =&gt; <code>realizeClassMaybeSwiftMaybeRelock</code> =&gt; <code>realizeClassWithoutSwift</code> =&gt; <code>methodizeClass</code> 流程中的 <code>methodizeClass</code> 打上断点，看下在这里分类会不会被加载：</p>
<p>这一次通过 <code>unattachedCategoriesForClass</code> 取出来值了，并且在这之前 <code>cls</code> 的 <code>ro</code> 中并没有分类的 <code>initialize</code> 方法：</p>
<p>为什么走的不是发送消息的流程，而走的是 <code>load_images</code> 里面的 <code>prepare_load_methods</code> 方法呢？我们来到 <code>prepare_load_methods</code> 方法处：</p>
<p>可以看到，其实是在这里调用了 <code>realizeClassWithoutSwift</code> 方法来加载类的。而上面的 <code>_getObjc2NonlazyCategoryList</code> 方法显示就是获取的所有的非懒加载分类，然后遍历这些非懒加载分类，然后去加载这些分类所依赖的类。这个逻辑很好理解，非懒加载分类让我们的懒加载类实现提前了，所以说懒加载类<strong>并不一定</strong>只会在第一次消息发送的时候加载，还要取决于有没有非懒加载的分类，如果有非懒加载的分类，那么就走的是 <code>load_images</code> 里面的 <code>prepare_load_methods</code> 的 <code>realizeClassWithoutSwift</code> 。</p>
<h5 id="与非懒加载类配合加载-1"><a href="#与非懒加载类配合加载-1" class="headerlink" title="与非懒加载类配合加载"></a>与非懒加载类配合加载</h5><p>非懒加载类的流程我们也十分熟悉了，在 <code>_read_images</code> 里面进行加载，而此时，分类也是非懒加载。我们还是在 <code>methodizeClass</code> 里面进行断点：</p>
<p>结果如上图所示，这次从 <code>unattachedCategoriesForClass</code> 方法取出来的是 <code>NULL</code> 值，显然分类不是在这个地方被加载的，我们回到 <code>_read_images</code> 方法，还记得那个 <code>Discover categories</code> 流程吗，我们打开里面的断点：</p>
<p>其实 <code>attachCategories</code> 这个方法只会在实现了 <code>load</code> 方法的分类下才会被调用，而来到 <code>attachCategories</code> 之前又取决于类是否为懒加载，如果是懒加载，那么就在 <code>load_images</code> 里面去处理，如果是非懒加载，那么就在 <code>map_images</code> 里面去处理。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们今天探索的内容可能会有点绕，不过其实探索下来，我们只需要保持研究重点就很简单。分类的加载其实可以笼统的分为实现 <code>load</code> 方法和没有实现 <code>load</code> 方法：</p>
<ul>
<li>没有实现 <code>load</code> 方法的分类由编译时确定</li>
<li>实现了 <code>load</code> 方法的分类由运行时去确定</li>
</ul>
<p>这也说明分类的加载和类的加载是不一样的，而结合着类的懒加载与否，我们有以下的结论：</p>
<ul>
<li>懒加载分类 + 懒加载类</li>
</ul>
<blockquote>
<p>类的加载在<strong>第一次消息发送</strong>的时候，而分类的加载则在<strong>编译时</strong></p>
</blockquote>
<ul>
<li>懒加载分类 + 非懒加载类</li>
</ul>
<blockquote>
<p>类的加载在 <code>_read_images</code> 处，分类的加载还是在<strong>编译时</strong></p>
</blockquote>
<ul>
<li>非懒加载分类 + 懒加载类</li>
</ul>
<blockquote>
<p>类的加载在 <code>load_images</code> 内部，分类的加载在类加载之后的 <code>methodizeClass</code></p>
</blockquote>
<ul>
<li>非懒加载分类 + 非懒加载类</li>
</ul>
<blockquote>
<p>类的加载在 <code>_read_images</code> 处，分类的加载在类加载之后的 <code>reMethodizeClass</code></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/15/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/15/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/" class="post-title-link" itemprop="url">iOS 底层探索 - 类的加载</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-15 16:19:03" itemprop="dateCreated datePublished" datetime="2021-05-15T16:19:03+08:00">2021-05-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-17 11:03:49" itemprop="dateModified" datetime="2021-05-17T11:03:49+08:00">2021-05-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="应用的加载回顾"><a href="#应用的加载回顾" class="headerlink" title="应用的加载回顾"></a>应用的加载回顾</h3><p>上一章我们对应用的加载有了初步的认识，我们知道了</p>
<ul>
<li>系统调用 <code>exec()</code> 会我们的应用<strong>映射</strong>到新的地址空间</li>
<li>然后通过 <code>dyld</code> 进行加载、链接、初始化主程序和主程序所依赖的各种动态库</li>
<li>最后在 <code>initializeMainExecutable</code> 方法中经过一系列初始化调用 <code>notifySingle</code> 函数，该函数会执行一个 <code>load_images</code> 的回调</li>
<li>然后在 <code>doModinitFuntions</code> 函数内部会调用 <code>__attribute__((constructor))</code> 的 <code>c</code> 函数</li>
<li>然后 <code>dyld</code> 返回主程序的入口函数，开始进入主程序的 <code>main</code> 函数 在 <code>main</code> 函数执行执行，其实 <code>dyld</code> 还会在流程中初始化 <code>libSystem</code>，而 <code>libSystem</code> 又会去初始化 <code>libDispatch</code>，在 <code>libDispatch</code> 初始化方法里面又会有一步 <code>_os_object_init</code>，在 <code>_os_object_init</code> 内部就会调起 <code>_objc_init</code>。而对于 <code>_objc_init</code> 我们还需要继续探索，因为这里面会进行类的加载等一系列重要的工作。</li>
</ul>
<h3 id="探索-objc-init"><a href="#探索-objc-init" class="headerlink" title="探索_objc_init"></a>探索<code>_objc_init</code></h3><p>首先来到 <code>libObjc</code> 源码的 <code>_objc_init</code> 方法处，你可以直接添加一个符号断点 <code>_objc_init</code> 或者全局搜索关键字来到这里：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* _objc_init</span></span><br><span class="line"><span class="comment">* Bootstrap initialization. Registers our image notifier with dyld.</span></span><br><span class="line"><span class="comment">* Called by libSystem BEFORE library initialization time</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">  	<span class="comment">//如果已经初始化直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    runtime_init();</span><br><span class="line">    exception_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    <span class="keyword">cache_t</span>::init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    _imp_implementationWithBlock_init();</span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    didCallDyldNotifyRegister = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="environ-init"><a href="#environ-init" class="headerlink" title="environ_init"></a><code>environ_init</code></h4><p>我们直接看调用的第一个方法<code>environ_init</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* environ_init</span></span><br><span class="line"><span class="comment">* Read environment variables that affect the runtime.</span></span><br><span class="line"><span class="comment">* Also print environment variable help, if requested.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">environ_init</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (issetugid()) &#123;</span><br><span class="line">        <span class="comment">// All environment variables are silently ignored when setuid or setgid</span></span><br><span class="line">        <span class="comment">// This includes OBJC_HELP and OBJC_PRINT_OPTIONS themselves.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// Turn off autorelease LRU coalescing by default for apps linked against</span></span><br><span class="line">    <span class="comment">// older SDKs. LRU coalescing can reorder releases and certain older apps</span></span><br><span class="line">    <span class="comment">// are accidentally relying on the ordering.</span></span><br><span class="line">    <span class="comment">// rdar://problem/63886091</span></span><br><span class="line"><span class="comment">//    if (!dyld_program_sdk_at_least(dyld_fall_2020_os_versions))</span></span><br><span class="line"><span class="comment">//        DisableAutoreleaseCoalescingLRU = true;</span></span><br><span class="line">    <span class="keyword">bool</span> PrintHelp = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> PrintOptions = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> maybeMallocDebugging = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// Scan environ[] directly instead of calling getenv() a lot.</span></span><br><span class="line">    <span class="comment">// This optimizes the case where none are set.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> **p = *_NSGetEnviron(); *p != nil; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strncmp</span>(*p, <span class="string">"Malloc"</span>, <span class="number">6</span>)  ||  <span class="number">0</span> == <span class="built_in">strncmp</span>(*p, <span class="string">"DYLD"</span>, <span class="number">4</span>)  ||  </span><br><span class="line">            <span class="number">0</span> == <span class="built_in">strncmp</span>(*p, <span class="string">"NSZombiesEnabled"</span>, <span class="number">16</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            maybeMallocDebugging = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != <span class="built_in">strncmp</span>(*p, <span class="string">"OBJC_"</span>, <span class="number">5</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strncmp</span>(*p, <span class="string">"OBJC_HELP="</span>, <span class="number">10</span>)) &#123;</span><br><span class="line">            PrintHelp = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strncmp</span>(*p, <span class="string">"OBJC_PRINT_OPTIONS="</span>, <span class="number">19</span>)) &#123;</span><br><span class="line">            PrintOptions = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strncmp</span>(*p, <span class="string">"OBJC_DEBUG_POOL_DEPTH="</span>, <span class="number">22</span>)) &#123;</span><br><span class="line">            SetPageCountWarning(*p + <span class="number">22</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *value = <span class="built_in">strchr</span>(*p, <span class="string">'='</span>);</span><br><span class="line">        <span class="keyword">if</span> (!*value) <span class="keyword">continue</span>;</span><br><span class="line">        value++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(Settings)/<span class="keyword">sizeof</span>(Settings[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">option_t</span> *opt = &amp;Settings[i];</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">size_t</span>)(value - *p) == <span class="number">1</span>+opt-&gt;envlen  &amp;&amp;  </span><br><span class="line">                <span class="number">0</span> == <span class="built_in">strncmp</span>(*p, opt-&gt;env, opt-&gt;envlen))</span><br><span class="line">            &#123;</span><br><span class="line">                *opt-&gt;var = (<span class="number">0</span> == <span class="built_in">strcmp</span>(value, <span class="string">"YES"</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Special case: enable some autorelease pool debugging</span></span><br><span class="line">    <span class="comment">// when some malloc debugging is enabled </span></span><br><span class="line">    <span class="comment">// and OBJC_DEBUG_POOL_ALLOCATION is not set to something other than NO.</span></span><br><span class="line">    <span class="keyword">if</span> (maybeMallocDebugging) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *insert = getenv(<span class="string">"DYLD_INSERT_LIBRARIES"</span>);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *zombie = getenv(<span class="string">"NSZombiesEnabled"</span>);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *pooldebug = getenv(<span class="string">"OBJC_DEBUG_POOL_ALLOCATION"</span>);</span><br><span class="line">        <span class="keyword">if</span> ((getenv(<span class="string">"MallocStackLogging"</span>)</span><br><span class="line">             || getenv(<span class="string">"MallocStackLoggingNoCompact"</span>)</span><br><span class="line">             || (zombie &amp;&amp; (*zombie == <span class="string">'Y'</span> || *zombie == <span class="string">'y'</span>))</span><br><span class="line">             || (insert &amp;&amp; <span class="built_in">strstr</span>(insert, <span class="string">"libgmalloc"</span>)))</span><br><span class="line">            &amp;&amp;</span><br><span class="line">            (!pooldebug || <span class="number">0</span> == <span class="built_in">strcmp</span>(pooldebug, <span class="string">"YES"</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            DebugPoolAllocation = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    if (!os_feature_enabled_simple(objc4, preoptimizedCaches, true)) &#123;</span></span><br><span class="line"><span class="comment">//        DisablePreoptCaches = true;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">// Print OBJC_HELP and OBJC_PRINT_OPTIONS output.</span></span><br><span class="line">    <span class="keyword">if</span> (PrintHelp  ||  PrintOptions) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintHelp) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"Objective-C runtime debugging. Set variable=YES to enable."</span>);</span><br><span class="line">            _objc_inform(<span class="string">"OBJC_HELP: describe available environment variables"</span>);</span><br><span class="line">            <span class="keyword">if</span> (PrintOptions) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"OBJC_HELP is set"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            _objc_inform(<span class="string">"OBJC_PRINT_OPTIONS: list which options are set"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (PrintOptions) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"OBJC_PRINT_OPTIONS is set"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(Settings)/<span class="keyword">sizeof</span>(Settings[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">option_t</span> *opt = &amp;Settings[i];            </span><br><span class="line">            <span class="keyword">if</span> (PrintHelp) _objc_inform(<span class="string">"%s: %s"</span>, opt-&gt;env, opt-&gt;help);</span><br><span class="line">            <span class="keyword">if</span> (PrintOptions &amp;&amp; *opt-&gt;var) _objc_inform(<span class="string">"%s is set"</span>, opt-&gt;env);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，这里主要是读取影响 <code>Runtime</code> 的一些环境变量，如果需要，还可以打印环境变量帮助提示。</p>
<p>我们可以在终端测试一下，直接输入<code>export OBJC-HELP=1</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">jason@<span class="number">192</span> ~ % <span class="keyword">export</span> OBJC_HELP=<span class="number">1</span></span><br><span class="line">jason@<span class="number">192</span> ~ % ls</span><br><span class="line">objc[<span class="number">6097</span>]: Objective-C runtime debugging. Set variable=YES to enable.</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_HELP: describe <span class="built_in">available</span> environment variables</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_OPTIONS: <span class="built_in">list</span> which options are <span class="built_in">set</span></span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_IMAGES: <span class="built_in">log</span> <span class="built_in">image</span> <span class="keyword">and</span> library names as they are loaded</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_IMAGE_TIMES: measure duration of <span class="built_in">image</span> loading steps</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_LOAD_METHODS: <span class="built_in">log</span> calls to class <span class="keyword">and</span> category +load methods</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_INITIALIZE_METHODS: <span class="built_in">log</span> calls to class +initialize methods</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_RESOLVED_METHODS: <span class="built_in">log</span> methods created by +resolveClassMethod: <span class="keyword">and</span> +resolveInstanceMethod:</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_CLASS_SETUP: <span class="built_in">log</span> progress of class <span class="keyword">and</span> category <span class="built_in">setup</span></span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_PROTOCOL_SETUP: <span class="built_in">log</span> progress of protocol <span class="built_in">setup</span></span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_IVAR_SETUP: <span class="built_in">log</span> processing of non-fragile ivars</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_VTABLE_SETUP: <span class="built_in">log</span> processing of class vtables</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_VTABLE_IMAGES: <span class="built_in">print</span> vtable images showing overridden methods</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_CACHE_SETUP: <span class="built_in">log</span> processing of method caches</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_FUTURE_CLASSES: <span class="built_in">log</span> use of <span class="built_in">future</span> classes <span class="keyword">for</span> toll-<span class="built_in">free</span> bridging</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_PREOPTIMIZATION: <span class="built_in">log</span> preoptimization courtesy of dyld shared cache</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_CXX_CTORS: <span class="built_in">log</span> calls to C++ ctors <span class="keyword">and</span> dtors <span class="keyword">for</span> instance variables</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_EXCEPTIONS: <span class="built_in">log</span> exception handling</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_EXCEPTION_THROW: <span class="built_in">log</span> backtrace of every objc_exception_throw()</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_ALT_HANDLERS: <span class="built_in">log</span> processing of exception alt handlers</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_REPLACED_METHODS: <span class="built_in">log</span> methods replaced by category implementations</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_DEPRECATION_WARNINGS: warn about calls to deprecated runtime functions</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_POOL_HIGHWATER: <span class="built_in">log</span> high-water marks <span class="keyword">for</span> autorelease pools</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_CUSTOM_CORE: <span class="built_in">log</span> classes with custom core methods</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_CUSTOM_RR: <span class="built_in">log</span> classes with custom retain/<span class="built_in">release</span> methods</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_CUSTOM_AWZ: <span class="built_in">log</span> classes with custom allocWithZone methods</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_RAW_ISA: <span class="built_in">log</span> classes that require raw pointer isa fields</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DEBUG_UNLOAD: warn about poorly-behaving bundles when unloaded</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DEBUG_FRAGILE_SUPERCLASSES: warn about subclasses that may have been broken by subsequent changes to superclasses</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DEBUG_NIL_SYNC: warn about @synchronized(nil), which does no synchronization</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DEBUG_NONFRAGILE_IVARS: capriciously rearrange non-fragile ivars</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DEBUG_ALT_HANDLERS: record more info about bad alt handler use</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DEBUG_MISSING_POOLS: warn about autorelease with no pool in place, which may be a leak</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DEBUG_POOL_ALLOCATION: halt when autorelease pools are popped out of order, <span class="keyword">and</span> allow heap debuggers to track autorelease pools</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DEBUG_DUPLICATE_CLASSES: halt when multiple classes with the same name are present</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DEBUG_DONT_CRASH: halt the <span class="built_in">process</span> by exiting instead of crashing</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DISABLE_VTABLES: disable vtable dispatch</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DISABLE_PREOPTIMIZATION: disable preoptimization courtesy of dyld shared cache</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DISABLE_TAGGED_POINTERS: disable tagged pointer optimization of NSNumber et al.</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DISABLE_TAG_OBFUSCATION: disable obfuscation of tagged pointers</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DISABLE_NONPOINTER_ISA: disable non-pointer isa fields</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DISABLE_INITIALIZE_FORK_SAFETY: disable safety checks <span class="keyword">for</span> +initialize after fork</span><br></pre></td></tr></table></figure>

<p>可以看到不同的环境变量对应的内容都被打印出来了。</p>
<h4 id="tls-init"><a href="#tls-init" class="headerlink" title="tls_init"></a><code>tls_init</code></h4><p>接着看<code>tls_init</code>方法内部：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tls_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line">    pthread_key_init_np(TLS_DIRECT_KEY, &amp;_objc_pthread_destroyspecific);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    _objc_pthread_key = tls_create(&amp;_objc_pthread_destroyspecific);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里执行的是关于线程 <code>key</code> 的绑定，比如每个线程数据的析构函数。</p>
<h4 id="static-init"><a href="#static-init" class="headerlink" title="static_init"></a><code>static_init</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* static_init</span></span><br><span class="line"><span class="comment">* Run C++ static constructor functions.</span></span><br><span class="line"><span class="comment">* libc calls _objc_init() before dyld would call our static constructors, </span></span><br><span class="line"><span class="comment">* so we have to do it ourselves.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">static_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    <span class="keyword">auto</span> inits = getLibobjcInitializers(&amp;_mh_dylib_header, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        inits[i]();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> offsets = getLibobjcInitializerOffsets(&amp;_mh_dylib_header, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="function">UnsignedInitializer <span class="title">init</span><span class="params">(offsets[i])</span></span>;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会运行 <code>C++</code> 的静态构造函数，在 <code>dyld</code> 调用我们的静态构造函数之前，<code>libc</code> 会调用 <code>_objc_init</code>，所以这里我们必须自己来做，并且这里只会初始化系统内置的 <code>C++</code> 静态构造函数，我们自己代码里面写的并不会在这里初始化。</p>
<h4 id="runtime-init"><a href="#runtime-init" class="headerlink" title="runtime_init"></a><code>runtime_init</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runtime_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    objc::unattachedCategories.init(<span class="number">32</span>);</span><br><span class="line">    objc::allocatedClasses.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Runtime环境初始化，unattachedCategories和allocatedClasses两张表的初始化工作</p>
<h4 id="exception-init"><a href="#exception-init" class="headerlink" title="exception_init"></a><code>exception_init</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* exception_init</span></span><br><span class="line"><span class="comment">* Initialize libobjc's exception handling system.</span></span><br><span class="line"><span class="comment">* Called by map_images().</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exception_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    old_terminate = <span class="built_in">std</span>::set_terminate(&amp;_objc_terminate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是初始化 <code>libobjc</code> 的异常处理系统，我们程序触发的异常都会来到：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* _objc_terminate</span></span><br><span class="line"><span class="comment">* Custom std::terminate handler.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* The uncaught exception callback is implemented as a std::terminate handler. </span></span><br><span class="line"><span class="comment">* 1. Check if there's an active exception</span></span><br><span class="line"><span class="comment">* 2. If so, check if it's an Objective-C exception</span></span><br><span class="line"><span class="comment">* 3. If so, call our registered callback with the object.</span></span><br><span class="line"><span class="comment">* 4. Finally, call the previous terminate handler.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*old_terminate)</span><span class="params">(<span class="keyword">void</span>)</span> </span>= nil;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _objc_terminate(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PrintExceptions) &#123;</span><br><span class="line">        _objc_inform(<span class="string">"EXCEPTIONS: terminating"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! __cxa_current_exception_type()) &#123;</span><br><span class="line">        <span class="comment">// No current exception.</span></span><br><span class="line">        (*old_terminate)();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// There is a current exception. Check if it's an objc exception.</span></span><br><span class="line">        @<span class="keyword">try</span> &#123;</span><br><span class="line">            __cxa_rethrow();</span><br><span class="line">        &#125; @<span class="keyword">catch</span> (id e) &#123;</span><br><span class="line">            <span class="comment">// It's an objc object. Call Foundation's handler, if any.</span></span><br><span class="line">            (*uncaught_handler)((id)e);</span><br><span class="line">            (*old_terminate)();</span><br><span class="line">        &#125; @<span class="keyword">catch</span> (...) &#123;</span><br><span class="line">            <span class="comment">// It's not an objc object. Continue to C++ terminate.</span></span><br><span class="line">            (*old_terminate)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到 <code>_objc_terminate</code> 是未处理异常的回调函数，其内部逻辑如下:</p>
<ul>
<li>检查是否是一个活跃的异常</li>
<li>如果是活跃的异常，检查是否是 <code>OC</code> 抛出的异常</li>
<li>如果是 <code>OC</code> 抛出的异常，调用 <code>uncaught_handeler</code> 回调函数指针</li>
<li>如果不是 <code>OC</code> 抛出的异常，则继续 <code>C++</code> 终止操作</li>
</ul>
<h4 id="cache-t-init"><a href="#cache-t-init" class="headerlink" title="cache_t::init()"></a><code>cache_t::init()</code></h4><p>看字面量很容易猜到，<code>cache_t</code>属性的初始化</p>
<h4 id="imp-implementationWithBlock-init"><a href="#imp-implementationWithBlock-init" class="headerlink" title="_imp_implementationWithBlock_init"></a><code>_imp_implementationWithBlock_init</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Initialize the trampoline machinery. Normally this does nothing, as</span></span><br><span class="line"><span class="comment">/// everything is initialized lazily, but for certain processes we eagerly load</span></span><br><span class="line"><span class="comment">/// the trampolines dylib.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_imp_implementationWithBlock_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_OSX</span></span><br><span class="line">    <span class="comment">// Eagerly load libobjc-trampolines.dylib in certain processes. Some</span></span><br><span class="line">    <span class="comment">// programs (most notably QtWebEngineProcess used by older versions of</span></span><br><span class="line">    <span class="comment">// embedded Chromium) enable a highly restrictive sandbox profile which</span></span><br><span class="line">    <span class="comment">// blocks access to that dylib. If anything calls</span></span><br><span class="line">    <span class="comment">// imp_implementationWithBlock (as AppKit has started doing) then we'll</span></span><br><span class="line">    <span class="comment">// crash trying to load it. Loading it here sets it up before the sandbox</span></span><br><span class="line">    <span class="comment">// profile is enabled and blocks it.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This fixes EA Origin (rdar://problem/50813789)</span></span><br><span class="line">    <span class="comment">// and Steam (rdar://problem/55286131)</span></span><br><span class="line">    <span class="keyword">if</span> (__progname &amp;&amp;</span><br><span class="line">        (<span class="built_in">strcmp</span>(__progname, <span class="string">"QtWebEngineProcess"</span>) == <span class="number">0</span> ||</span><br><span class="line">         <span class="built_in">strcmp</span>(__progname, <span class="string">"Steam Helper"</span>) == <span class="number">0</span>)) &#123;</span><br><span class="line">        Trampolines.Initialize();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动回调机制。通常不会做什么，因为所有的初始化都是惰性的，但是对于某些进程，我们会迫不及待地加载trampolines dylib。</p>
<h4 id="dyld-objc-notify-register"><a href="#dyld-objc-notify-register" class="headerlink" title="_dyld_objc_notify_register"></a><code>_dyld_objc_notify_register</code></h4><p>接下来是我们今天探索的重点了： <code>_dyld_objc_notify_register</code> ，我们先看下它的定义:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note: only for use by objc runtime</span></span><br><span class="line"><span class="comment">// Register handlers to be called when objc images are mapped, unmapped, and initialized.</span></span><br><span class="line"><span class="comment">// Dyld will call back the "mapped" function with an array of images that contain an objc-image-info section.</span></span><br><span class="line"><span class="comment">// Those images that are dylibs will have the ref-counts automatically bumped, so objc will no longer need to</span></span><br><span class="line"><span class="comment">// call dlopen() on them to keep them from being unloaded.  During the call to _dyld_objc_notify_register(),</span></span><br><span class="line"><span class="comment">// dyld will call the "mapped" function with already loaded objc images.  During any later dlopen() call,</span></span><br><span class="line"><span class="comment">// dyld will also call the "mapped" function.  Dyld will call the "init" function when dyld would be called</span></span><br><span class="line"><span class="comment">// initializers in that image.  This is when objc calls any +load methods in that image.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span> _dyld_objc_notify_register(_dyld_objc_notify_mapped    mapped,</span><br><span class="line">                                _dyld_objc_notify_init      init,</span><br><span class="line">                                _dyld_objc_notify_unmapped  unmapped);</span><br></pre></td></tr></table></figure>

<p>注意：仅供 <code>objc</code> 运行时使用<br>当 <code>objc</code> 镜像被<strong>映射（mapped）</strong>、<strong>卸载（unmapped）</strong>和<strong>初始化（initialized）</strong>的时候，注册的回调函数就会被调用。<br>这个方法是 <code>dlyd</code> 中声明的，一旦调用该方法，调用结果会作为该函数的参数回传回来。比如，当所有的 <code>images</code> 以及 <code>section</code> 为 <code>objc-image-info</code> 被加载之后会回调 <code>mapped</code> 方法。<br><code>load</code> 方法也将在这个方法中被调用。</p>
<p><code>_dyld_objc_notify_register</code> 方法的三个参数 <code>map_images</code> 、 <code>load_images</code> 、 <code>unmap_image</code> 其实都是函数指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*_dyld_objc_notify_mapped)</span><span class="params">(<span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> paths[], <span class="keyword">const</span> struct mach_header* <span class="keyword">const</span> mh[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*_dyld_objc_notify_init)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> struct mach_header* mh)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*_dyld_objc_notify_unmapped)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> struct mach_header* mh)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这三个函数指针是在 <code>dyld</code> 中回调的，我们打开 <code>dyld</code> 的源码即可一探究竟，我们直接搜索 <code>_dyld_objc_notify_register</code> :</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _dyld_objc_notify_register(_dyld_objc_notify_mapped    mapped,</span><br><span class="line">                                _dyld_objc_notify_init      init,</span><br><span class="line">                                _dyld_objc_notify_unmapped  unmapped)</span><br><span class="line">&#123;</span><br><span class="line">	dyld::registerObjCNotifiers(mapped, init, unmapped);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着来到 <code>dyld</code> 的 <code>registerObjCNotifiers</code> 方法内部：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerObjCNotifiers</span><span class="params">(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// record functions to call</span></span><br><span class="line">	sNotifyObjCMapped	= mapped;<span class="comment">//map_images</span></span><br><span class="line">	sNotifyObjCInit		= init;<span class="comment">//load_images</span></span><br><span class="line">	sNotifyObjCUnmapped = unmapped;<span class="comment">//unmap_images</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// call 'mapped' function with all images mapped so far</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		notifyBatchPartial(dyld_image_state_bound, <span class="literal">true</span>, <span class="literal">NULL</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line">		<span class="comment">// ignore request to abort during registration</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// &lt;rdar://problem/32209809&gt; call 'init' function on all images already init'ed (below libSystem)</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ImageLoader*&gt;::iterator it=sAllImages.<span class="built_in">begin</span>(); it != sAllImages.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		ImageLoader* <span class="built_in">image</span> = *it;</span><br><span class="line">		<span class="keyword">if</span> ( (<span class="built_in">image</span>-&gt;getState() == dyld_image_state_initialized) &amp;&amp; <span class="built_in">image</span>-&gt;notifyObjC() ) &#123;</span><br><span class="line">			<span class="function">dyld3::ScopedTimer <span class="title">timer</span><span class="params">(DBG_DYLD_TIMING_OBJC_INIT, (<span class="keyword">uint64_t</span>)<span class="built_in">image</span>-&gt;machHeader(), <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">			(*sNotifyObjCInit)(<span class="built_in">image</span>-&gt;getRealPath(), <span class="built_in">image</span>-&gt;machHeader());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> _dyld_objc_notify_mapped		sNotifyObjCMapped;</span><br><span class="line"><span class="keyword">static</span> _dyld_objc_notify_init		sNotifyObjCInit;</span><br><span class="line"><span class="keyword">static</span> _dyld_objc_notify_unmapped	sNotifyObjCUnmapped;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码的内容说明在<code>registerObjCNotifiers</code> 内部， <code>libObjc</code> 传过来的这三个函数指针被 <code>dyld</code> 保存在了本地静态变量中。换句话来说，最终函数指针是否能被调用，取决于这三个静态变量：</p>
<ul>
<li><code>sNotifyObjCMapped</code></li>
<li><code>sNotifyObjCInit</code></li>
<li><code>sNotifyObjCUnmapped</code></li>
</ul>
<p>我们注意到 <code>registerObjCNotifiers</code> 的 <code>try-catch</code> 语句中的 <code>try</code> 分支注释如下：</p>
<blockquote>
<p>call ‘mapped’ function with all images mapped so far<br>调用 <code>mapped</code> 函数来映射所有的镜像</p>
</blockquote>
<p>那么也就是说 <code>notifyBatchPartial</code> 里面会进行真正的函数指针的调用，我们进入这个方法内部：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notifyBatchPartial</span><span class="params">(dyld_image_states state, <span class="keyword">bool</span> orLater, dyld_image_state_change_handler onlyHandler, <span class="keyword">bool</span> preflightOnly, <span class="keyword">bool</span> onlyObjCMappedNotification)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">			<span class="comment">//省略代码</span></span><br><span class="line">			<span class="comment">// tell objc about new images</span></span><br><span class="line">			<span class="keyword">if</span> ( (onlyHandler == <span class="literal">NULL</span>) &amp;&amp; ((state == dyld_image_state_bound) || (orLater &amp;&amp; (dyld_image_state_bound &gt; state))) &amp;&amp; (sNotifyObjCMapped != <span class="literal">NULL</span>) ) &#123;</span><br><span class="line">				<span class="keyword">const</span> <span class="keyword">char</span>* paths[imageCount];</span><br><span class="line">				<span class="keyword">const</span> mach_header* mhs[imageCount];</span><br><span class="line">				<span class="keyword">unsigned</span> objcImageCount = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; imageCount; ++i) &#123;</span><br><span class="line">					ImageLoader* <span class="built_in">image</span> = findImageByMachHeader(infos[i].imageLoadAddress);</span><br><span class="line">					<span class="keyword">bool</span> hasObjC = <span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">if</span> ( <span class="built_in">image</span> != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">						<span class="keyword">if</span> ( <span class="built_in">image</span>-&gt;objCMappedNotified() )</span><br><span class="line">							<span class="keyword">continue</span>;</span><br><span class="line">						hasObjC = <span class="built_in">image</span>-&gt;notifyObjC();</span><br><span class="line">					&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_ACCELERATE_TABLES</span></span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> ( sAllCacheImagesProxy != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">						<span class="keyword">const</span> mach_header* mh;</span><br><span class="line">						<span class="keyword">const</span> <span class="keyword">char</span>* path;</span><br><span class="line">						<span class="keyword">unsigned</span> index;</span><br><span class="line">						<span class="keyword">if</span> ( sAllCacheImagesProxy-&gt;addressInCache(infos[i].imageLoadAddress, &amp;mh, &amp;path, &amp;index) ) &#123;</span><br><span class="line">							hasObjC = (mh-&gt;flags &amp; MH_HAS_OBJC);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">					<span class="keyword">if</span> ( hasObjC ) &#123;</span><br><span class="line">						paths[objcImageCount] = infos[i].imageFilePath;</span><br><span class="line">						mhs[objcImageCount]   = infos[i].imageLoadAddress;</span><br><span class="line">						++objcImageCount;</span><br><span class="line">						<span class="keyword">if</span> ( <span class="built_in">image</span> != <span class="literal">NULL</span> )</span><br><span class="line">							<span class="built_in">image</span>-&gt;setObjCMappedNotified();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> ( objcImageCount != <span class="number">0</span> ) &#123;</span><br><span class="line">					<span class="function">dyld3::ScopedTimer <span class="title">timer</span><span class="params">(DBG_DYLD_TIMING_OBJC_MAP, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">					<span class="keyword">uint64_t</span> t0 = mach_absolute_time();</span><br><span class="line">					(*sNotifyObjCMapped)(objcImageCount, paths, mhs);<span class="comment">//函数指针真正调用的地方</span></span><br><span class="line">					<span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line">					ImageLoader::fgTotalObjCSetupTime += (t1-t0);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//省略代码</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，在 <code>notifyBatchPartial</code> 方法内部，这里的注释:</p>
<blockquote>
<p>tell objc about new images 告诉 <code>objc</code> 镜像已经映射完成了</p>
</blockquote>
<p>弄清楚了三个函数指针是怎么调用的还不够，接下来我们要深入各个函数的内部看里面究竟做了什么样的事情。</p>
<h3 id="探索-map-images"><a href="#探索-map-images" class="headerlink" title="探索 map_images"></a>探索 <code>map_images</code></h3><p>首先是 <code>map_images</code> ，我们来到它的实现:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* map_images</span></span><br><span class="line"><span class="comment">* Process the given images which are being mapped in by dyld.</span></span><br><span class="line"><span class="comment">* Calls ABI-agnostic code after taking ABI-specific locks.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: write-locks runtimeLock</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">map_images(<span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> paths[],</span><br><span class="line">           <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> map_images_nolock(count, paths, mhdrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Process the given images which are being mapped in by dyld.<br>Calls ABI-agnostic code after taking ABI-specific locks.</p>
</blockquote>
<blockquote>
<p>处理由 <code>dyld</code> 映射的给定镜像<br>取得特定于 <code>ABI</code> 的锁后，调用与 <code>ABI</code> 无关的代码。</p>
</blockquote>
<p>这里会继续往下走到 <code>map_images_nolock</code></p>
<p><code>map_images_nolock</code> 内部代码十分冗长，我们经过分析之后，前面的工作基本上都是进行镜像文件信息的提取与统计，所以可以定位到最后的 <code>_read_images</code> ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里进入 <code>_read_images</code> 的条件是 <code>hCount</code> 大于 0， <code>hCount</code> 表示的是 <code>Mach-O</code> 中 <code>header</code> 的数量</p>
<p>OK，我们的主角登场了， <code>_read_images</code> 和 <code>lookupImpOrForward</code> 可以说是我们学习 <code>Runtime</code> 和 <code>iOS</code> 底层里面非常重要的两个概念了， <code>lookUpImpOrForward</code> 已经探索过了，剩下的 <code>_read_images</code> 我们也不能落下。</p>
<h4 id="read-images定义"><a href="#read-images定义" class="headerlink" title="_read_images定义"></a>_read_images定义</h4><p>Perform initial processing of the headers in the linked list beginning with headerList.<br>从 <code>headerList</code> 开始，对已经链接了的 <code>Mach-O</code> 镜像表中的头部进行初始化处理</p>
<p>我们可以看到，整个 <code>_read_images</code> 有接近 400 行代码。</p>
<p>通过查看代码，以及日志打印提示信息，我们大致可以将 <code>_read_images</code> 分为下面几个流程:</p>
<h4 id="read-images具体流程"><a href="#read-images具体流程" class="headerlink" title="_read_images具体流程"></a>_read_images具体流程</h4><p><strong>doneOnce 流程</strong></p>
<p>我们从第一个分支 <code>doneOnce</code> 开始，这个名词顾名思义，只会执行一次：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EACH_HEADER \</span></span><br><span class="line">    hIndex = <span class="number">0</span>;         \</span><br><span class="line">    hIndex &lt; hCount &amp;&amp; (hi = hList[hIndex]); \</span><br><span class="line">    hIndex++</span><br><span class="line">    <span class="keyword">if</span> (!doneOnce) &#123;</span><br><span class="line">        doneOnce = YES;</span><br><span class="line">        launchTime = YES;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">        <span class="comment">// Disable non-pointer isa under some conditions.</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class="line">        <span class="comment">// Disable nonpointer isa if any image contains old Swift code</span></span><br><span class="line">        <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hi-&gt;info()-&gt;containsSwift()  &amp;&amp;</span><br><span class="line">                hi-&gt;info()-&gt;swiftUnstableVersion() &lt; objc_image_info::SwiftVersion3)</span><br><span class="line">            &#123;</span><br><span class="line">                DisableNonpointerIsa = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (PrintRawIsa) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"RAW ISA: disabling non-pointer isa because "</span></span><br><span class="line">                                 <span class="string">"the app or a framework contains Swift code "</span></span><br><span class="line">                                 <span class="string">"older than Swift 3.0"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过宏 <code>SUPPORT_NONPOINTER_ISA</code> 判断当前是否支持开启内存优化的 <code>isa</code><ul>
<li>如果支持，则在某些条件下需要禁用这个优化</li>
</ul>
</li>
<li>通过宏 <code>SUPPORT_INDEXED_ISA</code> 判断当前是否是将类存储在 <code>isa</code> 作为类表索引<ul>
<li>如果是的话，再递归遍历所有的 <code>Mach-O</code> 的头部，并且判断如果是 <code>Swift 3.0</code> 之前的代码，就需要禁用对 <code>isa</code> 的内存优化</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">if</span> TARGET_OS_OSX</span></span><br><span class="line">        <span class="comment">// Disable non-pointer isa if the app is too old</span></span><br><span class="line">        <span class="comment">// (linked before OS X 10.11)</span></span><br><span class="line"><span class="comment">//        if (!dyld_program_sdk_at_least(dyld_platform_version_macOS_10_11)) &#123;</span></span><br><span class="line"><span class="comment">//            DisableNonpointerIsa = true;</span></span><br><span class="line"><span class="comment">//            if (PrintRawIsa) &#123;</span></span><br><span class="line"><span class="comment">//                _objc_inform("RAW ISA: disabling non-pointer isa because "</span></span><br><span class="line"><span class="comment">//                             "the app is too old.");</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Disable non-pointer isa if the app has a __DATA,__objc_rawisa section</span></span><br><span class="line">        <span class="comment">// New apps that load old extensions may need this.</span></span><br><span class="line">        <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hi-&gt;mhdr()-&gt;filetype != MH_EXECUTE) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line">            <span class="keyword">if</span> (getsectiondata(hi-&gt;mhdr(), <span class="string">"__DATA"</span>, <span class="string">"__objc_rawisa"</span>, &amp;<span class="built_in">size</span>)) &#123;</span><br><span class="line">                DisableNonpointerIsa = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (PrintRawIsa) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"RAW ISA: disabling non-pointer isa because "</span></span><br><span class="line">                                 <span class="string">"the app has a __DATA,__objc_rawisa section"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// assume only one MH_EXECUTE image</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过宏 <code>TARGET_OS_OSX</code> 判断是否是 <code>macOS</code> 执行环境</li>
<li>判断 <code>macOS</code> 的系统版本，如果小于 <code>10.11</code> 则说明 <code>app</code> 太陈旧了，需要禁用掉 <code>non-pointer isa</code></li>
<li>然后再遍历所有的 <code>Mach-O</code> 的头部，判断如果有 <code>__DATA__,__objc_rawisa</code> 段的存在，则禁用掉 <code>non-pointer isa</code> ，因为很多新的 <code>app</code> 加载老的扩展的时候会需要这样的判断操作。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// namedClasses</span></span><br><span class="line"><span class="comment">// Preoptimized classes don't go in this table.</span></span><br><span class="line"><span class="comment">// 4/3 is NXMapTable's load factor</span></span><br><span class="line"><span class="keyword">int</span> namedClassesSize = </span><br><span class="line">    (isPreoptimized() ? unoptimizedTotalClasses : totalClasses) * <span class="number">4</span> / <span class="number">3</span>;</span><br><span class="line">gdb_objc_realized_classes =</span><br><span class="line">    NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);</span><br></pre></td></tr></table></figure>

<p>预先优化过的类不会加入到 <code>gdb_objc_realized_classes</code> 这个哈希表中来， <code>gdb_objc_realized_classes</code> 哈希表的装载因子为 0.75，这是一个经过验证的效率很高的扩容临界值。</p>
<ul>
<li>加载所有类到类的 <code>gdb_objc_realized_classes</code> 表中来</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is a misnomer: gdb_objc_realized_classes is actually a list of </span></span><br><span class="line"><span class="comment">// named classes not in the dyld shared cache, whether realized or not.</span></span><br><span class="line"><span class="comment">// This list excludes lazily named classes, which have to be looked up</span></span><br><span class="line"><span class="comment">// using a getClass hook.</span></span><br><span class="line">NXMapTable *gdb_objc_realized_classes;  <span class="comment">// exported for debuggers in objc-gdb.h</span></span><br></pre></td></tr></table></figure>

<p>这是一个误称：gdb_objc_realized_classes 表实际上存储的是不在 <code>dyld</code> 共享缓存里面的命名类，无论这些类是否实现</p>
<p>除了 <code>gdb_objc_realized_classes</code> 表之外，还有一张表 <code>allocatedClasses</code> :</p>
<p>其实 <code>gdb_objc_realized_classes</code> 对 <code>allocatedClasses</code> 是一种包含的关系，一张是类的总表，一张是已经开辟了内存的类表.</p>
<h5 id="Discover-classes-流程"><a href="#Discover-classes-流程" class="headerlink" title="Discover classes 流程"></a>Discover classes 流程</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discover classes. Fix up unresolved future classes. Mark bundle classes.</span></span><br><span class="line"><span class="keyword">bool</span> hasDyldRoots = dyld_shared_cache_some_image_overridden();</span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="keyword">if</span> (! mustReadClasses(hi, hasDyldRoots)) &#123;</span><br><span class="line">        <span class="comment">// Image is sufficiently optimized that we need not call readClass()</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist = _getObjc2ClassList(hi, &amp;count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> headerIsBundle = hi-&gt;isBundle();</span><br><span class="line">    <span class="keyword">bool</span> headerIsPreoptimized = hi-&gt;hasPreoptimizedClasses();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Class cls = (Class)classlist[i];</span><br><span class="line">        Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newCls != cls  &amp;&amp;  newCls) &#123;</span><br><span class="line">            <span class="comment">// Class was moved but not deleted. Currently this occurs </span></span><br><span class="line">            <span class="comment">// only when the new class resolved a future class.</span></span><br><span class="line">            <span class="comment">// Non-lazily realize the class below.</span></span><br><span class="line">            resolvedFutureClasses = (Class *)</span><br><span class="line">                <span class="built_in">realloc</span>(resolvedFutureClasses, </span><br><span class="line">                        (resolvedFutureClassCount+<span class="number">1</span>) * <span class="keyword">sizeof</span>(Class));</span><br><span class="line">            resolvedFutureClasses[resolvedFutureClassCount++] = newCls;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Discover classes. Fix up unresolved future classes. Mark bundle classes.<br>发现类。修正未解析的 <code>future</code> 类，标记 <code>bundle</code> 类。</p>
<ul>
<li>先通过 <code>_getObjc2ClassList</code> 来获取到所有的类</li>
<li>接着还是遍历所有的 <code>Mach-O</code> 的 <code>header</code> 部分，然后通过 <code>mustReadClasses</code> 来判断哪些条件可以跳过读取类这一步骤</li>
<li>读取 <code>header</code> 是否是 <code>Bundle</code></li>
<li>读取 <code>header</code> 是否开启了 <strong>预优化</strong></li>
<li>遍历 <code>_getObjc2ClassList</code> 取出的所有的类<ul>
<li>通过 <code>readClass</code> 来读取类信息</li>
<li>判断如果不相等并且 <code>readClass</code> 结果不为空，则需要重新为类开辟内存</li>
</ul>
</li>
</ul>
<p><strong>Fix up remapped classes 流程</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fix up remapped classes</span></span><br><span class="line"><span class="comment">// Class list and nonlazy class list remain unremapped.</span></span><br><span class="line"><span class="comment">// Class refs and super refs are remapped for message dispatching.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!noClassesRemapped()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        Class *classrefs = _getObjc2ClassRefs(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            remapClassRef(&amp;classrefs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fixme why doesn't test future1 catch the absence of this?</span></span><br><span class="line">        classrefs = _getObjc2SuperRefs(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            remapClassRef(&amp;classrefs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修复 重映射类<br>类表和非懒加载类表没有被重映射 (也就是 <strong>_objc_classlist</strong>)<br>由于消息转发，类引用和父类引用会被重映射 (也就是 <strong>_objc_classrefs</strong>)</p>
<ul>
<li>通过 <code>noClassesRemapped</code> 方法判断是否有类引用(<strong>_objc_classrefs</strong>)需要进行重映射<ul>
<li>如果需要，则遍历 <code>EACH_HEADER</code></li>
<li>通过 <code>_getObjc2ClassRefs</code> 和 <code>_getObjc2SuperRefs</code> 取出当前遍历到的 <code>Mach-O</code> 的类引用和父类引用，然后调用 <code>remapClassRef</code> 进行重映射</li>
</ul>
</li>
</ul>
<p><strong>Fix up @selector references 流程</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Fix up @selector references</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> UnfixedSelectors;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(selLock)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hi-&gt;hasPreoptimizedSelectors()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> isBundle = hi-&gt;isBundle();</span><br><span class="line">            SEL *sels = _getObjc2SelectorRefs(hi, &amp;count);</span><br><span class="line">            UnfixedSelectors += count;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char</span> *name = sel_cname(sels[i]);</span><br><span class="line">                SEL sel = sel_registerNameNoLock(name, isBundle);</span><br><span class="line">                <span class="keyword">if</span> (sels[i] != sel) &#123;</span><br><span class="line">                    sels[i] = sel;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function">SEL <span class="title">sel_registerNameNoLock</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">bool</span> copy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __sel_registerName(name, <span class="number">0</span>, copy);  <span class="comment">// NO lock, maybe copy</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>修正 <code>SEL</code> 引用</p>
</blockquote>
<ul>
<li>操作前先加一个 <code>selLock</code> 锁</li>
<li>然后遍历<code>EACH_HEADER</code><ul>
<li>如果开启了<strong>预优化</strong>，contiue 到下一个 <code>Mach-O</code></li>
<li>通过 <code>_getObjc2SelectorRefs</code> 拿到所有的 <code>SEL</code> 引用</li>
<li>然后对所有的 <code>SEL</code> 引用调用 <code>sel_registerNameNoLock</code> 进行注册</li>
</ul>
</li>
</ul>
<p>也就是说这一流程最主要的目的就是注册 <code>SEL</code> ，我们注册真正发生的地方: <code>__sel_registerName</code> ，这个函数如果大家经常玩 <code>Runtime</code> 肯定不会陌生：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> SEL __sel_registerName(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">bool</span> shouldLock, <span class="keyword">bool</span> copy) </span><br><span class="line">&#123;</span><br><span class="line">    SEL result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldLock) selLock.assertUnlocked();</span><br><span class="line">    <span class="keyword">else</span> selLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!name) <span class="keyword">return</span> (SEL)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    result = search_builtins(name);</span><br><span class="line">    <span class="keyword">if</span> (result) <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">conditional_mutex_locker_t</span> <span class="title">lock</span><span class="params">(selLock, shouldLock)</span></span>;</span><br><span class="line">	<span class="keyword">auto</span> it = namedSelectors.<span class="built_in">get</span>().insert(name);</span><br><span class="line">	<span class="keyword">if</span> (it.second) &#123;</span><br><span class="line">		<span class="comment">// No match. Insert.</span></span><br><span class="line">		*it.first = (<span class="keyword">const</span> <span class="keyword">char</span> *)sel_alloc(name, copy);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (SEL)*it.first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们简单分析一下 <code>__sel_registerName</code> 方法的流程：</p>
<ul>
<li>判断是否要加锁</li>
<li>如果 <code>sel</code> 为空，则返回一个空的 <code>SEL</code></li>
<li>从 <code>builtins</code> 中搜索，看是否已经注册过，如果找到，直接返回结果</li>
<li>从 <code>namedSelectors</code> 哈希表中查询，找到了就返回结果</li>
<li>如果 <code>namedSelectors</code> 未初始化，则创建一下这个哈希表</li>
<li>如果上面的流程都没有找到，则需要调用 <code>sel_alloc</code> 来创建一下 <code>SEL</code> ，然后把新创建的 <code>SEL</code> 插入哈希表中进行缓存的填充</li>
</ul>
<h5 id="Fix-up-old-objc-msgSend-fixup-call-sites-流程"><a href="#Fix-up-old-objc-msgSend-fixup-call-sites-流程" class="headerlink" title="Fix up old objc_msgSend_fixup call sites 流程"></a><strong>Fix up old objc_msgSend_fixup call sites 流程</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_FIXUP</span></span><br><span class="line">    <span class="comment">// Fix up old objc_msgSend_fixup call sites</span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="keyword">message_ref_t</span> *refs = _getObjc2MessageRefs(hi, &amp;count);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (PrintVtables) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"VTABLES: repairing %zu unsupported vtable dispatch "</span></span><br><span class="line">                         <span class="string">"call sites in %s"</span>, count, hi-&gt;fname());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            fixupMessageRef(refs+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: fix up objc_msgSend_fixup"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>修正旧的 <code>objc_msgSend_fixup</code> 调用</p>
<p>这个流程的执行前提是 <code>FIXUP</code> 被开启。</p>
<ul>
<li>还是老套路，遍历<code>EACH_HEADER</code><ul>
<li>通过 <code>_getObjc2MessageRefs</code> 方法来获取当前遍历到的 <code>Mach-O</code> 镜像的所有消息引用</li>
<li>然后遍历这些消息引用，然后调用 <code>fixupMessageRef</code> 进行修正</li>
</ul>
</li>
</ul>
<h5 id="Discover-protocols-流程"><a href="#Discover-protocols-流程" class="headerlink" title="Discover protocols 流程"></a><strong>Discover protocols 流程</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discover protocols. Fix up protocol refs.</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="keyword">extern</span> objc_class OBJC_CLASS_$_Protocol;</span><br><span class="line">    Class cls = (Class)&amp;OBJC_CLASS_$_Protocol;</span><br><span class="line">    ASSERT(cls);</span><br><span class="line">    NXMapTable *protocol_map = protocols();</span><br><span class="line">    <span class="keyword">bool</span> isPreoptimized = hi-&gt;hasPreoptimizedProtocols();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip reading protocols if this is an image from the shared cache</span></span><br><span class="line">    <span class="comment">// and we support roots</span></span><br><span class="line">    <span class="comment">// Note, after launch we do need to walk the protocol as the protocol</span></span><br><span class="line">    <span class="comment">// in the shared cache is marked with isCanonical() and that may not</span></span><br><span class="line">    <span class="comment">// be true if some non-shared cache binary was chosen as the canonical</span></span><br><span class="line">    <span class="comment">// definition</span></span><br><span class="line">    <span class="keyword">if</span> (launchTime &amp;&amp; isPreoptimized) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintProtocols) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"PROTOCOLS: Skipping reading protocols in image: %s"</span>,</span><br><span class="line">                         hi-&gt;fname());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> isBundle = hi-&gt;isBundle();</span><br><span class="line">    <span class="keyword">protocol_t</span> * <span class="keyword">const</span> *protolist = _getObjc2ProtocolList(hi, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        readProtocol(protolist[i], cls, protocol_map, </span><br><span class="line">                     isPreoptimized, isBundle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现协议，并修正协议引用</p>
<h5 id="Fix-up-protocol-references-流程"><a href="#Fix-up-protocol-references-流程" class="headerlink" title="Fix up @protocol references 流程"></a><strong>Fix up @protocol references 流程</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fix up @protocol references</span></span><br><span class="line"><span class="comment">// Preoptimized images may have the right </span></span><br><span class="line"><span class="comment">// answer already but we don't know for sure.</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="comment">// At launch time, we know preoptimized image refs are pointing at the</span></span><br><span class="line">    <span class="comment">// shared cache definition of a protocol.  We can skip the check on</span></span><br><span class="line">    <span class="comment">// launch, but have to visit @protocol refs for shared cache images</span></span><br><span class="line">    <span class="comment">// loaded later.</span></span><br><span class="line">    <span class="keyword">if</span> (launchTime &amp;&amp; hi-&gt;isPreoptimized())</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">protocol_t</span> **protolist = _getObjc2ProtocolRefs(hi, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        remapProtocolRef(&amp;protolist[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对所有的协议做重映射</p>
<h5 id="Realize-non-lazy-classes-流程"><a href="#Realize-non-lazy-classes-流程" class="headerlink" title="Realize non-lazy classes 流程"></a><strong>Realize non-lazy classes 流程</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Realize non-lazy classes (for +load methods and static instances)</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist = hi-&gt;nlclslist(&amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Class cls = remapClass(classlist[i]);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        addClassTableEntry(cls);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;isSwiftStable()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cls-&gt;swiftMetadataInitializer()) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">"Swift class %s with a metadata initializer "</span></span><br><span class="line">                            <span class="string">"is not allowed to be non-lazy"</span>,</span><br><span class="line">                            cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// fixme also disallow relocatable classes</span></span><br><span class="line">            <span class="comment">// We can't disallow all Swift classes because of</span></span><br><span class="line">            <span class="comment">// classes like Swift.__EmptyArrayStorage</span></span><br><span class="line">        &#125;</span><br><span class="line">        realizeClassWithoutSwift(cls, nil);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化<strong>非懒加载类( <code>+load</code> 方法和静态实例</strong>)**</p>
<h5 id="Realize-newly-resolved-future-classes-流程"><a href="#Realize-newly-resolved-future-classes-流程" class="headerlink" title="Realize newly-resolved future classes 流程"></a><strong>Realize newly-resolved future classes 流程</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Realize newly-resolved future classes, in case CF manipulates them</span></span><br><span class="line"><span class="keyword">if</span> (resolvedFutureClasses) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; resolvedFutureClassCount; i++) &#123;</span><br><span class="line">        Class cls = resolvedFutureClasses[i];</span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;isSwiftStable()) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">"Swift class is not allowed to be future"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        realizeClassWithoutSwift(cls, nil);</span><br><span class="line">        cls-&gt;setInstancesRequireRawIsaRecursively(<span class="literal">false</span><span class="comment">/*inherited*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(resolvedFutureClasses);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化新解析出来的 <code>future</code> 类</p>
<h5 id="Discover-categories-流程"><a href="#Discover-categories-流程" class="headerlink" title="Discover categories 流程"></a><strong>Discover categories 流程</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discover categories. Only do this after the initial category</span></span><br><span class="line"><span class="comment">// attachment has been done. For categories present at startup,</span></span><br><span class="line"><span class="comment">// discovery is deferred until the first load_images call after</span></span><br><span class="line"><span class="comment">// the call to _dyld_objc_notify_register completes. rdar://problem/53119145</span></span><br><span class="line"><span class="keyword">if</span> (didInitialAttachCategories) &#123;</span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        load_categories_nolock(hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理所有的分类，包括类和元类</p>
<p>到这里， <code>_read_images</code> 的流程就分析完毕，我们可以新建一个文件来去掉一些干扰的信息，只保留核心的逻辑，这样从宏观的角度来分析更直观:</p>
<p><img src="/images/_read_image_schedule.png" alt="_read_image_schedule"></p>
<p>Q &amp; A 环节<br>Q： <code>dyld</code> 主要逻辑是加载库，也就是镜像文件，但是加载完是怎么读取的呢？<br>A： <code>_read_images</code> 是真正读取的地方</p>
<p>Q: <code>SEL</code> 方法编号何时加载？<br>A: <code>_read_images</code></p>
<h4 id="read-class-分析"><a href="#read-class-分析" class="headerlink" title="read_class 分析"></a>read_class 分析</h4><p>我们探索了 <code>_read_images</code> 方法的流程，接下来让我们把目光放到本文的主题 - <strong>类的加载</strong><br>既然是类的加载，那么我们在前面所探索的类的结构中出现的内容都会一一重现。<br>所以我们不妨直接进行断点调试，让我们略过其它干扰信息，聚焦于类的加载。</p>
<ul>
<li>根据上一小节我们探索的结果， <code>doneOnce</code> 流程中会创建两个哈希表，并没有涉及到类的加载，所以我们跳过</li>
<li>我们来到第二个流程 - <strong>类处理</strong></li>
</ul>
<p>我们在<code>_read_images</code>函数，定位到下面这行代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class cls = (Class)classlist[i];<span class="comment">//断点</span></span><br><span class="line">Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized);</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>cls</code> 的属性、方法、协议以及类名都为空，说明这里类并没有被真正加载完成，我们接着聚焦到 <code>read_class</code> 函数上面，我们进入其内部实现，我们大致浏览之后会定位到如下图所示的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* readClass</span></span><br><span class="line"><span class="comment">* Read a class and metaclass as written by a compiler.</span></span><br><span class="line"><span class="comment">* Returns the new class pointer. This could be: </span></span><br><span class="line"><span class="comment">* - cls</span></span><br><span class="line"><span class="comment">* - nil  (cls has a missing weak-linked superclass)</span></span><br><span class="line"><span class="comment">* - something else (space for this class was reserved by a future class)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Note that all work performed by this function is preflighted by </span></span><br><span class="line"><span class="comment">* mustReadClasses(). Do not change this function without updating that one.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: runtimeLock acquired by map_images or objc_readClassPair</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function">Class <span class="title">readClass</span><span class="params">(Class cls, <span class="keyword">bool</span> headerIsBundle, <span class="keyword">bool</span> headerIsPreoptimized)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mangledName = cls-&gt;nonlazyMangledName();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (missingWeakSuperclass(cls)) &#123;</span><br><span class="line">        <span class="comment">// No superclass (probably weak-linked). </span></span><br><span class="line">        <span class="comment">// Disavow any knowledge of this subclass.</span></span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"CLASS: IGNORING class '%s' with "</span></span><br><span class="line">                         <span class="string">"missing weak-linked superclass"</span>, </span><br><span class="line">                         cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        addRemappedClass(cls, nil);</span><br><span class="line">        cls-&gt;setSuperclass(nil);</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cls-&gt;fixupBackwardDeployingStableSwift();</span><br><span class="line"></span><br><span class="line">    Class replacing = nil;</span><br><span class="line">    <span class="keyword">if</span> (mangledName != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Class newCls = popFutureNamedClass(mangledName)) &#123;</span><br><span class="line">            <span class="comment">// This name was previously allocated as a future class.</span></span><br><span class="line">            <span class="comment">// Copy objc_class to future class's struct.</span></span><br><span class="line">            <span class="comment">// Preserve future's rw data block.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newCls-&gt;isAnySwift()) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">"Can't complete future class request for '%s' "</span></span><br><span class="line">                            <span class="string">"because the real class is too big."</span>,</span><br><span class="line">                            cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">class_rw_t</span> *rw = newCls-&gt;data();</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *old_ro = rw-&gt;ro();</span><br><span class="line">            <span class="built_in">memcpy</span>(newCls, cls, <span class="keyword">sizeof</span>(objc_class));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Manually set address-discriminated ptrauthed fields</span></span><br><span class="line">            <span class="comment">// so that newCls gets the correct signatures.</span></span><br><span class="line">            newCls-&gt;setSuperclass(cls-&gt;getSuperclass());</span><br><span class="line">            newCls-&gt;initIsa(cls-&gt;getIsa());</span><br><span class="line"></span><br><span class="line">            rw-&gt;set_ro((<span class="keyword">class_ro_t</span> *)newCls-&gt;data());</span><br><span class="line">            newCls-&gt;setData(rw);</span><br><span class="line">            freeIfMutable((<span class="keyword">char</span> *)old_ro-&gt;getName());</span><br><span class="line">            <span class="built_in">free</span>((<span class="keyword">void</span> *)old_ro);</span><br><span class="line"></span><br><span class="line">            addRemappedClass(cls, newCls);</span><br><span class="line"></span><br><span class="line">            replacing = cls;</span><br><span class="line">            cls = newCls;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (headerIsPreoptimized  &amp;&amp;  !replacing) &#123;</span><br><span class="line">        <span class="comment">// class list built in shared cache</span></span><br><span class="line">        <span class="comment">// fixme strict assert doesn't work because of duplicates</span></span><br><span class="line">        <span class="comment">// ASSERT(cls == getClass(name));</span></span><br><span class="line">        ASSERT(mangledName == <span class="literal">nullptr</span> || getClassExceptSomeSwift(mangledName));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mangledName) &#123; <span class="comment">//some Swift generic classes can lazily generate their names</span></span><br><span class="line">            addNamedClass(cls, mangledName, replacing);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Class meta = cls-&gt;ISA();</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *metaRO = meta-&gt;bits.safe_ro();</span><br><span class="line">            ASSERT(metaRO-&gt;getNonMetaclass() &amp;&amp; <span class="string">"Metaclass with lazy name must have a pointer to the corresponding nonmetaclass."</span>);</span><br><span class="line">            ASSERT(metaRO-&gt;getNonMetaclass() == cls &amp;&amp; <span class="string">"Metaclass nonmetaclass pointer must equal the original class."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        addClassTableEntry(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for future reference: shared cache never contains MH_BUNDLEs</span></span><br><span class="line">    <span class="keyword">if</span> (headerIsBundle) &#123;</span><br><span class="line">        cls-&gt;data()-&gt;flags |= RO_FROM_BUNDLE;</span><br><span class="line">        cls-&gt;ISA()-&gt;data()-&gt;flags |= RO_FROM_BUNDLE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来类的信息在这里完成了加载，那么为了验证我们的猜想，直接断点调试一下但发现断点根本走不进来，原因在于这里的判断语句</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Class newCls = popFutureNamedClass(mangledName))</span><br></pre></td></tr></table></figure>

<p>判断当前传入的类的类名是否有 <code>future</code> 类的实现，但是我们刚才已经打印了，类名是空的，所以肯定不会执行这里。我们接着往下走：</p>
<ul>
<li>addNamedClass 内部其实是将 <code>cls</code> 插入到 <code>gdb_objc_realized_classes</code> 表</li>
<li>addclassTableEntry 内部是将 <code>cls</code> 插入到 <code>allocatedClasses</code> 表</li>
</ul>
<p>分析完 <code>read_class</code> ，我们回到 <code>_read_images</code> 方法</p>
<p>我们可以看到 <code>read_class</code> 返回的 <code>newCls</code> 会进行一个判断，判断与传入 <code>read_class</code> 之前的 <code>cls</code> 是否相等，而在 <code>read_class</code> 内部只有一个地方对类的内容进行了改动，但是我们刚才测试了是进不去的，所以这个 <code>if</code> 里面的内容我们可以略过，也就是说 <code>resolvedFutureClasses</code> 的内容我们都可以暂时略过。</p>
<p>总结一下 <code>readClass</code> ：</p>
<ul>
<li>判断是不是要后期处理的类<ul>
<li>如果是的话，就取出后期处理的类，读取这个类的 <code>data()</code> 类设置 <code>ro/rw</code></li>
</ul>
</li>
<li>addNamedClass 插入总表</li>
<li>addClassTableEntry 插入已开辟内存的类的表</li>
</ul>
<h4 id="realizeClassWithoutSwift-分析"><a href="#realizeClassWithoutSwift-分析" class="headerlink" title="realizeClassWithoutSwift 分析"></a>realizeClassWithoutSwift 分析</h4><p>通过分析 <code>read_class</code> ，我们可以得知，类已经被注册到两个哈希表中去了，那么现在一切时机都已经成熟了。但是我们还是要略过像 <code>Fix up remapped classes</code> 、 <code>Fix up @selector references</code> 、 <code>fix up old objc_msgSend_fixup call sites</code> 、 <code>Discover protocols. Fix up protocol refs</code> 、 <code>Fix up @protocol references</code> ，因为我们的重点是类的加载，我们最终来到了 <code>Realize non-lazy classes (for +load methods and static instances)</code> ，略去无关信息之后，我们可以看到我们的<br>主角 <code>realizeClassWithoutSwift</code> 闪亮登场了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* realizeClassWithoutSwift</span></span><br><span class="line"><span class="comment">* Performs first-time initialization on class cls, </span></span><br><span class="line"><span class="comment">* including allocating its read-write data.</span></span><br><span class="line"><span class="comment">* Does not perform any Swift-side initialization.</span></span><br><span class="line"><span class="comment">* Returns the real class structure for the class. </span></span><br><span class="line"><span class="comment">* Locking: runtimeLock must be write-locked by the caller</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">realizeClassWithoutSwift</span><span class="params">(Class cls, Class previously)</span></span></span><br></pre></td></tr></table></figure>

<p>从方法的名称以及方法注释我们可以知道， <code>realizeClassWithoutSwift</code> 是进行类的第一次初始化操作，包括分配读写数据也就是我们常说的 <code>rw</code> ，但是并不会进行任何的 <code>Swift</code> 端初始化。我们直接聚焦下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Normal class. Allocate writeable class data.</span></span><br><span class="line">rw = objc::zalloc&lt;<span class="keyword">class_rw_t</span>&gt;();</span><br><span class="line">rw-&gt;set_ro(ro);</span><br><span class="line">rw-&gt;flags = RW_REALIZED|RW_REALIZING|isMeta;</span><br><span class="line">cls-&gt;setData(rw);</span><br></pre></td></tr></table></figure>

<ul>
<li>通过 <code>zalloc</code> 开辟内存空间，返回一个新的 <code>rw</code></li>
<li>把 <code>cls</code> 取出来的 <code>ro</code> 赋值给这个 <code>rw</code></li>
<li>将 <code>rw</code> 设置到 <code>cls</code> 身上</li>
</ul>
<p>可以清楚地看到，此时 <code>rw</code> 还是为空，说明这里只是对 <code>rw</code> 进行了初始化，但是方法、属性、协议这些都没有被添加上。</p>
<p>我们接着往下走:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Realize superclass and metaclass, if they aren't already.</span></span><br><span class="line"><span class="comment">// This needs to be done after RW_REALIZED is set above, for root classes.</span></span><br><span class="line"><span class="comment">// This needs to be done after class index is chosen, for root metaclasses.</span></span><br><span class="line"><span class="comment">// This assumes that none of those classes have Swift contents,</span></span><br><span class="line"><span class="comment">//   or that Swift's initializers have already been called.</span></span><br><span class="line"><span class="comment">//   fixme that assumption will be wrong if we add support</span></span><br><span class="line"><span class="comment">//   for ObjC subclasses of Swift classes.</span></span><br><span class="line">supercls = realizeClassWithoutSwift(remapClass(cls-&gt;getSuperclass()), nil);</span><br><span class="line">metacls = realizeClassWithoutSwift(remapClass(cls-&gt;ISA()), nil);</span><br></pre></td></tr></table></figure>

<p>这里可以看到父类和元类都会递归调用 <code>realizeClassWithoutSwift</code> 来初始化各自的 <code>rw</code> 。为什么在类的加载操作里面要去加载类和元类呢？回忆一下类的结构，答案很简单，要保证 <code>superclass</code> 和 <code>isa</code> 的完整性，也就是保证类的完整性，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update superclass and metaclass in case of remapping</span></span><br><span class="line">cls-&gt;setSuperclass(supercls);</span><br><span class="line">cls-&gt;initClassIsa(metacls);</span><br></pre></td></tr></table></figure>

<p>上面的代码就是最好的证明，初始化完毕的父类和元类被赋值到了类的 <code>superclass</code> 和 <code>isa</code> 上面。</p>
<p>接着往下走可以看到，不光要把父类关联到类上面，还要让父类知道子类的存在。</p>
<p>最后一行代码是 <code>methodizeClass(cls)</code> ，注释显示的是 <code>attach categories</code> ，附加分类到类？我们进入其内部实现一探究竟。</p>
<p>在探索 <code>methodizeClass</code> 前，我们先总结一下 <code>realizeClassWithoutSwift</code> :</p>
<ul>
<li>读取 <code>class</code> 的 <code>data()</code></li>
<li><code>ro/rw</code> 赋值</li>
<li>父类和元类实现<ul>
<li>supercls = realizeClassWithoutSwift(remapClass(cls-&gt;superclass))</li>
<li>metacls = realizeClassWithoutSwift(remapClass(cls-&gt;ISA()))</li>
</ul>
</li>
<li>父类和元类归属关系<ul>
<li>cls-&gt;superclass = supercls</li>
<li>cls-&gt;initClassIsa(metacls)</li>
</ul>
</li>
<li>将当前类链接到其父类的子类列表 addSubclass(supercls, cls)</li>
</ul>
<h4 id="methodizeClass-分析"><a href="#methodizeClass-分析" class="headerlink" title="methodizeClass 分析"></a>methodizeClass 分析</h4><p>realizeClassWithoutSwift方法最后一行调用的是<code>methodizeClass</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* methodizeClass</span></span><br><span class="line"><span class="comment">* Fixes up cls's method list, protocol list, and property list.</span></span><br><span class="line"><span class="comment">* Attaches any outstanding categories.</span></span><br><span class="line"><span class="comment">* Locking: runtimeLock must be held by the caller</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodizeClass</span><span class="params">(Class cls, Class previously)</span></span></span><br></pre></td></tr></table></figure>

<p>对类的方法列表、协议列表和属性列表进行修正<br>附加 <code>category</code> 到类上面来</p>
<p>我们直接往下面走：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Install methods and properties that the class implements itself.</span></span><br><span class="line"><span class="keyword">method_list_t</span> *<span class="built_in">list</span> = ro-&gt;baseMethods();</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">    prepareMethodLists(cls, &amp;<span class="built_in">list</span>, <span class="number">1</span>, YES, isBundleClass(cls), <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (rwe) rwe-&gt;methods.attachLists(&amp;<span class="built_in">list</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从 <code>ro</code> 中取出<strong>方法列表</strong>附加到 <code>rw</code> 上</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">property_list_t</span> *proplist = ro-&gt;baseProperties;</span><br><span class="line"><span class="keyword">if</span> (rwe &amp;&amp; proplist) &#123;</span><br><span class="line">    rwe-&gt;properties.attachLists(&amp;proplist, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从 <code>ro</code> 中取出<strong>属性列表</strong>附加到 <code>rw</code> 上</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol_list_t</span> *protolist = ro-&gt;baseProtocols;</span><br><span class="line"><span class="keyword">if</span> (rwe &amp;&amp; protolist) &#123;</span><br><span class="line">    rwe-&gt;protocols.attachLists(&amp;protolist, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从 <code>ro</code> 中取出<strong>协议列表</strong>附加到 <code>rw</code> 上</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Attach categories.</span></span><br><span class="line"><span class="keyword">if</span> (previously) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isMeta) &#123;</span><br><span class="line">        objc::unattachedCategories.attachToClass(cls, previously,</span><br><span class="line">                                                 ATTACH_METACLASS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// When a class relocates, categories with class methods</span></span><br><span class="line">        <span class="comment">// may be registered on the class itself rather than on</span></span><br><span class="line">        <span class="comment">// the metaclass. Tell attachToClass to look for those.</span></span><br><span class="line">        objc::unattachedCategories.attachToClass(cls, previously,</span><br><span class="line">                                                 ATTACH_CLASS_AND_METACLASS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">objc::unattachedCategories.attachToClass(cls, cls,</span><br><span class="line">                                         isMeta ? ATTACH_METACLASS : ATTACH_CLASS);</span><br></pre></td></tr></table></figure>

<ul>
<li>从 <code>cls</code> 中取出未附加的分类进行附加操作</li>
</ul>
<h3 id="探索-load-images"><a href="#探索-load-images" class="headerlink" title="探索 load_images"></a>探索 load_images</h3><p>我们接着探索 <code>_dyld_objc_notify_register</code> 的第二个参数 <code>load_images</code> ，这个函数指针是在什么时候调用的呢，同样的，我们接着在 <code>dyld</code> 源码中搜索对应的函数指针 <code>sNotifyObjCInit</code> :</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ImageLoader*&gt;::iterator it=sAllImages.<span class="built_in">begin</span>(); it != sAllImages.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">	ImageLoader* <span class="built_in">image</span> = *it;</span><br><span class="line">	<span class="keyword">if</span> ( (<span class="built_in">image</span>-&gt;getState() == dyld_image_state_initialized) &amp;&amp; <span class="built_in">image</span>-&gt;notifyObjC() ) &#123;</span><br><span class="line">		<span class="function">dyld3::ScopedTimer <span class="title">timer</span><span class="params">(DBG_DYLD_TIMING_OBJC_INIT, (<span class="keyword">uint64_t</span>)<span class="built_in">image</span>-&gt;machHeader(), <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">		(*sNotifyObjCInit)(<span class="built_in">image</span>-&gt;getRealPath(), <span class="built_in">image</span>-&gt;machHeader());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在 <code>notifySingle</code> 方法内部， <code>sNotifyObjCInit</code> 函数指针被调用了。根据我们上一篇文章探索 <code>dyld</code> 底层可以知道， <code>_load_images</code> 应该是对于每一个加载进来的 <code>Mach-O</code> 镜像都会递归调用一次。</p>
<p>我们来到 <code>libObjc</code> 源码中 <code>load_images</code> 的定义处:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* load_images</span></span><br><span class="line"><span class="comment">* Process +load in the given images which are being mapped in by dyld.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: write-locks runtimeLock and loadMethodLock</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">bool</span> <span class="title">hasLoadMethods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">prepare_load_methods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span>;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">load_images(<span class="keyword">const</span> <span class="keyword">char</span> *path __unused, <span class="keyword">const</span> struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!didInitialAttachCategories &amp;&amp; didCallDyldNotifyRegister) &#123;</span><br><span class="line">        didInitialAttachCategories = <span class="literal">true</span>;</span><br><span class="line">        loadAllCategories();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Return without taking locks if there are no +load methods here.</span></span><br><span class="line">    <span class="keyword">if</span> (!hasLoadMethods((<span class="keyword">const</span> headerType *)mh)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="function"><span class="keyword">recursive_mutex_locker_t</span> <span class="title">lock</span><span class="params">(loadMethodLock)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// Discover load methods</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock2</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">        prepare_load_methods((<span class="keyword">const</span> headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>处理由 <code>dyld</code> 映射的给定镜像中的 <code>+load</code> 方法</p>
</blockquote>
<ul>
<li>判断是否有 <code>load</code> 方法，如果没有，直接返回</li>
<li>搜索 <code>load</code> 方法，具体实现通过 <code>prepare_load_methods</code></li>
<li>调用 <code>load</code> 方法，具体实现通过 <code>call_load_methods</code></li>
</ul>
<h4 id="prepare-load-methods-分析"><a href="#prepare-load-methods-分析" class="headerlink" title="prepare_load_methods 分析"></a>prepare_load_methods 分析</h4><p>从这个方法名称，我们猜测这里应该做的是 <code>load</code> 方法的一些预处理工作，让我们来到源码进行分析：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_load_methods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count, i;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">category_t</span> * <span class="keyword">const</span> *categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">category_t</span> *cat = categorylist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;isSwiftStable()) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">"Swift class extensions and categories on Swift "</span></span><br><span class="line">                        <span class="string">"classes are not allowed to have +load methods"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        realizeClassWithoutSwift(cls, nil);</span><br><span class="line">        ASSERT(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* prepare_load_methods</span></span><br><span class="line"><span class="comment">* Schedule +load for classes in this image, any un-+load-ed </span></span><br><span class="line"><span class="comment">* superclasses in other images, and any categories in this image.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="comment">// Recursively schedule +load for cls and any un-+load-ed superclasses.</span></span><br><span class="line"><span class="comment">// cls must already be connected.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule_class_load</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    ASSERT(cls-&gt;isRealized());  <span class="comment">// _read_images should realize</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">    schedule_class_load(cls-&gt;getSuperclass());</span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* add_class_to_loadable_list</span></span><br><span class="line"><span class="comment">* Class cls has just become connected. Schedule it for +load if</span></span><br><span class="line"><span class="comment">* it implements a +load method.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_class_to_loadable_list</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IMP method;</span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line">    method = cls-&gt;getLoadMethod();</span><br><span class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;  <span class="comment">// Don't bother if cls has no +load method</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(<span class="string">"LOAD: class '%s' scheduled for +load"</span>, </span><br><span class="line">                     cls-&gt;nameForLogging());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class="line">        loadable_classes_allocated = loadable_classes_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        loadable_classes = (struct loadable_class *)</span><br><span class="line">            <span class="built_in">realloc</span>(loadable_classes,</span><br><span class="line">                              loadable_classes_allocated *</span><br><span class="line">                              <span class="keyword">sizeof</span>(struct loadable_class));</span><br><span class="line">    &#125;</span><br><span class="line">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">    loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先通过 <code>_getObjc2NonlazyClassList</code> 获取所有已经加载进去的类列表</p>
</li>
<li><p>然后通过<code>schedule_class_load</code> 遍历这些类</p>
<ul>
<li>递归调用遍历父类的 <code>load</code> 方法，确保父类的 <code>load</code> 方法顺序排在子类的前面</li>
<li>通过 <code>add_class_to_loadable_list</code> , 把类的 <code>load</code> 方法存在 <code>loadable_classes</code> 里面</li>
</ul>
</li>
<li><p>完成 <code>schedule_class_load</code> 之后，通过 <code>_getObjc2NonlazyCategoryList</code> 取出所有分类数据</p>
</li>
<li><p>然后遍历这些分类</p>
<ul>
<li>通过 <code>realizeClassWithoutSwift</code> 来防止类没有初始化，如果已经初始化了则不影响</li>
<li>通过 <code>add_category_to_loadable_list</code> ，加载分类中的 <code>load</code> 方法到 <code>loadable_categories</code> 里面</li>
</ul>
</li>
</ul>
<h4 id="call-load-methods-分析"><a href="#call-load-methods-分析" class="headerlink" title="call_load_methods 分析"></a>call_load_methods 分析</h4><p>通过名称我们可以知道 <code>call_load_methods</code> 应该就是 <code>load</code> 方法被调用的地方了。我们直接看源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* call_load_methods</span></span><br><span class="line"><span class="comment">* Call all pending class and category +load methods.</span></span><br><span class="line"><span class="comment">* Class +load methods are called superclass-first. </span></span><br><span class="line"><span class="comment">* Category +load methods are not called until after the parent class's +load.</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* This method must be RE-ENTRANT, because a +load could trigger </span></span><br><span class="line"><span class="comment">* more image mapping. In addition, the superclass-first ordering </span></span><br><span class="line"><span class="comment">* must be preserved in the face of re-entrant calls. Therefore, </span></span><br><span class="line"><span class="comment">* only the OUTERMOST call of this function will do anything, and </span></span><br><span class="line"><span class="comment">* that call will handle all loadable classes, even those generated </span></span><br><span class="line"><span class="comment">* while it was running.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* The sequence below preserves +load ordering in the face of </span></span><br><span class="line"><span class="comment">* image loading during a +load, and make sure that no </span></span><br><span class="line"><span class="comment">* +load method is forgotten because it was added during </span></span><br><span class="line"><span class="comment">* a +load call.</span></span><br><span class="line"><span class="comment">* Sequence:</span></span><br><span class="line"><span class="comment">* 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line"><span class="comment">* 2. Call category +loads ONCE.</span></span><br><span class="line"><span class="comment">* 3. Run more +loads if:</span></span><br><span class="line"><span class="comment">*    (a) there are more classes to load, OR</span></span><br><span class="line"><span class="comment">*    (b) there are some potential category +loads that have </span></span><br><span class="line"><span class="comment">*        still never been attempted.</span></span><br><span class="line"><span class="comment">* Category +loads are only run once to ensure "parent class first" </span></span><br><span class="line"><span class="comment">* ordering, even if a category +load triggers a new loadable class </span></span><br><span class="line"><span class="comment">* and a new loadable category attached to that class. </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: loadMethodLock must be held by the caller </span></span><br><span class="line"><span class="comment">*   All other locks must not be held.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = NO;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = YES;</span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>call_load_methods<br>调用类和类别中所有未决的 <code>+load</code> 方法<br>类里面 <code>+load</code> 方法是父类优先调用的<br>而在父类的 <code>+load</code> 之后才会调用分类的 <code>+load</code> 方法</p>
</blockquote>
<ul>
<li>通过 <code>objc_autoreleasePoolPush</code> 压栈一个自动释放池</li>
<li><code>do-while</code>循环开始<ul>
<li>循环调用类的 <code>+load</code> 方法直到找不到为止</li>
<li>调用一次分类中的 <code>+load</code> 方法</li>
</ul>
</li>
<li>通过 <code>objc_autoreleasePoolPop</code> 出栈一个自动释放池</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此， <code>_objc_init</code> 和 <code>_dyld_objc_notify_register</code> 我们就分析完了，我们对类的加载有了更细致的认知。 <code>iOS</code> 底层有时候探索起来确实很枯燥，但是如果能找到高效的方法以及明确自己的所探索的方向，会让自己从宏观上重新审视这门技术。是的，技术只是工具，我们不能被技术所绑架，我们要做到有的放矢的去探索，这样才能事半功倍。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jason</p>
  <div class="site-description" itemprop="description">个人技术博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
