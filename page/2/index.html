<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yujiusheng.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="个人技术博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Jason的博客">
<meta property="og:url" content="http://yujiusheng.com/page/2/index.html">
<meta property="og:site_name" content="Jason的博客">
<meta property="og:description" content="个人技术博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yujiusheng.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Jason的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jason的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/06/01/Swift-RxSwift%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/01/Swift-RxSwift%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Swift - RxSwift源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-01 15:35:58" itemprop="dateCreated datePublished" datetime="2021-06-01T15:35:58+08:00">2021-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-03 21:54:22" itemprop="dateModified" datetime="2021-06-03T21:54:22+08:00">2021-06-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="RxSwift简介"><a href="#RxSwift简介" class="headerlink" title="RxSwift简介"></a>RxSwift简介</h3><p><code>RxSwift</code> 是 <a href="http://reactivex.io/" target="_blank" rel="noopener"><code>ReactiveX</code></a> 家族的重要一员, <code>ReactiveX</code> 是 <code>Reactive Extensions</code> 的缩写，一般简写为 <code>Rx</code>。<code>ReactiveX</code> 官方给<code>Rx</code>的定义是：<strong>Rx是一个使用可观察数据流进行异步编程的编程接口。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactiveX&#96; 不仅仅是一个编程接口，它是一种编程思想的突破，它影响了许多其它的程序库和框架以及编程语言。它拓展了&#96;观察者模式&#96;，使你能够&#96;自由组合多个异步事件&#96;，而&#96;不需要去关心线程&#96;，&#96;同步，线程安全&#96;，&#96;并发数据以及I&#x2F;O阻塞</span><br></pre></td></tr></table></figure>

<p><code>RxSwift</code> 是 <code>Rx</code> 为 <code>Swift</code> 语言开发的一门函数响应式编程语言， 它可以代替iOS系统的 <code>Target Action</code> / <code>代理</code> / <code>闭包</code> / <code>通知</code> / <code>KVO</code>,同时还提供<code>网络</code>、<code>数据绑定</code>、<code>UI事件处理</code>、<code>UI的展示和更新</code>、<code>多线程</code>……</p>
<p><code>Swift</code>为值类型，在传值与方法回调上有影响，<code>RxSwift</code>一定程度上弥补<code>Swift</code>的灵活性</p>
<ul>
<li><code>RxSwift</code>使得代码复用性较强，减少代码量</li>
<li><code>RxSwift</code>因为声明都是不可变更，增加代码可读性</li>
<li><code>RxSwift</code>使得更易于理解业务代码，抽象异步编程，统一代码风格</li>
<li><code>RxSwift</code>使得代码更易于编写集成单元测试，增加代码稳定性</li>
</ul>
<h3 id="RxSwift核心流程"><a href="#RxSwift核心流程" class="headerlink" title="RxSwift核心流程"></a>RxSwift核心流程</h3><p>RxSwift的api设计非常精简，流程就是：</p>
<p>1、创建序列（）</p>
<p>2、订阅序列</p>
<p>3、发送信号</p>
<p>4、销毁</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1: 创建序列</span></span><br><span class="line"><span class="number">_</span> = <span class="type">Observable</span>&lt;<span class="type">String</span>&gt;.create &#123; (obserber) -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// 3:发送信号</span></span><br><span class="line">    obserber.onNext(<span class="string">"RxSwift 研究"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create()  <span class="comment">// 4、销毁</span></span><br><span class="line">    <span class="comment">// 2: 订阅序列</span></span><br><span class="line">    &#125;.subscribe(onNext: &#123; (text) <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"订阅到:\(text)"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台打印：“订阅到:RxSwift 研究”</span></span><br></pre></td></tr></table></figure>

<h3 id="创建序列"><a href="#创建序列" class="headerlink" title="创建序列"></a>创建序列</h3><p>我们先看Create.swift文件的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ObservableType</span> </span>&#123;</span><br><span class="line">    <span class="comment">// MARK: create</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     Creates an observable sequence from a specified subscribe method implementation.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     - seealso: [create operator on reactivex.io](http://reactivex.io/documentation/operators/create.html)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     - parameter subscribe: Implementation of the resulting observable sequence's `subscribe` method.</span></span><br><span class="line"><span class="comment">     - returns: The observable sequence with the specified implementation for the `subscribe` method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(<span class="number">_</span> subscribe: @escaping <span class="params">(AnyObserver&lt;Element&gt;)</span></span></span> -&gt; <span class="type">Disposable</span>) -&gt; <span class="type">Observable</span>&lt;<span class="type">Element</span>&gt; &#123;</span><br><span class="line">        <span class="type">AnonymousObservable</span>(subscribe)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousObservable</span>&lt;<span class="title">Element</span>&gt;: <span class="title">Producer</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">SubscribeHandler</span> = (<span class="type">AnyObserver</span>&lt;<span class="type">Element</span>&gt;) -&gt; <span class="type">Disposable</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> subscribeHandler: <span class="type">SubscribeHandler</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> subscribeHandler: @escaping <span class="type">SubscribeHandler</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.subscribeHandler = subscribeHandler</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">run</span>&lt;Observer: ObserverType&gt;<span class="params">(<span class="number">_</span> observer: Observer, cancel: Cancelable)</span></span> -&gt; (sink: <span class="type">Disposable</span>, subscription: <span class="type">Disposable</span>) <span class="keyword">where</span> <span class="type">Observer</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> sink = <span class="type">AnonymousObservableSink</span>(observer: observer, cancel: cancel)</span><br><span class="line">        <span class="keyword">let</span> subscription = sink.run(<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">return</span> (sink: sink, subscription: subscription)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，可观察序列的创建是利用扩展<code>ObservableType</code>协议的<code>create</code>方法实现的,里面创建了<code>AnonymousObservable</code>(匿名可观察序列) ，这个命名体现了作者的思维，这是一个内部类，具备一些通用特性（具有自己功能的类才会命名）可以总结一下：</p>
<ul>
<li><code>create</code>方法的时候创建了一个内部对象<code>AnonymousObservable</code></li>
<li><code>AnonymousObservable</code>保存了外界传入的闭包</li>
<li><code>AnonymousObservable</code>继承了<code>Producer</code></li>
</ul>
<p>接下来我们看一下<code>Producer</code>类</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span>&lt;<span class="title">Element</span>&gt;: <span class="title">Observable</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span>&lt;Observer: ObserverType&gt;<span class="params">(<span class="number">_</span> observer: Observer)</span></span> -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">Observer</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !<span class="type">CurrentThreadScheduler</span>.isScheduleRequired &#123;</span><br><span class="line">            <span class="comment">// The returned disposable needs to release all references once it was disposed.</span></span><br><span class="line">            <span class="keyword">let</span> disposer = <span class="type">SinkDisposer</span>()</span><br><span class="line">            <span class="keyword">let</span> sinkAndSubscription = <span class="keyword">self</span>.run(observer, cancel: disposer)</span><br><span class="line">            disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink, subscription: sinkAndSubscription.subscription)</span><br><span class="line">            <span class="keyword">return</span> disposer</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">CurrentThreadScheduler</span>.instance.schedule(()) &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">let</span> disposer = <span class="type">SinkDisposer</span>()</span><br><span class="line">                <span class="keyword">let</span> sinkAndSubscription = <span class="keyword">self</span>.run(observer, cancel: disposer)</span><br><span class="line">                disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink, subscription: sinkAndSubscription.subscription)</span><br><span class="line">                <span class="keyword">return</span> disposer</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span>&lt;Observer: ObserverType&gt;<span class="params">(<span class="number">_</span> observer: Observer, cancel: Cancelable)</span></span> -&gt; (sink: <span class="type">Disposable</span>, subscription: <span class="type">Disposable</span>) <span class="keyword">where</span> <span class="type">Observer</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">        rxAbstractMethod()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到Producer有一个很重要的方法<code>subscribe</code>(订阅)，<code>subscribe</code>方法最后返回一个<code>Disposable</code>对象。</p>
<h3 id="订阅序列"><a href="#订阅序列" class="headerlink" title="订阅序列"></a>订阅序列</h3><p>我们看一下<code>ObservableType</code>拓展（ObservableType+Extensions.swift）的功能，订阅的方法<code>subscribe</code>（注意这个方法和<code>Producer</code>的<code>subscribe</code>不是同一个）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     Subscribes an element handler, an error handler, a completion handler and disposed handler to an observable sequence.</span></span><br><span class="line"><span class="comment">     - parameter onNext: Action to invoke for each element in the observable sequence.</span></span><br><span class="line"><span class="comment">     - parameter onError: Action to invoke upon errored termination of the observable sequence.</span></span><br><span class="line"><span class="comment">     - parameter onCompleted: Action to invoke upon graceful termination of the observable sequence.</span></span><br><span class="line"><span class="comment">     - parameter onDisposed: Action to invoke upon any type of termination of sequence (if the sequence has</span></span><br><span class="line"><span class="comment">     gracefully completed, errored, or if the generation is canceled by disposing subscription).</span></span><br><span class="line"><span class="comment">     - returns: Subscription object used to unsubscribe from the observable sequence.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        onNext: <span class="params">(<span class="params">(Element)</span></span></span></span> -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span>,</span><br><span class="line">        onError: ((<span class="type">Swift</span>.<span class="type">Error</span>) -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span>,</span><br><span class="line">        onCompleted: (() -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span>,</span><br><span class="line">        onDisposed: (() -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span></span><br><span class="line">    ) -&gt; <span class="type">Disposable</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> disposable: <span class="type">Disposable</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> disposed = onDisposed &#123;</span><br><span class="line">                disposable = <span class="type">Disposables</span>.create(with: disposed)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                disposable = <span class="type">Disposables</span>.create()</span><br><span class="line">            &#125;</span><br><span class="line">            #<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line">                <span class="keyword">let</span> synchronizationTracker = <span class="type">SynchronizationTracker</span>()</span><br><span class="line">            #endif</span><br><span class="line">            <span class="keyword">let</span> callStack = <span class="type">Hooks</span>.recordCallStackOnError ? <span class="type">Hooks</span>.customCaptureSubscriptionCallstack() : []</span><br><span class="line">      			<span class="comment">///以下重点关注的代码 创建匿名观察者</span></span><br><span class="line">            <span class="keyword">let</span> observer = <span class="type">AnonymousObserver</span>&lt;<span class="type">Element</span>&gt; &#123; event <span class="keyword">in</span> </span><br><span class="line">                #<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line">                    synchronizationTracker.register(synchronizationErrorMessage: .<span class="keyword">default</span>)</span><br><span class="line">                    <span class="keyword">defer</span> &#123; synchronizationTracker.unregister() &#125;</span><br><span class="line">                #endif</span><br><span class="line">                <span class="keyword">switch</span> event &#123;</span><br><span class="line">                <span class="keyword">case</span> .next(<span class="keyword">let</span> value):</span><br><span class="line">                    onNext?(value)</span><br><span class="line">                <span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> onError = onError &#123;</span><br><span class="line">                        onError(error)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="type">Hooks</span>.defaultErrorHandler(callStack, error)</span><br><span class="line">                    &#125;</span><br><span class="line">                    disposable.dispose()</span><br><span class="line">                <span class="keyword">case</span> .completed:</span><br><span class="line">                    onCompleted?()</span><br><span class="line">                    disposable.dispose()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Disposables</span>.create(</span><br><span class="line">                <span class="keyword">self</span>.asObservable().subscribe(observer),</span><br><span class="line">                disposable</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码说明：</p>
<ul>
<li><p><code>E</code>是<code>Swift</code>的关联类型，这个如果仔细看过可观察序列的继承链源码应该不难得出：这个<code>E</code> 就是我们的 序列类型，我们这里就是<code>String</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span>&lt;<span class="title">Element</span>&gt; : <span class="title">ObservableType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Type of elements in sequence.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">E</span> = <span class="type">Element</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建<code>AnonymousObserver</code>对象，可以类比前面<code>create</code>的<code>AnonymousObservable</code>对象，初始化参数为闭包，保存了外界传入的<code>onNext</code>,<code>onError</code>,<code>onComplete</code>,<code>onDisposed</code>的处理回调闭包。</p>
</li>
<li><p><code>self.asObservable()</code>是我们的<code>RxSwift</code>为了保持一致性的写法。</p>
</li>
<li><p><code>self.asObservable().subscribe(observer)</code>其实本质就是<code>self.</code>subscribe(observer),通过可观察序列的继承关系，我们可以快速定位到<code>Producer</code>订阅代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span>&lt;Observer: ObserverType&gt;<span class="params">(<span class="number">_</span> observer: Observer)</span></span> -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">Observer</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !<span class="type">CurrentThreadScheduler</span>.isScheduleRequired &#123;</span><br><span class="line">        <span class="comment">// The returned disposable needs to release all references once it was disposed.</span></span><br><span class="line">        <span class="keyword">let</span> disposer = <span class="type">SinkDisposer</span>()</span><br><span class="line">        <span class="keyword">let</span> sinkAndSubscription = <span class="keyword">self</span>.run(observer, cancel: disposer)</span><br><span class="line">        disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink, subscription: sinkAndSubscription.subscription)</span><br><span class="line">        <span class="keyword">return</span> disposer</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CurrentThreadScheduler</span>.instance.schedule(()) &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> disposer = <span class="type">SinkDisposer</span>()</span><br><span class="line">            <span class="keyword">let</span> sinkAndSubscription = <span class="keyword">self</span>.run(observer, cancel: disposer)</span><br><span class="line">            disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink, subscription: sinkAndSubscription.subscription)</span><br><span class="line">            <span class="keyword">return</span> disposer</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>销毁代码后面在分析</p>
</li>
<li><p><code>self.run</code>这个代码最终由我们生产者<code>Producer</code>(抽象方法找子类)延伸到具体事务代码<code>AnonymousObservable.run</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">run</span>&lt;Observer: ObserverType&gt;<span class="params">(<span class="number">_</span> observer: Observer, cancel: Cancelable)</span></span> -&gt; (sink: <span class="type">Disposable</span>, subscription: <span class="type">Disposable</span>) <span class="keyword">where</span> <span class="type">Observer</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> sink = <span class="type">AnonymousObservableSink</span>(observer: observer, cancel: cancel)</span><br><span class="line">      <span class="keyword">let</span> subscription = sink.run(<span class="keyword">self</span>)</span><br><span class="line">      <span class="keyword">return</span> (sink: sink, subscription: subscription)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里调用了<code>sink.run(self)</code>方法，将业务处理下沉，分工更加明确。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(<span class="number">_</span> parent: Parent)</span></span> -&gt; <span class="type">Disposable</span> &#123;</span><br><span class="line">    parent.subscribeHandler(<span class="type">AnyObserver</span>(<span class="keyword">self</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>parent</code>是上面传入进来的<code>AnonymousObservable</code>对象</p>
</li>
<li><p>这个地方我们可以看到调用了<code>AnonymousObservable</code>对象的<code>subscribeHandler</code>方法，这里我们清楚了，为什么<code>序列订阅</code>的时候流程会执行我们的<code>序列闭包</code>，然后去执行<code>发送响应</code></p>
</li>
<li><p>发送响应的代码后面再分析，下面还有个点是<code>AnyObserver(self)</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Construct an instance whose `on(event)` calls `observer.on(event)`</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - parameter observer: Observer that receives sequence events.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">Observer</span>: <span class="type">ObserverType</span>&gt;(<span class="number">_</span> observer: <span class="type">Observer</span>) <span class="keyword">where</span> <span class="type">Observer</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">     <span class="keyword">self</span>.observer = observer.on</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个构造方法里面，我们创建了一个结构体<code>AnyObserver</code>保存了一个信息<code>AnonymousObservableSink.on</code>函数。注意不是<code>AnonymousObservableSink</code></p>
</li>
</ul>
<h3 id="发送响应"><a href="#发送响应" class="headerlink" title="发送响应"></a>发送响应</h3><p>通过上面的分析，我们清楚了<code>observer.onNext(&quot;&quot;)</code>本质是<code>AnyObserver.onNext(&quot;&quot;)</code>,我们发现AnyObserver没有这个方法，顺着思路找父类，找<code>ObserverType</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Convenience API extensions to provide alternate next, error, completed events</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ObserverType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Convenience method equivalent to `on(.next(element: Element))`</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - parameter element: Next element to send to observer(s)</span></span><br><span class="line">  	<span class="comment">///这里是我们关注的点 AnyObserver.onNext("")实际调用这里</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">onNext</span><span class="params">(<span class="number">_</span> element: Element)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.on(.next(element))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Convenience method equivalent to `on(.completed)`</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">onCompleted</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.on(.completed)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Convenience method equivalent to `on(.error(Swift.Error))`</span></span><br><span class="line">    <span class="comment">/// - parameter error: Swift.Error to send to observer(s)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">onError</span><span class="params">(<span class="number">_</span> error: Swift.Error)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.on(.error(error))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>外界调用的<code>observer.onNext(&quot;&quot;)</code>再次变形：<code>AnyObserver.on(.next(&quot;&quot;))</code>,<code>AnyObserver</code>调用了<code>on</code>里面的<code>.next</code>函数，<code>.next</code>函数带有我们最终的参数</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Construct an instance whose `on(event)` calls `observer.on(event)`</span></span><br><span class="line"><span class="comment">/// - parameter observer: Observer that receives sequence events.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">Observer</span>: <span class="type">ObserverType</span>&gt;(<span class="number">_</span> observer: <span class="type">Observer</span>) <span class="keyword">where</span> <span class="type">Observer</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.observer = observer.on</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// Send `event` to this observer.</span></span><br><span class="line"><span class="comment">/// - parameter event: Event instance.</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">on</span><span class="params">(<span class="number">_</span> event: Event&lt;Element&gt;)</span></span> &#123;</span><br><span class="line">     <span class="keyword">self</span>.observer(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>self.observer</code> 构造初始化就是：<code>AnonymousObservableSink .on 函数</code></p>
</li>
<li><p><code>self.observer(event)</code> -&gt; <code>AnonymousObservableSink .on(event)</code> 其中 <code>event = .next(&quot;&quot;)</code> 最终我们的核心逻辑又回到了 <code>sink</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousObservableSink</span>&lt;<span class="title">Observer</span>: <span class="title">ObserverType</span>&gt;: <span class="title">Sink</span>&lt;<span class="title">Observer</span>&gt;, <span class="title">ObserverType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">on</span><span class="params">(<span class="number">_</span> event: Event&lt;Element&gt;)</span></span> &#123;</span><br><span class="line">        #<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line">            <span class="keyword">self</span>.synchronizationTracker.register(synchronizationErrorMessage: .<span class="keyword">default</span>)</span><br><span class="line">            <span class="keyword">defer</span> &#123; <span class="keyword">self</span>.synchronizationTracker.unregister() &#125;</span><br><span class="line">        #endif</span><br><span class="line">        <span class="keyword">switch</span> event &#123;</span><br><span class="line">        <span class="keyword">case</span> .next:</span><br><span class="line">            <span class="keyword">if</span> load(<span class="keyword">self</span>.isStopped) == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.forwardOn(event)</span><br><span class="line">        <span class="keyword">case</span> .error, .completed:</span><br><span class="line">            <span class="keyword">if</span> fetchOr(<span class="keyword">self</span>.isStopped, <span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.forwardOn(event)</span><br><span class="line">                <span class="keyword">self</span>.dispose()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>self.forwardOn(event)</code> 这也是执行的核心代码，因为 <code>AnonymousObservableSink</code> 继承 <code>Sink</code> 这里还有封装，请看下面的代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sink</span>&lt;<span class="title">Observer</span>: <span class="title">ObserverType</span>&gt;: <span class="title">Disposable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="function"><span class="keyword">func</span> <span class="title">forwardOn</span><span class="params">(<span class="number">_</span> event: Event&lt;Observer.Element&gt;)</span></span> &#123;</span><br><span class="line">        #<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line">            <span class="keyword">self</span>.synchronizationTracker.register(synchronizationErrorMessage: .<span class="keyword">default</span>)</span><br><span class="line">            <span class="keyword">defer</span> &#123; <span class="keyword">self</span>.synchronizationTracker.unregister() &#125;</span><br><span class="line">        #endif</span><br><span class="line">        <span class="keyword">if</span> isFlagSet(<span class="keyword">self</span>.disposed, <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.observer.on(event)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其中 <code>self.observer</code> 就是我们初始化保存的 <code>观察者：AnonymousObserver</code></p>
</li>
<li><p>到这里我们得出了发送序列的本质就是<code>AnonymousObserver.on（.next(&quot;&quot;)）</code>,这个逻辑又回到了我们<code>订阅序列</code>时候创建的<code>AnonymousObserver</code>参数闭包的调用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="type">AnonymousObserver</span>&lt;<span class="type">E</span>&gt; &#123; event <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> event &#123;</span><br><span class="line">    <span class="keyword">case</span> .next(<span class="keyword">let</span> value):</span><br><span class="line">        onNext?(value)</span><br><span class="line">    <span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> onError = onError &#123;</span><br><span class="line">            onError(error)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Hooks</span>.defaultErrorHandler(callStack, error)</span><br><span class="line">        &#125;</span><br><span class="line">        disposable.dispose()</span><br><span class="line">    <span class="keyword">case</span> .completed:</span><br><span class="line">        onCompleted?()</span><br><span class="line">        disposable.dispose()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断<code>event</code>进而调用<code>onNext?(value)</code>,因为枚举的关联值<code>value=&quot;&quot;</code>,接下来外界<code>onNext</code>的调用参数。</p>
</li>
</ul>
<h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><p>我们先看一下创建序列到销毁的执行代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建序列</span></span><br><span class="line"><span class="keyword">let</span> ob = <span class="type">Observable</span>&lt;<span class="type">Any</span>&gt;.create &#123; (observer) -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">    observer.onNext(<span class="string">"Jason"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"销毁释放了"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 序列订阅</span></span><br><span class="line"><span class="keyword">let</span> dispose = ob.subscribe(onNext: &#123; (anything) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"订阅到了:\(anything)"</span>)</span><br><span class="line">&#125;, onError: &#123; (error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"订阅到了:\(error)"</span>)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"完成了"</span>)</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"销毁回调"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这段代码里面关于销毁相关的代码就是<code>Disposables.create {print(&quot;销毁释放了&quot;)}</code>,所以我们直接定位到<code>Disposables</code>类（AnonymousDisposable.swift文件）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Disposables</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Constructs a new disposable with the given action used for disposal.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - parameter dispose: Disposal action which will be run upon calling `dispose`.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(with dispose: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Cancelable</span> &#123;</span><br><span class="line">        <span class="type">AnonymousDisposable</span>(disposeAction: dispose)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以看出，这里创建了一个匿名销毁序列<code>AnonymousDisposable</code>,和订阅一样的手法。继续看<code>AnonymousDisposable</code>代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// When dispose method is called, disposal action will be dereferenced.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousDisposable</span> : <span class="title">DisposeBase</span>, <span class="title">Cancelable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Non-deprecated version of the constructor, used by `Disposables.create(with:)`</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">init</span>(disposeAction: @escaping <span class="type">DisposeAction</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.disposeAction = disposeAction</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Calls the disposal action if and only if the current instance hasn't been disposed yet.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// After invoking disposal action, disposal action will be dereferenced.</span></span><br><span class="line">    <span class="comment">///销毁核心的逻辑</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">dispose</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> fetchOr(<span class="keyword">self</span>.disposed, <span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> action = <span class="keyword">self</span>.disposeAction &#123;</span><br><span class="line">                <span class="keyword">self</span>.disposeAction = <span class="literal">nil</span></span><br><span class="line">                action()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上我们看到，初始化方法里保存了销毁响应闭包，什么时候调用，我们看下面的<code>dispose()</code>方法。</p>
</li>
<li><p>fetchOr(self.disposed, 1)是一个单项标记手段，这里利用了牛逼的算法标记可以降低依赖和更加快速。</p>
</li>
<li><p>主要就是保证只会销毁一次</p>
</li>
<li><p>销毁会首先<code>self.disposeAction = nil</code>,将回调闭包置空</p>
</li>
<li><p>最后调用闭包调用<code>action()</code>,这里是一个局部变量不需要再置空</p>
</li>
</ul>
<p>下面我们看一下<code>dispose()</code>是什么时候调用的</p>
<p>上面的流程，我们再序列的回调闭包：<code>subscriberHandle</code>里面，这个流程之前有一个重要的流程就是订阅<code>subscriber</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> disposed = onDisposed &#123;</span><br><span class="line">  disposable = <span class="type">Disposables</span>.create(with: disposed)  </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  disposable = <span class="type">Disposables</span>.create()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这里保存外界传入的销毁闭包</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> event &#123;</span><br><span class="line"><span class="keyword">case</span> .next(<span class="keyword">let</span> value):</span><br><span class="line">    onNext?(value)</span><br><span class="line"><span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">  <span class="comment">// 响应外界调回闭包</span></span><br><span class="line">    disposable.dispose()</span><br><span class="line"><span class="keyword">case</span> .completed:</span><br><span class="line">  <span class="comment">// 响应外界调回闭包</span></span><br><span class="line">    disposable.dispose()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>观察者回调里面调用， 响应外界调回闭包</p>
</li>
</ul>
<ul>
<li><code>return Disposables.create(self.asObservable().subscribe(observer),disposable)</code> 综合来看，我们的重点必然在这句代码，沟通下面流程的 <code>subscribe</code>, 外界订阅返回的销毁者（可以随时随地进行 <code>dispose.dispose()</code> ）</li>
<li>上面代码跟进去看到<code>BinaryDisposable(disposable1, disposable2)</code> 原来创建的二元销毁者！</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dispose</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> fetchOr(<span class="keyword">self</span>._isDisposed, <span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>._disposable1?.dispose()</span><br><span class="line">        <span class="keyword">self</span>._disposable2?.dispose()</span><br><span class="line">        <span class="keyword">self</span>._disposable1 = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>._disposable2 = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>二元销毁者的 <code>dispose</code> 方法也在预料之中，分别销毁</p>
</li>
<li><p>那么我们的重点就应该探索，在 <code>subscribe</code> 这里面创建的关键销毁者是什么?</p>
</li>
<li><p>下面我们进入非常熟悉的：<code>Producer</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> disposer = <span class="type">SinkDisposer</span>()</span><br><span class="line"><span class="keyword">let</span> sinkAndSubscription = <span class="keyword">self</span>.run(observer, cancel: disposer)</span><br><span class="line">disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink,</span><br><span class="line"> subscription: sinkAndSubscription.subscription)</span><br><span class="line"><span class="comment">// 返回销毁者</span></span><br><span class="line"><span class="keyword">return</span> disposer</span><br></pre></td></tr></table></figure>
</li>
<li><p>看到 <code>SinkDisposer</code> 就熟悉了，普通销毁者：<code>AnonymousDisposable</code> , 关键销毁者： <code>SinkDisposer</code></p>
</li>
<li><p>先看什么东西进入了 <code>SinkDisposer</code></p>
</li>
<li><p><code>self.run(observer, cancel: disposer)</code> 证明里面需要用到 <code>SinkDisposer</code></p>
</li>
<li><p><code>disposer.setSinkAndSubscription</code> 常规操作</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setSinkAndSubscription</span><span class="params">(sink: Disposable, subscription: Disposable)</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>._sink = sink</span><br><span class="line">    <span class="keyword">self</span>._subscription = subscription</span><br><span class="line"><span class="comment">// 获取状态 </span></span><br><span class="line">    <span class="keyword">let</span> previousState = fetchOr(<span class="keyword">self</span>._state, </span><br><span class="line"><span class="type">DisposeState</span>.sinkAndSubscriptionSet.rawValue)</span><br><span class="line"><span class="comment">// 如果状态满足就销毁</span></span><br><span class="line">    <span class="keyword">if</span> (previousState &amp; <span class="type">DisposeState</span>.disposed.rawValue) != <span class="number">0</span> &#123;</span><br><span class="line">        sink.dispose()</span><br><span class="line">        subscription.dispose()</span><br><span class="line">        <span class="keyword">self</span>._sink = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>._subscription = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>保存了两个属性 : <code>sink</code> 和 <code>subscription</code>(就是外界创建序列的闭包的返回销毁者)</p>
</li>
<li><p>取了某一个状态：<code>previousState</code>,判断状态的条件，然后执行 这两个保存属性的销毁和置空释放销毁 ： <code>.dispose() + = nil</code></p>
</li>
<li><p>其实是可以理解，就是我们在加入的东西其实需要销毁的，不应该保留的，那么没必要给它继续保留生命迹象</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 sink 保存了销毁者</span></span><br><span class="line"><span class="keyword">let</span> sink = <span class="type">AnonymousObservableSink</span>(observer: observer, cancel: cancel)</span><br><span class="line"><span class="comment">// 省略不相管代码。。。。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">on</span><span class="params">(<span class="number">_</span> event: Event&lt;Element&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> event &#123;</span><br><span class="line">    <span class="keyword">case</span> .next:</span><br><span class="line">        <span class="keyword">self</span>.forwardOn(event)</span><br><span class="line">    <span class="keyword">case</span> .error, .completed:</span><br><span class="line">        <span class="keyword">if</span> fetchOr(<span class="keyword">self</span>._isStopped, <span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.forwardOn(event)</span><br><span class="line">            <span class="comment">// 关键点：完成和错误信号的响应式必然会直接开启销毁的</span></span><br><span class="line">            <span class="keyword">self</span>.dispose()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>完成和错误信号的响应式必然会直接开启销毁的 ： <code>self.dispose()</code>! 这里也解释了：一旦我们的序列发出完成或者错误就无法再次响应了！</p>
</li>
<li><p>剩下一个问题： <strong>到底我们的销毁的是什么</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dispose</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> previousState = fetchOr(<span class="keyword">self</span>._state, <span class="type">DisposeState</span>.disposed.rawValue)</span><br><span class="line">    <span class="keyword">if</span> (previousState &amp; <span class="type">DisposeState</span>.sinkAndSubscriptionSet.rawValue) != <span class="number">0</span> &#123;</span><br><span class="line">        sink.dispose()</span><br><span class="line">        subscription.dispose()</span><br><span class="line">        <span class="keyword">self</span>._sink = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>._subscription = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>无论我们直接销毁还是系统帮助我们销毁必然会调用：<code>dispose()</code></p>
</li>
<li><p>我们查看 <code>dispose()</code> 得出: 就是在初始化初期我们保留的两个属性的操作</p>
</li>
<li><p><code>sink.dispose() + self._sink = nil</code> &amp; <code>subscription.dispose() + self._subscription = nil</code> 执行相关释放和销毁</p>
</li>
</ul>
<h4 id="总结一下销毁"><a href="#总结一下销毁" class="headerlink" title="总结一下销毁"></a>总结一下销毁</h4><p>第一：内部创建的临时序列和观察者都会随着对外的观察者和序列的生命周期而销毁释放。</p>
<p>第二：外界观察者和序列会随着他们的作用域空间而释放</p>
<p>第三：释放不了只是对象的释放有问题，常规内存管理问题</p>
<p>第四：最为一个再牛逼的框架也不能对程序员写的代码直接管理控制</p>
<p>第五：<code>RxSwift</code> 的观察和序列以及销毁者就是普通对象。</p>
<p>到这里RxSwift从创建序列-&gt;订阅序列-&gt;发送信号-&gt;销毁的源码解析就结束了，里面的精妙还是需要细细品味的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/28/GitHub-s-file-size-limit-of-100-00-MB%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/28/GitHub-s-file-size-limit-of-100-00-MB%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/" class="post-title-link" itemprop="url">GitHub's file size limit of 100.00 MB解决办法(转)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-28 14:42:48 / 修改时间：17:32:00" itemprop="dateCreated datePublished" datetime="2021-05-28T14:42:48+08:00">2021-05-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">遇到的问题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上传github发现不给上传100m以上文件的错误,按着提示进行了,用到一个叫lfs的工具专门用来上传大文件的！附<a href="https://github.com/git-lfs/git-lfs" target="_blank" rel="noopener">git-lfs</a> 1.安装 mac</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install git-lfs</span><br><span class="line">git lfs install</span><br></pre></td></tr></table></figure>

<p>找出超过100m的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 目标项目path</span><br><span class="line">find .&#x2F; -size +100M</span><br></pre></td></tr></table></figure>

<p>大文件加入git large file storage上面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git lfs track &quot;name_of_a_giant_file&quot;</span><br><span class="line">#example:</span><br><span class="line">git lfs track &quot;.&#x2F;&#x2F;huanxin&#x2F;HXTest&#x2F;Hyphenate.framework&#x2F;Hyphenate&quot;</span><br></pre></td></tr></table></figure>

<p>添加到git上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add path_of_a_giant_file</span><br><span class="line">#example:</span><br><span class="line">git add .&#x2F;&#x2F;huanxin&#x2F;HXTest&#x2F;Hyphenate.framework&#x2F;Hyphenate</span><br></pre></td></tr></table></figure>

<p>仅供记录以后遇到类似问题查找。</p>
<p><a href="https://juejin.cn/post/6844904205476478989" target="_blank" rel="noopener">原文地址</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/21/flutter%E6%8E%A2%E7%B4%A2-%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/21/flutter%E6%8E%A2%E7%B4%A2-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">flutter探索  - 多线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-21 10:36:00 / 修改时间：16:06:28" itemprop="dateCreated datePublished" datetime="2021-05-21T10:36:00+08:00">2021-05-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Flutter默认是单线程任务处理的，如果不开启新的线程，任务默认在主线程中处理。</p>
<h3 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a>事件队列</h3><p>和iOS应用很像，在<code>Dart</code>的线程中也存在事件循环和消息队列的概念，但在<code>Dart</code>中线程叫做<code>isolate</code>。应用程序启动后，开始执行<code>main</code>函数并运行<code>main isolate</code>。</p>
<p>每个<code>isolate</code>包含一个事件循环以及两个事件队列，<code>event loop</code>事件循环，以及<code>event queue</code>和<code>microtask queue</code>事件队列，<code>event</code>和<code>microtask</code>队列有点类似iOS的<code>source0</code>和<code>source1</code>。</p>
<ul>
<li>event queue：负责处理I/O事件、绘制事件、手势事件、接收其他<code>isolate</code>消息等外部事件。</li>
<li>microtask queue：可以自己向<code>isolate</code>内部添加事件，事件的优先级比<code>event queue</code>高。</li>
</ul>
<p>这两个队列也是有优先级的，当<code>isolate</code>开始执行后，会先处理<code>microtask</code>的事件，当<code>microtask</code>队列中没有事件后，才会处理<code>event</code>队列中的事件，并按照这个顺序反复执行。但需要注意的是，当执行<code>microtask</code>事件时，会阻塞<code>event</code>队列的事件执行，这样就会导致渲染、手势响应等<code>event</code>事件响应延时。为了保证渲染和手势响应，应该尽量将耗时操作放在<code>event</code>队列中。</p>
<h3 id="async、await"><a href="#async、await" class="headerlink" title="async、await"></a>async、await</h3><p>在异步调用中有三个关键词，<code>async</code>、<code>await</code>、<code>Future</code>，其中<code>async</code>和<code>await</code>需要一起使用。在<code>Dart</code>中可以通过<code>async</code>和<code>await</code>进行异步操作，<code>async</code>表示开启一个异步操作，也可以返回一个<code>Future</code>结果。如果没有返回值，则默认返回一个返回值为<code>null</code>的<code>Future</code>。</p>
<p><code>async</code>、<code>await</code>本质上就是<code>Dart</code>对异步操作的一个语法糖，可以减少异步调用的嵌套调用，并且由<code>async</code>修饰后返回一个<code>Future</code>，外界可以以链式调用的方式调用。这个语法是<code>JS</code>的<code>ES7</code>标准中推出的，<code>Dart</code>的设计和<code>JS</code>相同。</p>
<p>下面封装了一个网络请求的异步操作，并且将请求后的<code>Response</code>类型的<code>Future</code>返回给外界，外界可以通过<code>await</code>调用这个请求，并获取返回数据。从代码中可以看到，即便直接返回一个字符串，<code>Dart</code>也会对其进行包装并成为一个<code>Future</code>。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Response&gt; dataReqeust() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="built_in">String</span> requestURL = <span class="string">'https://jsonplaceholder.typicode.com/posts'</span>;</span><br><span class="line">    Client client = Client();</span><br><span class="line">    Future&lt;Response&gt; response = client.<span class="keyword">get</span>(requestURL);</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; loadData() <span class="keyword">async</span> &#123;</span><br><span class="line">    Response response = <span class="keyword">await</span> dataReqeust();</span><br><span class="line">    <span class="keyword">return</span> response.body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码示例中，执行到<code>loadData</code>方法时，会同步进入方法内部进行执行，当执行到<code>await</code>时就会停止<code>async</code>内部的执行，从而继续执行外面的代码。当<code>await</code>有返回后，会继续从<code>await</code>的位置继续执行。所以<code>await</code>的操作，不会影响后面代码的执行。</p>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p><code>Future</code>就是延时操作的一个封装，可以将异步任务封装为<code>Future</code>对象。获取到<code>Future</code>对象后，最简单的方法就是用<code>await</code>修饰，并等待返回结果继续向下执行。正如上面<code>async、await</code>中讲到的，使用<code>await</code>修饰时需要配合<code>async</code>一起使用。</p>
<p>在<code>Dart</code>中，和时间相关的操作基本都和<code>Future</code>有关，例如延时操作、异步操作等。下面是一个很简单的延时操作，通过<code>Future</code>的<code>delayed</code>方法实现。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">loadData() &#123;</span><br><span class="line">    <span class="comment">// DateTime.now()，获取当前时间</span></span><br><span class="line">    <span class="built_in">DateTime</span> now = <span class="built_in">DateTime</span>.now();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'request begin <span class="subst">$now</span>'</span>);</span><br><span class="line">    Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">1</span>), ()&#123;</span><br><span class="line">      now = <span class="built_in">DateTime</span>.now();</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'request response <span class="subst">$now</span>'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Dart</code>还支持对<code>Future</code>的链式调用，通过追加一个或多个<code>then</code>方法来实现，这个特性非常实用。例如一个延时操作完成后，会调用<code>then</code>方法，并且可以传递一个参数给<code>then</code>。调用方式是链式调用，也就代表可以进行很多层的处理。这有点类似于iOS的<code>RAC</code>框架，链式调用进行信号处理。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">1</span>), ()&#123;</span><br><span class="line">  <span class="built_in">int</span> age = <span class="number">18</span>;</span><br><span class="line">  <span class="keyword">return</span> age;</span><br><span class="line">&#125;).then((onValue)&#123;</span><br><span class="line">  onValue++;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'age <span class="subst">$onValue</span>'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>如果想要了解<code>async</code>、<code>await</code>的原理，就要先了解协程的概念，<code>async</code>、<code>await</code>本质上就是协程的一种语法糖。协程，也叫作<code>coroutine</code>，是一种比线程更小的单元。如果从单元大小来说，基本可以理解为进程-&gt;线程-&gt;协程。</p>
<h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>在弄懂协程之前，首先要明白并发和并行的概念，并发指的是由系统来管理多个IO的切换，并交由CPU去处理。并行指的是多核CPU在同一时间里执行多个任务。</p>
<p>并发的实现由非阻塞操作+事件通知来完成，事件通知也叫做“中断”。操作过程分为两种，一种是CPU对IO进行操作，在操作完成后发起中断告诉IO操作完成。另一种是IO发起中断，告诉CPU可以进行操作。</p>
<p>线程本质上也是依赖于中断来进行调度的，线程还有一种叫做“阻塞式中断”，就是在执行IO操作时将线程阻塞，等待执行完成后再继续执行。但线程的消耗是很大的，并不适合大量并发操作的处理，而通过单线程并发可以进行大量并发操作。当多核CPU出现后，单个线程就无法很好的利用多核CPU的优势了，所以又引入了线程池的概念，通过线程池来管理大量线程。</p>
<h3 id="协程-1"><a href="#协程-1" class="headerlink" title="协程"></a>协程</h3><p>在程序执行过程中，离开当前的调用位置有两种方式，继续调用其他函数和<code>return</code>返回离开当前函数。但是执行<code>return</code>时，当前函数在调用栈中的局部变量、形参等状态则会被销毁。</p>
<p>协程分为无线协程和有线协程，无线协程在离开当前调用位置时，会将当前变量放在堆区，当再次回到当前位置时，还会继续从堆区中获取到变量。所以，一般在执行当前函数时就会将变量直接分配到堆区，而<code>async</code>、<code>await</code>就属于无线协程的一种。有线协程则会将变量继续保存在栈区，在回到指针指向的离开位置时，会继续从栈中取出调用。</p>
<h3 id="async、await原理"><a href="#async、await原理" class="headerlink" title="async、await原理"></a>async、await原理</h3><p>以<code>async</code>、<code>await</code>为例，协程在执行时，执行到<code>async</code>则表示进入一个协程，会同步执行<code>async</code>的代码块。<code>async</code>的代码块本质上也相当于一个函数，并且有自己的上下文环境。当执行到<code>await</code>时，则表示有任务需要等待，CPU则去调度执行其他IO，也就是后面的代码或其他协程代码。过一段时间CPU就会轮训一次，看某个协程是否任务已经处理完成，有返回结果可以被继续执行，如果可以被继续执行的话，则会沿着上次离开时指针指向的位置继续执行，也就是<code>await</code>标志的位置。</p>
<p>由于并没有开启新的线程，只是进行IO中断改变CPU调度，所以网络请求这样的异步操作可以使用<code>async</code>、<code>await</code>，但如果是执行大量耗时同步操作的话，应该使用<code>isolate</code>开辟新的线程去执行。</p>
<p>如果用协程和iOS的<code>dispatch_async</code>进行对比，可以发现二者是比较相似的。从结构定义来看，协程需要将当前<code>await</code>的代码块相关的变量进行存储，<code>dispatch_async</code>也可以通过<code>block</code>来实现临时变量的存储能力。</p>
<p>我之前还在想一个问题，苹果为什么不引入协程的特性呢？后来想了一下，<code>await</code>和<code>dispatch_async</code>都可以简单理解为异步操作，OC的线程是基于<code>Runloop</code>实现的，<code>Dart</code>本质上也是有事件循环的，而且二者都有自己的事件队列，只是队列数量和分类不同。</p>
<p>我觉得当执行到<code>await</code>时，保存当前的上下文，并将当前位置标记为待处理任务，用一个指针指向当前位置，并将待处理任务放入当前<code>isolate</code>的队列中。在每个事件循环时都去询问这个任务，如果需要进行处理，就恢复上下文进行任务处理。</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>这里想提一下<code>JS</code>里的<code>Promise</code>语法，在iOS中会出现很多<code>if</code>判断或者其他的嵌套调用，而<code>Promise</code>可以把之前横向的嵌套调用，改成纵向链式调用。如果能把<code>Promise</code>引入到OC里，可以让代码看起来更简洁，直观。</p>
<h3 id="isolate"><a href="#isolate" class="headerlink" title="isolate"></a>isolate</h3><p><code>isolate</code>是<code>Dart</code>平台对线程的实现方案，但和普通<code>Thread</code>不同的是，<code>isolate</code>拥有独立的内存，<code>isolate</code>由线程和独立内存构成。正是由于<code>isolate</code>线程之间的内存不共享，所以<code>isolate</code>线程之间并不存在资源抢夺的问题，所以也不需要锁。</p>
<p>通过<code>isolate</code>可以很好的利用多核CPU，来进行大量耗时任务的处理。<code>isolate</code>线程之间的通信主要通过<code>port</code>来进行，这个<code>port</code>消息传递的过程是异步的。通过<code>Dart</code>源码也可以看出，实例化一个<code>isolate</code>的过程包括，实例化<code>isolate</code>结构体、在堆中分配线程内存、配置<code>port</code>等过程。</p>
<p><code>isolate</code>看起来其实和进程比较相似，之前请教阿里架构师宗心问题时，宗心也说过“<code>isolate</code>的整体模型我自己的理解其实更像进程，而<code>async</code>、<code>await</code>更像是线程”。如果对比一下<code>isolate</code>和进程的定义，会发现确实<code>isolate</code>很像是进程。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>下面是一个<code>isolate</code>的例子，例子中新创建了一个<code>isolate</code>，并且绑定了一个方法进行网络请求和数据解析的处理，并通过<code>port</code>将处理好的数据返回给调用方。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">loadData() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// 通过spawn新建一个isolate，并绑定静态方法</span></span><br><span class="line">    ReceivePort receivePort =ReceivePort();</span><br><span class="line">    <span class="keyword">await</span> Isolate.spawn(dataLoader, receivePort.sendPort);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取新isolate的监听port</span></span><br><span class="line">    SendPort sendPort = <span class="keyword">await</span> receivePort.first;</span><br><span class="line">    <span class="comment">// 调用sendReceive自定义方法</span></span><br><span class="line">    <span class="built_in">List</span> dataList = <span class="keyword">await</span> sendReceive(sendPort, <span class="string">'https://jsonplaceholder.typicode.com/posts'</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'dataList <span class="subst">$dataList</span>'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// isolate的绑定方法</span></span><br><span class="line"><span class="keyword">static</span> dataLoader(SendPort sendPort) <span class="keyword">async</span>&#123;</span><br><span class="line">    <span class="comment">// 创建监听port，并将sendPort传给外界用来调用</span></span><br><span class="line">    ReceivePort receivePort =ReceivePort();</span><br><span class="line">    sendPort.send(receivePort.sendPort);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 监听外界调用</span></span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> msg <span class="keyword">in</span> receivePort) &#123;</span><br><span class="line">      <span class="built_in">String</span> requestURL =msg[<span class="number">0</span>];</span><br><span class="line">      SendPort callbackPort =msg[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">      Client client = Client();</span><br><span class="line">      Response response = <span class="keyword">await</span> client.<span class="keyword">get</span>(requestURL);</span><br><span class="line">      <span class="built_in">List</span> dataList = json.decode(response.body);</span><br><span class="line">      <span class="comment">// 回调返回值给调用者</span></span><br><span class="line">      callbackPort.send(dataList);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建自己的监听port，并且向新isolate发送消息</span></span><br><span class="line">Future sendReceive(SendPort sendPort, <span class="built_in">String</span> url) &#123;</span><br><span class="line">    ReceivePort receivePort =ReceivePort();</span><br><span class="line">    sendPort.send([url, receivePort.sendPort]);</span><br><span class="line">    <span class="comment">// 接收到返回值，返回给调用者</span></span><br><span class="line">    <span class="keyword">return</span> receivePort.first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>isolate</code>和iOS中的线程还不太一样，<code>isolate</code>的线程更偏底层。当生成一个<code>isolate</code>后，其内存是各自独立的，相互之间并不能进行访问。但<code>isolate</code>提供了基于<code>port</code>的消息机制，通过建立通信双方的<code>sendPort</code>和<code>receiveport</code>，进行相互的消息传递，在<code>Dart</code>中叫做消息传递。</p>
<p>从上面例子中可以看出，在进行<code>isolate</code>消息传递的过程中，本质上就是进行<code>port</code>的传递。将<code>port</code>传递给其他<code>isolate</code>，其他<code>isolate</code>通过<code>port</code>拿到<code>sendPort</code>，向调用方发送消息来进行相互的消息传递。</p>
<h3 id="Embedder"><a href="#Embedder" class="headerlink" title="Embedder"></a>Embedder</h3><p>正如其名，<code>Embedder</code>是一个嵌入层，将<code>Flutter</code>嵌入到各个平台上。<code>Embedder</code>负责范围包括原生平台插件、线程管理、事件循环等。</p>
<p><code>Embedder</code>中存在四个<code>Runner</code>，四个<code>Runner</code>分别如下。其中每个<code>Flutter Engine</code>各自对应一个<code>UI Runner</code>、<code>GPU Runner</code>、<code>IO Runner</code>，但所有<code>Engine</code>共享一个<code>Platform Runner</code>。</p>
<p><code>Runner</code>和<code>isolate</code>并不是一码事，彼此相互独立。以iOS平台为例，<code>Runner</code>的实现就是<code>CFRunLoop</code>，以一个事件循环的方式不断处理任务。并且<code>Runner</code>不只处理<code>Engine</code>的任务，还有<code>Native Plugin</code>带来的原生平台的任务。而<code>isolate</code>则由<code>Dart VM</code>进行管理，和原生平台线程并无关系。</p>
<h3 id="Platform-Runner"><a href="#Platform-Runner" class="headerlink" title="Platform Runner"></a>Platform Runner</h3><p><code>Platform Runner</code>和iOS平台的<code>Main Thread</code>非常相似，在<code>Flutter</code>中除耗时操作外，所有任务都应该放在<code>Platform</code>中，<code>Flutter</code>中的很多API并不是线程安全的，放在其他线程中可能会导致一些bug。</p>
<p>但例如IO之类的耗时操作，应该放在其他线程中完成，否则会影响<code>Platform</code>的正常执行，甚至于被<code>watchdog</code>干掉。但需要注意的是，由于<code>Embedder Runner</code>的机制，<code>Platform</code>被阻塞后并不会导致页面卡顿。</p>
<p>不只是<code>Flutter Engine</code>的代码在<code>Platform</code>中执行，<code>Native Plugin</code>的任务也会派发到<code>Platform</code>中执行。实际上，在原生侧的代码运行在<code>Platform Runner</code>中，而<code>Flutter</code>侧的代码运行在<code>Root Isolate</code>中，如果在<code>Platform</code>中执行耗时代码，则会卡原生平台的主线程。 </p>
<h3 id="UI-Runner"><a href="#UI-Runner" class="headerlink" title="UI Runner"></a>UI Runner</h3><p><code>UI Runner</code>负责为<code>Flutter Engine</code>执行<code>Root Isolate</code>的代码，除此之外，也处理来自<code>Native Plugin</code>的任务。<code>Root Isolate</code>为了处理自身事件，绑定了很多函数方法。程序启动时，<code>Flutter Engine</code>会为<code>Root</code>绑定<code>UI Runner</code>的处理函数，使<code>Root Isolate</code>具备提交渲染帧的能力。</p>
<p>当<code>Root Isolate</code>向<code>Engine</code>提交一次渲染帧时，<code>Engine</code>会等待下次vsync，当下次vsync到来时，由<code>Root Isolate</code>对<code>Widgets</code>进行布局操作，并生成页面的显示信息的描述，并将信息交给<code>Engine</code>去处理。</p>
<p>由于对<code>widgets</code>进行<code>layout</code>并生成<code>layer tree</code>是<code>UI Runner</code>进行的，如果在<code>UI Runner</code>中进行大量耗时处理，会影响页面的显示，所以应该将耗时操作交给其他<code>isolate</code>处理，例如来自<code>Native Plugin</code>的事件。</p>
<h3 id="GPU-Runner"><a href="#GPU-Runner" class="headerlink" title="GPU Runner"></a>GPU Runner</h3><p><code>GPU Runner</code>并不直接负责渲染操作，其负责GPU相关的管理和调度。当<code>layer tree</code>信息到来时，<code>GPU Runner</code>将其提交给指定的渲染平台，渲染平台是Skia配置的，不同平台可能有不同的实现。</p>
<p><code>GPU Runner</code>相对比较独立，除了<code>Embedder</code>外其他线程均不可向其提交渲染信息。</p>
<h3 id="IO-Runner"><a href="#IO-Runner" class="headerlink" title="IO Runner"></a>IO Runner</h3><p>一些<code>GPU Runner</code>中比较耗时的操作，就放在<code>IO Runner</code>中进行处理，例如图片读取、解压、渲染等操作。但是只有<code>GPU Runner</code>才能对GPU提交渲染信息，为了保证<code>IO Runner</code>也具备这个能力，所以<code>IO Runner</code>会引用<code>GPU Runner</code>的<code>context</code>，这样就具备向GPU提交渲染信息的能力</p>
<p><a href="https://www.jianshu.com/p/54da18ed1a9e" target="_blank" rel="noopener">本文地址</a></p>
<p><a href="https://www.jianshu.com/p/aaa6a8b1d6b0" target="_blank" rel="noopener">闲鱼讲解</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/19/flutter%E6%8E%A2%E7%B4%A2-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/19/flutter%E6%8E%A2%E7%B4%A2-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Flutter探索  - 状态管理分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-19 16:05:48" itemprop="dateCreated datePublished" datetime="2021-05-19T16:05:48+08:00">2021-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-20 09:57:51" itemprop="dateModified" datetime="2021-05-20T09:57:51+08:00">2021-05-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="状态管理是什么"><a href="#状态管理是什么" class="headerlink" title="状态管理是什么"></a>状态管理是什么</h3><p>我们知道最基本的程序是什么</p>
<ul>
<li><p>程序 = 算法 + 数据结构</p>
<p>数据是程序的中心。数据结构和算法两个概念间的逻辑关系贯穿整个程序世界，首先两者表现为不可分割的关系。flutter也是一个程序。由此得出</p>
</li>
<li><p>Flutter = 算法 + 数据结构</p>
<p>那状态管理是什么？我们也用公式表示一下：</p>
</li>
<li><p>Flutter状态管理 = 算法 + 数据结构 + UI绑定</p>
<p>来看一段代码例子：</p>
</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThemeBloc</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> _themeStreamController = StreamController&lt;AppTheme&gt;();</span><br><span class="line">  <span class="keyword">get</span> changeTheTheme =&gt; _themeStreamController.sink.add;</span><br><span class="line">  <span class="keyword">get</span> darkThemIsEnABLE =&gt; _themeStreamController.stream;</span><br><span class="line">  dispose()&#123;</span><br><span class="line">    _themStreamController.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> bloc = ThemeBloc();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppTheme</span> </span>&#123;</span><br><span class="line">  ThemeData themeData;</span><br><span class="line">  AppTheme(<span class="keyword">this</span>.themeData);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//绑定到UI</span></span><br><span class="line">StreamBulder&lt;AppTheme&gt;(</span><br><span class="line">	initialData:AppTheme.LIGHT_THEME,</span><br><span class="line">  stream:bloc.dartThemeIsEnabled,</span><br><span class="line">  builder:(contenxt,AsyncSnapshot&lt;AppTheme&gt; snapshot)&#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title:<span class="string">"Jason"</span>,</span><br><span class="line">      theme:snapshot.data.themeData,</span><br><span class="line">      home:PageHome(),</span><br><span class="line">      routes:&lt;<span class="built_in">String</span>,WidgetBuilder&gt;&#123;</span><br><span class="line">        <span class="string">"/pageChatGroup"</span>:(context) =&gt; PageChatGroup(),</span><br><span class="line">        <span class="string">"/laoYu"</span>:(context) =&gt; LaoYu(),</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>AppTheme 是数据结构</li>
<li>changeTheTheme 是算法</li>
<li>StreamBuilder 是绑定UI</li>
</ul>
<p>这样一整套代码的逻辑就是我们所说的Flutter状态管理。算法就是我们如何管理，数据结构是数据状态，状态管理的本质还是如何通过合理的算法管理数据，如何取，如何接收等，最终展示在UI上，通过UI的变更来提现状态的管理逻辑。</p>
<h3 id="为什么需要状态管理"><a href="#为什么需要状态管理" class="headerlink" title="为什么需要状态管理"></a>为什么需要状态管理</h3><p>状态管理可以实现组件通信、跨组件数据储存。原生的状态变更是通过具体的组件直接复制，如果页面全部变更，是不是需要每一个都设置一遍，而Flutter的变更就简单粗暴 ，setState搞定，它背后的逻辑是重新build整个页面，发现有变更，再将新的数据复制。其实原生开发与Flutter的本质的区别就是数据与视图完全分离，目前原生也出现了UI绑定框架。说明flutter的设计的先进性。这样设计的弊端是什么？</p>
<p>答案就是<code>页面如何刷新才是Flutter的关键</code>，原生也面临这个问题，页面的重绘导致丢帧问题，为了效果更好，我们很多时候都选择局部刷新，原生已经很明确的告诉UI要刷新什么更新什么，而对于Flutter来说，这一点恨不清晰，虽然Flutter也做了类似虚拟Dom优化重绘逻辑，但这远远不够，如何合理的更新UI才是最主要的，这个时候一大堆的状态管理就出来了，当然状态管理也不是仅仅为了解决更新问题。我们再思考一个问题，如果我有一个widget A，我想在另外一个widget B中改变widget A的一个状态，或者从网络、数据库取到数据，然后刷新它。</p>
<p>一个糟糕的写法是，A widget的 state为全局的，当B widget 需要刷新的时候 直接调用 AState对象的 <code>setState</code> 方法.</p>
<p>这样写有几个问题：</p>
<p>1、违背了封装的概念，其他所有类都可以拿到A的state对象。</p>
<p>2、A和B强耦合了。</p>
<p>3、每次都是重绘整个widget A 性能变差。</p>
<p>4、不利于测试。</p>
<p>如何变好了，这就需要我们选择一种合适的状态管理方式。</p>
<h4 id="状态管理的目标"><a href="#状态管理的目标" class="headerlink" title="状态管理的目标"></a>状态管理的目标</h4><p>其实我们做状态管理，不仅仅是因为它的特点，也是更好地架构。</p>
<ul>
<li>代码层次分明，易维护，易阅读。</li>
<li>可扩展，可以动态替换UI而不影响算法逻辑。</li>
<li>安全可靠，保持数据的稳定伸缩</li>
<li>性能佳，局部刷新。</li>
</ul>
<p>这不仅仅是状态管理的目的，也是我们做一款优秀应用的基础架构。</p>
<h3 id="状态管理的基本分类"><a href="#状态管理的基本分类" class="headerlink" title="状态管理的基本分类"></a>状态管理的基本分类</h3><ul>
<li>局部管理 官方也称Ephemeral State，意思是短暂的状态，这种状态根本不需要做全局处理，StatefulWidget处理即可完成。</li>
<li>全局管理 官方称App state ，即应用状态，非短暂状态，你要在应用程序的许多部分之间共享，以及希望在用户会话之间保持的状态，就是我们所说的应用程序状态（也称共享状态）。例如：<ul>
<li>用户偏好</li>
<li>登录信息</li>
<li>购物车</li>
<li>新闻阅读状态</li>
</ul>
</li>
</ul>
<p>总之，任何Flutter应用程序中都有两种概念性的状态类型。临时状态可以使用State和setState来事项，并且通常是单个窗口小部件的本地状态。剩下的就是应用的状态。两种类型在任何Flutter应用程序中都有自己的位置，两者之间的划分取决于你自己的喜好和应用程序的复杂性。没有最好的管理方式，只有最合适的管理方式。</p>
<h3 id="底层逻辑"><a href="#底层逻辑" class="headerlink" title="底层逻辑"></a>底层逻辑</h3><p>底层逻辑主要讲，Flutter中目前有哪些可以做到状态管理，有什么缺点，适合做什么不适合做什么，完全明白底层逻辑才不会畏惧复杂的逻辑，即使逻辑复杂也能选择合理的方式去管理状态。</p>
<ul>
<li><p>State</p>
<p>StatefulWidget、SteamBuilder状态管理方式。</p>
</li>
<li><p>InheritedWidget</p>
<p>专门负责Widget树种数据共享的功能型Widget，如Provider、scoped_model就是基于它开发</p>
</li>
<li><p>Notification</p>
<p>与InheritedWidget正好相反，InheritedWidget是从上往下传递数据，Notification是从下往上，但两者都是在自己的Widget树种传递，无法跨越树传递。</p>
</li>
<li><p>Stream</p>
<p>数据流 如Bloc、flutter_redux、fish_redux等也都基于它来做实现。</p>
</li>
</ul>
<p>下面一一分析</p>
<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>State是我们常用而且使用最频繁的一个状态管理类，它必须结合StatefulWidget一起使用，StreamBuilder继承自StatefulWidget，同样使用setState来管理状态。</p>
<p>为什么用State管理状态，而不是Widget本身。Flutter设计时让Widget本身是不变的，类似固定的配置信息，那么就需要一个角色来控制它，State就出现了，但State的任何更改都会强制整个Widget重新构建，当然也可以覆盖必要的方法自己控制逻辑。</p>
<p>注意：setState是整个Widget重新构建（子Widget也会销毁重建），这个点也是为什么不推荐大量使用StatefulWidget的原因。如果页面足够复杂，就会导致严重的性能损耗。建议使用StreamBuilder，它原理上是State，但它做到了子Widget的局部刷新，不会导致整个页面的重建。</p>
<h4 id="State的缺点"><a href="#State的缺点" class="headerlink" title="State的缺点"></a>State的缺点</h4><ul>
<li>无法做到夸组件共享数据（这个夸是无关联的，如果是直接的父子关系，不算是跨组件）。一般我们将State的子类设置为私有，所以无法做到让别的组件调用State的setState函数来刷新。</li>
<li>setState会成为维护的难点，因为到处都有。随着页面状态的增多，可能调用的setState的地方会越来越多，不能统一管理。</li>
<li>处理数据逻辑和视图混合在一起，违反代码设计原则。比如网络的数据取出来setState的UI上，这样编写代码，导致状态和UI耦合在一起，不利于测试和复用。</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>反过来讲，State简单高效，当复杂到需要更好地管理的时候再重构，一个基本原则就是，状态是否需要跨组件使用，如果需要那就用别的方法管理状态而不是State管理。</p>
<h3 id="InheritedWidget"><a href="#InheritedWidget" class="headerlink" title="InheritedWidget"></a>InheritedWidget</h3><p>InheritedWidget是一个无私的Widget，它可以把自己的状态数据，无私交给所有的子Widget，所有的子Widget可以无条件的继承它的状态。它的数据是只读的，子widget不能修改。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>缺点：</p>
<ul>
<li>容易造成不必要的刷新。</li>
<li>不支持跨页面（router）的状态，不是同一个树的状态无法获取。</li>
<li>数据不可变，必须结合StatefulWidget、ChangeNotifier或者Steam使用。</li>
</ul>
<p>比较适合在一个属性Widget中，抽象出公有状态，每一个子Widget或者孙Widget都可以获取该状态，我们可以通过手段控制rebuild的粒度来优化重绘逻辑，但它更适合从上往下传递，如果从下往上传递，如何做，下面解答。</p>
<h3 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h3><p>它是flutter中跨层数据共享的一种机制，它不是widget，它提供了dispatch方法，来让我们沿着context对应的Element节点向上逐层发送通知。</p>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p>缺点</p>
<ul>
<li>不支持跨页面的状态，准确的说不支持NotificationListener同级或者父级Widget的状态通知</li>
<li>本身不支持刷新UI,需要结合State使用</li>
<li>如果结合State，会导致整个UI的重绘，效率低下不科学。</li>
</ul>
<p>使用起来简单，如果页面复杂度高不推荐。</p>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p>Stream其实是一个生产者消费者模型，一端负责生产，一端负责消费，而且是纯Dart的实现，跟Flutter没什么关系，扯上关系的就是StreamBuilder来构建一个Stream通道的Widget，像知名的rxdart、Bloc、flutter_redux全都用到了Stream的api。所以学习它才是我们掌握状态管理的关键。</p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>缺点</p>
<ul>
<li>api生涩，不好理解。</li>
<li>需要定制化，才能满足更复杂的场景。</li>
<li>没有自动dispose逻辑。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上所有的状态更新都离不开State的支持。</p>
<h3 id="状态管理的使用原则"><a href="#状态管理的使用原则" class="headerlink" title="状态管理的使用原则"></a>状态管理的使用原则</h3><h4 id="局部管理优于全局"><a href="#局部管理优于全局" class="headerlink" title="局部管理优于全局"></a>局部管理优于全局</h4><p>这个原则来源于，Flutter的性能优化，局部刷新肯定比全局刷新要好很多，那么我们在管理状态的同时，也要考虑该状态到底是局部还是全局，从而编写正确的逻辑。</p>
<h4 id="保持数据安全性"><a href="#保持数据安全性" class="headerlink" title="保持数据安全性"></a>保持数据安全性</h4><p>用<code>_</code>私有化状态，因为当开发人员众多，当别人看到你的变量的时候，第一反应可能不是找你提供的方法，而是直接对变量操作，那就有可能出现想不到的后果，如果他只能调用你提供的方法，那他就要遵循你方法的逻辑，避免数据被处理错误。</p>
<h4 id="考虑页面重新build带来的影响"><a href="#考虑页面重新build带来的影响" class="headerlink" title="考虑页面重新build带来的影响"></a>考虑页面重新build带来的影响</h4><p>很多时候页面的重建都会调用build函数，也就是说，在一个生命周期内，build函数是多次被调用的，所以你就要考虑数据的初始化或者刷新怎么样才能合理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/18/iOS-Runloop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/18/iOS-Runloop/" class="post-title-link" itemprop="url">iOS  - Runloop</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-18 15:33:42" itemprop="dateCreated datePublished" datetime="2021-05-18T15:33:42+08:00">2021-05-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/17/iOS-%E5%BA%95%E5%B1%82-%E7%B1%BB%E6%8B%93%E5%B1%95%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/17/iOS-%E5%BA%95%E5%B1%82-%E7%B1%BB%E6%8B%93%E5%B1%95%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">iOS 底层 - 类拓展和关联对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-17 13:39:24 / 修改时间：14:02:24" itemprop="dateCreated datePublished" datetime="2021-05-17T13:39:24+08:00">2021-05-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/17/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E5%88%86%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/17/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E5%88%86%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/" class="post-title-link" itemprop="url">iOS 底层探索 - 分类的加载</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-17 11:20:09 / 修改时间：13:38:57" itemprop="dateCreated datePublished" datetime="2021-05-17T11:20:09+08:00">2021-05-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="初探懒加载类"><a href="#初探懒加载类" class="headerlink" title="初探懒加载类"></a>初探懒加载类</h3><p>上一章我们探索了 <code>iOS</code> 中类的加载，让我们简单回顾一下大概的流程。</p>
<h4 id="类的加载回顾"><a href="#类的加载回顾" class="headerlink" title="类的加载回顾"></a>类的加载回顾</h4><ul>
<li><code>libObjc</code> 向 <code>dyld</code> 注册了回调 <code>_dyld_objc_notify_register</code>，当 <code>dyld</code> 把 <code>App</code> 以及 <code>App</code> 所依赖的一系列 <code>Mach-O</code> 镜像加载到当前 <code>App</code> 被分配的内存空间之后，<code>dyld</code> 会通过 <code>_dyld_objc_notify_mapped</code> 也就是 <code>map_images</code> 来通知 <code>libObjc</code> 来完成具体的加载工作，<code>map_images</code> 被调用之后会来到 <code>_read_images</code></li>
<li><code>_read_images</code><ul>
<li>主要会进行类的加载工作，会插入 <strong>所有的类</strong> 到 <code>gdb_objc_realized_classes</code> 哈希表中（插入方式为 类名为 <code>key</code>，类对象为<code>value</code>, 不包括通过 <em>共享缓存</em> 里面的类），同时还会把类插入到 <code>allocatedClasses</code> 这个集合里面，注意，<code>allocatedClasses</code> 的类型为 <code>NXHashTable</code>，可以类比为 <code>NSSet</code>，而 <code>gdb_objc_realized_classes</code> 的类型为 <code>NXMapTable</code>，可以类比为 <code>NSDictionary</code></li>
<li>对所有的类进行重映射</li>
<li>将所有的 <code>SEL</code> 插入到 <code>namedSelectors</code> 哈希表中(插入方式为：<code>SEL</code> 名称为 <code>key</code>，<code>SEL</code> 为<code>value</code>)</li>
<li>修复函数指针遗留</li>
<li>将所有的 <code>Protocol</code> 插入到 <code>readProtocol</code> 哈希表中(插入方式为：<code>Protocol</code> 名称为 <code>key</code>，<code>Protocol</code> 为 <code>value</code>)</li>
<li>对所有的 <code>Protocol</code> 做重映射</li>
<li>初始化所有的<strong>非懒加载类</strong>，包括 <code>rw</code> 和 <code>ro</code> 的初始化操作</li>
<li>处理所有的分类(包括类的分类和元类的分类)</li>
</ul>
</li>
</ul>
<h4 id="懒加载类的发现"><a href="#懒加载类的发现" class="headerlink" title="懒加载类的发现"></a>懒加载类的发现</h4><p>我们这个时候观察 <code>_read_images</code> 源码这部分的注释:</p>
<blockquote>
<p>Realize non-lazy classes (for +load methods and static instances)</p>
<p>实现<strong>非懒加载</strong>类(实现了 <code>+load</code> 方法和静态实例)</p>
</blockquote>
<p>什么意思呢，我们这里其实打印的都是所谓的<strong>非懒加载类</strong>，这里除了我们自己实现了 <code>+load</code> 方法的两个类之外，其他的内容都是系统内置的类，包括我们十分熟悉的 <code>NSObject</code> 类。通过这里其实反过来推论，我们没有实现 <code>+load</code> 方法就是所谓的懒加载类，这种类并不会在 <code>_read_images</code>环节被加载，那么应该是在哪里加载呢？我们稍微思考一下，我们一般第一次操作一个类是不是在初始化这个类的时候，而初始化类不就是发送<code>alloc</code>消息吗，而根据我们前面探索消息查找的知识，在第一次发送某个消息的时候，是没有缓存的，所以会来到一个非常重要的方法叫<code>lookUpImpOrForward</code>，我们在<code>main.m</code>中<code>LGPerson</code>类初始化的地方和<code>lookUpImpOrForward</code> 入口处打上断点:</p>
<p>Tips: 这里有个小技巧，我们先打开 <code>main.m</code> 文件中的断点，等断点来到了我们想要探索的 <code>LGPerson</code> 初始化的位置的时候，我们再打开 <code>lookUpImpOrForward</code> 处的断点，这样才能确保当前执行 <code>lookUpImpOrForward</code> 的是我们的研究对象 <code>LGPerson</code></p>
<p>因为我们断点的位置是 <code>LGPerson</code> 类发送 <code>alloc</code> 消息，而显然 <code>alloc</code> 作为类方法是存储在元类上的，也就是说 <code>lookUpImpOrForward</code> 的 <code>cls</code> 其实是 <code>LGPerson</code> 元类。那么 <code>inst</code> 就应该是真正的对象.</p>
<p>我们总结一下，如果类没有实现 <code>load</code> 方法，那么这个类就是<strong>懒加载类</strong>，反之、这个类如果实现了 <code>load</code> 方法，那么这个类就是<strong>非懒加载类</strong>。</p>
<h4 id="懒加载类的流程"><a href="#懒加载类的流程" class="headerlink" title="懒加载类的流程"></a>懒加载类的流程</h4><p>关于<strong>非懒加载类</strong>的加载流程我们已经很熟悉了，我们总结下<strong>懒加载类</strong>的流程：</p>
<ul>
<li>类第一次发送消息的时候是没有缓存的，所以会来到 <code>_class_lookupMethodAndLoadCache3</code> ，关于这个方法我们在前面的消息查找章节已经介绍过了，不熟悉的同学可以去查阅一下。</li>
<li><code>_class_lookupMethodAndLoadCache3</code> 会调用 <code>lookUpImpOrForward</code> ，这个方法的重要性在我们学习 <code>Runtime</code> 的过程中不言而喻</li>
<li><code>lookUpImpOrForward</code> 内部会进行一下判断，如果 <code>cls</code> 没有被实现，会调用 <code>realizeClassMaybeSwiftAndLeaveLocked</code> 方法</li>
<li><code>realizeClassMaybeSwiftAndLeaveLocked</code> 方法又会调用 <code>realizeClassMaybeSwiftMaybeRelock</code> 方法</li>
<li><code>realizeClassMaybeSwiftMaybeRelock</code> 方法内部会进行一下是否是 <code>Swift</code> 的判断，如果不是 <code>Swift</code> 环境的话，就会来到 <code>realizeClassWithoutSwift</code> ，也就是最终的类的加载的地方</li>
</ul>
<h3 id="分类的底层实现"><a href="#分类的底层实现" class="headerlink" title="分类的底层实现"></a>分类的底层实现</h3><p>分类作为 <code>Objective-C</code> 中常见的特性，相信大家都不会陌生，不过在底层它是怎么实现的呢？</p>
<h4 id="分类的定义"><a href="#分类的定义" class="headerlink" title="分类的定义"></a>分类的定义</h4><p>我们根据 <code>_category_t</code> 来到 <code>libObjc</code> 源码中进行查找，不过我们需要去掉一下 <code>_category_t</code> 的下划线，然后不难找到分类真正的定义所在：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">classref_t</span> cls;</span><br><span class="line">    WrappedPtr&lt;<span class="keyword">method_list_t</span>, PtrauthStrip&gt; instanceMethods;</span><br><span class="line">    WrappedPtr&lt;<span class="keyword">method_list_t</span>, PtrauthStrip&gt; classMethods;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span></span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *_<span class="title">classProperties</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">method_list_t</span> *<span class="title">methodsForMeta</span><span class="params">(<span class="keyword">bool</span> isMeta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">property_list_t</span> *<span class="title">propertiesForMeta</span><span class="params">(<span class="keyword">bool</span> isMeta, struct header_info *hi)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protocol_list_t</span> *<span class="title">protocolsForMeta</span><span class="params">(<span class="keyword">bool</span> isMeta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> protocols;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据刚才 <code>clang</code> 重写之后的内容，我们不难看出</p>
<ul>
<li><p><code>name</code> : 是分类所关联的类，也就是类的名字，而不是分类的名字</p>
</li>
<li><p><code>cls</code> : 我们在前面可以看到 <code>clang</code> 重写后这个值为 0，但是后面有注释为 <code>&amp;OBJC_CLASS_$_LGTeacher</code> ，也就是我们的类对象的定义，所以这里其实就是我们要扩展的类对象，只是在编译期这个值并不存在</p>
</li>
<li><p><code>instanceMethods</code> : 分类上存储的实例方法</p>
</li>
<li><p><code>classMethods</code> ：分类上存储的类方法</p>
</li>
<li><p><code>protocols</code> ：分类所实现的协议</p>
</li>
<li><p><code>instanceProperties</code> ：分类所定义的实例属性，不过我们一般在分类中添加属性都是通过关联对象来实现的</p>
</li>
<li><p><code>_classProperties</code>：分类所定义的类属性。这里有一行注释：</p>
<blockquote>
<p>Fields below this point are not always present on disk.<br>下面的内容并不是一直在磁盘上保存</p>
</blockquote>
</li>
</ul>
<p>也就是说 <code>_classProperties</code> 其实是一个私有属性，但并不是一直都存在的。</p>
<h3 id="分类的加载"><a href="#分类的加载" class="headerlink" title="分类的加载"></a>分类的加载</h3><p>我们现在知道了类分为了 <code>懒加载类</code> 和 <code>非懒加载类</code> ，它们的加载时机是不一样的，那么分类的加载又是怎么样的呢？我们还是同样的先分析没有实现 <code>load</code> 方法的分类的情况:</p>
<p>但是我们在分析前，还要搞清楚一点，分类必须依附于类而存在，如果只有分类，没有类，那么从逻辑上是说不通的，就算实现了，编译器也会忽略掉。而关于类是懒加载还是非懒加载的，所以这里我们还要再细分一次。</p>
<ul>
<li>懒加载分类与懒加载类</li>
<li>懒加载分类和非懒加载类</li>
</ul>
<h4 id="没有实现-load-的分类"><a href="#没有实现-load-的分类" class="headerlink" title="没有实现 load 的分类"></a>没有实现 load 的分类</h4><h5 id="与懒加载类配合加载"><a href="#与懒加载类配合加载" class="headerlink" title="与懒加载类配合加载"></a>与懒加载类配合加载</h5><p>我们先分析第一种情况，也就是类和分类都不实现 <code>load</code> 方法的情况。<br>首先，懒加载类的流程上面我们已经探索过了，在向类<strong>第一次发送消息</strong>的时候，懒加载类才会开始加载，而根据我们上一章类的加载探索内容，在 <code>realizeClassWithoutSwift</code> 方法的最后有一个 <code>methodizeClass</code> 方法，在这个方法里面会有一个 <code>Attach categories</code> 的地方：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Attach categories.</span></span><br><span class="line"><span class="keyword">if</span> (previously) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isMeta) &#123;</span><br><span class="line">        objc::unattachedCategories.attachToClass(cls, previously,</span><br><span class="line">                                                 ATTACH_METACLASS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// When a class relocates, categories with class methods</span></span><br><span class="line">        <span class="comment">// may be registered on the class itself rather than on</span></span><br><span class="line">        <span class="comment">// the metaclass. Tell attachToClass to look for those.</span></span><br><span class="line">        objc::unattachedCategories.attachToClass(cls, previously,</span><br><span class="line">                                                 ATTACH_CLASS_AND_METACLASS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">objc::unattachedCategories.attachToClass(cls, cls,</span><br><span class="line">                                         isMeta ? ATTACH_METACLASS : ATTACH_CLASS);</span><br></pre></td></tr></table></figure>

<p>我们进入<code>unattachedCategories</code>的<code>attachToClass</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachToClass</span><span class="params">(Class cls, Class previously, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    ASSERT((flags &amp; ATTACH_CLASS) ||</span><br><span class="line">           (flags &amp; ATTACH_METACLASS) ||</span><br><span class="line">           (flags &amp; ATTACH_CLASS_AND_METACLASS));</span><br><span class="line">    <span class="keyword">auto</span> &amp;<span class="built_in">map</span> = <span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">map</span>.<span class="built_in">find</span>(previously);</span><br><span class="line">    <span class="keyword">if</span> (it != <span class="built_in">map</span>.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        category_list &amp;<span class="built_in">list</span> = it-&gt;second;</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; ATTACH_CLASS_AND_METACLASS) &#123;</span><br><span class="line">            <span class="keyword">int</span> otherFlags = flags &amp; ~ATTACH_CLASS_AND_METACLASS;</span><br><span class="line">            attachCategories(cls, <span class="built_in">list</span>.<span class="built_in">array</span>(), <span class="built_in">list</span>.count(), otherFlags | ATTACH_CLASS);</span><br><span class="line">            attachCategories(cls-&gt;ISA(), <span class="built_in">list</span>.<span class="built_in">array</span>(), <span class="built_in">list</span>.count(), otherFlags | ATTACH_METACLASS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            attachCategories(cls, <span class="built_in">list</span>.<span class="built_in">array</span>(), <span class="built_in">list</span>.count(), flags);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>.erase(it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们断点之后发现这个时候通过 <code>unattachedCategoriesForClass</code> 方法并没有取到分类，我们此时不妨通过 <code>LLDB</code> 打印一下当前类里面是否已经把分类的内容附加上了。<br>前面的流程大家都很熟悉了，我们直接看 <code>cls</code> 的 <code>rw</code> 中的 <code>methods</code> 是否有内容：</p>
<p>这样进一步证明了，如果是懒加载类，并且分类也是懒加载，那么分类的加载并不会来到 <code>unattachedCategoriesForClass</code> ，而是直接在编译时加载到了类的 <code>ro</code> 里面，然后在运行时被拷贝到了类的 <code>rw</code> 里面。这一点可以通过下面的 <code>LLDB</code> 打印来证明。</p>
<h5 id="与非懒加载类配合加载"><a href="#与非懒加载类配合加载" class="headerlink" title="与非懒加载类配合加载"></a>与非懒加载类配合加载</h5><p>同样的道理，当类为非懒加载类的时候，走的是 <code>_read_images</code> 里面的流程，这个时候我们的懒加载分类是在哪加载的呢？</p>
<p>分类还是不在这，同时通过 <code>LLDB</code> 打印，发现分类的方法已经在类的 <code>ro</code> 里面了，所以说分类的加载其实跟类的懒加载与否并没有关系，也就是说懒加载的分类都是在编译时期被加载的。</p>
<h4 id="实现了-load-的分类"><a href="#实现了-load-的分类" class="headerlink" title="实现了 load 的分类"></a>实现了 load 的分类</h4><p>我们再接着分下下面两种情况：</p>
<ul>
<li>非懒加载分类与懒加载类</li>
<li>非懒加载分类和非懒加载类</li>
</ul>
<h5 id="与懒加载类配合加载-1"><a href="#与懒加载类配合加载-1" class="headerlink" title="与懒加载类配合加载"></a>与懒加载类配合加载</h5><p>其实懒加载和非懒加载的最大区别就是加载是否提前，而实现了 <code>+load</code> 方法的分类，面对的是懒加载的类，<br>而懒加载的类我们前面已经知道了，是在第一次发送消息的时候才会被加载的，那我们直接在<br><code>lookupImpOrForward</code> =&gt; <code>realizeClassMaybeSwiftAndLeaveLocked</code> =&gt; <code>realizeClassMaybeSwiftMaybeRelock</code> =&gt; <code>realizeClassWithoutSwift</code> =&gt; <code>methodizeClass</code> 流程中的 <code>methodizeClass</code> 打上断点，看下在这里分类会不会被加载：</p>
<p>这一次通过 <code>unattachedCategoriesForClass</code> 取出来值了，并且在这之前 <code>cls</code> 的 <code>ro</code> 中并没有分类的 <code>initialize</code> 方法：</p>
<p>为什么走的不是发送消息的流程，而走的是 <code>load_images</code> 里面的 <code>prepare_load_methods</code> 方法呢？我们来到 <code>prepare_load_methods</code> 方法处：</p>
<p>可以看到，其实是在这里调用了 <code>realizeClassWithoutSwift</code> 方法来加载类的。而上面的 <code>_getObjc2NonlazyCategoryList</code> 方法显示就是获取的所有的非懒加载分类，然后遍历这些非懒加载分类，然后去加载这些分类所依赖的类。这个逻辑很好理解，非懒加载分类让我们的懒加载类实现提前了，所以说懒加载类<strong>并不一定</strong>只会在第一次消息发送的时候加载，还要取决于有没有非懒加载的分类，如果有非懒加载的分类，那么就走的是 <code>load_images</code> 里面的 <code>prepare_load_methods</code> 的 <code>realizeClassWithoutSwift</code> 。</p>
<h5 id="与非懒加载类配合加载-1"><a href="#与非懒加载类配合加载-1" class="headerlink" title="与非懒加载类配合加载"></a>与非懒加载类配合加载</h5><p>非懒加载类的流程我们也十分熟悉了，在 <code>_read_images</code> 里面进行加载，而此时，分类也是非懒加载。我们还是在 <code>methodizeClass</code> 里面进行断点：</p>
<p>结果如上图所示，这次从 <code>unattachedCategoriesForClass</code> 方法取出来的是 <code>NULL</code> 值，显然分类不是在这个地方被加载的，我们回到 <code>_read_images</code> 方法，还记得那个 <code>Discover categories</code> 流程吗，我们打开里面的断点：</p>
<p>其实 <code>attachCategories</code> 这个方法只会在实现了 <code>load</code> 方法的分类下才会被调用，而来到 <code>attachCategories</code> 之前又取决于类是否为懒加载，如果是懒加载，那么就在 <code>load_images</code> 里面去处理，如果是非懒加载，那么就在 <code>map_images</code> 里面去处理。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们今天探索的内容可能会有点绕，不过其实探索下来，我们只需要保持研究重点就很简单。分类的加载其实可以笼统的分为实现 <code>load</code> 方法和没有实现 <code>load</code> 方法：</p>
<ul>
<li>没有实现 <code>load</code> 方法的分类由编译时确定</li>
<li>实现了 <code>load</code> 方法的分类由运行时去确定</li>
</ul>
<p>这也说明分类的加载和类的加载是不一样的，而结合着类的懒加载与否，我们有以下的结论：</p>
<ul>
<li>懒加载分类 + 懒加载类</li>
</ul>
<blockquote>
<p>类的加载在<strong>第一次消息发送</strong>的时候，而分类的加载则在<strong>编译时</strong></p>
</blockquote>
<ul>
<li>懒加载分类 + 非懒加载类</li>
</ul>
<blockquote>
<p>类的加载在 <code>_read_images</code> 处，分类的加载还是在<strong>编译时</strong></p>
</blockquote>
<ul>
<li>非懒加载分类 + 懒加载类</li>
</ul>
<blockquote>
<p>类的加载在 <code>load_images</code> 内部，分类的加载在类加载之后的 <code>methodizeClass</code></p>
</blockquote>
<ul>
<li>非懒加载分类 + 非懒加载类</li>
</ul>
<blockquote>
<p>类的加载在 <code>_read_images</code> 处，分类的加载在类加载之后的 <code>reMethodizeClass</code></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/15/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/15/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/" class="post-title-link" itemprop="url">iOS 底层探索 - 类的加载</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-15 16:19:03" itemprop="dateCreated datePublished" datetime="2021-05-15T16:19:03+08:00">2021-05-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-17 11:03:49" itemprop="dateModified" datetime="2021-05-17T11:03:49+08:00">2021-05-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="应用的加载回顾"><a href="#应用的加载回顾" class="headerlink" title="应用的加载回顾"></a>应用的加载回顾</h3><p>上一章我们对应用的加载有了初步的认识，我们知道了</p>
<ul>
<li>系统调用 <code>exec()</code> 会我们的应用<strong>映射</strong>到新的地址空间</li>
<li>然后通过 <code>dyld</code> 进行加载、链接、初始化主程序和主程序所依赖的各种动态库</li>
<li>最后在 <code>initializeMainExecutable</code> 方法中经过一系列初始化调用 <code>notifySingle</code> 函数，该函数会执行一个 <code>load_images</code> 的回调</li>
<li>然后在 <code>doModinitFuntions</code> 函数内部会调用 <code>__attribute__((constructor))</code> 的 <code>c</code> 函数</li>
<li>然后 <code>dyld</code> 返回主程序的入口函数，开始进入主程序的 <code>main</code> 函数 在 <code>main</code> 函数执行执行，其实 <code>dyld</code> 还会在流程中初始化 <code>libSystem</code>，而 <code>libSystem</code> 又会去初始化 <code>libDispatch</code>，在 <code>libDispatch</code> 初始化方法里面又会有一步 <code>_os_object_init</code>，在 <code>_os_object_init</code> 内部就会调起 <code>_objc_init</code>。而对于 <code>_objc_init</code> 我们还需要继续探索，因为这里面会进行类的加载等一系列重要的工作。</li>
</ul>
<h3 id="探索-objc-init"><a href="#探索-objc-init" class="headerlink" title="探索_objc_init"></a>探索<code>_objc_init</code></h3><p>首先来到 <code>libObjc</code> 源码的 <code>_objc_init</code> 方法处，你可以直接添加一个符号断点 <code>_objc_init</code> 或者全局搜索关键字来到这里：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* _objc_init</span></span><br><span class="line"><span class="comment">* Bootstrap initialization. Registers our image notifier with dyld.</span></span><br><span class="line"><span class="comment">* Called by libSystem BEFORE library initialization time</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">  	<span class="comment">//如果已经初始化直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    runtime_init();</span><br><span class="line">    exception_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    <span class="keyword">cache_t</span>::init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    _imp_implementationWithBlock_init();</span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    didCallDyldNotifyRegister = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="environ-init"><a href="#environ-init" class="headerlink" title="environ_init"></a><code>environ_init</code></h4><p>我们直接看调用的第一个方法<code>environ_init</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* environ_init</span></span><br><span class="line"><span class="comment">* Read environment variables that affect the runtime.</span></span><br><span class="line"><span class="comment">* Also print environment variable help, if requested.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">environ_init</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (issetugid()) &#123;</span><br><span class="line">        <span class="comment">// All environment variables are silently ignored when setuid or setgid</span></span><br><span class="line">        <span class="comment">// This includes OBJC_HELP and OBJC_PRINT_OPTIONS themselves.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// Turn off autorelease LRU coalescing by default for apps linked against</span></span><br><span class="line">    <span class="comment">// older SDKs. LRU coalescing can reorder releases and certain older apps</span></span><br><span class="line">    <span class="comment">// are accidentally relying on the ordering.</span></span><br><span class="line">    <span class="comment">// rdar://problem/63886091</span></span><br><span class="line"><span class="comment">//    if (!dyld_program_sdk_at_least(dyld_fall_2020_os_versions))</span></span><br><span class="line"><span class="comment">//        DisableAutoreleaseCoalescingLRU = true;</span></span><br><span class="line">    <span class="keyword">bool</span> PrintHelp = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> PrintOptions = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> maybeMallocDebugging = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// Scan environ[] directly instead of calling getenv() a lot.</span></span><br><span class="line">    <span class="comment">// This optimizes the case where none are set.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> **p = *_NSGetEnviron(); *p != nil; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strncmp</span>(*p, <span class="string">"Malloc"</span>, <span class="number">6</span>)  ||  <span class="number">0</span> == <span class="built_in">strncmp</span>(*p, <span class="string">"DYLD"</span>, <span class="number">4</span>)  ||  </span><br><span class="line">            <span class="number">0</span> == <span class="built_in">strncmp</span>(*p, <span class="string">"NSZombiesEnabled"</span>, <span class="number">16</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            maybeMallocDebugging = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != <span class="built_in">strncmp</span>(*p, <span class="string">"OBJC_"</span>, <span class="number">5</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strncmp</span>(*p, <span class="string">"OBJC_HELP="</span>, <span class="number">10</span>)) &#123;</span><br><span class="line">            PrintHelp = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strncmp</span>(*p, <span class="string">"OBJC_PRINT_OPTIONS="</span>, <span class="number">19</span>)) &#123;</span><br><span class="line">            PrintOptions = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strncmp</span>(*p, <span class="string">"OBJC_DEBUG_POOL_DEPTH="</span>, <span class="number">22</span>)) &#123;</span><br><span class="line">            SetPageCountWarning(*p + <span class="number">22</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *value = <span class="built_in">strchr</span>(*p, <span class="string">'='</span>);</span><br><span class="line">        <span class="keyword">if</span> (!*value) <span class="keyword">continue</span>;</span><br><span class="line">        value++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(Settings)/<span class="keyword">sizeof</span>(Settings[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">option_t</span> *opt = &amp;Settings[i];</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">size_t</span>)(value - *p) == <span class="number">1</span>+opt-&gt;envlen  &amp;&amp;  </span><br><span class="line">                <span class="number">0</span> == <span class="built_in">strncmp</span>(*p, opt-&gt;env, opt-&gt;envlen))</span><br><span class="line">            &#123;</span><br><span class="line">                *opt-&gt;var = (<span class="number">0</span> == <span class="built_in">strcmp</span>(value, <span class="string">"YES"</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Special case: enable some autorelease pool debugging</span></span><br><span class="line">    <span class="comment">// when some malloc debugging is enabled </span></span><br><span class="line">    <span class="comment">// and OBJC_DEBUG_POOL_ALLOCATION is not set to something other than NO.</span></span><br><span class="line">    <span class="keyword">if</span> (maybeMallocDebugging) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *insert = getenv(<span class="string">"DYLD_INSERT_LIBRARIES"</span>);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *zombie = getenv(<span class="string">"NSZombiesEnabled"</span>);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *pooldebug = getenv(<span class="string">"OBJC_DEBUG_POOL_ALLOCATION"</span>);</span><br><span class="line">        <span class="keyword">if</span> ((getenv(<span class="string">"MallocStackLogging"</span>)</span><br><span class="line">             || getenv(<span class="string">"MallocStackLoggingNoCompact"</span>)</span><br><span class="line">             || (zombie &amp;&amp; (*zombie == <span class="string">'Y'</span> || *zombie == <span class="string">'y'</span>))</span><br><span class="line">             || (insert &amp;&amp; <span class="built_in">strstr</span>(insert, <span class="string">"libgmalloc"</span>)))</span><br><span class="line">            &amp;&amp;</span><br><span class="line">            (!pooldebug || <span class="number">0</span> == <span class="built_in">strcmp</span>(pooldebug, <span class="string">"YES"</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            DebugPoolAllocation = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    if (!os_feature_enabled_simple(objc4, preoptimizedCaches, true)) &#123;</span></span><br><span class="line"><span class="comment">//        DisablePreoptCaches = true;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">// Print OBJC_HELP and OBJC_PRINT_OPTIONS output.</span></span><br><span class="line">    <span class="keyword">if</span> (PrintHelp  ||  PrintOptions) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintHelp) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"Objective-C runtime debugging. Set variable=YES to enable."</span>);</span><br><span class="line">            _objc_inform(<span class="string">"OBJC_HELP: describe available environment variables"</span>);</span><br><span class="line">            <span class="keyword">if</span> (PrintOptions) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"OBJC_HELP is set"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            _objc_inform(<span class="string">"OBJC_PRINT_OPTIONS: list which options are set"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (PrintOptions) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"OBJC_PRINT_OPTIONS is set"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(Settings)/<span class="keyword">sizeof</span>(Settings[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">option_t</span> *opt = &amp;Settings[i];            </span><br><span class="line">            <span class="keyword">if</span> (PrintHelp) _objc_inform(<span class="string">"%s: %s"</span>, opt-&gt;env, opt-&gt;help);</span><br><span class="line">            <span class="keyword">if</span> (PrintOptions &amp;&amp; *opt-&gt;var) _objc_inform(<span class="string">"%s is set"</span>, opt-&gt;env);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，这里主要是读取影响 <code>Runtime</code> 的一些环境变量，如果需要，还可以打印环境变量帮助提示。</p>
<p>我们可以在终端测试一下，直接输入<code>export OBJC-HELP=1</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">jason@<span class="number">192</span> ~ % <span class="keyword">export</span> OBJC_HELP=<span class="number">1</span></span><br><span class="line">jason@<span class="number">192</span> ~ % ls</span><br><span class="line">objc[<span class="number">6097</span>]: Objective-C runtime debugging. Set variable=YES to enable.</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_HELP: describe <span class="built_in">available</span> environment variables</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_OPTIONS: <span class="built_in">list</span> which options are <span class="built_in">set</span></span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_IMAGES: <span class="built_in">log</span> <span class="built_in">image</span> <span class="keyword">and</span> library names as they are loaded</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_IMAGE_TIMES: measure duration of <span class="built_in">image</span> loading steps</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_LOAD_METHODS: <span class="built_in">log</span> calls to class <span class="keyword">and</span> category +load methods</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_INITIALIZE_METHODS: <span class="built_in">log</span> calls to class +initialize methods</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_RESOLVED_METHODS: <span class="built_in">log</span> methods created by +resolveClassMethod: <span class="keyword">and</span> +resolveInstanceMethod:</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_CLASS_SETUP: <span class="built_in">log</span> progress of class <span class="keyword">and</span> category <span class="built_in">setup</span></span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_PROTOCOL_SETUP: <span class="built_in">log</span> progress of protocol <span class="built_in">setup</span></span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_IVAR_SETUP: <span class="built_in">log</span> processing of non-fragile ivars</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_VTABLE_SETUP: <span class="built_in">log</span> processing of class vtables</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_VTABLE_IMAGES: <span class="built_in">print</span> vtable images showing overridden methods</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_CACHE_SETUP: <span class="built_in">log</span> processing of method caches</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_FUTURE_CLASSES: <span class="built_in">log</span> use of <span class="built_in">future</span> classes <span class="keyword">for</span> toll-<span class="built_in">free</span> bridging</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_PREOPTIMIZATION: <span class="built_in">log</span> preoptimization courtesy of dyld shared cache</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_CXX_CTORS: <span class="built_in">log</span> calls to C++ ctors <span class="keyword">and</span> dtors <span class="keyword">for</span> instance variables</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_EXCEPTIONS: <span class="built_in">log</span> exception handling</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_EXCEPTION_THROW: <span class="built_in">log</span> backtrace of every objc_exception_throw()</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_ALT_HANDLERS: <span class="built_in">log</span> processing of exception alt handlers</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_REPLACED_METHODS: <span class="built_in">log</span> methods replaced by category implementations</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_DEPRECATION_WARNINGS: warn about calls to deprecated runtime functions</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_POOL_HIGHWATER: <span class="built_in">log</span> high-water marks <span class="keyword">for</span> autorelease pools</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_CUSTOM_CORE: <span class="built_in">log</span> classes with custom core methods</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_CUSTOM_RR: <span class="built_in">log</span> classes with custom retain/<span class="built_in">release</span> methods</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_CUSTOM_AWZ: <span class="built_in">log</span> classes with custom allocWithZone methods</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_PRINT_RAW_ISA: <span class="built_in">log</span> classes that require raw pointer isa fields</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DEBUG_UNLOAD: warn about poorly-behaving bundles when unloaded</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DEBUG_FRAGILE_SUPERCLASSES: warn about subclasses that may have been broken by subsequent changes to superclasses</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DEBUG_NIL_SYNC: warn about @synchronized(nil), which does no synchronization</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DEBUG_NONFRAGILE_IVARS: capriciously rearrange non-fragile ivars</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DEBUG_ALT_HANDLERS: record more info about bad alt handler use</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DEBUG_MISSING_POOLS: warn about autorelease with no pool in place, which may be a leak</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DEBUG_POOL_ALLOCATION: halt when autorelease pools are popped out of order, <span class="keyword">and</span> allow heap debuggers to track autorelease pools</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DEBUG_DUPLICATE_CLASSES: halt when multiple classes with the same name are present</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DEBUG_DONT_CRASH: halt the <span class="built_in">process</span> by exiting instead of crashing</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DISABLE_VTABLES: disable vtable dispatch</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DISABLE_PREOPTIMIZATION: disable preoptimization courtesy of dyld shared cache</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DISABLE_TAGGED_POINTERS: disable tagged pointer optimization of NSNumber et al.</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DISABLE_TAG_OBFUSCATION: disable obfuscation of tagged pointers</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DISABLE_NONPOINTER_ISA: disable non-pointer isa fields</span><br><span class="line">objc[<span class="number">6097</span>]: OBJC_DISABLE_INITIALIZE_FORK_SAFETY: disable safety checks <span class="keyword">for</span> +initialize after fork</span><br></pre></td></tr></table></figure>

<p>可以看到不同的环境变量对应的内容都被打印出来了。</p>
<h4 id="tls-init"><a href="#tls-init" class="headerlink" title="tls_init"></a><code>tls_init</code></h4><p>接着看<code>tls_init</code>方法内部：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tls_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line">    pthread_key_init_np(TLS_DIRECT_KEY, &amp;_objc_pthread_destroyspecific);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    _objc_pthread_key = tls_create(&amp;_objc_pthread_destroyspecific);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里执行的是关于线程 <code>key</code> 的绑定，比如每个线程数据的析构函数。</p>
<h4 id="static-init"><a href="#static-init" class="headerlink" title="static_init"></a><code>static_init</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* static_init</span></span><br><span class="line"><span class="comment">* Run C++ static constructor functions.</span></span><br><span class="line"><span class="comment">* libc calls _objc_init() before dyld would call our static constructors, </span></span><br><span class="line"><span class="comment">* so we have to do it ourselves.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">static_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    <span class="keyword">auto</span> inits = getLibobjcInitializers(&amp;_mh_dylib_header, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        inits[i]();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> offsets = getLibobjcInitializerOffsets(&amp;_mh_dylib_header, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="function">UnsignedInitializer <span class="title">init</span><span class="params">(offsets[i])</span></span>;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会运行 <code>C++</code> 的静态构造函数，在 <code>dyld</code> 调用我们的静态构造函数之前，<code>libc</code> 会调用 <code>_objc_init</code>，所以这里我们必须自己来做，并且这里只会初始化系统内置的 <code>C++</code> 静态构造函数，我们自己代码里面写的并不会在这里初始化。</p>
<h4 id="runtime-init"><a href="#runtime-init" class="headerlink" title="runtime_init"></a><code>runtime_init</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runtime_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    objc::unattachedCategories.init(<span class="number">32</span>);</span><br><span class="line">    objc::allocatedClasses.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Runtime环境初始化，unattachedCategories和allocatedClasses两张表的初始化工作</p>
<h4 id="exception-init"><a href="#exception-init" class="headerlink" title="exception_init"></a><code>exception_init</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* exception_init</span></span><br><span class="line"><span class="comment">* Initialize libobjc's exception handling system.</span></span><br><span class="line"><span class="comment">* Called by map_images().</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exception_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    old_terminate = <span class="built_in">std</span>::set_terminate(&amp;_objc_terminate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是初始化 <code>libobjc</code> 的异常处理系统，我们程序触发的异常都会来到：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* _objc_terminate</span></span><br><span class="line"><span class="comment">* Custom std::terminate handler.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* The uncaught exception callback is implemented as a std::terminate handler. </span></span><br><span class="line"><span class="comment">* 1. Check if there's an active exception</span></span><br><span class="line"><span class="comment">* 2. If so, check if it's an Objective-C exception</span></span><br><span class="line"><span class="comment">* 3. If so, call our registered callback with the object.</span></span><br><span class="line"><span class="comment">* 4. Finally, call the previous terminate handler.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*old_terminate)</span><span class="params">(<span class="keyword">void</span>)</span> </span>= nil;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _objc_terminate(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PrintExceptions) &#123;</span><br><span class="line">        _objc_inform(<span class="string">"EXCEPTIONS: terminating"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! __cxa_current_exception_type()) &#123;</span><br><span class="line">        <span class="comment">// No current exception.</span></span><br><span class="line">        (*old_terminate)();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// There is a current exception. Check if it's an objc exception.</span></span><br><span class="line">        @<span class="keyword">try</span> &#123;</span><br><span class="line">            __cxa_rethrow();</span><br><span class="line">        &#125; @<span class="keyword">catch</span> (id e) &#123;</span><br><span class="line">            <span class="comment">// It's an objc object. Call Foundation's handler, if any.</span></span><br><span class="line">            (*uncaught_handler)((id)e);</span><br><span class="line">            (*old_terminate)();</span><br><span class="line">        &#125; @<span class="keyword">catch</span> (...) &#123;</span><br><span class="line">            <span class="comment">// It's not an objc object. Continue to C++ terminate.</span></span><br><span class="line">            (*old_terminate)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到 <code>_objc_terminate</code> 是未处理异常的回调函数，其内部逻辑如下:</p>
<ul>
<li>检查是否是一个活跃的异常</li>
<li>如果是活跃的异常，检查是否是 <code>OC</code> 抛出的异常</li>
<li>如果是 <code>OC</code> 抛出的异常，调用 <code>uncaught_handeler</code> 回调函数指针</li>
<li>如果不是 <code>OC</code> 抛出的异常，则继续 <code>C++</code> 终止操作</li>
</ul>
<h4 id="cache-t-init"><a href="#cache-t-init" class="headerlink" title="cache_t::init()"></a><code>cache_t::init()</code></h4><p>看字面量很容易猜到，<code>cache_t</code>属性的初始化</p>
<h4 id="imp-implementationWithBlock-init"><a href="#imp-implementationWithBlock-init" class="headerlink" title="_imp_implementationWithBlock_init"></a><code>_imp_implementationWithBlock_init</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Initialize the trampoline machinery. Normally this does nothing, as</span></span><br><span class="line"><span class="comment">/// everything is initialized lazily, but for certain processes we eagerly load</span></span><br><span class="line"><span class="comment">/// the trampolines dylib.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_imp_implementationWithBlock_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_OSX</span></span><br><span class="line">    <span class="comment">// Eagerly load libobjc-trampolines.dylib in certain processes. Some</span></span><br><span class="line">    <span class="comment">// programs (most notably QtWebEngineProcess used by older versions of</span></span><br><span class="line">    <span class="comment">// embedded Chromium) enable a highly restrictive sandbox profile which</span></span><br><span class="line">    <span class="comment">// blocks access to that dylib. If anything calls</span></span><br><span class="line">    <span class="comment">// imp_implementationWithBlock (as AppKit has started doing) then we'll</span></span><br><span class="line">    <span class="comment">// crash trying to load it. Loading it here sets it up before the sandbox</span></span><br><span class="line">    <span class="comment">// profile is enabled and blocks it.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This fixes EA Origin (rdar://problem/50813789)</span></span><br><span class="line">    <span class="comment">// and Steam (rdar://problem/55286131)</span></span><br><span class="line">    <span class="keyword">if</span> (__progname &amp;&amp;</span><br><span class="line">        (<span class="built_in">strcmp</span>(__progname, <span class="string">"QtWebEngineProcess"</span>) == <span class="number">0</span> ||</span><br><span class="line">         <span class="built_in">strcmp</span>(__progname, <span class="string">"Steam Helper"</span>) == <span class="number">0</span>)) &#123;</span><br><span class="line">        Trampolines.Initialize();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动回调机制。通常不会做什么，因为所有的初始化都是惰性的，但是对于某些进程，我们会迫不及待地加载trampolines dylib。</p>
<h4 id="dyld-objc-notify-register"><a href="#dyld-objc-notify-register" class="headerlink" title="_dyld_objc_notify_register"></a><code>_dyld_objc_notify_register</code></h4><p>接下来是我们今天探索的重点了： <code>_dyld_objc_notify_register</code> ，我们先看下它的定义:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note: only for use by objc runtime</span></span><br><span class="line"><span class="comment">// Register handlers to be called when objc images are mapped, unmapped, and initialized.</span></span><br><span class="line"><span class="comment">// Dyld will call back the "mapped" function with an array of images that contain an objc-image-info section.</span></span><br><span class="line"><span class="comment">// Those images that are dylibs will have the ref-counts automatically bumped, so objc will no longer need to</span></span><br><span class="line"><span class="comment">// call dlopen() on them to keep them from being unloaded.  During the call to _dyld_objc_notify_register(),</span></span><br><span class="line"><span class="comment">// dyld will call the "mapped" function with already loaded objc images.  During any later dlopen() call,</span></span><br><span class="line"><span class="comment">// dyld will also call the "mapped" function.  Dyld will call the "init" function when dyld would be called</span></span><br><span class="line"><span class="comment">// initializers in that image.  This is when objc calls any +load methods in that image.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span> _dyld_objc_notify_register(_dyld_objc_notify_mapped    mapped,</span><br><span class="line">                                _dyld_objc_notify_init      init,</span><br><span class="line">                                _dyld_objc_notify_unmapped  unmapped);</span><br></pre></td></tr></table></figure>

<p>注意：仅供 <code>objc</code> 运行时使用<br>当 <code>objc</code> 镜像被<strong>映射（mapped）</strong>、<strong>卸载（unmapped）</strong>和<strong>初始化（initialized）</strong>的时候，注册的回调函数就会被调用。<br>这个方法是 <code>dlyd</code> 中声明的，一旦调用该方法，调用结果会作为该函数的参数回传回来。比如，当所有的 <code>images</code> 以及 <code>section</code> 为 <code>objc-image-info</code> 被加载之后会回调 <code>mapped</code> 方法。<br><code>load</code> 方法也将在这个方法中被调用。</p>
<p><code>_dyld_objc_notify_register</code> 方法的三个参数 <code>map_images</code> 、 <code>load_images</code> 、 <code>unmap_image</code> 其实都是函数指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*_dyld_objc_notify_mapped)</span><span class="params">(<span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> paths[], <span class="keyword">const</span> struct mach_header* <span class="keyword">const</span> mh[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*_dyld_objc_notify_init)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> struct mach_header* mh)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*_dyld_objc_notify_unmapped)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> struct mach_header* mh)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这三个函数指针是在 <code>dyld</code> 中回调的，我们打开 <code>dyld</code> 的源码即可一探究竟，我们直接搜索 <code>_dyld_objc_notify_register</code> :</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _dyld_objc_notify_register(_dyld_objc_notify_mapped    mapped,</span><br><span class="line">                                _dyld_objc_notify_init      init,</span><br><span class="line">                                _dyld_objc_notify_unmapped  unmapped)</span><br><span class="line">&#123;</span><br><span class="line">	dyld::registerObjCNotifiers(mapped, init, unmapped);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着来到 <code>dyld</code> 的 <code>registerObjCNotifiers</code> 方法内部：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerObjCNotifiers</span><span class="params">(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// record functions to call</span></span><br><span class="line">	sNotifyObjCMapped	= mapped;<span class="comment">//map_images</span></span><br><span class="line">	sNotifyObjCInit		= init;<span class="comment">//load_images</span></span><br><span class="line">	sNotifyObjCUnmapped = unmapped;<span class="comment">//unmap_images</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// call 'mapped' function with all images mapped so far</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		notifyBatchPartial(dyld_image_state_bound, <span class="literal">true</span>, <span class="literal">NULL</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line">		<span class="comment">// ignore request to abort during registration</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// &lt;rdar://problem/32209809&gt; call 'init' function on all images already init'ed (below libSystem)</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ImageLoader*&gt;::iterator it=sAllImages.<span class="built_in">begin</span>(); it != sAllImages.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		ImageLoader* <span class="built_in">image</span> = *it;</span><br><span class="line">		<span class="keyword">if</span> ( (<span class="built_in">image</span>-&gt;getState() == dyld_image_state_initialized) &amp;&amp; <span class="built_in">image</span>-&gt;notifyObjC() ) &#123;</span><br><span class="line">			<span class="function">dyld3::ScopedTimer <span class="title">timer</span><span class="params">(DBG_DYLD_TIMING_OBJC_INIT, (<span class="keyword">uint64_t</span>)<span class="built_in">image</span>-&gt;machHeader(), <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">			(*sNotifyObjCInit)(<span class="built_in">image</span>-&gt;getRealPath(), <span class="built_in">image</span>-&gt;machHeader());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> _dyld_objc_notify_mapped		sNotifyObjCMapped;</span><br><span class="line"><span class="keyword">static</span> _dyld_objc_notify_init		sNotifyObjCInit;</span><br><span class="line"><span class="keyword">static</span> _dyld_objc_notify_unmapped	sNotifyObjCUnmapped;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码的内容说明在<code>registerObjCNotifiers</code> 内部， <code>libObjc</code> 传过来的这三个函数指针被 <code>dyld</code> 保存在了本地静态变量中。换句话来说，最终函数指针是否能被调用，取决于这三个静态变量：</p>
<ul>
<li><code>sNotifyObjCMapped</code></li>
<li><code>sNotifyObjCInit</code></li>
<li><code>sNotifyObjCUnmapped</code></li>
</ul>
<p>我们注意到 <code>registerObjCNotifiers</code> 的 <code>try-catch</code> 语句中的 <code>try</code> 分支注释如下：</p>
<blockquote>
<p>call ‘mapped’ function with all images mapped so far<br>调用 <code>mapped</code> 函数来映射所有的镜像</p>
</blockquote>
<p>那么也就是说 <code>notifyBatchPartial</code> 里面会进行真正的函数指针的调用，我们进入这个方法内部：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notifyBatchPartial</span><span class="params">(dyld_image_states state, <span class="keyword">bool</span> orLater, dyld_image_state_change_handler onlyHandler, <span class="keyword">bool</span> preflightOnly, <span class="keyword">bool</span> onlyObjCMappedNotification)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">			<span class="comment">//省略代码</span></span><br><span class="line">			<span class="comment">// tell objc about new images</span></span><br><span class="line">			<span class="keyword">if</span> ( (onlyHandler == <span class="literal">NULL</span>) &amp;&amp; ((state == dyld_image_state_bound) || (orLater &amp;&amp; (dyld_image_state_bound &gt; state))) &amp;&amp; (sNotifyObjCMapped != <span class="literal">NULL</span>) ) &#123;</span><br><span class="line">				<span class="keyword">const</span> <span class="keyword">char</span>* paths[imageCount];</span><br><span class="line">				<span class="keyword">const</span> mach_header* mhs[imageCount];</span><br><span class="line">				<span class="keyword">unsigned</span> objcImageCount = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; imageCount; ++i) &#123;</span><br><span class="line">					ImageLoader* <span class="built_in">image</span> = findImageByMachHeader(infos[i].imageLoadAddress);</span><br><span class="line">					<span class="keyword">bool</span> hasObjC = <span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">if</span> ( <span class="built_in">image</span> != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">						<span class="keyword">if</span> ( <span class="built_in">image</span>-&gt;objCMappedNotified() )</span><br><span class="line">							<span class="keyword">continue</span>;</span><br><span class="line">						hasObjC = <span class="built_in">image</span>-&gt;notifyObjC();</span><br><span class="line">					&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_ACCELERATE_TABLES</span></span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> ( sAllCacheImagesProxy != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">						<span class="keyword">const</span> mach_header* mh;</span><br><span class="line">						<span class="keyword">const</span> <span class="keyword">char</span>* path;</span><br><span class="line">						<span class="keyword">unsigned</span> index;</span><br><span class="line">						<span class="keyword">if</span> ( sAllCacheImagesProxy-&gt;addressInCache(infos[i].imageLoadAddress, &amp;mh, &amp;path, &amp;index) ) &#123;</span><br><span class="line">							hasObjC = (mh-&gt;flags &amp; MH_HAS_OBJC);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">					<span class="keyword">if</span> ( hasObjC ) &#123;</span><br><span class="line">						paths[objcImageCount] = infos[i].imageFilePath;</span><br><span class="line">						mhs[objcImageCount]   = infos[i].imageLoadAddress;</span><br><span class="line">						++objcImageCount;</span><br><span class="line">						<span class="keyword">if</span> ( <span class="built_in">image</span> != <span class="literal">NULL</span> )</span><br><span class="line">							<span class="built_in">image</span>-&gt;setObjCMappedNotified();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> ( objcImageCount != <span class="number">0</span> ) &#123;</span><br><span class="line">					<span class="function">dyld3::ScopedTimer <span class="title">timer</span><span class="params">(DBG_DYLD_TIMING_OBJC_MAP, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">					<span class="keyword">uint64_t</span> t0 = mach_absolute_time();</span><br><span class="line">					(*sNotifyObjCMapped)(objcImageCount, paths, mhs);<span class="comment">//函数指针真正调用的地方</span></span><br><span class="line">					<span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line">					ImageLoader::fgTotalObjCSetupTime += (t1-t0);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//省略代码</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，在 <code>notifyBatchPartial</code> 方法内部，这里的注释:</p>
<blockquote>
<p>tell objc about new images 告诉 <code>objc</code> 镜像已经映射完成了</p>
</blockquote>
<p>弄清楚了三个函数指针是怎么调用的还不够，接下来我们要深入各个函数的内部看里面究竟做了什么样的事情。</p>
<h3 id="探索-map-images"><a href="#探索-map-images" class="headerlink" title="探索 map_images"></a>探索 <code>map_images</code></h3><p>首先是 <code>map_images</code> ，我们来到它的实现:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* map_images</span></span><br><span class="line"><span class="comment">* Process the given images which are being mapped in by dyld.</span></span><br><span class="line"><span class="comment">* Calls ABI-agnostic code after taking ABI-specific locks.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: write-locks runtimeLock</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">map_images(<span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> paths[],</span><br><span class="line">           <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> map_images_nolock(count, paths, mhdrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Process the given images which are being mapped in by dyld.<br>Calls ABI-agnostic code after taking ABI-specific locks.</p>
</blockquote>
<blockquote>
<p>处理由 <code>dyld</code> 映射的给定镜像<br>取得特定于 <code>ABI</code> 的锁后，调用与 <code>ABI</code> 无关的代码。</p>
</blockquote>
<p>这里会继续往下走到 <code>map_images_nolock</code></p>
<p><code>map_images_nolock</code> 内部代码十分冗长，我们经过分析之后，前面的工作基本上都是进行镜像文件信息的提取与统计，所以可以定位到最后的 <code>_read_images</code> ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里进入 <code>_read_images</code> 的条件是 <code>hCount</code> 大于 0， <code>hCount</code> 表示的是 <code>Mach-O</code> 中 <code>header</code> 的数量</p>
<p>OK，我们的主角登场了， <code>_read_images</code> 和 <code>lookupImpOrForward</code> 可以说是我们学习 <code>Runtime</code> 和 <code>iOS</code> 底层里面非常重要的两个概念了， <code>lookUpImpOrForward</code> 已经探索过了，剩下的 <code>_read_images</code> 我们也不能落下。</p>
<h4 id="read-images定义"><a href="#read-images定义" class="headerlink" title="_read_images定义"></a>_read_images定义</h4><p>Perform initial processing of the headers in the linked list beginning with headerList.<br>从 <code>headerList</code> 开始，对已经链接了的 <code>Mach-O</code> 镜像表中的头部进行初始化处理</p>
<p>我们可以看到，整个 <code>_read_images</code> 有接近 400 行代码。</p>
<p>通过查看代码，以及日志打印提示信息，我们大致可以将 <code>_read_images</code> 分为下面几个流程:</p>
<h4 id="read-images具体流程"><a href="#read-images具体流程" class="headerlink" title="_read_images具体流程"></a>_read_images具体流程</h4><p><strong>doneOnce 流程</strong></p>
<p>我们从第一个分支 <code>doneOnce</code> 开始，这个名词顾名思义，只会执行一次：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EACH_HEADER \</span></span><br><span class="line">    hIndex = <span class="number">0</span>;         \</span><br><span class="line">    hIndex &lt; hCount &amp;&amp; (hi = hList[hIndex]); \</span><br><span class="line">    hIndex++</span><br><span class="line">    <span class="keyword">if</span> (!doneOnce) &#123;</span><br><span class="line">        doneOnce = YES;</span><br><span class="line">        launchTime = YES;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">        <span class="comment">// Disable non-pointer isa under some conditions.</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class="line">        <span class="comment">// Disable nonpointer isa if any image contains old Swift code</span></span><br><span class="line">        <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hi-&gt;info()-&gt;containsSwift()  &amp;&amp;</span><br><span class="line">                hi-&gt;info()-&gt;swiftUnstableVersion() &lt; objc_image_info::SwiftVersion3)</span><br><span class="line">            &#123;</span><br><span class="line">                DisableNonpointerIsa = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (PrintRawIsa) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"RAW ISA: disabling non-pointer isa because "</span></span><br><span class="line">                                 <span class="string">"the app or a framework contains Swift code "</span></span><br><span class="line">                                 <span class="string">"older than Swift 3.0"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过宏 <code>SUPPORT_NONPOINTER_ISA</code> 判断当前是否支持开启内存优化的 <code>isa</code><ul>
<li>如果支持，则在某些条件下需要禁用这个优化</li>
</ul>
</li>
<li>通过宏 <code>SUPPORT_INDEXED_ISA</code> 判断当前是否是将类存储在 <code>isa</code> 作为类表索引<ul>
<li>如果是的话，再递归遍历所有的 <code>Mach-O</code> 的头部，并且判断如果是 <code>Swift 3.0</code> 之前的代码，就需要禁用对 <code>isa</code> 的内存优化</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">if</span> TARGET_OS_OSX</span></span><br><span class="line">        <span class="comment">// Disable non-pointer isa if the app is too old</span></span><br><span class="line">        <span class="comment">// (linked before OS X 10.11)</span></span><br><span class="line"><span class="comment">//        if (!dyld_program_sdk_at_least(dyld_platform_version_macOS_10_11)) &#123;</span></span><br><span class="line"><span class="comment">//            DisableNonpointerIsa = true;</span></span><br><span class="line"><span class="comment">//            if (PrintRawIsa) &#123;</span></span><br><span class="line"><span class="comment">//                _objc_inform("RAW ISA: disabling non-pointer isa because "</span></span><br><span class="line"><span class="comment">//                             "the app is too old.");</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Disable non-pointer isa if the app has a __DATA,__objc_rawisa section</span></span><br><span class="line">        <span class="comment">// New apps that load old extensions may need this.</span></span><br><span class="line">        <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hi-&gt;mhdr()-&gt;filetype != MH_EXECUTE) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line">            <span class="keyword">if</span> (getsectiondata(hi-&gt;mhdr(), <span class="string">"__DATA"</span>, <span class="string">"__objc_rawisa"</span>, &amp;<span class="built_in">size</span>)) &#123;</span><br><span class="line">                DisableNonpointerIsa = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (PrintRawIsa) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"RAW ISA: disabling non-pointer isa because "</span></span><br><span class="line">                                 <span class="string">"the app has a __DATA,__objc_rawisa section"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// assume only one MH_EXECUTE image</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过宏 <code>TARGET_OS_OSX</code> 判断是否是 <code>macOS</code> 执行环境</li>
<li>判断 <code>macOS</code> 的系统版本，如果小于 <code>10.11</code> 则说明 <code>app</code> 太陈旧了，需要禁用掉 <code>non-pointer isa</code></li>
<li>然后再遍历所有的 <code>Mach-O</code> 的头部，判断如果有 <code>__DATA__,__objc_rawisa</code> 段的存在，则禁用掉 <code>non-pointer isa</code> ，因为很多新的 <code>app</code> 加载老的扩展的时候会需要这样的判断操作。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// namedClasses</span></span><br><span class="line"><span class="comment">// Preoptimized classes don't go in this table.</span></span><br><span class="line"><span class="comment">// 4/3 is NXMapTable's load factor</span></span><br><span class="line"><span class="keyword">int</span> namedClassesSize = </span><br><span class="line">    (isPreoptimized() ? unoptimizedTotalClasses : totalClasses) * <span class="number">4</span> / <span class="number">3</span>;</span><br><span class="line">gdb_objc_realized_classes =</span><br><span class="line">    NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);</span><br></pre></td></tr></table></figure>

<p>预先优化过的类不会加入到 <code>gdb_objc_realized_classes</code> 这个哈希表中来， <code>gdb_objc_realized_classes</code> 哈希表的装载因子为 0.75，这是一个经过验证的效率很高的扩容临界值。</p>
<ul>
<li>加载所有类到类的 <code>gdb_objc_realized_classes</code> 表中来</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is a misnomer: gdb_objc_realized_classes is actually a list of </span></span><br><span class="line"><span class="comment">// named classes not in the dyld shared cache, whether realized or not.</span></span><br><span class="line"><span class="comment">// This list excludes lazily named classes, which have to be looked up</span></span><br><span class="line"><span class="comment">// using a getClass hook.</span></span><br><span class="line">NXMapTable *gdb_objc_realized_classes;  <span class="comment">// exported for debuggers in objc-gdb.h</span></span><br></pre></td></tr></table></figure>

<p>这是一个误称：gdb_objc_realized_classes 表实际上存储的是不在 <code>dyld</code> 共享缓存里面的命名类，无论这些类是否实现</p>
<p>除了 <code>gdb_objc_realized_classes</code> 表之外，还有一张表 <code>allocatedClasses</code> :</p>
<p>其实 <code>gdb_objc_realized_classes</code> 对 <code>allocatedClasses</code> 是一种包含的关系，一张是类的总表，一张是已经开辟了内存的类表.</p>
<h5 id="Discover-classes-流程"><a href="#Discover-classes-流程" class="headerlink" title="Discover classes 流程"></a>Discover classes 流程</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discover classes. Fix up unresolved future classes. Mark bundle classes.</span></span><br><span class="line"><span class="keyword">bool</span> hasDyldRoots = dyld_shared_cache_some_image_overridden();</span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="keyword">if</span> (! mustReadClasses(hi, hasDyldRoots)) &#123;</span><br><span class="line">        <span class="comment">// Image is sufficiently optimized that we need not call readClass()</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist = _getObjc2ClassList(hi, &amp;count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> headerIsBundle = hi-&gt;isBundle();</span><br><span class="line">    <span class="keyword">bool</span> headerIsPreoptimized = hi-&gt;hasPreoptimizedClasses();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Class cls = (Class)classlist[i];</span><br><span class="line">        Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newCls != cls  &amp;&amp;  newCls) &#123;</span><br><span class="line">            <span class="comment">// Class was moved but not deleted. Currently this occurs </span></span><br><span class="line">            <span class="comment">// only when the new class resolved a future class.</span></span><br><span class="line">            <span class="comment">// Non-lazily realize the class below.</span></span><br><span class="line">            resolvedFutureClasses = (Class *)</span><br><span class="line">                <span class="built_in">realloc</span>(resolvedFutureClasses, </span><br><span class="line">                        (resolvedFutureClassCount+<span class="number">1</span>) * <span class="keyword">sizeof</span>(Class));</span><br><span class="line">            resolvedFutureClasses[resolvedFutureClassCount++] = newCls;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Discover classes. Fix up unresolved future classes. Mark bundle classes.<br>发现类。修正未解析的 <code>future</code> 类，标记 <code>bundle</code> 类。</p>
<ul>
<li>先通过 <code>_getObjc2ClassList</code> 来获取到所有的类</li>
<li>接着还是遍历所有的 <code>Mach-O</code> 的 <code>header</code> 部分，然后通过 <code>mustReadClasses</code> 来判断哪些条件可以跳过读取类这一步骤</li>
<li>读取 <code>header</code> 是否是 <code>Bundle</code></li>
<li>读取 <code>header</code> 是否开启了 <strong>预优化</strong></li>
<li>遍历 <code>_getObjc2ClassList</code> 取出的所有的类<ul>
<li>通过 <code>readClass</code> 来读取类信息</li>
<li>判断如果不相等并且 <code>readClass</code> 结果不为空，则需要重新为类开辟内存</li>
</ul>
</li>
</ul>
<p><strong>Fix up remapped classes 流程</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fix up remapped classes</span></span><br><span class="line"><span class="comment">// Class list and nonlazy class list remain unremapped.</span></span><br><span class="line"><span class="comment">// Class refs and super refs are remapped for message dispatching.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!noClassesRemapped()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        Class *classrefs = _getObjc2ClassRefs(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            remapClassRef(&amp;classrefs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fixme why doesn't test future1 catch the absence of this?</span></span><br><span class="line">        classrefs = _getObjc2SuperRefs(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            remapClassRef(&amp;classrefs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修复 重映射类<br>类表和非懒加载类表没有被重映射 (也就是 <strong>_objc_classlist</strong>)<br>由于消息转发，类引用和父类引用会被重映射 (也就是 <strong>_objc_classrefs</strong>)</p>
<ul>
<li>通过 <code>noClassesRemapped</code> 方法判断是否有类引用(<strong>_objc_classrefs</strong>)需要进行重映射<ul>
<li>如果需要，则遍历 <code>EACH_HEADER</code></li>
<li>通过 <code>_getObjc2ClassRefs</code> 和 <code>_getObjc2SuperRefs</code> 取出当前遍历到的 <code>Mach-O</code> 的类引用和父类引用，然后调用 <code>remapClassRef</code> 进行重映射</li>
</ul>
</li>
</ul>
<p><strong>Fix up @selector references 流程</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Fix up @selector references</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> UnfixedSelectors;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(selLock)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hi-&gt;hasPreoptimizedSelectors()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> isBundle = hi-&gt;isBundle();</span><br><span class="line">            SEL *sels = _getObjc2SelectorRefs(hi, &amp;count);</span><br><span class="line">            UnfixedSelectors += count;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char</span> *name = sel_cname(sels[i]);</span><br><span class="line">                SEL sel = sel_registerNameNoLock(name, isBundle);</span><br><span class="line">                <span class="keyword">if</span> (sels[i] != sel) &#123;</span><br><span class="line">                    sels[i] = sel;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function">SEL <span class="title">sel_registerNameNoLock</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">bool</span> copy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __sel_registerName(name, <span class="number">0</span>, copy);  <span class="comment">// NO lock, maybe copy</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>修正 <code>SEL</code> 引用</p>
</blockquote>
<ul>
<li>操作前先加一个 <code>selLock</code> 锁</li>
<li>然后遍历<code>EACH_HEADER</code><ul>
<li>如果开启了<strong>预优化</strong>，contiue 到下一个 <code>Mach-O</code></li>
<li>通过 <code>_getObjc2SelectorRefs</code> 拿到所有的 <code>SEL</code> 引用</li>
<li>然后对所有的 <code>SEL</code> 引用调用 <code>sel_registerNameNoLock</code> 进行注册</li>
</ul>
</li>
</ul>
<p>也就是说这一流程最主要的目的就是注册 <code>SEL</code> ，我们注册真正发生的地方: <code>__sel_registerName</code> ，这个函数如果大家经常玩 <code>Runtime</code> 肯定不会陌生：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> SEL __sel_registerName(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">bool</span> shouldLock, <span class="keyword">bool</span> copy) </span><br><span class="line">&#123;</span><br><span class="line">    SEL result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldLock) selLock.assertUnlocked();</span><br><span class="line">    <span class="keyword">else</span> selLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!name) <span class="keyword">return</span> (SEL)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    result = search_builtins(name);</span><br><span class="line">    <span class="keyword">if</span> (result) <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">conditional_mutex_locker_t</span> <span class="title">lock</span><span class="params">(selLock, shouldLock)</span></span>;</span><br><span class="line">	<span class="keyword">auto</span> it = namedSelectors.<span class="built_in">get</span>().insert(name);</span><br><span class="line">	<span class="keyword">if</span> (it.second) &#123;</span><br><span class="line">		<span class="comment">// No match. Insert.</span></span><br><span class="line">		*it.first = (<span class="keyword">const</span> <span class="keyword">char</span> *)sel_alloc(name, copy);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (SEL)*it.first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们简单分析一下 <code>__sel_registerName</code> 方法的流程：</p>
<ul>
<li>判断是否要加锁</li>
<li>如果 <code>sel</code> 为空，则返回一个空的 <code>SEL</code></li>
<li>从 <code>builtins</code> 中搜索，看是否已经注册过，如果找到，直接返回结果</li>
<li>从 <code>namedSelectors</code> 哈希表中查询，找到了就返回结果</li>
<li>如果 <code>namedSelectors</code> 未初始化，则创建一下这个哈希表</li>
<li>如果上面的流程都没有找到，则需要调用 <code>sel_alloc</code> 来创建一下 <code>SEL</code> ，然后把新创建的 <code>SEL</code> 插入哈希表中进行缓存的填充</li>
</ul>
<h5 id="Fix-up-old-objc-msgSend-fixup-call-sites-流程"><a href="#Fix-up-old-objc-msgSend-fixup-call-sites-流程" class="headerlink" title="Fix up old objc_msgSend_fixup call sites 流程"></a><strong>Fix up old objc_msgSend_fixup call sites 流程</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_FIXUP</span></span><br><span class="line">    <span class="comment">// Fix up old objc_msgSend_fixup call sites</span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="keyword">message_ref_t</span> *refs = _getObjc2MessageRefs(hi, &amp;count);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (PrintVtables) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"VTABLES: repairing %zu unsupported vtable dispatch "</span></span><br><span class="line">                         <span class="string">"call sites in %s"</span>, count, hi-&gt;fname());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            fixupMessageRef(refs+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: fix up objc_msgSend_fixup"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>修正旧的 <code>objc_msgSend_fixup</code> 调用</p>
<p>这个流程的执行前提是 <code>FIXUP</code> 被开启。</p>
<ul>
<li>还是老套路，遍历<code>EACH_HEADER</code><ul>
<li>通过 <code>_getObjc2MessageRefs</code> 方法来获取当前遍历到的 <code>Mach-O</code> 镜像的所有消息引用</li>
<li>然后遍历这些消息引用，然后调用 <code>fixupMessageRef</code> 进行修正</li>
</ul>
</li>
</ul>
<h5 id="Discover-protocols-流程"><a href="#Discover-protocols-流程" class="headerlink" title="Discover protocols 流程"></a><strong>Discover protocols 流程</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discover protocols. Fix up protocol refs.</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="keyword">extern</span> objc_class OBJC_CLASS_$_Protocol;</span><br><span class="line">    Class cls = (Class)&amp;OBJC_CLASS_$_Protocol;</span><br><span class="line">    ASSERT(cls);</span><br><span class="line">    NXMapTable *protocol_map = protocols();</span><br><span class="line">    <span class="keyword">bool</span> isPreoptimized = hi-&gt;hasPreoptimizedProtocols();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip reading protocols if this is an image from the shared cache</span></span><br><span class="line">    <span class="comment">// and we support roots</span></span><br><span class="line">    <span class="comment">// Note, after launch we do need to walk the protocol as the protocol</span></span><br><span class="line">    <span class="comment">// in the shared cache is marked with isCanonical() and that may not</span></span><br><span class="line">    <span class="comment">// be true if some non-shared cache binary was chosen as the canonical</span></span><br><span class="line">    <span class="comment">// definition</span></span><br><span class="line">    <span class="keyword">if</span> (launchTime &amp;&amp; isPreoptimized) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintProtocols) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"PROTOCOLS: Skipping reading protocols in image: %s"</span>,</span><br><span class="line">                         hi-&gt;fname());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> isBundle = hi-&gt;isBundle();</span><br><span class="line">    <span class="keyword">protocol_t</span> * <span class="keyword">const</span> *protolist = _getObjc2ProtocolList(hi, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        readProtocol(protolist[i], cls, protocol_map, </span><br><span class="line">                     isPreoptimized, isBundle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现协议，并修正协议引用</p>
<h5 id="Fix-up-protocol-references-流程"><a href="#Fix-up-protocol-references-流程" class="headerlink" title="Fix up @protocol references 流程"></a><strong>Fix up @protocol references 流程</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fix up @protocol references</span></span><br><span class="line"><span class="comment">// Preoptimized images may have the right </span></span><br><span class="line"><span class="comment">// answer already but we don't know for sure.</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="comment">// At launch time, we know preoptimized image refs are pointing at the</span></span><br><span class="line">    <span class="comment">// shared cache definition of a protocol.  We can skip the check on</span></span><br><span class="line">    <span class="comment">// launch, but have to visit @protocol refs for shared cache images</span></span><br><span class="line">    <span class="comment">// loaded later.</span></span><br><span class="line">    <span class="keyword">if</span> (launchTime &amp;&amp; hi-&gt;isPreoptimized())</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">protocol_t</span> **protolist = _getObjc2ProtocolRefs(hi, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        remapProtocolRef(&amp;protolist[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对所有的协议做重映射</p>
<h5 id="Realize-non-lazy-classes-流程"><a href="#Realize-non-lazy-classes-流程" class="headerlink" title="Realize non-lazy classes 流程"></a><strong>Realize non-lazy classes 流程</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Realize non-lazy classes (for +load methods and static instances)</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist = hi-&gt;nlclslist(&amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Class cls = remapClass(classlist[i]);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        addClassTableEntry(cls);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;isSwiftStable()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cls-&gt;swiftMetadataInitializer()) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">"Swift class %s with a metadata initializer "</span></span><br><span class="line">                            <span class="string">"is not allowed to be non-lazy"</span>,</span><br><span class="line">                            cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// fixme also disallow relocatable classes</span></span><br><span class="line">            <span class="comment">// We can't disallow all Swift classes because of</span></span><br><span class="line">            <span class="comment">// classes like Swift.__EmptyArrayStorage</span></span><br><span class="line">        &#125;</span><br><span class="line">        realizeClassWithoutSwift(cls, nil);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化<strong>非懒加载类( <code>+load</code> 方法和静态实例</strong>)**</p>
<h5 id="Realize-newly-resolved-future-classes-流程"><a href="#Realize-newly-resolved-future-classes-流程" class="headerlink" title="Realize newly-resolved future classes 流程"></a><strong>Realize newly-resolved future classes 流程</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Realize newly-resolved future classes, in case CF manipulates them</span></span><br><span class="line"><span class="keyword">if</span> (resolvedFutureClasses) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; resolvedFutureClassCount; i++) &#123;</span><br><span class="line">        Class cls = resolvedFutureClasses[i];</span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;isSwiftStable()) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">"Swift class is not allowed to be future"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        realizeClassWithoutSwift(cls, nil);</span><br><span class="line">        cls-&gt;setInstancesRequireRawIsaRecursively(<span class="literal">false</span><span class="comment">/*inherited*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(resolvedFutureClasses);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化新解析出来的 <code>future</code> 类</p>
<h5 id="Discover-categories-流程"><a href="#Discover-categories-流程" class="headerlink" title="Discover categories 流程"></a><strong>Discover categories 流程</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discover categories. Only do this after the initial category</span></span><br><span class="line"><span class="comment">// attachment has been done. For categories present at startup,</span></span><br><span class="line"><span class="comment">// discovery is deferred until the first load_images call after</span></span><br><span class="line"><span class="comment">// the call to _dyld_objc_notify_register completes. rdar://problem/53119145</span></span><br><span class="line"><span class="keyword">if</span> (didInitialAttachCategories) &#123;</span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        load_categories_nolock(hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理所有的分类，包括类和元类</p>
<p>到这里， <code>_read_images</code> 的流程就分析完毕，我们可以新建一个文件来去掉一些干扰的信息，只保留核心的逻辑，这样从宏观的角度来分析更直观:</p>
<p><img src="/images/_read_image_schedule.png" alt="_read_image_schedule"></p>
<p>Q &amp; A 环节<br>Q： <code>dyld</code> 主要逻辑是加载库，也就是镜像文件，但是加载完是怎么读取的呢？<br>A： <code>_read_images</code> 是真正读取的地方</p>
<p>Q: <code>SEL</code> 方法编号何时加载？<br>A: <code>_read_images</code></p>
<h4 id="read-class-分析"><a href="#read-class-分析" class="headerlink" title="read_class 分析"></a>read_class 分析</h4><p>我们探索了 <code>_read_images</code> 方法的流程，接下来让我们把目光放到本文的主题 - <strong>类的加载</strong><br>既然是类的加载，那么我们在前面所探索的类的结构中出现的内容都会一一重现。<br>所以我们不妨直接进行断点调试，让我们略过其它干扰信息，聚焦于类的加载。</p>
<ul>
<li>根据上一小节我们探索的结果， <code>doneOnce</code> 流程中会创建两个哈希表，并没有涉及到类的加载，所以我们跳过</li>
<li>我们来到第二个流程 - <strong>类处理</strong></li>
</ul>
<p>我们在<code>_read_images</code>函数，定位到下面这行代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class cls = (Class)classlist[i];<span class="comment">//断点</span></span><br><span class="line">Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized);</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>cls</code> 的属性、方法、协议以及类名都为空，说明这里类并没有被真正加载完成，我们接着聚焦到 <code>read_class</code> 函数上面，我们进入其内部实现，我们大致浏览之后会定位到如下图所示的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* readClass</span></span><br><span class="line"><span class="comment">* Read a class and metaclass as written by a compiler.</span></span><br><span class="line"><span class="comment">* Returns the new class pointer. This could be: </span></span><br><span class="line"><span class="comment">* - cls</span></span><br><span class="line"><span class="comment">* - nil  (cls has a missing weak-linked superclass)</span></span><br><span class="line"><span class="comment">* - something else (space for this class was reserved by a future class)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Note that all work performed by this function is preflighted by </span></span><br><span class="line"><span class="comment">* mustReadClasses(). Do not change this function without updating that one.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: runtimeLock acquired by map_images or objc_readClassPair</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function">Class <span class="title">readClass</span><span class="params">(Class cls, <span class="keyword">bool</span> headerIsBundle, <span class="keyword">bool</span> headerIsPreoptimized)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mangledName = cls-&gt;nonlazyMangledName();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (missingWeakSuperclass(cls)) &#123;</span><br><span class="line">        <span class="comment">// No superclass (probably weak-linked). </span></span><br><span class="line">        <span class="comment">// Disavow any knowledge of this subclass.</span></span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"CLASS: IGNORING class '%s' with "</span></span><br><span class="line">                         <span class="string">"missing weak-linked superclass"</span>, </span><br><span class="line">                         cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        addRemappedClass(cls, nil);</span><br><span class="line">        cls-&gt;setSuperclass(nil);</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cls-&gt;fixupBackwardDeployingStableSwift();</span><br><span class="line"></span><br><span class="line">    Class replacing = nil;</span><br><span class="line">    <span class="keyword">if</span> (mangledName != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Class newCls = popFutureNamedClass(mangledName)) &#123;</span><br><span class="line">            <span class="comment">// This name was previously allocated as a future class.</span></span><br><span class="line">            <span class="comment">// Copy objc_class to future class's struct.</span></span><br><span class="line">            <span class="comment">// Preserve future's rw data block.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newCls-&gt;isAnySwift()) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">"Can't complete future class request for '%s' "</span></span><br><span class="line">                            <span class="string">"because the real class is too big."</span>,</span><br><span class="line">                            cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">class_rw_t</span> *rw = newCls-&gt;data();</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *old_ro = rw-&gt;ro();</span><br><span class="line">            <span class="built_in">memcpy</span>(newCls, cls, <span class="keyword">sizeof</span>(objc_class));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Manually set address-discriminated ptrauthed fields</span></span><br><span class="line">            <span class="comment">// so that newCls gets the correct signatures.</span></span><br><span class="line">            newCls-&gt;setSuperclass(cls-&gt;getSuperclass());</span><br><span class="line">            newCls-&gt;initIsa(cls-&gt;getIsa());</span><br><span class="line"></span><br><span class="line">            rw-&gt;set_ro((<span class="keyword">class_ro_t</span> *)newCls-&gt;data());</span><br><span class="line">            newCls-&gt;setData(rw);</span><br><span class="line">            freeIfMutable((<span class="keyword">char</span> *)old_ro-&gt;getName());</span><br><span class="line">            <span class="built_in">free</span>((<span class="keyword">void</span> *)old_ro);</span><br><span class="line"></span><br><span class="line">            addRemappedClass(cls, newCls);</span><br><span class="line"></span><br><span class="line">            replacing = cls;</span><br><span class="line">            cls = newCls;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (headerIsPreoptimized  &amp;&amp;  !replacing) &#123;</span><br><span class="line">        <span class="comment">// class list built in shared cache</span></span><br><span class="line">        <span class="comment">// fixme strict assert doesn't work because of duplicates</span></span><br><span class="line">        <span class="comment">// ASSERT(cls == getClass(name));</span></span><br><span class="line">        ASSERT(mangledName == <span class="literal">nullptr</span> || getClassExceptSomeSwift(mangledName));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mangledName) &#123; <span class="comment">//some Swift generic classes can lazily generate their names</span></span><br><span class="line">            addNamedClass(cls, mangledName, replacing);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Class meta = cls-&gt;ISA();</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *metaRO = meta-&gt;bits.safe_ro();</span><br><span class="line">            ASSERT(metaRO-&gt;getNonMetaclass() &amp;&amp; <span class="string">"Metaclass with lazy name must have a pointer to the corresponding nonmetaclass."</span>);</span><br><span class="line">            ASSERT(metaRO-&gt;getNonMetaclass() == cls &amp;&amp; <span class="string">"Metaclass nonmetaclass pointer must equal the original class."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        addClassTableEntry(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for future reference: shared cache never contains MH_BUNDLEs</span></span><br><span class="line">    <span class="keyword">if</span> (headerIsBundle) &#123;</span><br><span class="line">        cls-&gt;data()-&gt;flags |= RO_FROM_BUNDLE;</span><br><span class="line">        cls-&gt;ISA()-&gt;data()-&gt;flags |= RO_FROM_BUNDLE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来类的信息在这里完成了加载，那么为了验证我们的猜想，直接断点调试一下但发现断点根本走不进来，原因在于这里的判断语句</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Class newCls = popFutureNamedClass(mangledName))</span><br></pre></td></tr></table></figure>

<p>判断当前传入的类的类名是否有 <code>future</code> 类的实现，但是我们刚才已经打印了，类名是空的，所以肯定不会执行这里。我们接着往下走：</p>
<ul>
<li>addNamedClass 内部其实是将 <code>cls</code> 插入到 <code>gdb_objc_realized_classes</code> 表</li>
<li>addclassTableEntry 内部是将 <code>cls</code> 插入到 <code>allocatedClasses</code> 表</li>
</ul>
<p>分析完 <code>read_class</code> ，我们回到 <code>_read_images</code> 方法</p>
<p>我们可以看到 <code>read_class</code> 返回的 <code>newCls</code> 会进行一个判断，判断与传入 <code>read_class</code> 之前的 <code>cls</code> 是否相等，而在 <code>read_class</code> 内部只有一个地方对类的内容进行了改动，但是我们刚才测试了是进不去的，所以这个 <code>if</code> 里面的内容我们可以略过，也就是说 <code>resolvedFutureClasses</code> 的内容我们都可以暂时略过。</p>
<p>总结一下 <code>readClass</code> ：</p>
<ul>
<li>判断是不是要后期处理的类<ul>
<li>如果是的话，就取出后期处理的类，读取这个类的 <code>data()</code> 类设置 <code>ro/rw</code></li>
</ul>
</li>
<li>addNamedClass 插入总表</li>
<li>addClassTableEntry 插入已开辟内存的类的表</li>
</ul>
<h4 id="realizeClassWithoutSwift-分析"><a href="#realizeClassWithoutSwift-分析" class="headerlink" title="realizeClassWithoutSwift 分析"></a>realizeClassWithoutSwift 分析</h4><p>通过分析 <code>read_class</code> ，我们可以得知，类已经被注册到两个哈希表中去了，那么现在一切时机都已经成熟了。但是我们还是要略过像 <code>Fix up remapped classes</code> 、 <code>Fix up @selector references</code> 、 <code>fix up old objc_msgSend_fixup call sites</code> 、 <code>Discover protocols. Fix up protocol refs</code> 、 <code>Fix up @protocol references</code> ，因为我们的重点是类的加载，我们最终来到了 <code>Realize non-lazy classes (for +load methods and static instances)</code> ，略去无关信息之后，我们可以看到我们的<br>主角 <code>realizeClassWithoutSwift</code> 闪亮登场了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* realizeClassWithoutSwift</span></span><br><span class="line"><span class="comment">* Performs first-time initialization on class cls, </span></span><br><span class="line"><span class="comment">* including allocating its read-write data.</span></span><br><span class="line"><span class="comment">* Does not perform any Swift-side initialization.</span></span><br><span class="line"><span class="comment">* Returns the real class structure for the class. </span></span><br><span class="line"><span class="comment">* Locking: runtimeLock must be write-locked by the caller</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">realizeClassWithoutSwift</span><span class="params">(Class cls, Class previously)</span></span></span><br></pre></td></tr></table></figure>

<p>从方法的名称以及方法注释我们可以知道， <code>realizeClassWithoutSwift</code> 是进行类的第一次初始化操作，包括分配读写数据也就是我们常说的 <code>rw</code> ，但是并不会进行任何的 <code>Swift</code> 端初始化。我们直接聚焦下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Normal class. Allocate writeable class data.</span></span><br><span class="line">rw = objc::zalloc&lt;<span class="keyword">class_rw_t</span>&gt;();</span><br><span class="line">rw-&gt;set_ro(ro);</span><br><span class="line">rw-&gt;flags = RW_REALIZED|RW_REALIZING|isMeta;</span><br><span class="line">cls-&gt;setData(rw);</span><br></pre></td></tr></table></figure>

<ul>
<li>通过 <code>zalloc</code> 开辟内存空间，返回一个新的 <code>rw</code></li>
<li>把 <code>cls</code> 取出来的 <code>ro</code> 赋值给这个 <code>rw</code></li>
<li>将 <code>rw</code> 设置到 <code>cls</code> 身上</li>
</ul>
<p>可以清楚地看到，此时 <code>rw</code> 还是为空，说明这里只是对 <code>rw</code> 进行了初始化，但是方法、属性、协议这些都没有被添加上。</p>
<p>我们接着往下走:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Realize superclass and metaclass, if they aren't already.</span></span><br><span class="line"><span class="comment">// This needs to be done after RW_REALIZED is set above, for root classes.</span></span><br><span class="line"><span class="comment">// This needs to be done after class index is chosen, for root metaclasses.</span></span><br><span class="line"><span class="comment">// This assumes that none of those classes have Swift contents,</span></span><br><span class="line"><span class="comment">//   or that Swift's initializers have already been called.</span></span><br><span class="line"><span class="comment">//   fixme that assumption will be wrong if we add support</span></span><br><span class="line"><span class="comment">//   for ObjC subclasses of Swift classes.</span></span><br><span class="line">supercls = realizeClassWithoutSwift(remapClass(cls-&gt;getSuperclass()), nil);</span><br><span class="line">metacls = realizeClassWithoutSwift(remapClass(cls-&gt;ISA()), nil);</span><br></pre></td></tr></table></figure>

<p>这里可以看到父类和元类都会递归调用 <code>realizeClassWithoutSwift</code> 来初始化各自的 <code>rw</code> 。为什么在类的加载操作里面要去加载类和元类呢？回忆一下类的结构，答案很简单，要保证 <code>superclass</code> 和 <code>isa</code> 的完整性，也就是保证类的完整性，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update superclass and metaclass in case of remapping</span></span><br><span class="line">cls-&gt;setSuperclass(supercls);</span><br><span class="line">cls-&gt;initClassIsa(metacls);</span><br></pre></td></tr></table></figure>

<p>上面的代码就是最好的证明，初始化完毕的父类和元类被赋值到了类的 <code>superclass</code> 和 <code>isa</code> 上面。</p>
<p>接着往下走可以看到，不光要把父类关联到类上面，还要让父类知道子类的存在。</p>
<p>最后一行代码是 <code>methodizeClass(cls)</code> ，注释显示的是 <code>attach categories</code> ，附加分类到类？我们进入其内部实现一探究竟。</p>
<p>在探索 <code>methodizeClass</code> 前，我们先总结一下 <code>realizeClassWithoutSwift</code> :</p>
<ul>
<li>读取 <code>class</code> 的 <code>data()</code></li>
<li><code>ro/rw</code> 赋值</li>
<li>父类和元类实现<ul>
<li>supercls = realizeClassWithoutSwift(remapClass(cls-&gt;superclass))</li>
<li>metacls = realizeClassWithoutSwift(remapClass(cls-&gt;ISA()))</li>
</ul>
</li>
<li>父类和元类归属关系<ul>
<li>cls-&gt;superclass = supercls</li>
<li>cls-&gt;initClassIsa(metacls)</li>
</ul>
</li>
<li>将当前类链接到其父类的子类列表 addSubclass(supercls, cls)</li>
</ul>
<h4 id="methodizeClass-分析"><a href="#methodizeClass-分析" class="headerlink" title="methodizeClass 分析"></a>methodizeClass 分析</h4><p>realizeClassWithoutSwift方法最后一行调用的是<code>methodizeClass</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* methodizeClass</span></span><br><span class="line"><span class="comment">* Fixes up cls's method list, protocol list, and property list.</span></span><br><span class="line"><span class="comment">* Attaches any outstanding categories.</span></span><br><span class="line"><span class="comment">* Locking: runtimeLock must be held by the caller</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodizeClass</span><span class="params">(Class cls, Class previously)</span></span></span><br></pre></td></tr></table></figure>

<p>对类的方法列表、协议列表和属性列表进行修正<br>附加 <code>category</code> 到类上面来</p>
<p>我们直接往下面走：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Install methods and properties that the class implements itself.</span></span><br><span class="line"><span class="keyword">method_list_t</span> *<span class="built_in">list</span> = ro-&gt;baseMethods();</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">    prepareMethodLists(cls, &amp;<span class="built_in">list</span>, <span class="number">1</span>, YES, isBundleClass(cls), <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (rwe) rwe-&gt;methods.attachLists(&amp;<span class="built_in">list</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从 <code>ro</code> 中取出<strong>方法列表</strong>附加到 <code>rw</code> 上</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">property_list_t</span> *proplist = ro-&gt;baseProperties;</span><br><span class="line"><span class="keyword">if</span> (rwe &amp;&amp; proplist) &#123;</span><br><span class="line">    rwe-&gt;properties.attachLists(&amp;proplist, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从 <code>ro</code> 中取出<strong>属性列表</strong>附加到 <code>rw</code> 上</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol_list_t</span> *protolist = ro-&gt;baseProtocols;</span><br><span class="line"><span class="keyword">if</span> (rwe &amp;&amp; protolist) &#123;</span><br><span class="line">    rwe-&gt;protocols.attachLists(&amp;protolist, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从 <code>ro</code> 中取出<strong>协议列表</strong>附加到 <code>rw</code> 上</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Attach categories.</span></span><br><span class="line"><span class="keyword">if</span> (previously) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isMeta) &#123;</span><br><span class="line">        objc::unattachedCategories.attachToClass(cls, previously,</span><br><span class="line">                                                 ATTACH_METACLASS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// When a class relocates, categories with class methods</span></span><br><span class="line">        <span class="comment">// may be registered on the class itself rather than on</span></span><br><span class="line">        <span class="comment">// the metaclass. Tell attachToClass to look for those.</span></span><br><span class="line">        objc::unattachedCategories.attachToClass(cls, previously,</span><br><span class="line">                                                 ATTACH_CLASS_AND_METACLASS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">objc::unattachedCategories.attachToClass(cls, cls,</span><br><span class="line">                                         isMeta ? ATTACH_METACLASS : ATTACH_CLASS);</span><br></pre></td></tr></table></figure>

<ul>
<li>从 <code>cls</code> 中取出未附加的分类进行附加操作</li>
</ul>
<h3 id="探索-load-images"><a href="#探索-load-images" class="headerlink" title="探索 load_images"></a>探索 load_images</h3><p>我们接着探索 <code>_dyld_objc_notify_register</code> 的第二个参数 <code>load_images</code> ，这个函数指针是在什么时候调用的呢，同样的，我们接着在 <code>dyld</code> 源码中搜索对应的函数指针 <code>sNotifyObjCInit</code> :</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ImageLoader*&gt;::iterator it=sAllImages.<span class="built_in">begin</span>(); it != sAllImages.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">	ImageLoader* <span class="built_in">image</span> = *it;</span><br><span class="line">	<span class="keyword">if</span> ( (<span class="built_in">image</span>-&gt;getState() == dyld_image_state_initialized) &amp;&amp; <span class="built_in">image</span>-&gt;notifyObjC() ) &#123;</span><br><span class="line">		<span class="function">dyld3::ScopedTimer <span class="title">timer</span><span class="params">(DBG_DYLD_TIMING_OBJC_INIT, (<span class="keyword">uint64_t</span>)<span class="built_in">image</span>-&gt;machHeader(), <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">		(*sNotifyObjCInit)(<span class="built_in">image</span>-&gt;getRealPath(), <span class="built_in">image</span>-&gt;machHeader());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在 <code>notifySingle</code> 方法内部， <code>sNotifyObjCInit</code> 函数指针被调用了。根据我们上一篇文章探索 <code>dyld</code> 底层可以知道， <code>_load_images</code> 应该是对于每一个加载进来的 <code>Mach-O</code> 镜像都会递归调用一次。</p>
<p>我们来到 <code>libObjc</code> 源码中 <code>load_images</code> 的定义处:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* load_images</span></span><br><span class="line"><span class="comment">* Process +load in the given images which are being mapped in by dyld.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: write-locks runtimeLock and loadMethodLock</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">bool</span> <span class="title">hasLoadMethods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">prepare_load_methods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span>;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">load_images(<span class="keyword">const</span> <span class="keyword">char</span> *path __unused, <span class="keyword">const</span> struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!didInitialAttachCategories &amp;&amp; didCallDyldNotifyRegister) &#123;</span><br><span class="line">        didInitialAttachCategories = <span class="literal">true</span>;</span><br><span class="line">        loadAllCategories();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Return without taking locks if there are no +load methods here.</span></span><br><span class="line">    <span class="keyword">if</span> (!hasLoadMethods((<span class="keyword">const</span> headerType *)mh)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="function"><span class="keyword">recursive_mutex_locker_t</span> <span class="title">lock</span><span class="params">(loadMethodLock)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// Discover load methods</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock2</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">        prepare_load_methods((<span class="keyword">const</span> headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>处理由 <code>dyld</code> 映射的给定镜像中的 <code>+load</code> 方法</p>
</blockquote>
<ul>
<li>判断是否有 <code>load</code> 方法，如果没有，直接返回</li>
<li>搜索 <code>load</code> 方法，具体实现通过 <code>prepare_load_methods</code></li>
<li>调用 <code>load</code> 方法，具体实现通过 <code>call_load_methods</code></li>
</ul>
<h4 id="prepare-load-methods-分析"><a href="#prepare-load-methods-分析" class="headerlink" title="prepare_load_methods 分析"></a>prepare_load_methods 分析</h4><p>从这个方法名称，我们猜测这里应该做的是 <code>load</code> 方法的一些预处理工作，让我们来到源码进行分析：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_load_methods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count, i;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">category_t</span> * <span class="keyword">const</span> *categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">category_t</span> *cat = categorylist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;isSwiftStable()) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">"Swift class extensions and categories on Swift "</span></span><br><span class="line">                        <span class="string">"classes are not allowed to have +load methods"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        realizeClassWithoutSwift(cls, nil);</span><br><span class="line">        ASSERT(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* prepare_load_methods</span></span><br><span class="line"><span class="comment">* Schedule +load for classes in this image, any un-+load-ed </span></span><br><span class="line"><span class="comment">* superclasses in other images, and any categories in this image.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="comment">// Recursively schedule +load for cls and any un-+load-ed superclasses.</span></span><br><span class="line"><span class="comment">// cls must already be connected.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule_class_load</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    ASSERT(cls-&gt;isRealized());  <span class="comment">// _read_images should realize</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">    schedule_class_load(cls-&gt;getSuperclass());</span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* add_class_to_loadable_list</span></span><br><span class="line"><span class="comment">* Class cls has just become connected. Schedule it for +load if</span></span><br><span class="line"><span class="comment">* it implements a +load method.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_class_to_loadable_list</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IMP method;</span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line">    method = cls-&gt;getLoadMethod();</span><br><span class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;  <span class="comment">// Don't bother if cls has no +load method</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(<span class="string">"LOAD: class '%s' scheduled for +load"</span>, </span><br><span class="line">                     cls-&gt;nameForLogging());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class="line">        loadable_classes_allocated = loadable_classes_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        loadable_classes = (struct loadable_class *)</span><br><span class="line">            <span class="built_in">realloc</span>(loadable_classes,</span><br><span class="line">                              loadable_classes_allocated *</span><br><span class="line">                              <span class="keyword">sizeof</span>(struct loadable_class));</span><br><span class="line">    &#125;</span><br><span class="line">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">    loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先通过 <code>_getObjc2NonlazyClassList</code> 获取所有已经加载进去的类列表</p>
</li>
<li><p>然后通过<code>schedule_class_load</code> 遍历这些类</p>
<ul>
<li>递归调用遍历父类的 <code>load</code> 方法，确保父类的 <code>load</code> 方法顺序排在子类的前面</li>
<li>通过 <code>add_class_to_loadable_list</code> , 把类的 <code>load</code> 方法存在 <code>loadable_classes</code> 里面</li>
</ul>
</li>
<li><p>完成 <code>schedule_class_load</code> 之后，通过 <code>_getObjc2NonlazyCategoryList</code> 取出所有分类数据</p>
</li>
<li><p>然后遍历这些分类</p>
<ul>
<li>通过 <code>realizeClassWithoutSwift</code> 来防止类没有初始化，如果已经初始化了则不影响</li>
<li>通过 <code>add_category_to_loadable_list</code> ，加载分类中的 <code>load</code> 方法到 <code>loadable_categories</code> 里面</li>
</ul>
</li>
</ul>
<h4 id="call-load-methods-分析"><a href="#call-load-methods-分析" class="headerlink" title="call_load_methods 分析"></a>call_load_methods 分析</h4><p>通过名称我们可以知道 <code>call_load_methods</code> 应该就是 <code>load</code> 方法被调用的地方了。我们直接看源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* call_load_methods</span></span><br><span class="line"><span class="comment">* Call all pending class and category +load methods.</span></span><br><span class="line"><span class="comment">* Class +load methods are called superclass-first. </span></span><br><span class="line"><span class="comment">* Category +load methods are not called until after the parent class's +load.</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* This method must be RE-ENTRANT, because a +load could trigger </span></span><br><span class="line"><span class="comment">* more image mapping. In addition, the superclass-first ordering </span></span><br><span class="line"><span class="comment">* must be preserved in the face of re-entrant calls. Therefore, </span></span><br><span class="line"><span class="comment">* only the OUTERMOST call of this function will do anything, and </span></span><br><span class="line"><span class="comment">* that call will handle all loadable classes, even those generated </span></span><br><span class="line"><span class="comment">* while it was running.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* The sequence below preserves +load ordering in the face of </span></span><br><span class="line"><span class="comment">* image loading during a +load, and make sure that no </span></span><br><span class="line"><span class="comment">* +load method is forgotten because it was added during </span></span><br><span class="line"><span class="comment">* a +load call.</span></span><br><span class="line"><span class="comment">* Sequence:</span></span><br><span class="line"><span class="comment">* 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line"><span class="comment">* 2. Call category +loads ONCE.</span></span><br><span class="line"><span class="comment">* 3. Run more +loads if:</span></span><br><span class="line"><span class="comment">*    (a) there are more classes to load, OR</span></span><br><span class="line"><span class="comment">*    (b) there are some potential category +loads that have </span></span><br><span class="line"><span class="comment">*        still never been attempted.</span></span><br><span class="line"><span class="comment">* Category +loads are only run once to ensure "parent class first" </span></span><br><span class="line"><span class="comment">* ordering, even if a category +load triggers a new loadable class </span></span><br><span class="line"><span class="comment">* and a new loadable category attached to that class. </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: loadMethodLock must be held by the caller </span></span><br><span class="line"><span class="comment">*   All other locks must not be held.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = NO;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = YES;</span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>call_load_methods<br>调用类和类别中所有未决的 <code>+load</code> 方法<br>类里面 <code>+load</code> 方法是父类优先调用的<br>而在父类的 <code>+load</code> 之后才会调用分类的 <code>+load</code> 方法</p>
</blockquote>
<ul>
<li>通过 <code>objc_autoreleasePoolPush</code> 压栈一个自动释放池</li>
<li><code>do-while</code>循环开始<ul>
<li>循环调用类的 <code>+load</code> 方法直到找不到为止</li>
<li>调用一次分类中的 <code>+load</code> 方法</li>
</ul>
</li>
<li>通过 <code>objc_autoreleasePoolPop</code> 出栈一个自动释放池</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此， <code>_objc_init</code> 和 <code>_dyld_objc_notify_register</code> 我们就分析完了，我们对类的加载有了更细致的认知。 <code>iOS</code> 底层有时候探索起来确实很枯燥，但是如果能找到高效的方法以及明确自己的所探索的方向，会让自己从宏观上重新审视这门技术。是的，技术只是工具，我们不能被技术所绑架，我们要做到有的放矢的去探索，这样才能事半功倍。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/14/iOS%E5%BA%95%E5%B1%82%EF%BC%9A%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B-main()%E5%87%BD%E6%95%B0%E4%B9%8B%E5%89%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/14/iOS%E5%BA%95%E5%B1%82%EF%BC%9A%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B-main()%E5%87%BD%E6%95%B0%E4%B9%8B%E5%89%8D/" class="post-title-link" itemprop="url">iOS底层：应用加载流程 main()函数之前</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-14 09:57:56" itemprop="dateCreated datePublished" datetime="2021-05-14T09:57:56+08:00">2021-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-17 11:12:23" itemprop="dateModified" datetime="2021-05-17T11:12:23+08:00">2021-05-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>App从点击图标就开启了生命周期，本文从App启动开始探索。</p>
<h3 id="前导知识"><a href="#前导知识" class="headerlink" title="前导知识"></a>前导知识</h3><h4 id="Mach-O文件"><a href="#Mach-O文件" class="headerlink" title="Mach-O文件"></a>Mach-O文件</h4><p>Mach-O is a bunch of file types for different run time executables.<br><code>Mach-O</code> 是 <code>iOS</code> 系统不同运行时期<strong>可执行的文件</strong>的文件类型统称。</p>
<p>维基百科上关于 <code>Mach-O</code> 的描述：</p>
<blockquote>
<p>Mach-O 是 Mach object 文件格式的缩写，它是一种用于记录可执行文件、对象代码、共享库、动态加载代码和内存转储的文件格式。作为 a.out 格式的替代品，Mach-O 提供了更好的扩展性，并提升了符号表中信息的访问速度。<br>大多数基于 Mach 内核的操作系统都使用 Mach-O。NeXTSTEP、OS X 和 iOS 是使用这种格式作为本地可执行文件、库和对象代码的例子。</p>
</blockquote>
<p><code>Mach-O</code>有三种文件类型：Executable<code>、</code>Dylib<code>、</code>Bundle</p>
<ul>
<li><p>ExecutableL类型</p>
<p>So the first executable, that’s the main binary in an app, it’s also the main binary in an app extension.<br><code>Executable</code> 是 <code>app</code> 的二进制主文件，同时也是 <code>app extension</code> 的二进制主文件</p>
<p>我们一般可以在 <code>Xcode</code> 项目中的 <code>Products</code> 文件夹中找到它.</p>
</li>
<li><p><code>Dylib</code>类型</p>
<p>A dylib is a dynamic library, on other platforms meet, you may know those as DSOs or DLLs.<br><code>dylib</code> 是动态库，在其他平台也叫 <code>DSO</code> 或者 <code>DLL</code>。</p>
<p>对于接触 <code>iOS</code> 开发比较早的同学，可能知道我们在 <code>Xcode 7</code> 之前添加一些比如 <code>sqlite</code> 的库的时候，其后缀名为 <code>dylib</code>，而 <code>Xcode 7</code> 之后后缀名都改成了 <code>tbd</code>。</p>
<p>这里引用 <a href="https://stackoverflow.com/questions/31450690/why-xcode-7-shows-tbd-instead-of-dylib" target="_blank" rel="noopener">StackoverFlow</a> 上的一篇回答。</p>
<blockquote>
<p>So it appears that the .dylib file is the actual library of binary code that your project is using and is located in the /usr/lib/ directory on the user’s device. The .tbd file, on the other hand, is just a text file that is included in your project and serves as a link to the required .dylib binary. Since this text file is much smaller than the binary library, it makes the SDK’s download size smaller.</p>
</blockquote>
<p>刚刚我们简单介绍了动态库，还有一种库是静态库，他们的区别是什么呢。</p>
<p>我们先看一下编译的过程：</p>
<p><img src="/images/compile_process.png" alt="compile_process"></p>
<p>当然，这个过程中间其实还设计到编译器前端的 <code>词法分析</code>、<code>语法分析</code>、<code>语义分析</code>、<code>优化</code> 等流程，我们在后面探索 <code>LLVM</code> 和 <code>Clang</code> 的时候会详细介绍。</p>
<p>回到刚才的话题，静态库和动态库的区别：</p>
<blockquote>
<p>Static frameworks are linked at <strong>compile time</strong>. Dynamic frameworks are linked <strong>at runtime</strong>.</p>
</blockquote>
<p>静态库和动态库都是编译好的二进制文件，只是用法不同。那为什么要分动态和静态库呢？</p>
<p><img src="/images/static_link.png" alt="static_link"></p>
<p><img src="/images/dyld_link.png" alt="dyld_link"></p>
<p>通过上面两幅图我们可以知道：</p>
<ul>
<li>静态库表现为：在链接阶段会将汇编生成的目标文件和引用的库一起链接打包到可执行文件中。</li>
<li>动态库的表现为：程序编译并不会链接到目标代码中，在程序可执行文件里面会保留对动态库的引用，其中动态库分为动态链接库和动态加载库。<ul>
<li>动态链接库：在没有被加载到内存的前提下，当可执行文件被加载，动态库也随着被加载到内存中。在<code>Linked Framework and Libraries</code>设置的一些<code>share libraries</code>。【随着程序启动而启动】</li>
<li>动态加载库：当需要的时候再使用<code>dlopen</code>等通过代码或者命令的方式来加载。【在程序启动之后】</li>
</ul>
</li>
</ul>
</li>
<li><p><code>Bundle</code>类型</p>
<p>Now a bundle’s a special kind of dylib that you cannot link against, all you can do is load it at run time by an dlopen and that’s used on a Mac OS for plug-ins.<br>现阶段 Bundle 是一种特殊类型的 dylib，你是无法对其进行链接的。你所能做的是在 Runtime 运行时去通过 dlopen 来加载它，它可以在 macOS 上用于插件。</p>
</li>
<li><p><code>Image</code>和<code>Framework</code></p>
<p>Image refers to any of these three types.<br>镜像文件包含了上述的三种文件类型</p>
<p>a framework is a dylib with a special directory structure around it to holds files needed by that dylib.<br>有很多东西都叫做 Framework，但在本文中，Framework 指的是一个 dylib，它周围有一个特殊的目录结构来保存该 dylib 所需的文件。</p>
</li>
</ul>
<h4 id="Mach-O结构分析"><a href="#Mach-O结构分析" class="headerlink" title="Mach-O结构分析"></a>Mach-O结构分析</h4><h5 id="segment段"><a href="#segment段" class="headerlink" title="segment段"></a><code>segment</code>段</h5><p><img src="/images/Mach-O.png" alt="Mach-O"></p>
<p><code>Mach-O</code>镜像文件是由<code>segments</code>段组成的。</p>
<ul>
<li><p>段的名称为大写格式</p>
<p>所有的段都是 <code>page size</code> 的倍数。</p>
</li>
<li><p>arm64 上段大小为 <code>16</code> 字节</p>
</li>
<li><p>其它架构为 <code>4</code> 字节</p>
</li>
</ul>
<p>这里再提及一下虚拟内存和内存页的知识：</p>
<p><code>具有 VM 机制的操作系统，会对每个运行的进程创建一个逻辑地址空间 logical address space 或者叫虚拟地址空间 virtual address space；该空间的大小由操作系统位数决定：32 位的操作系统，其逻辑地址空间的大小为 4GB，64位的操作系统为 2^34 GB（其计算方式是 2^32 || 2^64(理论上是64位，x86 Intel 是48位)）。</code><br><img src="/images/vitual_memory.png" alt="vitual_memory"></p>
<p><code>虚拟地址空间(或者逻辑地址空间)会被分为相同大小的块，这些块被称为内存页（page）。计算机处理器和它的内存管理单元（MMU - memory management uinit）维护着一张将程序的逻辑地址空间映射到物理地址上的分页表</code>page table<code>。</code></p>
<p><code>在</code>masOS<code>和早版本的</code>iOS<code>中，分页的大小为</code>4kB<code>。在之后的基于</code>A7<code>和</code>A8<code>的系统中，虚拟内存（</code>64<code>位的地址空间）地址空间的分页大小变为了</code>16KB<code>，而物理RAM上的内存分页大小仍然维持在</code>4KB<code>；基于A9及之后的系统，虚拟内存和物理内存的分页都是</code>16KB<code>。</code></p>
<h5 id="section"><a href="#section" class="headerlink" title="section"></a>section</h5><p><img src="/images/Mach-O_section.png" alt="Mach-O_section"></p>
<p>在 segment 段内部还有许多的 section 区。section 名称为小写格式。</p>
<p>But sections are really just a subrange of a segment, they don’t have any of the constraints of being page size, but they are non-overlapping.<br>但是 sections 节实际上只是一个 segment 段的子范围，它们没有页面大小的任何限制，但是它们是不重叠的。</p>
<p>通过<code>MachOView</code>工具查看App的二进制可执行文件可以看到：</p>
<p><img src="/images/section_show.png" alt="section_show"></p>
<h4 id="常见的segments"><a href="#常见的segments" class="headerlink" title="常见的segments"></a>常见的<code>segments</code></h4><ul>
<li><p><code>_TEXT</code>:代码段，包括头文件、代码和常量。只读不可修改</p>
<p><img src="/images/_TEXT_image.png" alt="_TEXT_image"></p>
</li>
<li><p><code>_DATA</code>：数据段，包括全局变量，静态变量等。可读可写。</p>
<p><img src="/images/_DATA_image.png" alt="_DATA_image"></p>
</li>
<li><p><code>_LINKEDIT</code>：如何加载程序的元数据, 包含了方法和变量的元数据（位置，偏移量），以及代码签名等信息。只读不可修改。</p>
<p><img src="/images/_LINKEDIT_image.png" alt="_LINKEDIT_image"></p>
</li>
</ul>
<h5 id="Mach-O-Universal-Files"><a href="#Mach-O-Universal-Files" class="headerlink" title="Mach-O Universal Files"></a>Mach-O Universal Files</h5><p><img src="/images/Mach-o_UniversalFiles.png" alt="Mach-o_UniversalFiles"></p>
<p><code>Mach-O</code> 通用文件，将多种架构的 <code>Mach-O</code> 文件合并而成。它通过 <code>header</code> 来记录不同架构在文件中的偏移量，<code>segement</code> 占多个分页，<code>header</code>占一页的空间。可能有人会觉得 <code>header</code> 单独占一页会浪费空间，但这有利于虚拟内存的实现。</p>
<h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p><img src="/images/virtualMemory_image.png" alt="virtualMemory_image"></p>
<p>虚拟内存是一层<strong>间接寻址</strong>。</p>
<p>虚拟内存解决的是管理所有进程使用<strong>物理 RAM</strong> 的问题。通过添加间接层来让每个进程使用<strong>逻辑地址空间</strong>，它可以映射到 RAM 上的某个物理页上。这种映射不是一对一的，逻辑地址可能映射不到 RAM 上，也可能有多个逻辑地址映射到同一个物理 RAM 上。</p>
<ul>
<li>针对第一种情况，当进程要存储逻辑地址内容时会触发 page fault。</li>
<li>而第二种情况就是多进程共享内存。</li>
<li>对于文件可以不用一次性读入整个文件，可以使用分页映射 mmap() 的方式读取。也就是把文件某个片段映射到进程逻辑内存的某个页上。当某个想要读取的页没有在内存中，就会触发 page fault，内核只会读入那一页，实现文件的懒加载。也就是说 Mach-O 文件中的 __TEXT 段可以映射到多个进程，并可以懒加载，且进程之间共享内存。</li>
<li>__DATA 段是可读写的。这里使用到了 Copy-On-Write 技术，简称 COW。也就是多个进程共享一页内存空间时，一旦有进程要做写操作，它会先将这页内存内容复制一份出来，然后重新映射逻辑地址到新的 RAM 页上。也就是这个进程自己拥有了那页内存的拷贝。这就涉及到了 clean/dirty page 的概念。dirty page 含有进程自己的信息，而 clean page 可以被内核重新生成（重新读磁盘）。所以 dirty page 的代价大于 clean page。</li>
</ul>
<h4 id="多进程加载Mach-O镜像"><a href="#多进程加载Mach-O镜像" class="headerlink" title="多进程加载Mach-O镜像"></a>多进程加载<code>Mach-O</code>镜像</h4><p><img src="/images/Mach-O_image_loading.png" alt="Mach-O_image_loading"></p>
<ul>
<li>所以在多个进程加载 Mach-O 镜像时 __TEXT 和 __LINKEDIT 因为只读，都是可以共享内存的，读取速度就会很快。</li>
<li>而 __DATA 因为可读写，就有可能会产生 dirty page，如果检测到有 clean page 就可以直接使用，反之就需要重新读取 DATA page。一旦产生了 dirty page，当 dyld 执行结束后，__LINKEDIT 需要通知内核当前页面不再需要了，当别人需要的使用时候就可以重新 clean 这些页面。</li>
</ul>
<h4 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h4><p><code>ASLR</code> (Address Space Layout Randomization) 地址空间布局随机化，镜像会在随机的地址上加载。</p>
<h4 id="Code-Signing"><a href="#Code-Signing" class="headerlink" title="Code Signing"></a>Code Signing</h4><p>可能我们认为 <code>Xcode</code> 会把整个文件都做加密 <code>hash</code> 并用做数字签名。其实为了在运行时验证 <code>Mach-O</code> 文件的签名，并不是每次重复读入整个文件，而是把每页内容都生成一个单独的加密散列值，并存储在 <code>__LINKEDIT</code> 中。这使得文件每页的内容都能及时被校验确并保不被篡改。</p>
<h4 id="exec"><a href="#exec" class="headerlink" title="exec()"></a><code>exec()</code></h4><p><img src="/images/exec_image.png" alt="exec_image"></p>
<p>Exec is a system call. When you trap into the kernel, you basically say I want to replace this process with this new program.</p>
<p>exec() 是一个系统调用。系统内核把应用映射到新的地址空间，且每次起始位置都是随机的（因为使用 ASLR）。并将起始位置到 0x000000 这段范围的进程权限都标记为不可读写不可执行。如果是 32 位进程，这个范围至少是 4KB；对于 64 位进程则至少是 4GB 。NULL 指针引用和指针截断误差都是会被它捕获。这个范围也叫做 PAGEZERO。</p>
<h4 id="dyld"><a href="#dyld" class="headerlink" title="dyld"></a><code>dyld</code></h4><p><img src="/images/dyld_image.png" alt="dyld_image"></p>
<p><code>Unix 的前二十年很安逸，因为那时还没有发明动态链接库。有了动态链接库后，一个用于加载链接库的帮助程序被创建。在苹果的平台里是 dyld，其他 Unix 系统也有 ld.so。 当内核完成映射进程的工作后会将名字为 dyld 的 Mach-O 文件映射到进程中的随机地址，它将 PC 寄存器设为 dyld 的地址并运行。dyld 在应用进程中运行的工作是加载应用依赖的所有动态链接库，准备好运行所需的一切，它拥有的权限跟应用一样。</code></p>
<h4 id="dyld流程"><a href="#dyld流程" class="headerlink" title="dyld流程"></a><code>dyld</code>流程</h4><p><img src="/images/dyld_process_image.png" alt="dyld_process_image"></p>
<ul>
<li><p>Load dylibs<br><code>从主执行文件的 header 获取到需要加载的所依赖动态库列表，而 header 早就被内核映射过。然后它需要找到每个 dylib，然后打开文件读取文件起始位置，确保它是 Mach-O 文件。接着会找到代码签名并将其注册到内核。然后在 dylib 文件的每个 segment 上调用 mmap()。应用所依赖的 dylib 文件可能会再依赖其他 dylib，所以 dyld 所需要加载的是动态库列表一个递归依赖的集合。一般应用会加载 100 到 400 个 dylib 文件，但大部分都是系统 dylib，它们会被预先计算和缓存起来，加载速度很快。</code></p>
</li>
<li><p>Fix-ups<br><code>在加载所有的动态链接库之后，它们只是处在相互独立的状态，需要将它们绑定起来，这就是 Fix-ups。代码签名使得我们不能修改指令，那样就不能让一个 dylib 的调用另一个 dylib。这时需要加很多间接层。
现代 code-gen 被叫做动态 PIC（Position Independent Code），意味着代码可以被加载到间接的地址上。当调用发生时，code-gen 实际上会在 __DATA 段中创建一个指向被调用者的指针，然后加载指针并跳转过去。所以 dyld 做的事情就是修正（fix-up）指针和数据。Fix-up 有两种类型，rebasing 和 binding。</code></p>
</li>
<li><p>Rebasing 和 Binding</p>
<p><code>Rebasing：在镜像内部调整指针的指向
Binding：将指针指向镜像外部的内容</code></p>
</li>
</ul>
<p><code>dyld</code> 的时间线由上图可知为：</p>
<p>Load dylibs -&gt; Rebase -&gt; Bind -&gt; ObjC -&gt; Initializers</p>
<h4 id="dyld2-amp-amp-dyld3"><a href="#dyld2-amp-amp-dyld3" class="headerlink" title="dyld2 &amp;&amp; dyld3"></a>dyld2 &amp;&amp; dyld3</h4><p><img src="/images/dyld3_image.png" alt="dyld3_image"></p>
<p>在 <code>iOS 13</code> 之前，所有的第三方 <code>App</code> 都是通过 <code>dyld 2</code> 来启动 <code>App</code> 的，主要过程如下：</p>
<ul>
<li>解析 <code>Mach-O</code> 的 <code>Header</code> 和 <code>Load Commands</code>，找到其依赖的库，并递归找到所有依赖的库</li>
<li>加载 <code>Mach-O</code> 文件</li>
<li>进行符号查找</li>
<li>绑定和变基</li>
<li>运行初始化程序</li>
</ul>
<p>dyld3 被分为了三个组件：</p>
<ul>
<li>一个进程外的 MachO 解析器<ul>
<li>预先处理了所有可能影响启动速度的 search path、@rpaths 和环境变量</li>
<li>然后分析 Mach-O 的 Header 和依赖，并完成了所有符号查找的工作</li>
<li>最后将这些结果创建成了一个启动闭包</li>
<li>这是一个普通的 daemon 进程，可以使用通常的测试架构</li>
</ul>
</li>
<li>一个进程内的引擎，用来运行启动闭包<ul>
<li>这部分在进程中处理</li>
<li>验证启动闭包的安全性，然后映射到 dylib 之中，再跳转到 main 函数</li>
<li>不需要解析 Mach-O 的 Header 和依赖，也不需要符号查找。</li>
</ul>
</li>
<li>一个启动闭包缓存服务<ul>
<li>系统 App 的启动闭包被构建在一个 Shared Cache 中， 我们甚至不需要打开一个单独的文件</li>
<li>对于第三方的 App，我们会在 App 安装或者升级的时候构建这个启动闭包。</li>
<li>在 iOS、tvOS、watchOS中，这这一切都是 App 启动之前完成的。在 macOS 上，由于有 Side Load App，进程内引擎会在首次启动的时候启动一个 daemon 进程，之后就可以使用启动闭包启动了。</li>
</ul>
</li>
</ul>
<p>dyld 3 把很多耗时的查找、计算和 I/O 的事前都预先处理好了，这使得启动速度有了很大的提升。</p>
<p>好了，先导知识就总结到这里，接下来让我们调整呼吸进入下一章~</p>
<h3 id="App加载分析"><a href="#App加载分析" class="headerlink" title="App加载分析"></a>App加载分析</h3><p>我们在探索 <code>iOS</code> 底层的时候，对于对象、类、方法有了一定的认知哦，接下来我们就一起来探索一下应用是怎么加载的。</p>
<p>我们直接新建一个 <code>Single View App</code> 的项目，然后在 <code>main.m</code> 中打一个断点:</p>
<p><img src="/images/demoMain_image.png" alt="demoMain_image"></p>
<p>可以看到堆栈信息为：</p>
<p><img src="/images/launch_stack_image.png" alt="launch_stack_image"></p>
<p>可以看到堆栈栈底是<code>_dyld_start</code>，说明App加载是从<code>_dyld_start</code>开始的</p>
<h4 id="dyld-start"><a href="#dyld-start" class="headerlink" title="_dyld_start"></a>_dyld_start</h4><p>我们在源码里全局搜索_dyld_start。<a href="https://opensource.apple.com/tarballs/dyld/" target="_blank" rel="noopener">源码下载地址</a>,我这里下载的版本是832.7.3，我们可以来到 <code>dyldStartup.s</code> 这个汇编文件，然后我们聚焦于 <code>arm64</code> 架构下的汇编代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __arm64__ &amp;&amp; !TARGET_OS_SIMULATOR</span></span><br><span class="line">	.<span class="built_in">text</span></span><br><span class="line">	.align <span class="number">2</span></span><br><span class="line">	.globl __dyld_start</span><br><span class="line">__dyld_start:</span><br><span class="line">	mov 	x28, sp</span><br><span class="line">	<span class="keyword">and</span>     sp, x28, #~<span class="number">15</span>		<span class="comment">// force 16-byte alignment of stack</span></span><br><span class="line">	mov	x0, #<span class="number">0</span></span><br><span class="line">	mov	x1, #<span class="number">0</span></span><br><span class="line">	stp	x1, x0, [sp, #<span class="number">-16</span>]!	<span class="comment">// make aligned terminating frame</span></span><br><span class="line">	mov	fp, sp			<span class="comment">// set up fp to point to terminating frame</span></span><br><span class="line">	sub	sp, sp, #<span class="number">16</span>             <span class="comment">// make room for local variables</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LP64__</span></span><br><span class="line">	ldr     x0, [x28]               <span class="comment">// get app's mh into x0</span></span><br><span class="line">	ldr     x1, [x28, #<span class="number">8</span>]           <span class="comment">// get argc into x1 (kernel passes 32-bit int argc as 64-bits on stack to keep alignment)</span></span><br><span class="line">	add     x2, x28, #<span class="number">16</span>            <span class="comment">// get argv into x2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	ldr     w0, [x28]               <span class="comment">// get app's mh into x0</span></span><br><span class="line">	ldr     w1, [x28, #<span class="number">4</span>]           <span class="comment">// get argc into x1 (kernel passes 32-bit int argc as 64-bits on stack to keep alignment)</span></span><br><span class="line">	add     w2, w28, #<span class="number">8</span>             <span class="comment">// get argv into x2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	adrp	x3,___dso_handle@page</span><br><span class="line">	add 	x3,x3,___dso_handle@pageoff <span class="comment">// get dyld's mh in to x4</span></span><br><span class="line">	mov	x4,sp                   <span class="comment">// x5 has &amp;startGlue</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// call dyldbootstrap::start(app_mh, argc, argv, dyld_mh, &amp;startGlue)</span></span><br><span class="line">	bl	__ZN13dyldbootstrap5startEPKN5dyld311MachOLoadedEiPPKcS3_Pm</span><br><span class="line">	mov	x16,x0                  <span class="comment">// save entry point address in x16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LP64__</span></span><br><span class="line">	ldr     x1, [sp]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	ldr     w1, [sp]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	cmp	x1, #<span class="number">0</span></span><br><span class="line">	b.ne	Lnew</span><br></pre></td></tr></table></figure>

<p>对于这里的汇编代码，我们肯定也没必要逐行分析，我们直接定位到 <code>bl</code> 语句后面(<code>bl</code> 在汇编层面是跳转的意思)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call dyldbootstrap::start(app_mh, argc, argv, dyld_mh, &amp;startGlue)</span></span><br><span class="line">	bl	__ZN13dyldbootstrap5startEPKN5dyld311MachOLoadedEiPPKcS3_Pm</span><br></pre></td></tr></table></figure>

<p>看注释可以知道，调用位于 dyldbootstrap 命名空间下的 start 方法，我们继续搜索一下这个 start 方法，结果位于 dyldInitialization.cpp 文件(从文件名我们可以看出该文件主要是用来初始化 dyld)，这里查找 start 的时候可能会有很多结果，我们其实可以先搜索命名空间，再搜索 start 方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  This is code to bootstrap dyld.  This work in normally done for a program by dyld and crt.</span></span><br><span class="line"><span class="comment">//  In dyld we have to do this manually.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">uintptr_t</span> <span class="title">start</span><span class="params">(<span class="keyword">const</span> dyld3::MachOLoaded* appsMachHeader, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[],</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">const</span> dyld3::MachOLoaded* dyldsMachHeader, <span class="keyword">uintptr_t</span>* startGlue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Emit kdebug tracepoint to indicate dyld bootstrap has started &lt;rdar://46878536&gt;</span></span><br><span class="line">    dyld3::kdebug_trace_dyld_marker(DBG_DYLD_TIMING_BOOTSTRAP_START, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// if kernel had to slide dyld, we need to fix up load sensitive locations</span></span><br><span class="line">	<span class="comment">// we have to do this before using any global variables</span></span><br><span class="line">  <span class="comment">// dyld 重定向</span></span><br><span class="line">    rebaseDyld(dyldsMachHeader);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// kernel sets up env pointer to be just past end of agv array</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>** envp = &amp;argv[argc+<span class="number">1</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// kernel sets up apple pointer to be just past end of envp array</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>** apple = envp;</span><br><span class="line">	<span class="keyword">while</span>(*apple != <span class="literal">NULL</span>) &#123; ++apple; &#125;</span><br><span class="line">	++apple;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// set up random value for stack canary</span></span><br><span class="line">  <span class="comment">// 栈溢出保护</span></span><br><span class="line">	__guard_setup(apple);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DYLD_INITIALIZER_SUPPORT</span></span><br><span class="line">	<span class="comment">// run all C++ initializers inside dyld</span></span><br><span class="line">  <span class="comment">// 初始化dyld</span></span><br><span class="line">	runDyldInitializers(argc, argv, envp, apple);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	_subsystem_init(apple);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// now that we are done bootstrapping dyld, call dyld's main</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> appsSlide = appsMachHeader-&gt;getSlide();</span><br><span class="line">	<span class="keyword">return</span> dyld::_main((macho_header*)appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>start</code>方法主要做了很多<code>dyld</code>的<code>初始化</code>工作：</p>
<ul>
<li><code>rebaseDyld</code>   <code>dyld重定位</code></li>
<li><code>__guard_setup</code>   <code>栈溢出保护</code></li>
</ul>
<p>在结束<code>dyld初始化</code>工作后，函数调用 <code>dyld::_main()</code> 函数，再将返回值传递给<code>__dyld_start</code>去调用真正的<code>main</code>函数。</p>
<h4 id="dyld-main"><a href="#dyld-main" class="headerlink" title="dyld::_main"></a>dyld::_main</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Entry point for dyld.  The kernel loads dyld and jumps to __dyld_start which</span></span><br><span class="line"><span class="comment">// sets up some registers and call this function.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns address of main() in target program which __dyld_start jumps to</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">		<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">		<span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">///省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_main方法</code> 官方的注释如下：</p>
<blockquote>
<p><code>dyld</code> 的入口。内核加载了 <code>dyld</code> 然后跳转到 <code>__dyld_start</code> 来设置一些寄存器的值然后调用到了这个方法。<br>返回 <code>__dyld_start</code> 所跳转到的目标程序的 <code>main</code> 函数地址。</p>
</blockquote>
<p><code>dyld</code>流程可总结为九个步骤：</p>
<ul>
<li>第一步：<code>设置运行环境</code></li>
<li>第二步：<code>加载共享缓存</code></li>
<li>第三步：<code>实例化主程序</code></li>
<li>第四步：<code>加载插入的动态库</code></li>
<li>第五步：<code>链接主程序</code></li>
<li>第六步：<code>链接插入的动态库</code></li>
<li>第七步：<code>执行弱引用绑定</code></li>
<li>第八步：<code>执行初始化方法</code></li>
<li>第九步：<code>查找程序入口main然后返回</code></li>
</ul>
<h5 id="第一步：设置运行环境"><a href="#第一步：设置运行环境" class="headerlink" title="第一步：设置运行环境"></a>第一步：设置运行环境</h5><p>这一步主要是设置程序的<code>运行环境</code>，<code>运行条件</code>等准备工作，包括<code>环境</code>，<code>平台</code>，<code>版本</code>，<code>路径</code>，<code>主机</code>信息，设置<code>程序上下文信息</code>等</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取主程序的hash</span></span><br><span class="line">    mainExecutableCDHash = mainExecutableCDHashBuffer;</span><br><span class="line"><span class="comment">// 获取主程序的macho_header结构</span></span><br><span class="line">    sMainExecutableMachHeader = mainExecutableMH;</span><br><span class="line"><span class="comment">// 获取主程序的slide值</span></span><br><span class="line">    sMainExecutableSlide = mainExecutableSlide;</span><br><span class="line"><span class="comment">// 设置上下文信息</span></span><br><span class="line">    setContext(mainExecutableMH, argc, argv, envp, apple);</span><br><span class="line"><span class="comment">// 获取主程序路径</span></span><br><span class="line">    sExecPath = _simple_getenv(apple, <span class="string">"executable_path"</span>);</span><br><span class="line"><span class="comment">// 进程的头环境配置</span></span><br><span class="line">    configureProcessRestrictions(mainExecutableMH, envp);</span><br><span class="line"><span class="comment">// 检测环境变量</span></span><br><span class="line">    checkEnvironmentVariables(envp);</span><br><span class="line">    defaultUninitializedFallbackPaths(envp);</span><br><span class="line"><span class="comment">// 获取主机信息 可理解为 程序结构</span></span><br><span class="line">    getHostInfo(mainExecutableMH, mainExecutableSlide);</span><br></pre></td></tr></table></figure>

<h5 id="第二步：加载共享缓存"><a href="#第二步：加载共享缓存" class="headerlink" title="第二步：加载共享缓存"></a><strong>第二步：加载共享缓存</strong></h5><p>首先检查<code>dyld</code>共享缓存区是否<code>禁用</code>，<code>iOS</code>必须<code>开启</code>，在<code>checkSharedRegionDisable</code>里面<code>iOS</code>环境下注释：</p>
<p><code>// iOS cannot run without shared region</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查缓存共享区域是否开启</span></span><br><span class="line">    checkSharedRegionDisable((dyld3::MachOLoaded*)mainExecutableMH, mainExecutableSlide);</span><br><span class="line"><span class="comment">// 共享缓存加载</span></span><br><span class="line">    mapSharedCache();</span><br><span class="line"><span class="comment">// mapSharedCache 函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mapSharedCache</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dyld3::SharedCacheOptions opts;</span><br><span class="line">    opts.cacheDirOverride   = sSharedCacheOverrideDir;</span><br><span class="line">    opts.forcePrivate       = (gLinkContext.sharedRegionMode == ImageLoader::kUsePrivateSharedRegion);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __x86_64__ &amp;&amp; !TARGET_OS_SIMULATOR</span></span><br><span class="line">    opts.useHaswell         = sHaswell;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    opts.useHaswell         = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    opts.verbose            = gLinkContext.verboseMapping;</span><br><span class="line"><span class="comment">//--- 加载dyld缓存主函数</span></span><br><span class="line">    loadDyldCache(opts, &amp;sSharedCacheLoadInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update global state</span></span><br><span class="line">    <span class="keyword">if</span> ( sSharedCacheLoadInfo.loadAddress != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">        gLinkContext.dyldCache                              = sSharedCacheLoadInfo.loadAddress;</span><br><span class="line">        dyld::gProcessInfo-&gt;processDetachedFromSharedRegion = opts.forcePrivate;</span><br><span class="line">        dyld::gProcessInfo-&gt;sharedCacheSlide                = sSharedCacheLoadInfo.slide;</span><br><span class="line">        dyld::gProcessInfo-&gt;sharedCacheBaseAddress          = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)sSharedCacheLoadInfo.loadAddress;</span><br><span class="line">        sSharedCacheLoadInfo.loadAddress-&gt;getUUID(dyld::gProcessInfo-&gt;sharedCacheUUID);</span><br><span class="line">        dyld3::kdebug_trace_dyld_image(DBG_DYLD_UUID_SHARED_CACHE_A, sSharedCacheLoadInfo.path, (<span class="keyword">const</span> <span class="keyword">uuid_t</span> *)&amp;dyld::gProcessInfo-&gt;sharedCacheUUID[<span class="number">0</span>], &#123;<span class="number">0</span>,<span class="number">0</span>&#125;, &#123;&#123; <span class="number">0</span>, <span class="number">0</span> &#125;&#125;, (<span class="keyword">const</span> mach_header *)sSharedCacheLoadInfo.loadAddress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// loadDyldCache函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">loadDyldCache</span><span class="params">(<span class="keyword">const</span> SharedCacheOptions&amp; options, SharedCacheLoadInfo* results)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    results-&gt;loadAddress        = <span class="number">0</span>;</span><br><span class="line">    results-&gt;slide              = <span class="number">0</span>;</span><br><span class="line">    results-&gt;errorMessage       = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_SIMULATOR</span></span><br><span class="line">    <span class="comment">// simulator only supports mmap()ing cache privately into process</span></span><br><span class="line">    <span class="keyword">return</span> mapCachePrivate(options, results);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> ( options.forcePrivate ) &#123;</span><br><span class="line">        <span class="comment">// mmap cache into this process only</span></span><br><span class="line">        <span class="keyword">return</span> mapCachePrivate(options, results);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// fast path: when cache is already mapped into shared region</span></span><br><span class="line">        <span class="keyword">bool</span> hasError = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> ( reuseExistingCache(options, results) ) &#123;</span><br><span class="line">            hasError = (results-&gt;errorMessage != <span class="literal">nullptr</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// slow path: this is first process to load cache</span></span><br><span class="line">            hasError = mapCacheSystemWide(options, results);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasError;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mapSharedCache</code>函数主要调用<code>loadDyldCache</code> 函数，<code>loadDyldCache</code>函数主要有三种方式加载共享缓存：</p>
<ul>
<li><code>mapCachePrivate()</code> 仅加载到当前进程</li>
<li>共享缓存已经加载过，不做任何处理</li>
<li><code>mapCacheSystemWide()</code> 未加载过，首次加载</li>
</ul>
<h5 id="第三步：实例化主程序"><a href="#第三步：实例化主程序" class="headerlink" title="第三步：实例化主程序"></a><strong>第三步：实例化主程序</strong></h5><p>这一步主要是将主程序的<code>Mach-O</code>加载进内存，并实例化一个<code>ImageLoader</code>。<code>instantiateFromLoadedImage()</code> 首先调用<code>isCompatibleMachO()</code> 函数检测当前进程的<code>magic</code>、<code>cputype</code>、<code>cpusubtype</code> 等相关属性，判断<code>Mach-O</code>文件的<code>兼容性</code>，如果兼容性满足，就调用<code>ImageLoaderMachO::instantiateMainExecutable()</code>实例化主程序的<code>ImageLoader</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第三步：实例化主程序</span></span><br><span class="line">        sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);</span><br><span class="line">        gLinkContext.mainExecutable = sMainExecutable;</span><br><span class="line">        gLinkContext.mainExecutableCodeSigned = hasCodeSignatureLoadCommand(mainExecutableMH);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The kernel maps in main executable before dyld gets control.  We need to </span></span><br><span class="line"><span class="comment">// make an ImageLoader* for the already mapped in main executable.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ImageLoaderMachO* <span class="title">instantiateFromLoadedImage</span><span class="params">(<span class="keyword">const</span> macho_header* mh, <span class="keyword">uintptr_t</span> slide, <span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// try mach-o loader</span></span><br><span class="line">    <span class="keyword">if</span> ( isCompatibleMachO((<span class="keyword">const</span> <span class="keyword">uint8_t</span>*)mh, path) ) &#123;</span><br><span class="line">        ImageLoader* <span class="built_in">image</span> = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext);</span><br><span class="line">        addImage(<span class="built_in">image</span>);</span><br><span class="line">        <span class="keyword">return</span> (ImageLoaderMachO*)<span class="built_in">image</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"main executable not a known format"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create image for main executable</span></span><br><span class="line"><span class="function">ImageLoader* <span class="title">ImageLoaderMachO::instantiateMainExecutable</span><span class="params">(<span class="keyword">const</span> macho_header* mh, <span class="keyword">uintptr_t</span> slide, <span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> LinkContext&amp; context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//dyld::log("ImageLoader=%ld, ImageLoaderMachO=%ld, ImageLoaderMachOClassic=%ld, ImageLoaderMachOCompressed=%ld\n",</span></span><br><span class="line">    <span class="comment">//  sizeof(ImageLoader), sizeof(ImageLoaderMachO), sizeof(ImageLoaderMachOClassic), sizeof(ImageLoaderMachOCompressed));</span></span><br><span class="line">    <span class="keyword">bool</span> compressed;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> segCount;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> libCount;</span><br><span class="line">    <span class="keyword">const</span> linkedit_data_command* codeSigCmd;</span><br><span class="line">    <span class="keyword">const</span> encryption_info_command* encryptCmd;</span><br><span class="line">    sniffLoadCommands(mh, path, <span class="literal">false</span>, &amp;compressed, &amp;segCount, &amp;libCount, context, &amp;codeSigCmd, &amp;encryptCmd);</span><br><span class="line">    <span class="comment">// instantiate concrete class based on content of load commands</span></span><br><span class="line">    <span class="keyword">if</span> ( compressed ) </span><br><span class="line">        <span class="keyword">return</span> ImageLoaderMachOCompressed::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">#<span class="keyword">if</span> SUPPORT_CLASSIC_MACHO</span><br><span class="line">        <span class="keyword">return</span> ImageLoaderMachOClassic::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">throw</span> <span class="string">"missing LC_DYLD_INFO load command"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>instantiateMainExecutable()</code>  函数中通过<code>sniffLoadCommands()</code> 判断这个<code>mach-o</code>文件是<code>普通的</code>还是<code>压缩</code>的LINKEDIT，以及它有多少段。<br> 最后根据<code>compressed</code> 是否压缩来实例化最后返回的<code>ImageLoader</code>。</p>
<h5 id="第四步：加载插入的动态库"><a href="#第四步：加载插入的动态库" class="headerlink" title="第四步：加载插入的动态库"></a><strong>第四步：加载插入的动态库</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第四步：加载插入的动态库</span></span><br><span class="line">        <span class="keyword">if</span>  ( sEnv.DYLD_INSERT_LIBRARIES != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class="literal">NULL</span>; ++lib) </span><br><span class="line">                loadInsertedDylib(*lib);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><code>loadInsertedDylib()</code> 函数中设置了一个<code>LoadContext</code>，并为它配置一些参数后，调用<code>load()</code> 方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ImageLoader* <span class="title">load</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> LoadContext&amp; context, <span class="keyword">unsigned</span>&amp; cacheIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line"><span class="comment">// try all path permutations and check against existing loaded images</span></span><br><span class="line"></span><br><span class="line">    ImageLoader* <span class="built_in">image</span> = loadPhase0(path, orgPath, context, cacheIndex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">image</span> != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        CRSetCrashLogMessage2(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">image</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// try all path permutations and try open() until first success</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; exceptions;</span><br><span class="line">    <span class="built_in">image</span> = loadPhase0(path, orgPath, context, cacheIndex, &amp;exceptions);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_OS_SIMULATOR</span></span><br><span class="line">    <span class="comment">// &lt;rdar://problem/16704628&gt; support symlinks on disk to a path in dyld shared cache</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">image</span> == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">image</span> = loadPhase2cache(path, orgPath, context, cacheIndex, &amp;exceptions);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    CRSetCrashLogMessage2(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">image</span> != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        <span class="comment">// &lt;rdar://problem/6916014&gt; leak in dyld during dlopen when using DYLD_ variables</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;::iterator it = exceptions.<span class="built_in">begin</span>(); it != exceptions.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            <span class="built_in">free</span>((<span class="keyword">void</span>*)(*it));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if loaded image is not from cache, but original path is in cache</span></span><br><span class="line">        <span class="comment">// set gSharedCacheOverridden flag to disable some ObjC optimizations</span></span><br><span class="line">        <span class="keyword">if</span> ( !gSharedCacheOverridden &amp;&amp; !<span class="built_in">image</span>-&gt;inSharedCache() &amp;&amp; <span class="built_in">image</span>-&gt;isDylib() &amp;&amp; dyld3::MachOFile::isSharedCacheEligiblePath(path) &amp;&amp; inSharedCache(path) ) &#123;</span><br><span class="line">            gSharedCacheOverridden = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">image</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第五步：链接主程序"><a href="#第五步：链接主程序" class="headerlink" title="第五步：链接主程序"></a><strong>第五步：链接主程序</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第五步：链接主程序        Executable：可执行的意思</span></span><br><span class="line">        link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, </span><br><span class="line">        <span class="literal">true</span>, ImageLoader::RPathChain(<span class="literal">NULL</span>, <span class="literal">NULL</span>), <span class="number">-1</span>);</span><br></pre></td></tr></table></figure>

<p>调用<code>link()</code>函数将实例化后的主程序进行<code>动态修正</code>，让二进制变为可正常执行的状态。<code>link()</code>函数内部调用了<code>ImgaeLoader::link()</code> 函数，主要做了下面几件事：</p>
<ul>
<li>this-&gt;<code>recursiveLoadLibraries()</code>  递归加载依赖库进内存</li>
<li>this-&gt;<code>recursiveUpdateDepth()</code>   递归更新依赖库的路径</li>
<li>this-&gt;<code>recursiveRebaseWithAccounting()</code>   递归重定位主程序和依赖库</li>
<li>this-&gt;<code>recursiveBindWithAccounting()</code>   递归将主程序和依赖库执行符号表绑定（链接动态库使用）</li>
<li>this-&gt;<code>weakBind()</code>   如果不是正在链接主程序二进制，那就主程序弱符号绑定（链接动态库使用）</li>
<li>this-&gt;<code>recursiveApplyInterposing()</code>   递归申请可插入依赖库权限</li>
<li>this-&gt;<code>recursiveMakeDataReadOnly()</code>   递归设置所有信息只读（链接动态库使用）</li>
<li>this-&gt;<code>recursiveGetDOFSections()</code>  注册DOF节</li>
</ul>
<p>代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageLoader::link</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context, <span class="keyword">bool</span> forceLazysBound, <span class="keyword">bool</span> preflightOnly, <span class="keyword">bool</span> neverUnload, <span class="keyword">const</span> RPathChain&amp; loaderRPaths, <span class="keyword">const</span> <span class="keyword">char</span>* imagePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// clear error strings</span></span><br><span class="line">    (*context.setErrorStrings)(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> t0 = mach_absolute_time();</span><br><span class="line">       <span class="comment">// 递归加载依赖库进内存</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;recursiveLoadLibraries(context, preflightOnly, loaderRPaths, imagePath);</span><br><span class="line">    context.notifyBatch(dyld_image_state_dependents_mapped, preflightOnly);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we only do the loading step for preflights</span></span><br><span class="line">    <span class="keyword">if</span> ( preflightOnly )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line">       <span class="comment">// 递归更新依赖库的路径</span></span><br><span class="line">    context.clearAllDepths();</span><br><span class="line">    <span class="keyword">this</span>-&gt;recursiveUpdateDepth(context.imageCount());</span><br><span class="line"></span><br><span class="line">    __block <span class="keyword">uint64_t</span> t2, t3, t4, t5;</span><br><span class="line">    &#123;</span><br><span class="line">        dyld3::ScopedTimer(DBG_DYLD_TIMING_APPLY_FIXUPS, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        t2 = mach_absolute_time();</span><br><span class="line">        <span class="comment">// 递归重定位主程序和依赖库</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;recursiveRebaseWithAccounting(context);</span><br><span class="line">        context.notifyBatch(dyld_image_state_rebased, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        t3 = mach_absolute_time();</span><br><span class="line">        <span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line">            <span class="comment">// 递归将主程序和依赖库执行符号表绑定</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;recursiveBindWithAccounting(context, forceLazysBound, neverUnload);</span><br><span class="line"></span><br><span class="line">        t4 = mach_absolute_time();</span><br><span class="line">        <span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line">        <span class="comment">// 如果不是正在链接主程序二进制，那就主程序弱符号绑定</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;weakBind(context);</span><br><span class="line">        t5 = mach_absolute_time();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// interpose any dynamically loaded images</span></span><br><span class="line">    <span class="keyword">if</span> ( !context.linkingMainExecutable &amp;&amp; (fgInterposingTuples.<span class="built_in">size</span>() != <span class="number">0</span>) ) &#123;</span><br><span class="line">        <span class="function">dyld3::ScopedTimer <span class="title">timer</span><span class="params">(DBG_DYLD_TIMING_APPLY_INTERPOSING, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 递归申请可插入依赖库权限</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;recursiveApplyInterposing(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now that all fixups are done, make __DATA_CONST segments read-only</span></span><br><span class="line">    <span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line">      <span class="comment">// 递归设置所有信息只读</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;recursiveMakeDataReadOnly(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line">        context.notifyBatch(dyld_image_state_bound, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> t6 = mach_absolute_time();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( context.registerDOFs != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;DOFInfo&gt; dofs;</span><br><span class="line">       <span class="comment">//  注册DOF节</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;recursiveGetDOFSections(context, dofs);</span><br><span class="line">        context.registerDOFs(dofs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint64_t</span> t7 = mach_absolute_time();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear error strings</span></span><br><span class="line">    (*context.setErrorStrings)(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    fgTotalLoadLibrariesTime += t1 - t0;</span><br><span class="line">    fgTotalRebaseTime += t3 - t2;</span><br><span class="line">    fgTotalBindTime += t4 - t3;</span><br><span class="line">    fgTotalWeakBindTime += t5 - t4;</span><br><span class="line">    fgTotalDOF += t7 - t6;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// done with initial dylib loads</span></span><br><span class="line">    fgNextPIEDylibAddress = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第六步：链接插入的动态库"><a href="#第六步：链接插入的动态库" class="headerlink" title="第六步：链接插入的动态库"></a><strong>第六步：链接插入的动态库</strong></h5><p>这一步跟链接主程序一样，将<code>sAllImages</code>中的<code>ImageLoader</code>遍历出来，然后调用<code>link()</code>进行链接，需要注意的是，<code>sAllImages</code>中保存的第一个是<code>主程序</code>的镜像，所以要获取所有的动态库的<code>ImageLoader</code>，就必须从<code>i + 1</code> 开始遍历：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">    ImageLoader* <span class="built_in">image</span> = sAllImages[i+<span class="number">1</span>];</span><br><span class="line">    link(<span class="built_in">image</span>, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>, ImageLoader::RPathChain(<span class="literal">NULL</span>, <span class="literal">NULL</span>), <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">image</span>-&gt;setNeverUnloadRecursive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第七步：执行主程序弱符号绑定"><a href="#第七步：执行主程序弱符号绑定" class="headerlink" title="第七步：执行主程序弱符号绑定"></a><strong>第七步：执行主程序弱符号绑定</strong></h5><p><code>weakBind()</code>首先通过<code>getCoalescedImages()</code>合并所有动态库的<code>弱符号</code>到一个列表里，然后调用<code>initializeCoalIterator()</code>对需要绑定的弱符号进行排序，接着调用<code>incrementCoalIterator()</code>读取<code>dyld_info_command</code>结构的<code>weak_bind_off</code>和<code>weak_bind_size</code>字段，确定弱符号的<code>数据偏移</code>与大小，最终进行弱符号绑定</p>
<h5 id="第八步：执行初始化方法"><a href="#第八步：执行初始化方法" class="headerlink" title="第八步：执行初始化方法"></a><strong>第八步：执行初始化方法</strong></h5><p>这一步就开始进行初始化工作了，<code>initializeMainExecutable()</code> 函数中调用 <code>runInitializers()</code> 函数，接着依次调用 <code>processInitializers()</code> 函数进行一些初始化准备工作，接着<code>recursiveInitialization()</code> 函数调用进行初始化工作，接着全局搜索<code>recursiveInitialization(</code>，找到<code>ImageLoader.cpp</code>中的此方法定义，看重点，函数里面我们看到<code>noffitySingle()单个通知注入</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageLoader::recursiveInitialization</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context, <span class="keyword">mach_port_t</span> this_thread, <span class="keyword">const</span> <span class="keyword">char</span>* pathToInitialize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InitializerTimingList&amp; timingInfo, UninitedUpwards&amp; uninitUps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">recursive_lock <span class="title">lock_info</span><span class="params">(this_thread)</span></span>;</span><br><span class="line">    recursiveSpinLock(lock_info);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( fState &lt; dyld_image_state_dependents_initialized<span class="number">-1</span> ) &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> oldState = fState;</span><br><span class="line">        <span class="comment">// break cycles</span></span><br><span class="line">        fState = dyld_image_state_dependents_initialized<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// initialize lower level libraries first</span></span><br><span class="line">            <span class="comment">// 先初始化底层依赖库</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; libraryCount(); ++i) &#123;</span><br><span class="line">                ImageLoader* dependentImage = libImage(i);</span><br><span class="line">                <span class="keyword">if</span> ( dependentImage != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">                    <span class="comment">// don't try to initialize stuff "above" me yet</span></span><br><span class="line">                    <span class="keyword">if</span> ( libIsUpward(i) ) &#123;</span><br><span class="line">                        uninitUps.imagesAndPaths[uninitUps.count] = &#123; dependentImage, libPath(i) &#125;;</span><br><span class="line">                        uninitUps.count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ( dependentImage-&gt;fDepth &gt;= fDepth ) &#123;</span><br><span class="line">                        dependentImage-&gt;recursiveInitialization(context, this_thread, libPath(i), timingInfo, uninitUps);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// record termination order</span></span><br><span class="line">            <span class="comment">// 记录终端序号</span></span><br><span class="line">            <span class="keyword">if</span> ( <span class="keyword">this</span>-&gt;needsTermination() )</span><br><span class="line">                context.terminationRecorder(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// let objc know we are about to initialize this image</span></span><br><span class="line">            <span class="comment">// 单个通知注入 通知告知大家我要开始初始化啦，你们赶紧去做初始化的工作</span></span><br><span class="line">            <span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line">            fState = dyld_image_state_dependents_initialized;</span><br><span class="line">            oldState = fState;</span><br><span class="line">            context.notifySingle(dyld_image_state_dependents_initialized, <span class="keyword">this</span>, &amp;timingInfo);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// initialize this image</span></span><br><span class="line">            <span class="keyword">bool</span> hasInitializers = <span class="keyword">this</span>-&gt;doInitialization(context);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// let anyone know we finished initializing this image</span></span><br><span class="line">            fState = dyld_image_state_initialized;</span><br><span class="line">            oldState = fState;</span><br><span class="line">            context.notifySingle(dyld_image_state_initialized, <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> ( hasInitializers ) &#123;</span><br><span class="line">                <span class="keyword">uint64_t</span> t2 = mach_absolute_time();</span><br><span class="line">                timingInfo.addTime(<span class="keyword">this</span>-&gt;getShortName(), t2-t1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line">            <span class="comment">// this image is not initialized</span></span><br><span class="line">            fState = oldState;</span><br><span class="line">            recursiveSpinUnLock();</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    recursiveSpinUnLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="探索-objc-init"><a href="#探索-objc-init" class="headerlink" title="探索 _objc_init"></a>探索 _objc_init</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    runtime_init();</span><br><span class="line">    exception_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    <span class="keyword">cache_t</span>::init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    _imp_implementationWithBlock_init();</span><br><span class="line"></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    didCallDyldNotifyRegister = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过LLDB来断掉调试<code>_objc_init</code>,然后通过<code>bt</code>命令打印出当前的调用堆栈，根据上一节我们探索<code>dyld</code>源码，感觉很清晰：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(lldb) bt</span><br><span class="line">* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1</span><br><span class="line">  * frame #<span class="number">0</span>: <span class="number">0x00000001002d29c4</span> libobjc.A.dylib`_objc_init at objc-os.mm:<span class="number">925</span>:<span class="number">9</span></span><br><span class="line">    frame #<span class="number">1</span>: <span class="number">0x000000010044f0bc</span> libdispatch.dylib`_os_object_init + <span class="number">13</span></span><br><span class="line">    frame #<span class="number">2</span>: <span class="number">0x000000010045fafc</span> libdispatch.dylib`libdispatch_init + <span class="number">282</span></span><br><span class="line">    frame #<span class="number">3</span>: <span class="number">0x00007fff6a99c791</span> libSystem.B.dylib`libSystem_initializer + <span class="number">220</span></span><br><span class="line">    frame #<span class="number">4</span>: <span class="number">0x000000010002f1d3</span> dyld`ImageLoaderMachO::doModInitFunctions(ImageLoader::LinkContext <span class="keyword">const</span>&amp;) + <span class="number">535</span></span><br><span class="line">    frame #<span class="number">5</span>: <span class="number">0x000000010002f5de</span> dyld`ImageLoaderMachO::doInitialization(ImageLoader::LinkContext <span class="keyword">const</span>&amp;) + <span class="number">40</span></span><br><span class="line">    frame #<span class="number">6</span>: <span class="number">0x0000000100029ffb</span> dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext <span class="keyword">const</span>&amp;, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">char</span> <span class="keyword">const</span>*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class="number">493</span></span><br><span class="line">    frame #<span class="number">7</span>: <span class="number">0x0000000100029f66</span> dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext <span class="keyword">const</span>&amp;, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">char</span> <span class="keyword">const</span>*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class="number">344</span></span><br><span class="line">    frame #<span class="number">8</span>: <span class="number">0x00000001000280b4</span> dyld`ImageLoader::processInitializers(ImageLoader::LinkContext <span class="keyword">const</span>&amp;, <span class="keyword">unsigned</span> <span class="keyword">int</span>, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class="number">188</span></span><br><span class="line">    frame #<span class="number">9</span>: <span class="number">0x0000000100028154</span> dyld`ImageLoader::runInitializers(ImageLoader::LinkContext <span class="keyword">const</span>&amp;, ImageLoader::InitializerTimingList&amp;) + <span class="number">82</span></span><br><span class="line">    frame #<span class="number">10</span>: <span class="number">0x0000000100016662</span> dyld`dyld::initializeMainExecutable() + <span class="number">129</span></span><br><span class="line">    frame #<span class="number">11</span>: <span class="number">0x000000010001bbba</span> dyld`dyld::_main(macho_header <span class="keyword">const</span>*, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">int</span>, <span class="keyword">char</span> <span class="keyword">const</span>**, <span class="keyword">char</span> <span class="keyword">const</span>**, <span class="keyword">char</span> <span class="keyword">const</span>**, <span class="keyword">unsigned</span> <span class="keyword">long</span>*) + <span class="number">6667</span></span><br><span class="line">    frame #<span class="number">12</span>: <span class="number">0x0000000100015227</span> dyld`dyldbootstrap::start(dyld3::MachOLoaded <span class="keyword">const</span>*, <span class="keyword">int</span>, <span class="keyword">char</span> <span class="keyword">const</span>**, dyld3::MachOLoaded <span class="keyword">const</span>*, <span class="keyword">unsigned</span> <span class="keyword">long</span>*) + <span class="number">453</span></span><br><span class="line">    frame #<span class="number">13</span>: <span class="number">0x0000000100015025</span> dyld`_dyld_start + <span class="number">37</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到 <code>dyld</code> 的最后一个流程是 <code>doModInitFunctions</code> 方法的执行。</p>
<p>我们打开 <code>libSystem</code> 的源码，全局搜索 <code>libSystem_initializer</code> 可以看到：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	_dyld_initializer();</span><br><span class="line">	_libSystem_ktrace_init_func(DYLD);</span><br><span class="line"></span><br><span class="line">	libdispatch_init();</span><br><span class="line">	_libSystem_ktrace_init_func(LIBDISPATCH);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_OS_DRIVERKIT</span></span><br><span class="line">	_libxpc_initializer();</span><br><span class="line">	_libSystem_ktrace_init_func(LIBXPC);</span><br></pre></td></tr></table></figure>

<p>然后我们打开 <code>libDispatch</code> 的源码，全局搜索 <code>libdispatch_init</code> 可以看到：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">void</span></span><br><span class="line">libdispatch_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//省略代码</span></span><br><span class="line">	_dispatch_hw_config_init();</span><br><span class="line">	_dispatch_time_init();</span><br><span class="line">	_dispatch_vtable_init();</span><br><span class="line">  <span class="comment">//调用</span></span><br><span class="line">	_os_object_init();</span><br><span class="line">	_voucher_init();</span><br><span class="line">	_dispatch_introspection_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再搜索<code>_os_object_init</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_os_object_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	_objc_init();</span><br><span class="line">	Block_callbacks_RR callbacks = &#123;</span><br><span class="line">		<span class="keyword">sizeof</span>(Block_callbacks_RR),</span><br><span class="line">		(<span class="keyword">void</span> (*)(<span class="keyword">const</span> <span class="keyword">void</span> *))&amp;objc_retain,</span><br><span class="line">		(<span class="keyword">void</span> (*)(<span class="keyword">const</span> <span class="keyword">void</span> *))&amp;objc_release,</span><br><span class="line">		(<span class="keyword">void</span> (*)(<span class="keyword">const</span> <span class="keyword">void</span> *))&amp;_os_objc_destructInstance</span><br><span class="line">	&#125;;</span><br><span class="line">	_Block_use_RR2(&amp;callbacks);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_COCOA_COMPAT</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *v = getenv(<span class="string">"OBJC_DEBUG_MISSING_POOLS"</span>);</span><br><span class="line">	<span class="keyword">if</span> (v) _os_object_debug_missing_pools = _dispatch_parse_bool(v);</span><br><span class="line">	v = getenv(<span class="string">"DISPATCH_DEBUG_MISSING_POOLS"</span>);</span><br><span class="line">	<span class="keyword">if</span> (v) _os_object_debug_missing_pools = _dispatch_parse_bool(v);</span><br><span class="line">	v = getenv(<span class="string">"LIBDISPATCH_DEBUG_MISSING_POOLS"</span>);</span><br><span class="line">	<span class="keyword">if</span> (v) _os_object_debug_missing_pools = _dispatch_parse_bool(v);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完美~，<code>_objc_init</code> 在这里就被调用了。所以 <code>_objc_init</code> 的流程是</p>
<p>dyld -&gt; libSystem -&gt; libDispatch -&gt; libObjc -&gt; <code>_objc_init</code></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要探索了 app 启动之后 dyld 的流程，整个分析过程确实比较复杂，但在探索的过程中，我们不仅对底层源码有了新的认知，同时对于优化我们 app 启动也是有很多好处的。下一章，我们会对 objc_init 内部的 map_images 和 load_images 进行更深入的分析。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/13/iOS%E5%BA%95%E5%B1%82%EF%BC%9Astatic_init%E3%80%81gdb_objc_realized_classes&remapped_clasass_map&future_named_class_map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/13/iOS%E5%BA%95%E5%B1%82%EF%BC%9Astatic_init%E3%80%81gdb_objc_realized_classes&remapped_clasass_map&future_named_class_map/" class="post-title-link" itemprop="url">iOS底层：static_init、gdb_objc_realized_classes&remapped_clasass_map&future_named_class_map</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-13 13:58:39 / 修改时间：16:51:43" itemprop="dateCreated datePublished" datetime="2021-05-13T13:58:39+08:00">2021-05-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="static-init"><a href="#static-init" class="headerlink" title="static_init"></a>static_init</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* static_init</span></span><br><span class="line"><span class="comment">* Run C++ static constructor functions.</span></span><br><span class="line"><span class="comment">* libc calls _objc_init() before dyld would call our static constructors, </span></span><br><span class="line"><span class="comment">* so we have to do it ourselves.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">static_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    <span class="keyword">auto</span> inits = getLibobjcInitializers(&amp;_mh_dylib_header, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        inits[i]();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> offsets = getLibobjcInitializerOffsets(&amp;_mh_dylib_header, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="function">UnsignedInitializer <span class="title">init</span><span class="params">(offsets[i])</span></span>;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会运行 <code>C++</code> 的静态构造函数，在 <code>dyld</code> 调用我们的静态构造函数之前，<code>libc</code> 会调用 <code>_objc_init</code>，所以这里我们必须自己来做，并且这里只会初始化系统内置的 <code>C++</code> 静态构造函数，我们自己代码里面写的并不会在这里初始化。</p>
<p>通过其注释，我们大概知道static_init函数的作用是运行C++的静态构造函数。其原因在于dyld调用我们的静态构造函数晚于libc调用_objc_init函数。</p>
<p>继续深入讲解<code>static_init</code>方法，可以看出，<code>getLibobjcInitializers</code>方法是它的实现主体，点击进入可以看到如下实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETSECT(getLibobjcInitializers,       UnsignedInitializer, <span class="string">"__objc_init_func"</span>);</span><br></pre></td></tr></table></figure>

<p>这就能理解我们文章开头提出的<code>static_init()</code>方法的含义了。其实就是找出<code>__objc_init_func</code>区的数据，获取了<code>Initializer</code>指针，然后按顺序调用。</p>
<p>由于全局变量都在 <code>mod_init_func</code> 这个区中，那这就给我们优化 App 启动提供了一个思路：我们可以通过 hook 这个区中所有的函数为自己的函数，并在我们的函数中添加时间节点来计时，从而了解在 main 函数之前的耗时情况，这也可以为我们 APP 提供优化借鉴。</p>
<p>其想法很简单，就是在 load 方法中 hook <code>__mod_init_func</code> 的方法。部分源代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load&#123;</span><br><span class="line"></span><br><span class="line">    sInitInfos &#x3D; [NSMutableArray new];</span><br><span class="line"></span><br><span class="line">    g_initializer &#x3D; new std::vector&lt;MemoryType&gt;();</span><br><span class="line"></span><br><span class="line">    g_cur_index &#x3D; -1;</span><br><span class="line"></span><br><span class="line">    g_aslr &#x3D; 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    hookModInitFunc();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以及</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hookModInitFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Dl_info info;</span><br><span class="line"></span><br><span class="line">    dladdr((<span class="keyword">const</span> <span class="keyword">void</span> *)hookModInitFunc, &amp;info);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __LP64__</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//        const struct mach_header *mhp = _dyld_get_image_header(0); // both works as below line</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mach_header</span> *<span class="title">mhp</span> = (<span class="title">struct</span> <span class="title">mach_header</span>*)<span class="title">info</span>.<span class="title">dli_fbase</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    MemoryType *memory = (<span class="keyword">uint32_t</span>*)getsectiondata(mhp, <span class="string">"__DATA"</span>, <span class="string">"__mod_init_func"</span>, &amp; <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* defined(__LP64__) */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mach_header_64</span> *<span class="title">mhp</span> = (<span class="title">struct</span> <span class="title">mach_header_64</span>*)<span class="title">info</span>.<span class="title">dli_fbase</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    MemoryType *memory = (<span class="keyword">uint64_t</span>*)getsectiondata(mhp, <span class="string">"__DATA"</span>, <span class="string">"__mod_init_func"</span>, &amp; <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* defined(__LP64__) */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; <span class="built_in">size</span>/<span class="keyword">sizeof</span>(<span class="keyword">void</span>*); ++idx)&#123;</span><br><span class="line"></span><br><span class="line">        MemoryType original_ptr = memory[idx];</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存原先的方法指针</span></span><br><span class="line"></span><br><span class="line">        g_initializer-&gt;push_back(original_ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将原先的方法替换为我们自己的方法</span></span><br><span class="line"></span><br><span class="line">        memory[idx] = (MemoryType)myInitFunc_Initializer;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    NSLog(@<span class="string">"zero mod init func : size = %@"</span>,@(<span class="built_in">size</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    [sInitInfos addObject:[NSString stringWithFormat:@<span class="string">"ASLR=%p"</span>,mhp]];</span><br><span class="line"></span><br><span class="line">    g_aslr = (MemoryType)mhp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是展示方法以及消耗时长：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myInitFunc_Initializer</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], <span class="keyword">const</span> struct MyProgramVars* vars)</span></span>&#123;</span><br><span class="line">    ++g_cur_index;</span><br><span class="line">    OriginalInitializer func = (OriginalInitializer)g_initializer-&gt;at(g_cur_index);</span><br><span class="line"></span><br><span class="line">    CFTimeInterval start = CFAbsoluteTimeGetCurrent();</span><br><span class="line"></span><br><span class="line">    func(argc,argv,envp,apple,vars);</span><br><span class="line"></span><br><span class="line">    CFTimeInterval <span class="built_in">end</span> = CFAbsoluteTimeGetCurrent();</span><br><span class="line">    sSumInitTime += <span class="number">1000.0</span> * (<span class="built_in">end</span>-start);</span><br><span class="line">    NSString *cost = [NSString stringWithFormat:@<span class="string">"%p=%@"</span>,func,@(<span class="number">1000.0</span>*(<span class="built_in">end</span> - start))];</span><br><span class="line">    [sInitInfos addObject:cost];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gdb-objc-realized-classes"><a href="#gdb-objc-realized-classes" class="headerlink" title="gdb_objc_realized_classes"></a>gdb_objc_realized_classes</h3><p>gdb_objc_realized_classes 的作用已经很明显了，即是对所有的类进行缓存：从对应的 section 中读取所有的类，取出来后以 mangledName 作为键，以 class 结构体作为值。</p>
<h3 id="remapped-class-map"><a href="#remapped-class-map" class="headerlink" title="remapped_class_map"></a>remapped_class_map</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* remappedClasses</span></span><br><span class="line"><span class="comment">* Returns the oldClass =&gt; newClass map for realized future classes.</span></span><br><span class="line"><span class="comment">* Returns the oldClass =&gt; nil map for ignored weak-linked classes.</span></span><br><span class="line"><span class="comment">* Locking: runtimeLock must be read- or write-locked by the caller</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line">static objc::DenseMap&lt;Class, Class&gt; *remappedClasses(bool create)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> objc::LazyInitDenseMap&lt;Class, Class&gt; remapped_class_map;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    <span class="comment">// start big enough to hold CF's classes and a few others</span></span><br><span class="line">    <span class="keyword">return</span> remapped_class_map.<span class="built_in">get</span>(create, <span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>remap class，字面意思是 重新映射 class，那肯定有一个映射者和映射结果。map 的键是 cls，也就是 section 中拿到的 cls，而 value 就是我们 remap 的结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Class <span class="title">readClass</span><span class="params">(Class cls, <span class="keyword">bool</span> headerIsBundle, <span class="keyword">bool</span> headerIsPreoptimized)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mangledName = cls-&gt;nonlazyMangledName();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (missingWeakSuperclass(cls)) &#123;</span><br><span class="line">        <span class="comment">// No superclass (probably weak-linked). </span></span><br><span class="line">        <span class="comment">// Disavow any knowledge of this subclass.</span></span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"CLASS: IGNORING class '%s' with "</span></span><br><span class="line">                         <span class="string">"missing weak-linked superclass"</span>, </span><br><span class="line">                         cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        addRemappedClass(cls, nil);</span><br><span class="line">        cls-&gt;setSuperclass(nil);</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cls-&gt;fixupBackwardDeployingStableSwift();</span><br><span class="line"></span><br><span class="line">    Class replacing = nil;</span><br><span class="line">    <span class="keyword">if</span> (mangledName != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Class newCls = popFutureNamedClass(mangledName)) &#123;</span><br><span class="line">            <span class="comment">// This name was previously allocated as a future class.</span></span><br><span class="line">            <span class="comment">// Copy objc_class to future class's struct.</span></span><br><span class="line">            <span class="comment">// Preserve future's rw data block.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newCls-&gt;isAnySwift()) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">"Can't complete future class request for '%s' "</span></span><br><span class="line">                            <span class="string">"because the real class is too big."</span>,</span><br><span class="line">                            cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">class_rw_t</span> *rw = newCls-&gt;data();</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *old_ro = rw-&gt;ro();</span><br><span class="line">            <span class="built_in">memcpy</span>(newCls, cls, <span class="keyword">sizeof</span>(objc_class));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Manually set address-discriminated ptrauthed fields</span></span><br><span class="line">            <span class="comment">// so that newCls gets the correct signatures.</span></span><br><span class="line">            newCls-&gt;setSuperclass(cls-&gt;getSuperclass());</span><br><span class="line">            newCls-&gt;initIsa(cls-&gt;getIsa());</span><br><span class="line"></span><br><span class="line">            rw-&gt;set_ro((<span class="keyword">class_ro_t</span> *)newCls-&gt;data());</span><br><span class="line">            newCls-&gt;setData(rw);</span><br><span class="line">            freeIfMutable((<span class="keyword">char</span> *)old_ro-&gt;getName());</span><br><span class="line">            <span class="built_in">free</span>((<span class="keyword">void</span> *)old_ro);</span><br><span class="line"></span><br><span class="line">            addRemappedClass(cls, newCls);</span><br><span class="line"></span><br><span class="line">            replacing = cls;</span><br><span class="line">            cls = newCls;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (headerIsPreoptimized  &amp;&amp;  !replacing) &#123;</span><br><span class="line">        <span class="comment">// class list built in shared cache</span></span><br><span class="line">        <span class="comment">// fixme strict assert doesn't work because of duplicates</span></span><br><span class="line">        <span class="comment">// ASSERT(cls == getClass(name));</span></span><br><span class="line">        ASSERT(mangledName == <span class="literal">nullptr</span> || getClassExceptSomeSwift(mangledName));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mangledName) &#123; <span class="comment">//some Swift generic classes can lazily generate their names</span></span><br><span class="line">            addNamedClass(cls, mangledName, replacing);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Class meta = cls-&gt;ISA();</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *metaRO = meta-&gt;bits.safe_ro();</span><br><span class="line">            ASSERT(metaRO-&gt;getNonMetaclass() &amp;&amp; <span class="string">"Metaclass with lazy name must have a pointer to the corresponding nonmetaclass."</span>);</span><br><span class="line">            ASSERT(metaRO-&gt;getNonMetaclass() == cls &amp;&amp; <span class="string">"Metaclass nonmetaclass pointer must equal the original class."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        addClassTableEntry(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for future reference: shared cache never contains MH_BUNDLEs</span></span><br><span class="line">    <span class="keyword">if</span> (headerIsBundle) &#123;</span><br><span class="line">        cls-&gt;data()-&gt;flags |= RO_FROM_BUNDLE;</span><br><span class="line">        cls-&gt;ISA()-&gt;data()-&gt;flags |= RO_FROM_BUNDLE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个函数我们发现，有两个分支有机会进入方法 addRemappedClass，一个是 missingWeakSuperclass 方法是否为真，另外一个是 popFutureNamedClass(mangledName) 方法返回是否为真。这里会有两个概念</p>
<ol>
<li>WeakSuperclass</li>
<li>FutureNamedClass</li>
</ol>
<p>而这两个条件为true 的情况就是需要 remap 的情况。</p>
<h3 id="missingWeakSuperclass"><a href="#missingWeakSuperclass" class="headerlink" title="missingWeakSuperclass"></a>missingWeakSuperclass</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* missingWeakSuperclass</span></span><br><span class="line"><span class="comment">* Return YES if some superclass of cls was weak-linked and is missing.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> </span><br><span class="line">missingWeakSuperclass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;getSuperclass()) &#123;</span><br><span class="line">        <span class="comment">// superclass nil. This is normal for root classes only.</span></span><br><span class="line">        <span class="keyword">return</span> (!(cls-&gt;data()-&gt;flags &amp; RO_ROOT));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// superclass not nil. Check if a higher superclass is missing.</span></span><br><span class="line">        Class supercls = remapClass(cls-&gt;getSuperclass());</span><br><span class="line">        ASSERT(cls != cls-&gt;getSuperclass());</span><br><span class="line">        ASSERT(cls != supercls);</span><br><span class="line">        <span class="keyword">if</span> (!supercls) <span class="keyword">return</span> YES;</span><br><span class="line">        <span class="keyword">if</span> (supercls-&gt;isRealized()) <span class="keyword">return</span> NO;</span><br><span class="line">        <span class="keyword">return</span> missingWeakSuperclass(supercls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码的注释已经一目了然：该函数就是判断某个 class 的父类是否是 weak-linked 并且缺失了。那 什么叫做 weak-linked？比如 NSObject 是否是 weak-linbked ？很显然不是的。那么什么是 weak-linked？</p>
<p>weak-linked<br>我们开发的时候，都会使用最新的SDK，但是为了让老的设备可以下载并运行我们的应用，就要将Deployment Target设置成之前系统的版本号。例如我们应用使用iOS 8.1的SDK，Deployment Target设置成iOS 5.1.1，虽然我们开发的时候使用的是8.1的SDK，但是程序运行在的设备中却可能是6.0 or 7.0的SDK上，按照苹果的说法，如果我们应用使用了最新SDK引入的特性，比如符号、函数等，那么在版本较旧的设备上就运行不了。下面是苹果官方文档的一段话：<br>Normally, if an application uses a new feature in a framework, it is unable to run on earlier versions of the framework that do not support that feature. Such applications would either fail to launch or crash when an attempt to use the feature was made.<br>那么为什么我们使用最新的SDK开发的应用却可以运行在旧的系统中呢？答案是使用了弱引用。资料里面说过，我们自己创建的framework，如果需要做版本兼容，那么就要对今后加入的符号等使用弱引用，使用了弱引用之后，即使在版本较旧的环境下跑，也可以运行，只是相应的符号是NULL，下面就是教我们怎样定义弱引用。有一点需要说明的是，如果一个framework没有为新加入的符号加入弱引用，那也不必担心，我们只要在链接时弱引用整个framework就好，方法就是链接的时候使用 -weak_framework frameworkName</p>
<p>一个使用 weak 的实例为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extern int MyWeakLinkedFunction() __attribute__((weak_import));</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    if (MyWeakLinkedFunction !&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        result &#x3D; MyWeakLinkedFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码片段来自苹果官网。</p>
<p>这么一来， missingWeakSuperclass 的作用的作用就不言而喻了：查看 cls 类的祖宗类中是否有类是 weak-linked 的，并且已经 missing，祖宗类里有 missing weak-linked 的，则 cls 的所有信息也是不可信的，所以将其添加到重映射表里，映射为nil，即 cls -&gt; nil。</p>
<h3 id="future-named-class-map"><a href="#future-named-class-map" class="headerlink" title="future_named_class_map"></a>future_named_class_map</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* futureNamedClasses</span></span><br><span class="line"><span class="comment">* Returns the classname =&gt; future class map for unrealized future classes.</span></span><br><span class="line"><span class="comment">* Locking: runtimeLock must be held by the caller</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">static</span> NXMapTable *future_named_class_map = nil;</span><br><span class="line"><span class="function"><span class="keyword">static</span> NXMapTable *<span class="title">futureNamedClasses</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    <span class="keyword">if</span> (future_named_class_map) <span class="keyword">return</span> future_named_class_map;</span><br><span class="line">    <span class="comment">// future_named_class_map is big enough for CF's classes and a few others</span></span><br><span class="line">    future_named_class_map = </span><br><span class="line">        NXCreateMapTable(NXStrValueMapPrototype, <span class="number">32</span>);</span><br><span class="line">    <span class="keyword">return</span> future_named_class_map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码是创建代码，下面我们看一下使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Used by CoreFoundation's toll-free bridging.</span></span><br><span class="line"><span class="comment"> * Return the id of the named class.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return The id of the named class, or an uninitialized class</span></span><br><span class="line"><span class="comment"> *  structure that will be used for the class when and if it does </span></span><br><span class="line"><span class="comment"> *  get loaded.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @warning Do not call this function yourself.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">OBJC_EXPORT Class _Nonnull</span><br><span class="line">objc_getFutureClass(<span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name) </span><br><span class="line">    OBJC_AVAILABLE(<span class="number">10.5</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>)</span><br><span class="line">    OBJC_ARC_UNAVAILABLE;</span><br></pre></td></tr></table></figure>

<p>看注释有个警告，不要主动调用这个函数。下面是具体的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* objc_getFutureClass.  Return the id of the named class.</span></span><br><span class="line"><span class="comment">* If the class does not exist, return an uninitialized class </span></span><br><span class="line"><span class="comment">* structure that will be used for the class when and if it </span></span><br><span class="line"><span class="comment">* does get loaded.</span></span><br><span class="line"><span class="comment">* Not thread safe. </span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function">Class <span class="title">objc_getFutureClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="comment">// YES unconnected, NO class handler</span></span><br><span class="line">    <span class="comment">// (unconnected is OK because it will someday be the real class)</span></span><br><span class="line">    cls = look_up_class(name, YES, NO);</span><br><span class="line">    <span class="keyword">if</span> (cls) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintFuture) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"FUTURE: found %p already in use for %s"</span>, </span><br><span class="line">                         (<span class="keyword">void</span>*)cls, name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No class or future class with that name yet. Make one.</span></span><br><span class="line">    <span class="comment">// fixme not thread-safe with respect to </span></span><br><span class="line">    <span class="comment">// simultaneous library load or getFutureClass.</span></span><br><span class="line">    <span class="keyword">return</span> _objc_allocateFutureClass(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中函数 look_up_class 这里先不多做介绍了，里面逻辑较多，而且不是这个函数的重点，重点是最后一句：<code>_objc_allocateFutureClass(name)</code> 它才是从 hash map 中获取对应值的函数，其实现如下 ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* _objc_allocateFutureClass</span></span><br><span class="line"><span class="comment">* Allocate an unresolved future class for the given class name.</span></span><br><span class="line"><span class="comment">* Returns any existing allocation if one was already made.</span></span><br><span class="line"><span class="comment">* Assumes the named class doesn't exist yet.</span></span><br><span class="line"><span class="comment">* Locking: acquires runtimeLock</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line">Class _objc_allocateFutureClass(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">    Class cls;</span><br><span class="line">    NXMapTable *<span class="built_in">map</span> = futureNamedClasses();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((cls = (Class)NXMapGet(<span class="built_in">map</span>, name))) &#123;</span><br><span class="line">        <span class="comment">// Already have a future class for this name.</span></span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125;</span><br><span class="line">    cls = _calloc_class(<span class="keyword">sizeof</span>(objc_class));</span><br><span class="line">    addFutureNamedClass(name, cls);</span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很容易理解：有的话就通过方法 NXMapGet 取出来，没有的话则创建。</p>
<p>我们再看一下一出代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* popFutureNamedClass</span></span><br><span class="line"><span class="comment">* Removes the named class from the unrealized future class list, </span></span><br><span class="line"><span class="comment">* because it has been realized.</span></span><br><span class="line"><span class="comment">* Returns nil if the name is not used by a future class.</span></span><br><span class="line"><span class="comment">* Locking: runtimeLock must be held by the caller</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">popFutureNamedClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    Class cls = nil;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (future_named_class_map) &#123;</span><br><span class="line">        cls = (Class)NXMapKeyFreeingRemove(future_named_class_map, name);</span><br><span class="line">        <span class="keyword">if</span> (cls &amp;&amp; NXCountMapTable(future_named_class_map) == <span class="number">0</span>) &#123;</span><br><span class="line">            NXFreeMapTable(future_named_class_map);</span><br><span class="line">            future_named_class_map = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法有点熟悉了，正是上文介绍的 remap 的条件之一。上一篇文章讲述的是第一个条件，本文讲的是第二个条件。这两个条件无论哪一个符合都会调用方法：addRemappedClass，即向 remapped_class_map 中插入数据</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>future named class 的介绍就到这里了，希望大家有所收获。其实笔者看来，不管是上一篇文章的 remapped_class_map 还是本文的 future_named_class_map 里面的数据都是空。remapped_class_map 有数据是需要一定条件，而 future_named_class_map 有数据也是需要先 add 的，所以大家对于这两个 map 只需要有个大概的概念就好，后面如果真的碰到他们有数据，我们在详细分析。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jason</p>
  <div class="site-description" itemprop="description">个人技术博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
