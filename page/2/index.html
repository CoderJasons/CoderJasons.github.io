<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yujiusheng.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="个人技术博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Jason的博客">
<meta property="og:url" content="http://yujiusheng.com/page/2/index.html">
<meta property="og:site_name" content="Jason的博客">
<meta property="og:description" content="个人技术博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yujiusheng.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Jason的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jason的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/07/27/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-KVO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/27/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-KVO/" class="post-title-link" itemprop="url">iOS底层探索-KVO</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-27 20:30:04" itemprop="dateCreated datePublished" datetime="2021-07-27T20:30:04+08:00">2021-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-31 15:58:49" itemprop="dateModified" datetime="2021-07-31T15:58:49+08:00">2021-07-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>KVO</code>是一种机制，它允许对象在其他对象的指定属性发生更改时收到通知。它最常用的一个场景就是<code>viewconroller</code>中监听<code>model</code>属性的变化从而刷新页面展示。</p>
<h3 id="KVO使用过程的细节"><a href="#KVO使用过程的细节" class="headerlink" title="KVO使用过程的细节"></a><code>KVO</code>使用过程的细节</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p><code>KVO</code>的基本使用就是三部曲：</p>
<ul>
<li><p>注册观察者 <code>addObserver:forKeyPath:options:context</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.person addObserver:self forKeyPath:@&quot;nickname&quot; options:NSKeyValueObservingOptionNew context:NULL];</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现<code>KVO</code>的回调<code>observeValueForKeyPath:ofObject:change:context</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    if ([keyPath isEqualToString:@&quot;nickname&quot;]) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,change);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>移除观察者<code>removeObserver:forKeyPath:context</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.person removeObserver:self forKeyPath:@&quot;nickname&quot; context:NULL];</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="context参数的使用"><a href="#context参数的使用" class="headerlink" title="context参数的使用"></a>context参数的使用</h4><p>基本使用的过程中我们经常会给<code>context</code>传<code>NULL</code>作为实参，<code>context</code>参数的作用很容易被我们忽略。苹果官方文档对<code>context</code>有详细的说明</p>
<blockquote>
<p>The context pointer in the <code>addObserver:forKeyPath:options:context:</code> message contains arbitrary data that will be passed back to the observer in the corresponding change notifications. You may specify <code>NULL</code> and rely entirely on the key path string to determine the origin of a change notification, but this approach may cause problems for an object whose superclass is also observing the same key path for different reasons.</p>
<p>A safer and more extensible approach is to use the context to ensure notifications you receive are destined for your observer and not a superclass.</p>
</blockquote>
<p>大体意思就是：<code>addObserver：forKeyPath：options：context：</code>方法中的<code>context</code>指针包含任意数据，这些数据将在相应的更改通知中传递回观察者。可以通过<code>指定context为NULL</code>，从而<code>依靠keyPath</code>即<code>键路径字符串</code>传来确定更改通知的来源，但是这种方法可能会导致对象的父类由于不同的原因也观察到相同的键路径而导致问题。所以可以为每个观察到的keyPath创建一个不同的context，从而<code>完全不需要进行字符串比较</code>，从而可以更有效地进行通知解析。</p>
<p><code>context</code>主要是用于区分不同对象的同名属性，从而在KVO回调方法中可以直接使用<code>context</code>进行区分，可以大大提升性能，以及代码的可读性。</p>
<ul>
<li><p>不使用context时，我们通过字符串判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[self.person addObserver:self forKeyPath:@&quot;nickname&quot; options:NSKeyValueObservingOptionNew context:NULL];</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    if ([keyPath isEqualToString:@&quot;nickname&quot;]) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,change);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用context时，我们通过<code>context</code>判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;context定义</span><br><span class="line">static void *PersonNickNameContext &#x3D; &amp;PersonNickNameContext;</span><br><span class="line">static void *PersonNameContext &#x3D; &amp;PersonNameContext;</span><br><span class="line">&#x2F;&#x2F;注册观察者</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;nick&quot; options:NSKeyValueObservingOptionNew context:PersonNickNameContext];</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:PersonNameContext];</span><br><span class="line">&#x2F;&#x2F;KVO的回调</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    if (context &#x3D;&#x3D; PersonNickNameContext) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,change);</span><br><span class="line">    &#125;else if (context &#x3D;&#x3D; PersonNameContext)&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,change);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="是否有必要移除KVOobserver"><a href="#是否有必要移除KVOobserver" class="headerlink" title="是否有必要移除KVOobserver"></a>是否有必要移除<code>KVO</code>observer</h4><p>官方文档对<code>removeObserver</code>也有说明：</p>
<blockquote>
<p>When removing an observer, keep several points in mind:</p>
<ul>
<li>Asking to be removed as an observer if not already registered as one results in an <code>NSRangeException</code>. You either call <code>removeObserver:forKeyPath:context:</code> exactly once for the corresponding call to <code>addObserver:forKeyPath:options:context:</code>, or if that is not feasible in your app, place the <code>removeObserver:forKeyPath:context:</code> call inside a try/catch block to process the potential exception.</li>
<li>An observer does not automatically remove itself when deallocated. The observed object continues to send notifications, oblivious to the state of the observer. However, a change notification, like any other message, sent to a released object, triggers a memory access exception. You therefore ensure that observers remove themselves before disappearing from memory.</li>
<li>The protocol offers no way to ask an object if it is an observer or being observed. Construct your code to avoid release related errors. A typical pattern is to register as an observer during the observer’s initialization (for example in <code>init</code> or <code>viewDidLoad</code>) and unregister during deallocation (usually in <code>dealloc</code>), ensuring properly paired and ordered add and remove messages, and that the observer is unregistered before it is freed from memory.</li>
</ul>
</blockquote>
<p>翻译过来就是，移除观察者时，注意以下几点：</p>
<ul>
<li>如果未注册为观察者，在移除观察者的时候会导致<code>NSRangeException</code>异常。<code>removeObserver</code>必须和<code>addObserver</code>对应，且只能调用一次。如果项目中不能保证，就需要在使用的时候使用<code>try/catch</code>来处理异常。</li>
<li>观察者在对象销毁的时候不会自动移除观察者。被观察者会继续发送通知，对观察者来说这个状态是感知不到的。但是，向一个已经释放的对象发送通知会引起内存访问异常。所以，我们要保证观察者在内存释放之前移除观察。</li>
<li>这个协议没有方法可以判断他是一个观察者还是被观察者，写代码是要避免释放内存相关的错误。一个典型的规范就是在观察者初始画的时候注册观察，在<code>dealloc</code>的时候移除观察，以确保成对和有序地添加和删除消息，并确保观察者在注册之前被取消注册，从内存中释放出来。</li>
</ul>
<p>所以，总的来说，<code>KVO注册观察者 和移除观察者是需要成对出现的</code>，如果只注册，不移除，会出现<code>野指针的崩溃</code>。</p>
<h4 id="自动触发与手动触发"><a href="#自动触发与手动触发" class="headerlink" title="自动触发与手动触发"></a>自动触发与手动触发</h4><p>KVO观察的自动和手动两种方式</p>
<ul>
<li><p>自动开关，<code>automaticallyNotifiesObserversForKey</code>返回<code>YES</code>的时候标示自动监听，如果是<code>NO</code>表示我们需要手动监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 自动开关</span><br><span class="line">+ (BOOL) automaticallyNotifiesObserversForKey:(NSString *)key&#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果是手动，我们需要通过<code>手动开关</code>监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)setNickName:(NSString *)nickName&#123;</span><br><span class="line">    &#x2F;&#x2F;手动开关</span><br><span class="line">    [self willChangeValueForKey:@&quot;nickName&quot;];</span><br><span class="line">    _nickName &#x3D; namenickName</span><br><span class="line">    [self didChangeValueForKey:@&quot;nickName&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="观察多个属性变化"><a href="#观察多个属性变化" class="headerlink" title="观察多个属性变化"></a>观察多个属性变化</h4><p>我们以观察两个属性为例，例如我们需要根据速度<code>speed</code>和时间<code>time</code>，取得当前的路程<code>distance</code>。我们用两种方式。</p>
<ul>
<li><p>第一种就是分别观察速度<code>speed</code>和时间<code>time</code>两个属性，当其中一个发生变化计算 当前路程<code>distance</code>。</p>
</li>
<li><p>第二种方式就是，通过<code>keyPathsForValuesAffectingValueForKey</code>方法，将两个观察合为一个观察，即观察当前路程<code>distance</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1、合二为一的观察方法</span><br><span class="line">+ (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key&#123;</span><br><span class="line">    NSSet *keyPaths &#x3D; [super keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line">    if ([key isEqualToString:@&quot;distance&quot;]) &#123;</span><br><span class="line">        NSArray *affectingKeys &#x3D; @[@&quot;speed&quot;, @&quot;time&quot;];</span><br><span class="line">        keyPaths &#x3D; [keyPaths setByAddingObjectsFromArray:affectingKeys];</span><br><span class="line">    &#125;</span><br><span class="line">    return keyPaths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2、注册KVO观察</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;distance&quot; options:(NSKeyValueObservingOptionNew) context:NULL];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3、触发属性值变化</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    self.person.speed +&#x3D; 10;</span><br><span class="line">    self.person.time  +&#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;4、移除观察者</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">    [self.person removeObserver:self forKeyPath:@&quot;distance&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="可变数组的观察"><a href="#可变数组的观察" class="headerlink" title="可变数组的观察"></a>可变数组的观察</h4><p>KVO是基于KVC基础之上的，所以可变数组如果直接添加数据，是不会调用setter方法的，所有对<code>可变数组</code>的KVO观察下面这种方式<code>不生效</code>的,即直接通过<code>[self.person.dateArray addObject:@&quot;1&quot;];</code>向数组添加元素，是不会触发kvo通知回调的，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1、注册可变数组KVO观察者</span><br><span class="line">self.person.dateArray &#x3D; [NSMutableArray arrayWithCapacity:1];</span><br><span class="line">    [self.person addObserver:self forKeyPath:@&quot;dateArray&quot; options:(NSKeyValueObservingOptionNew) context:NULL];</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;2、KVO回调</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,change);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3、移除观察者</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line"> [self.person removeObserver:self forKeyPath:@&quot;dateArray&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;4、触发数组添加数据</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    [self.person.dateArray addObject:@&quot;1&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在KVC官方文档中，针对<code>可变数组的集合</code>类型，有如下说明，即访问集合对象需要需要通过<code>mutableArrayValueForKey</code>方法，这样才能<code>将元素添加到可变数组</code>中</p>
<blockquote>
<p>The protocol defines three different proxy methods for collection object access, each with a key and a key path variant:</p>
<ul>
<li><p><code>mutableArrayValueForKey:</code> and <code>mutableArrayValueForKeyPath:</code></p>
<p>These return a proxy object that behaves like an <code>NSMutableArray</code> object.</p>
</li>
<li><p><code>mutableSetValueForKey:</code> and <code>mutableSetValueForKeyPath:</code></p>
<p>These return a proxy object that behaves like an <code>NSMutableSet</code> object.</p>
</li>
<li><p><code>mutableOrderedSetValueForKey:</code> and <code>mutableOrderedSetValueForKeyPath:</code></p>
<p>These return a proxy object that behaves like an <code>NSMutableOrderedSet</code> object.</p>
</li>
</ul>
</blockquote>
<p>我们代码这样修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    &#x2F;&#x2F; KVC 集合 array</span><br><span class="line">    [[self.person mutableArrayValueForKey:@&quot;dateArray&quot;] addObject:@&quot;1&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在可变数组就可以监听到了。</p>
<h3 id="KVO底层探索"><a href="#KVO底层探索" class="headerlink" title="KVO底层探索"></a>KVO底层探索</h3><p>苹果官方文档在<code>Key-Value Observing Implementation Details</code>里有提到<code>KVO</code>的实现：</p>
<blockquote>
<p>Automatic key-value observing is implemented using a technique called <em>isa-swizzling</em>.</p>
<p>The <code>isa</code> pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.</p>
<p>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</p>
<p>You should never rely on the <code>isa</code> pointer to determine class membership. Instead, you should use the <code>class</code> method to determine the class of an object instance.</p>
</blockquote>
<p>大概意思就是<code>KVO</code>的实现使用了<code>isa</code>的交换。当我们添加一个<code>observer</code>的时候<code>isa</code>的指向会发生改变，是一个<code>中间类</code>而不是<code>真正的类</code>。我们不能根据<code>isa</code>指针确定类的成员身份，而是用哪个<code>class</code>方法确定。</p>
<h4 id="中间类是什么"><a href="#中间类是什么" class="headerlink" title="中间类是什么"></a><code>中间类</code>是什么</h4><p>看苹果官网文档我们了解了，<code>KVO</code>的实现时通过修改<code>isa</code>指针指向了一个<code>中间类</code>实现的，我们使用<code>lldb</code>探究一下<code>中间类</code>是什么。</p>
<ul>
<li><p>添加观察者之前，我们打印实例对象<code>person</code>的方法是<code>JSPerson</code>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) <span class="function">po <span class="title">object_getClassName</span><span class="params">(self.person)</span></span></span><br><span class="line">"JSPerson"</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加观察者之后，我们打印实例对象<code>person</code>的方法是<code>NSKVONotifying_JSPerson</code>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) <span class="function">po <span class="title">object_getClassName</span><span class="params">(self.person)</span></span></span><br><span class="line">"NSKVONotifying_JSPerson"</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>通过上面的调试，我们看到添加观察者值<code>isa</code>指向了一个名为<code>&quot;NSKVONotifying_JSPerson</code>的中间类。关于这个<code>中间类</code>我们有几个点需要研究一下。</p>
<ol>
<li><p><code>中间类</code>和之前的类是父子类关系吗</p>
<p>我们通过一个方法来判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 遍历类以及子类</span><br><span class="line">- (void)printClasses:(Class)cls&#123;</span><br><span class="line">    &#x2F;&#x2F; 注册类的总数</span><br><span class="line">    int count &#x3D; objc_getClassList(NULL, 0);</span><br><span class="line">    &#x2F;&#x2F; 创建一个数组， 其中包含给定对象</span><br><span class="line">    NSMutableArray *mArray &#x3D; [NSMutableArray arrayWithObject:cls];</span><br><span class="line">    &#x2F;&#x2F; 获取所有已注册的类</span><br><span class="line">    Class* classes &#x3D; (Class*)malloc(sizeof(Class)*count);</span><br><span class="line">    objc_getClassList(classes, count);</span><br><span class="line">    for (int i &#x3D; 0; i&lt;count; i++) &#123;</span><br><span class="line">        if (cls &#x3D;&#x3D; class_getSuperclass(classes[i])) &#123;</span><br><span class="line">            [mArray addObject:classes[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(classes);</span><br><span class="line">    NSLog(@&quot;classes &#x3D; %@&quot;, mArray);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;********以下为调用********</span><br><span class="line">[self printClasses:[JSPerson class]];</span><br></pre></td></tr></table></figure>

<p>打印结果为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">classes = (</span><br><span class="line">    JSPerson,</span><br><span class="line">    <span class="string">"NSKVONotifying_JSPerson"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>通过打印结果我们可以判断中间类<code>NSKVONotifying_JSPerson</code>是<code>JSPerson</code>的子类。</p>
</li>
<li><p>中间类里有什么方法。</p>
<p>同样，我们定义一个方法获取<code>NSKVONotifying_JSPerson</code>的所有方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 遍历方法-ivar-property</span><br><span class="line">- (void)printClassAllMethod:(Class)cls&#123;</span><br><span class="line">    unsigned int count &#x3D; 0;</span><br><span class="line">    Method *methodList &#x3D; class_copyMethodList(cls, &amp;count);</span><br><span class="line">    for (int i &#x3D; 0; i&lt;count; i++) &#123;</span><br><span class="line">        Method method &#x3D; methodList[i];</span><br><span class="line">        SEL sel &#x3D; method_getName(method);</span><br><span class="line">        IMP imp &#x3D; class_getMethodImplementation(cls, sel);</span><br><span class="line">        NSLog(@&quot;%@-%p&quot;,NSStringFromSelector(sel),imp);</span><br><span class="line">    &#125;</span><br><span class="line">    free(methodList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;********以下为调用********</span><br><span class="line">[self printClassAllMethod:objc_getClass(&quot;NSKVONotifying_JSPerson&quot;)];</span><br></pre></td></tr></table></figure>

<p>打印结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setNickName:<span class="number">-0x7fff207bbb57</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>-0<span class="title">x7fff207ba662</span></span></span><br><span class="line"><span class="class"><span class="title">dealloc</span>-0<span class="title">x7fff207ba40b</span></span></span><br><span class="line"><span class="class">_<span class="title">isKVOA</span>-0<span class="title">x7fff207ba403</span></span></span><br></pre></td></tr></table></figure>

<p>我们看到一共有四个方法</p>
<ul>
<li>重写了父类的<code>setNickName</code>方法</li>
<li>重写了根类的<code>class</code>、<code>dealloc</code>方法</li>
<li><code>_isKVO</code>方法，用来判断是否是<code>kvo</code>类</li>
</ul>
</li>
<li><p>dealloc中移除观察者后，isa会指回来吗</p>
<ul>
<li><p>移除观察者之前，我们用<code>lldb</code>打印</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) <span class="function">po <span class="title">object_getClassName</span><span class="params">(self.person)</span></span></span><br><span class="line">"NSKVONotifying_JSPerson"</span><br></pre></td></tr></table></figure>
</li>
<li><p>移除观察者之后，我们重新打印</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) <span class="function">po <span class="title">object_getClassName</span><span class="params">(self.person)</span></span></span><br><span class="line">"JSPerson"</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>说明的确是在移除观察的时候将<code>isa</code>指回来的。</p>
</li>
<li><p>移除观察后中间类会销毁吗</p>
<p>我们返回前一个页面，此时添加观察者的VC已经销毁，我们打印<code>JSPerson</code>的子类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self printClasses:[JSPerson class]];</span><br></pre></td></tr></table></figure>

<p>打印结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">classes = (</span><br><span class="line">    JSPerson,</span><br><span class="line">    <span class="string">"NSKVONotifying_JSPerson"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>发现子类并不会被销毁。</p>
</li>
</ol>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>实例对象<code>isa</code>的指向<code>在添加KVO观察者之后</code>，由<code>原有类</code>更改为<code>指向中间类</code></li>
<li><code>中间类</code>重写了观察<code>属性的setter方法</code>、<code>class</code>、<code>dealloc</code>、<code>_isKVOA</code>方法</li>
<li><code>dealloc</code>方法中，移除KVO观察者之后，实例对象<code>isa</code>指向由<code>中间类</code>更改为<code>原有类</code></li>
<li><code>中间类</code>从创建后，就一直<code>存在内存中，不会被销毁</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/07/26/Flutter-IneritedWidget/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/26/Flutter-IneritedWidget/" class="post-title-link" itemprop="url">Flutter-InheritedWidget</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-26 10:41:49" itemprop="dateCreated datePublished" datetime="2021-07-26T10:41:49+08:00">2021-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-30 15:06:34" itemprop="dateModified" datetime="2021-07-30T15:06:34+08:00">2021-07-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/07/25/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-KVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/25/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-KVC/" class="post-title-link" itemprop="url">iOS底层探索-KVC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-25 11:04:54 / 修改时间：16:26:44" itemprop="dateCreated datePublished" datetime="2021-07-25T11:04:54+08:00">2021-07-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>KVC</code>的全拼是<code>Key-Value Coding</code>,中文是<code>键值编码</code>。是由<code>NSKeyValueCoding</code>非正式协议的一种机制。对象可以间接地访问它们的属性。这种间接访问机制是实例变量及其相关访问器方法提供的直接访问的补充。</p>
<h3 id="使用KVC"><a href="#使用KVC" class="headerlink" title="使用KVC"></a>使用<code>KVC</code></h3><h4 id="通过key取值和设置值"><a href="#通过key取值和设置值" class="headerlink" title="通过key取值和设置值"></a>通过<code>key</code>取值和设置值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;直接通过Key来取值</span><br><span class="line">- (nullable id)valueForKey:(NSString *)key;</span><br><span class="line">&#x2F;&#x2F;通过Key来设值</span><br><span class="line">- (void)setValue:(nullable id)value forKey:(NSString *)key;</span><br></pre></td></tr></table></figure>

<h4 id="通过keyPath（路由）取值和设置值"><a href="#通过keyPath（路由）取值和设置值" class="headerlink" title="通过keyPath（路由）取值和设置值"></a>通过<code>keyPath</code>（路由）取值和设置值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通过KeyPath来取值</span><br><span class="line">- (nullable id)valueForKeyPath:(NSString *)keyPath; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过KeyPath来设值                 </span><br><span class="line">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure>

<p>我们平时项目中主要是通过使用的是<code>valueForKey</code>和<code>valueForKeyPath</code>的方式取值和设值，当然还有<code>集合类型</code>的一些操作可以参见<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107-SW1" target="_blank" rel="noopener">苹果KVC的文档</a>查看使用。</p>
<h3 id="KVC的设值过程"><a href="#KVC的设值过程" class="headerlink" title="KVC的设值过程"></a><code>KVC</code>的设值过程</h3><p><code>setValue:forKey:</code>这个方法有一个调用顺序(基本数据类型)：</p>
<ul>
<li>按顺序查找名为 set<Key>: 或 _set<Key> 的第一个访问器。如果找到，则使用输入值（或根据需要展开的值）调用它并完成。</li>
<li>如果未找到简单访问器，并且类方法 accessInstanceVariablesDirectly 返回 YES，则按顺序查找名称类似于 _<key>、_is<Key>、<key> 或 is<Key> 的实例变量。如果找到，直接使用输入值（或解包值）设置变量并完成。</li>
<li>在未找到访问器或实例变量时，调用 setValue:forUndefinedKey:。默认情况下，这会引发异常，但 NSObject 的子类可能会提供特定于键的行为。</li>
</ul>
<p>整个流程图如下(以<code>person</code>对象设置<code>name</code>属性为例)：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fafa22458d84357afcda544590fc1e1~tplv-k3u1fbpfcp-watermark.image" alt="kvc取值流程"></p>
<h3 id="KVC取值过程"><a href="#KVC取值过程" class="headerlink" title="KVC取值过程"></a><code>KVC</code>取值过程</h3><p>和设值过程一样，取值过程<code>valueForKey:</code>也有一个调用顺序(包含集合类型)：</p>
<ul>
<li>在实例中搜索找到的第一个访问器方法，其名称类似于 get<Key>、<key>、is<Key> 或 _<key>，按该顺序。如果找到，则调用它并使用结果继续执行步骤 5。否则继续下一个步骤</li>
<li>如果没有找到简单的访问器方法，则在实例中搜索名称与模式 countOf<Key> 和 objectIn<Key>AtIndex:（对应于 NSArray 类定义的原始方法）和 <key>AtIndexes:（对应于模式）的方法NSArray 方法 objectsAtIndexes:)。如果找到其中的第一个和至少其他两个中的一个，则创建一个集合代理对象，该对象响应所有 NSArray 方法并返回该对象。否则，继续执行步骤 3。代理对象随后将它接收到的任何 NSArray 消息转换为 countOf<Key>、objectIn<Key>AtIndex: 和 <key>AtIndexes: 消息的某种组合，并将其转换为创建它的键值编码兼容对象。如果原始对象还实现了一个可选方法，其名称类似于 get<Key>:range:，则代理对象也会在适当的时候使用它。实际上，代理对象与键值编码兼容对象一起工作允许底层属性表现得好像它是一个 NSArray，即使它不是。</li>
<li>如果没有找到简单的访问器方法或数组访问方法组，则查找名为 countOf<Key>、enumeratorOf<Key> 和 memberOf<Key> 的三元组方法：（对应于 NSSet 类定义的原始方法）。如果找到所有三个方法，则创建一个集合代理对象，该对象响应所有 NSSet 方法并返回该对象。否则，继续执行步骤 4。这个代理对象随后将它接收到的任何 NSSet 消息转换为 countOf<Key>、enumeratorOf<Key> 和 memberOf<Key> 的某种组合：消息到创建它的对象。实际上，与键值编码兼容的对象一起工作的代理对象允许底层属性表现得好像它是一个 NSSet，即使它不是。</li>
<li>如果没有找到简单的访问器方法或集合访问方法组，并且如果接收者的类方法accessInstanceVariables直接返回YES，则搜索名为_<key>、_is<Key>、<key>或is<Key>的实例变量，以该顺序。如果找到，直接获取实例变量的值并进行步骤5，否则进行步骤6。</li>
<li>如果检索到的属性值是一个对象指针，只需返回结果即可。 如果该值是 NSNumber 支持的标量类型，则将其存储在 NSNumber 实例中并返回。 如果结果是 NSNumber 不支持的标量类型，则转换为 NSValue 对象并返回。</li>
<li>如果所有其他方法都失败，请调用 valueForUndefinedKey:。默认情况下，这会引发异常，但 NSObject 的子类可能会提供特定于键的行为。</li>
</ul>
<p>其流程图如下：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21604d5aa0e64c64a2f038d4436db4f8~tplv-k3u1fbpfcp-watermark.image" alt="KVC取值过程"></p>
<h3 id="自定义实现KVC"><a href="#自定义实现KVC" class="headerlink" title="自定义实现KVC"></a>自定义实现KVC</h3><p>如果自己实现一个<code>KVC</code>可以参考上面的顺序，实现<code>valueForKey</code>和<code>setValueForKey</code>。</p>
<h4 id="设值过程"><a href="#设值过程" class="headerlink" title="设值过程"></a>设值过程</h4><ul>
<li>判断<code>key</code>是否为空，为空直接返回。</li>
<li>查找是否有 setter方法 <code>set&lt;Key&gt;:</code> ， <code>_set&lt;Key&gt;</code>, <code>setIs&lt;Key&gt;</code>，如果有则实现并返回。</li>
<li>如果没找到则判断accessInstanceVariablesDirectly的返回值是否为YES，可以则往下走，否则抛出异常。</li>
<li>查找自己的ivar列表中是否包含实例变量 <code>_&lt;key&gt;</code>, <code>_is&lt;Key&gt;</code>,<code>&lt;key&gt;</code>,<code>is&lt;Key&gt;</code>,找到就赋值。</li>
<li>如果都搜索不到，就抛出异常。</li>
</ul>
<p>实现代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">- (void)js_setValue:(nullable id)value forKey:(NSString *)key&#123;</span><br><span class="line">    &#x2F;&#x2F; 空判断</span><br><span class="line">    if (key &#x3D;&#x3D; nil || key.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 2: setter set&lt;Key&gt;: or _set&lt;Key&gt;,</span><br><span class="line">    &#x2F;&#x2F; key 要大写</span><br><span class="line">    NSString *Key &#x3D; key.capitalizedString;</span><br><span class="line">    &#x2F;&#x2F; 拼接方法</span><br><span class="line">    NSString *setKey &#x3D; [NSString stringWithFormat:@&quot;set%@:&quot;,Key];</span><br><span class="line">    NSString *_setKey &#x3D; [NSString stringWithFormat:@&quot;_set%@:&quot;,Key];</span><br><span class="line">    NSString *setIsKey &#x3D; [NSString stringWithFormat:@&quot;setIs%@:&quot;,Key];</span><br><span class="line">    </span><br><span class="line">    if ([self js_performSelectorWithMethodName:setKey value:value]) &#123;</span><br><span class="line">        NSLog(@&quot;*********%@**********&quot;,setKey);</span><br><span class="line">        return;</span><br><span class="line">    &#125;else if ([self js_performSelectorWithMethodName:_setKey value:value]) &#123;</span><br><span class="line">        NSLog(@&quot;*********%@**********&quot;,_setKey);</span><br><span class="line">        return;</span><br><span class="line">    &#125;else if ([self js_performSelectorWithMethodName:setIsKey value:value]) &#123;</span><br><span class="line">        NSLog(@&quot;*********%@**********&quot;,setIsKey);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 3: 判断是否响应 accessInstanceVariablesDirectly 返回YES NO 奔溃</span><br><span class="line">    &#x2F;&#x2F; 3:判断是否能够直接赋值实例变量</span><br><span class="line">    if (![self.class accessInstanceVariablesDirectly] ) &#123;</span><br><span class="line">        @throw [NSException exceptionWithName:@&quot;JSUnknownKeyException&quot; reason:[NSString stringWithFormat:@&quot;****[%@ valueForUndefinedKey:]: this class is not key value coding-compliant for the key name.****&quot;,self] userInfo:nil];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 4: 间接变量</span><br><span class="line">    &#x2F;&#x2F; 获取 ivar -&gt; 遍历 containsObjct -</span><br><span class="line">    &#x2F;&#x2F; 4.1 定义一个收集实例变量的可变数组</span><br><span class="line">    NSMutableArray *mArray &#x3D; [self getIvarListName];</span><br><span class="line">    &#x2F;&#x2F; _&lt;key&gt; _is&lt;Key&gt; &lt;key&gt; is&lt;Key&gt;</span><br><span class="line">    NSString *_key &#x3D; [NSString stringWithFormat:@&quot;_%@&quot;,key];</span><br><span class="line">    NSString *_isKey &#x3D; [NSString stringWithFormat:@&quot;_is%@&quot;,Key];</span><br><span class="line">    NSString *isKey &#x3D; [NSString stringWithFormat:@&quot;is%@&quot;,Key];</span><br><span class="line">    if ([mArray containsObject:_key]) &#123;</span><br><span class="line">        &#x2F;&#x2F; 4.2 获取相应的 ivar</span><br><span class="line">       Ivar ivar &#x3D; class_getInstanceVariable([self class], _key.UTF8String);</span><br><span class="line">        &#x2F;&#x2F; 4.3 对相应的 ivar 设置值</span><br><span class="line">       object_setIvar(self , ivar, value);</span><br><span class="line">       return;</span><br><span class="line">    &#125;else if ([mArray containsObject:_isKey]) &#123;</span><br><span class="line">       Ivar ivar &#x3D; class_getInstanceVariable([self class], _isKey.UTF8String);</span><br><span class="line">       object_setIvar(self , ivar, value);</span><br><span class="line">       return;</span><br><span class="line">    &#125;else if ([mArray containsObject:key]) &#123;</span><br><span class="line">       Ivar ivar &#x3D; class_getInstanceVariable([self class], key.UTF8String);</span><br><span class="line">       object_setIvar(self , ivar, value);</span><br><span class="line">       return;</span><br><span class="line">    &#125;else if ([mArray containsObject:isKey]) &#123;</span><br><span class="line">       Ivar ivar &#x3D; class_getInstanceVariable([self class], isKey.UTF8String);</span><br><span class="line">       object_setIvar(self , ivar, value);</span><br><span class="line">       return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 5:如果找不到相关实例</span><br><span class="line">    @throw [NSException exceptionWithName:@&quot;JSUnknownKeyException&quot; reason:[NSString stringWithFormat:@&quot;****[%@ %@]: this class is not key value coding-compliant for the key name.****&quot;,self,NSStringFromSelector(_cmd)] userInfo:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="取值过程"><a href="#取值过程" class="headerlink" title="取值过程"></a>取值过程</h4><ul>
<li>同样是判断key非空</li>
<li>按顺序查找方法：<code>get&lt;Key&gt;</code>、 <code>&lt;key&gt;</code>、<code>countOf&lt;Key&gt;</code>、 <code>objectIn&lt;Key&gt;AtIndex</code></li>
<li>判断accessInstanceVariablesDirectly的返回值是否为YES，可以则往下走，否则抛出异常。</li>
<li>查找自己的ivar列表中是否包含实例变量 <code>_&lt;key&gt;</code>, <code>_is&lt;Key&gt;</code>,<code>&lt;key&gt;</code>,<code>is&lt;Key&gt;</code>,找到就取值。</li>
<li>未找到抛出异常。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)js_valueForKey:(NSString *)key&#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 1:判断非空</span><br><span class="line">    if (key &#x3D;&#x3D; nil  || key.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 2:找到相关方法 get&lt;Key&gt; &lt;key&gt; countOf&lt;Key&gt;  objectIn&lt;Key&gt;AtIndex</span><br><span class="line">    &#x2F;&#x2F; key 要大写</span><br><span class="line">    NSString *Key &#x3D; key.capitalizedString;</span><br><span class="line">    &#x2F;&#x2F; 拼接方法</span><br><span class="line">    NSString *getKey &#x3D; [NSString stringWithFormat:@&quot;get%@&quot;,Key];</span><br><span class="line">    NSString *countOfKey &#x3D; [NSString stringWithFormat:@&quot;countOf%@&quot;,Key];</span><br><span class="line">    NSString *objectInKeyAtIndex &#x3D; [NSString stringWithFormat:@&quot;objectIn%@AtIndex:&quot;,Key];</span><br><span class="line">        </span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">    if ([self respondsToSelector:NSSelectorFromString(getKey)]) &#123;</span><br><span class="line">        return [self performSelector:NSSelectorFromString(getKey)];</span><br><span class="line">    &#125;else if ([self respondsToSelector:NSSelectorFromString(key)])&#123;</span><br><span class="line">        return [self performSelector:NSSelectorFromString(key)];</span><br><span class="line">    &#125;else if ([self respondsToSelector:NSSelectorFromString(countOfKey)])&#123;</span><br><span class="line">        if ([self respondsToSelector:NSSelectorFromString(objectInKeyAtIndex)]) &#123;</span><br><span class="line">            int num &#x3D; (int)[self performSelector:NSSelectorFromString(countOfKey)];</span><br><span class="line">            NSMutableArray *mArray &#x3D; [NSMutableArray arrayWithCapacity:1];</span><br><span class="line">            for (int i &#x3D; 0; i&lt;num-1; i++) &#123;</span><br><span class="line">                num &#x3D; (int)[self performSelector:NSSelectorFromString(countOfKey)];</span><br><span class="line">            &#125;</span><br><span class="line">            for (int j &#x3D; 0; j&lt;num; j++) &#123;</span><br><span class="line">                id objc &#x3D; [self performSelector:NSSelectorFromString(objectInKeyAtIndex) withObject:@(num)];</span><br><span class="line">                [mArray addObject:objc];</span><br><span class="line">            &#125;</span><br><span class="line">            return mArray;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 3:判断是否能够直接赋值实例变量</span><br><span class="line">    if (![self.class accessInstanceVariablesDirectly] ) &#123;</span><br><span class="line">        @throw [NSException exceptionWithName:@&quot;JSUnknownKeyException&quot; reason:[NSString stringWithFormat:@&quot;****[%@ valueForUndefinedKey:]: this class is not key value coding-compliant for the key name.****&quot;,self] userInfo:nil];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 4.找相关实例变量进行赋值</span><br><span class="line">    &#x2F;&#x2F; 4.1 定义一个收集实例变量的可变数组</span><br><span class="line">    NSMutableArray *mArray &#x3D; [self getIvarListName];</span><br><span class="line">    &#x2F;&#x2F; _&lt;key&gt; _is&lt;Key&gt; &lt;key&gt; is&lt;Key&gt;</span><br><span class="line">    &#x2F;&#x2F; _name -&gt; _isName -&gt; name -&gt; isName</span><br><span class="line">    NSString *_key &#x3D; [NSString stringWithFormat:@&quot;_%@&quot;,key];</span><br><span class="line">    NSString *_isKey &#x3D; [NSString stringWithFormat:@&quot;_is%@&quot;,Key];</span><br><span class="line">    NSString *isKey &#x3D; [NSString stringWithFormat:@&quot;is%@&quot;,Key];</span><br><span class="line">    if ([mArray containsObject:_key]) &#123;</span><br><span class="line">        Ivar ivar &#x3D; class_getInstanceVariable([self class], _key.UTF8String);</span><br><span class="line">        return object_getIvar(self, ivar);;</span><br><span class="line">    &#125;else if ([mArray containsObject:_isKey]) &#123;</span><br><span class="line">        Ivar ivar &#x3D; class_getInstanceVariable([self class], _isKey.UTF8String);</span><br><span class="line">        return object_getIvar(self, ivar);;</span><br><span class="line">    &#125;else if ([mArray containsObject:key]) &#123;</span><br><span class="line">        Ivar ivar &#x3D; class_getInstanceVariable([self class], key.UTF8String);</span><br><span class="line">        return object_getIvar(self, ivar);;</span><br><span class="line">    &#125;else if ([mArray containsObject:isKey]) &#123;</span><br><span class="line">        Ivar ivar &#x3D; class_getInstanceVariable([self class], isKey.UTF8String);</span><br><span class="line">        return object_getIvar(self, ivar);;</span><br><span class="line">    &#125;</span><br><span class="line">    return @&quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇我们主要探索了KVC的<code>取值</code>和<code>设值</code>的流程。设值过程<code>集合</code>类型的情况没有写，感兴趣的童鞋可以查看苹果<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107-SW1" target="_blank" rel="noopener">官方文档</a>进行探索。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/07/22/Objective-c%E5%BA%95%E5%B1%82%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/22/Objective-c%E5%BA%95%E5%B1%82%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">Objective-C底层面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-22 20:15:48" itemprop="dateCreated datePublished" datetime="2021-07-22T20:15:48+08:00">2021-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-25 11:04:14" itemprop="dateModified" datetime="2021-07-25T11:04:14+08:00">2021-07-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>oc</code>底层探索了很多了，今天主要总结一下一些相关的面试题。</p>
<h3 id="load方法什么时候调用。"><a href="#load方法什么时候调用。" class="headerlink" title="load方法什么时候调用。"></a><code>load</code>方法什么时候调用。</h3><p>这个问题很多同学应该都知道，就是<code>main</code>函数之前，但是<code>main</code>之前的哪一步执行的，可能有些同学就疑惑了，，同时还有一个方法的调用时机也会被经常问到就是<code>initialize</code>,我们分别讨论。</p>
<h4 id="load方法"><a href="#load方法" class="headerlink" title="load方法"></a><code>load</code>方法</h4><ul>
<li><code>load</code>方法是在应用程序加载过程中调用的，确实是在<code>main</code>函数之前调用。</li>
<li>具体是<code>_dyld_objc_notify_register</code>方法的第二个参数<code>load_images</code>回调的。</li>
<li>通过<code>prepare_load_methods</code>递归查找<code>load</code>方法添加到一个<code>load</code>方法的加载表<code>loadable_classes</code>里，注意父类会比子类先加入到表中，查找完类的<code>load</code>方法之后，查找分类的<code>load</code>也会添加到一个<code>loadable_categories</code>表中。</li>
<li>最后是<code>call_load_methods</code>调用<code>load</code>方法，先从<code>loadable_classes</code>表里循环调用类的<code>load</code>方法，然后从<code>loadable_categories</code>表里循环调用分类的<code>load</code>方法。</li>
<li>因为是顺序遍历表调用<code>load</code>方法的。所以<code>load</code>方法的调用次序是<code>父类</code>&gt;<code>本类</code>&gt;<code>分类</code>。</li>
<li>如果有多个分类都有<code>load</code>方法，其调用顺序会根据编译的顺序调用。编译顺序可以在<code>Compiles Sources</code>里调整。</li>
<li><code>load</code>方法过多会影响到应用的启动速度。</li>
</ul>
<h4 id="initialize方法。"><a href="#initialize方法。" class="headerlink" title="initialize方法。"></a><code>initialize</code>方法。</h4><ul>
<li><code>initialize</code>方法是在第一次<code>objc_msgSend</code>的时候调用的，它的调用时机晚于<code>load</code>。</li>
<li>分类的方法是在类<code>realize</code>之后<code>attachCategorys</code>进去的，会在类的方法前面。如果分类实现了<code>initialize</code>方法，会优先调用分类的方法。</li>
</ul>
<h3 id="Runtime是什么"><a href="#Runtime是什么" class="headerlink" title="Runtime是什么"></a><code>Runtime</code>是什么</h3><ul>
<li><code>runtime</code>是由<code>c</code>、<code>c++</code>、<code>汇编</code>实现的一套<code>API</code>,为<code>oc</code>语言加入面向对象运行时功能。</li>
<li><code>运行时</code>是指讲数据类型的确定有<code>编译时</code>推迟到了<code>运行时</code>。</li>
<li>我们写的<code>oc</code>代码，在程序运行过程中，最终都会转换成<code>runtime</code>的<code>c</code>语言代码。</li>
</ul>
<h3 id="⽅法的本质，sel是什么？IMP是什么？两者之间的关系是什么"><a href="#⽅法的本质，sel是什么？IMP是什么？两者之间的关系是什么" class="headerlink" title="⽅法的本质，sel是什么？IMP是什么？两者之间的关系是什么"></a>⽅法的本质，<code>sel</code>是什么？<code>IMP</code>是什么？两者之间的关系是什么</h3><h4 id="⽅法的本质"><a href="#⽅法的本质" class="headerlink" title="⽅法的本质"></a>⽅法的本质</h4><p>⽅法的本质是消息发送，即<code>objc_msgSend</code>,它的流程是：</p>
<ul>
<li>快速查找 （<code>objc_msgSend</code>）~ <code>cache_t</code> 缓存消息</li>
<li>慢速查找~ 递归⾃⼰或⽗类 ~ <code>lookUpImpOrForward</code></li>
<li>查找不到消息: 动态⽅法解析 ~ <code>resolveInstanceMethod</code></li>
<li>消息快速转发 ~ <code>forwardingTargetForSelector</code></li>
<li>消息慢速转发 ~ <code>methodSignatureForSelector</code> 和 <code>forwardInvocation</code></li>
</ul>
<h4 id="sel是什么"><a href="#sel是什么" class="headerlink" title="sel是什么"></a><code>sel</code>是什么</h4><p><code>sel</code>是⽅法编号，在<code>read_images</code>期间就加载进⼊了内存。它实际是<code>objc_selector</code>结构体。</p>
<h4 id="IMP是什么"><a href="#IMP是什么" class="headerlink" title="IMP是什么"></a><code>IMP</code>是什么</h4><p><code>imp</code>就是我们函数实现指针，找<code>imp</code>就是找函数实现的过程。</p>
<h4 id="sel与IMP的关系"><a href="#sel与IMP的关系" class="headerlink" title="sel与IMP的关系"></a><code>sel</code>与<code>IMP</code>的关系</h4><ul>
<li><code>sel</code>就相当于书本的⽬录<code>title</code></li>
<li><code>imp</code>就是书本的⻚码</li>
<li>方法调用的时候首先根据<code>sel</code>找到<code>imp</code>最后到具体函数的实现，完成调用。</li>
</ul>
<h3 id="能否向编译后的类中增加实例变量？能否向运⾏时创建的类中添加实例变量？"><a href="#能否向编译后的类中增加实例变量？能否向运⾏时创建的类中添加实例变量？" class="headerlink" title="能否向编译后的类中增加实例变量？能否向运⾏时创建的类中添加实例变量？"></a>能否向编译后的类中增加实例变量？能否向运⾏时创建的类中添加实例变量？</h3><ul>
<li><p>不能向编译后的得到的类中增加实例变量：</p>
<ul>
<li>我们编译好的实例变量存储的位置在<code>ro</code>（read only），⼀旦编译完成，内存结构就完全确定。</li>
<li>我们可以通过<code>分类</code>向类中添加<code>方法</code>和<code>属性</code>(通过关联对象)。</li>
</ul>
</li>
<li><p>可以向运行时创建的类中添加实例变量，只要类没有注册到内存还是可以添加。</p>
<p>这里<code>运行时创建的类</code>指的是通过<code>objc_allocateClassPair</code>方法，创建的<code>类</code>,在调用<code>objc_registerClassPair</code>方法之前是可以添加<code>实例变量</code>的。</p>
</li>
</ul>
<h3 id="self-class-和-super-class-区别"><a href="#self-class-和-super-class-区别" class="headerlink" title="[self class]和[super class]区别"></a>[self class]和[super class]区别</h3><p>先定义两个类<code>JSPerson</code>和<code>JSStudent</code>,其中<code>JSStudent</code>继承于<code>JSPerson</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@interface JSPerson : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">#import &quot;JSPerson.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation JSPerson</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface JSStudent : JSPerson</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation JSStudent</span><br><span class="line"></span><br><span class="line">- (instancetype)init&#123;</span><br><span class="line">    self &#x3D; [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        NSLog(@&quot;%@ - %@&quot;,[self class],[super class]);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>在<code>main</code>函数里实例化一个<code>JSStudent</code>对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        JSStudent *student &#x3D; [[JSStudent alloc] init];;</span><br><span class="line">        NSLog(@&quot;%@&quot;,student);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现打印结果为<code>JSStudent - JSStudent</code>。这是为什么呢，我们下面分析一下。</p>
<p>首先，<code>JSPerson</code>和<code>JSStudent</code>类都没有实现<code>class</code>方法，根据消息发送查找流程，会调用<code>NSObject</code>类的<code>class</code>方法，它的实现为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (Class)<span class="class"><span class="keyword">class</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> object_getClass(self);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据isa找到类</span></span><br><span class="line"><span class="function">Class <span class="title">object_getClass</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) <span class="keyword">return</span> obj-&gt;getIsa();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>class</code>方法的作用是返回当前的类，<code>self</code>是调用的对象也就是<code>student</code>实例。</p>
<ul>
<li><p><code>[self class]</code>打印的是<code>JSStudent</code>很好理解，因为消息接受者就是<code>JSStudent</code>的实例对象，通过<code>isa</code>找到的就是<code>JSStudent</code>类。</p>
</li>
<li><p><code>[super class]</code>打印的也是<code>JSStudent</code>就让人困惑了，我们打开<code>汇编调试</code>看一下<code>[super class]</code>的底层调用了什么</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32b236096024497cb3c8e4345f302f03~tplv-k3u1fbpfcp-watermark.image" alt="WechatIMG1246"></p>
<p><code>[super class]</code>实际调用的是<code>objc_msgSendSuper2</code>方法，我们在源码看一下这个方法的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc_msgSendSuper2() takes the current search class, not its superclass.</span></span><br><span class="line">OBJC_EXPORT id _Nullable</span><br><span class="line">objc_msgSendSuper2(struct objc_super * _Nonnull super, SEL _Nonnull op, ...)</span><br><span class="line">    OBJC_AVAILABLE(<span class="number">10.6</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br></pre></td></tr></table></figure>

<p>其实看<code>objc_msgSendSuper2</code>的注释就可以看出来，方法查找的是<code>本类</code>而不是它的<code>父类</code>。</p>
<p>继续看，<code>super</code>是方法的第一个参数，也就是<code>objc_super *</code>它的结构是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_super</span> &#123;</span></span><br><span class="line">    <span class="comment">/// Specifies an instance of a class.</span></span><br><span class="line">    __unsafe_unretained _Nonnull id receiver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Specifies the particular superclass of the instance to message. </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span></span><br><span class="line">    <span class="comment">/* For compatibility with old objc-runtime.h header */</span></span><br><span class="line">  	<span class="comment">///old结构，我们可以忽略 !__OBJC2__使用</span></span><br><span class="line">    __unsafe_unretained _Nonnull Class <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    __unsafe_unretained _Nonnull Class super_class;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* super_class is the first class to search */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>objc_super</code>的成员变量有<code>receiver</code>它是当前的调用的实例也就是<code>student</code>,<code>super_class</code>是当前实例对象的类的<code>父类</code>。所以说<code>[super class]</code>的消息接受者<code>self</code>还是<code>student</code>,所以打印的是<code>JSStudent</code>，<code>super</code>是一个关键字。</p>
<h3 id="内存平移问题"><a href="#内存平移问题" class="headerlink" title="内存平移问题"></a>内存平移问题</h3><p>案例说明:<code>JSPerson</code>类中有一个<code>saySomething</code>方法，在<code>ViewController</code>类的<code>viewDidLoad</code>通过两种方式调用，详细看代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@implementation JSPerson</span><br><span class="line">- (void)saySomething&#123;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    &#x2F;&#x2F; Do any additional setup after loading the view.</span><br><span class="line">    JSPerson *person &#x3D; [JSPerson alloc];</span><br><span class="line">    [person saySomething];</span><br><span class="line">    </span><br><span class="line">    Class cls &#x3D; [JSPerson class];</span><br><span class="line">    void  *js &#x3D; &amp;cls;</span><br><span class="line">    [(__bridge id)js saySomething];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>问题是这两个调用<code>saySomething</code>的语句是否有问题。</p>
<ul>
<li><p><code>[person saySomething]</code>：这种方式没什么疑问，正常的方法调用。它的流程是通过<code>person</code>对象的<code>isa</code>指针找到类<code>JSPerson</code>,首先通过内存平移找到<code>cache</code>里查找，如果找不到，继续平移找到<code>bits</code>查找方法列表查找，最后找到<code>imp</code>调用。</p>
</li>
<li><p><code>[(__bridge id)js saySomething]</code>:运行代码，我们这一行代码也正常执行了，原因是什么呢</p>
<p><code>void  *js = &amp;cls;</code>说明<code>js</code>是一个指向<code>JSPerson</code>类首地址的指针，它和对象的<code>isa</code>指向的是同一个地址，通过内存平移也可以找到对应的方法。</p>
</li>
</ul>
<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>在<code>saySomething</code>方法里增加属性<code>self.js_name</code> 的打印,其他不变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@interface JSPerson : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSString *js_name;</span><br><span class="line"></span><br><span class="line">- (void)saySomething;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation JSPerson</span><br><span class="line">- (void)saySomething&#123;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;%s - %@&quot;,__func__,self.js_name);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>再次运行程序发现打印结果为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-[JSPerson saySomething] - (null)</span><br><span class="line">-[JSPerson saySomething] - &lt;JSPerson: <span class="number">0x600003a00380</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>[person saySomething]</code>：因为我们没有对<code>js_name</code>赋值，<code>[person saySomething]</code>打印<code>(null)</code>正常。</p>
</li>
<li><p><code>[(__bridge id)js saySomething]</code>：这里打印了<code>&lt;JSPerson: 0x600003a00380&gt;</code>很困惑。</p>
<p>我们首先要清楚<code>self.js_name</code>是怎么找到<code>js_name</code>并打印的，它是从<code>person</code>内存地址中平移8位(<code>isa</code>是8位)找到第一个属性<code>js_name</code>。</p>
<p>类比<code>js</code>也需要平移8位找<code>js_name</code>,由于<code>js</code>是一个指针，存在<code>栈</code>上的，栈是一个<code>先进后出</code>的数据结构，每次参数传入就会压栈。</p>
<ul>
<li><p>其中<code>隐藏参数会压入栈</code>，且每个函数都会有两个隐藏参数<code>(id self，sel _cmd)</code>，这个我们前面探索过，可以通过<code>clang</code>将<code>oc</code>代码转成<code>c++</code>代码查看。</p>
</li>
<li><p><code>隐藏参数压栈</code>的过程，其地址是<code>递减</code>的，而<code>栈是从高地址-&gt;低地址 分配</code>的，即<code>在栈中，参数会从前往后一直压</code></p>
</li>
<li><p>前面还有一行<code>[super viewDidLoad];</code>,<code>super</code>调用的压栈我们也需要研究一下，其实上一题我们研究过它实际调用的是<code>objc_msgSendSuper2</code>,有两个参数<code>_objc_super</code>和<code>sel</code>。结构体的属性的压栈我们通过自定义一个结构体探索</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct js_struct&#123;</span><br><span class="line">    NSNumber *num1;</span><br><span class="line">    NSNumber *num2;</span><br><span class="line">&#125; js_struct;</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    &#x2F;&#x2F; Do any additional setup after loading the view.</span><br><span class="line">    JSPerson *person1 &#x3D; [JSPerson alloc];</span><br><span class="line">    struct js_struct jst &#x3D; &#123;@(1),@(3)&#125;;</span><br><span class="line">    JSPerson *person &#x3D; [JSPerson alloc];</span><br><span class="line">    [person saySomething];</span><br><span class="line">    </span><br><span class="line">    Class cls &#x3D; [JSPerson class];</span><br><span class="line">    void  *js &#x3D; &amp;cls;</span><br><span class="line">    [(__bridge id)js saySomething];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在图示位置添加断点调试</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/900abebd0f814bdb9251b1f21cefaf32~tplv-k3u1fbpfcp-watermark.image" alt="1627138804130"></p>
<p>使用<code>lldb</code>调试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p &amp;person1</span><br><span class="line">(JSPerson **) $<span class="number">0</span> = <span class="number">0x00007ffeed1d8118</span></span><br><span class="line">(lldb) p &amp;jst</span><br><span class="line">(js_struct *) $<span class="number">1</span> = <span class="number">0x00007ffeed1d8108</span></span><br><span class="line">(lldb) p &amp;person</span><br><span class="line">(JSPerson **) $<span class="number">2</span> = <span class="number">0x00007ffeed1d8100</span></span><br><span class="line">(lldb) p jst.num1</span><br><span class="line">(__NSCFNumber *) $<span class="number">3</span> = <span class="number">0xbab63c269bab4904</span> (<span class="keyword">int</span>)<span class="number">1</span></span><br><span class="line">(lldb) p &amp;$<span class="number">3</span></span><br><span class="line">(NSNumber **) $<span class="number">4</span> = <span class="number">0x00007ffeed1d8108</span></span><br><span class="line">(lldb) p jst.num2</span><br><span class="line">(__NSCFNumber *) $<span class="number">5</span> = <span class="number">0xbab63c269bab4924</span> (<span class="keyword">int</span>)<span class="number">3</span></span><br><span class="line">(lldb) p &amp;$<span class="number">5</span></span><br><span class="line">(NSNumber **) $<span class="number">6</span> = <span class="number">0x00007ffeed1d8110</span></span><br></pre></td></tr></table></figure>

<p>发现<code>num1</code>的地址&lt;<code>num2</code>的地址，说明<code>num2</code>先入栈。也就是<code>结构体是从后向前入栈的</code>。</p>
</li>
<li><p>总结来说题中压栈的顺序是<code>self</code>-&gt;<code>_cmd</code>-&gt;<code>superClass</code>-&gt;<code>self</code>-&gt;<code>person</code>-&gt;<code>cls</code>-&gt;<code>js</code>。地址空间是由高到低。所以这个地方<code>js</code>向高地址平移8字节找到的是<code>person</code>也就是打印是<code>&lt;JSPerson: 0x600003a00380&gt;</code>的原因。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/07/22/Flutter-runApp-%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/22/Flutter-runApp-%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">Flutter-runApp()方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-22 14:46:42" itemprop="dateCreated datePublished" datetime="2021-07-22T14:46:42+08:00">2021-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-23 17:05:06" itemprop="dateModified" datetime="2021-07-23T17:05:06+08:00">2021-07-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>Flutter</code>程序的入口<code>main()</code>方法会调用<code>runApp()</code>方法，我们本篇探索<code>runApp</code>都做了啥。</p>
<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> runApp(Widget app) &#123;</span><br><span class="line">  WidgetsFlutterBinding.ensureInitialized()</span><br><span class="line">    ..scheduleAttachRootWidget(app)</span><br><span class="line">    ..scheduleWarmUpFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法一看很简洁，一共调用了<code>WidgetsFlutterBinding</code>的三个方法，在看三个方法的实现之前，我们看一下<code>WidgetsFlutterBinding</code>是什么。</p>
<h3 id="WidgetsFlutterBinding"><a href="#WidgetsFlutterBinding" class="headerlink" title="WidgetsFlutterBinding"></a>WidgetsFlutterBinding</h3><p>我们看一下官方的解释：</p>
<p><code>A concrete binding for applications based on the Widgets framework.This is the glue that binds the framework to the Flutter engine.</code></p>
<p>翻译过来就是，一个基于<code>Widgets framework</code>的应用程序的具体绑定，它是绑定<code>framework</code>和<code>Flutter engine</code>的胶水层。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetsFlutterBinding</span> <span class="keyword">extends</span> <span class="title">BindingBase</span> <span class="title">with</span> <span class="title">GestureBinding</span>, <span class="title">SchedulerBinding</span>, <span class="title">ServicesBinding</span>, <span class="title">PaintingBinding</span>, <span class="title">SemanticsBinding</span>, <span class="title">RendererBinding</span>, <span class="title">WidgetsBinding</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> WidgetsBinding ensureInitialized() &#123;</span><br><span class="line">    <span class="keyword">if</span> (WidgetsBinding.instance == <span class="keyword">null</span>)</span><br><span class="line">      WidgetsFlutterBinding();</span><br><span class="line">    <span class="keyword">return</span> WidgetsBinding.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的父类<code>BindingBase</code>是一个抽象类，<code>with</code>实现了很多<code>mixin</code>,这些<code>mixin</code>只能用于继承自<code>BindingBase</code>的类。<code>mixin</code>的作用是扩展功能，<code>mixin</code>可以类比于<code>iOS</code>的<code>protocol</code>(个人见解，如果不对欢迎指正)。</p>
<h4 id="BindingBase"><a href="#BindingBase" class="headerlink" title="BindingBase"></a>BindingBase</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingBase</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">省略代码</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">However, multiple window support is not yet implemented, so currently this</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">provides access to the one and only window.</span></span></span><br><span class="line">  <span class="comment">// TODO(gspencergoog): remove the preceding note once multi-window support is</span></span><br><span class="line">  <span class="comment">// active.</span></span><br><span class="line">  <span class="comment">// 唯一的window</span></span><br><span class="line">  ui.SingletonFlutterWindow <span class="keyword">get</span> <span class="built_in">window</span> =&gt; ui.<span class="built_in">window</span>;</span><br><span class="line">  <span class="comment">/// <span class="markdown">每一个BindingBase类定义行为 都有一个 platformDispatcher 作为回调(handlers)</span></span></span><br><span class="line">  ui.PlatformDispatcher <span class="keyword">get</span> platformDispatcher =&gt; ui.PlatformDispatcher.instance;</span><br><span class="line">  <span class="comment">/// <span class="markdown">初始化实例</span></span></span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">assert</span>(!_debugInitialized);</span><br><span class="line">    <span class="keyword">assert</span>(() &#123;</span><br><span class="line">      _debugInitialized = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// <span class="markdown">The current [WidgetsBinding], if one has been created.</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">ensureInitialized方法返回的实例</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">If you need the binding to be constructed before calling [runApp],</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">you can ensure a Widget binding has been constructed by calling the</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown"><span class="code">`WidgetsFlutterBinding.ensureInitialized()`</span> function.</span></span></span><br><span class="line">  <span class="keyword">static</span> WidgetsBinding? <span class="keyword">get</span> instance =&gt; _instance;</span><br><span class="line">  <span class="keyword">static</span> WidgetsBinding? _instance;</span><br><span class="line">  <span class="comment">/// <span class="markdown">注册 service extensions 初始化之后调用</span></span></span><br><span class="line">  <span class="keyword">void</span> initServiceExtensions() &#123;</span><br><span class="line">    <span class="comment">///<span class="markdown">省略代码</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ui.window</code>：是<code>Flutter App</code>显示的窗口，它继承自<code>FlutterView</code>,位于<code>Flutter engine</code>层。</li>
<li><code>ui.PlatformDispatcher.instance</code>：platformDispatcher是Flutter 的一个事件分发器，负责Flutter分发engine的事件，和传递事件给engine层。</li>
<li><code>initInstances</code>：初始化实例的方法。</li>
<li><code>initServiceExtensions()</code>：注册 <code>service extensions</code>,比如<code>platformOverride</code>、<code>activeDevToolsServerAddress</code>等。</li>
</ul>
<h3 id="ensureInitialized（）方法"><a href="#ensureInitialized（）方法" class="headerlink" title="ensureInitialized（）方法"></a>ensureInitialized（）方法</h3><p>该方法的作用是返回一个<code>WidgetsBinding</code>类型实例，如果未创建就新创建一个。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> WidgetsBinding ensureInitialized() &#123;</span><br><span class="line">  <span class="keyword">if</span> (WidgetsBinding.instance == <span class="keyword">null</span>)</span><br><span class="line">    WidgetsFlutterBinding();</span><br><span class="line">  <span class="keyword">return</span> WidgetsBinding.instance!;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是返回一个<code>WidgetsBinding.instance</code>实例，因为<code>WidgetsFlutterBinding</code>实现了<code>GestureBinding, SchedulerBinding, ServicesBinding, PaintingBinding, SemanticsBinding, RendererBinding, WidgetsBinding</code>mixin，mixin的<code>initInstances</code>和<code>initServiceExtensions</code>方法也会调用，每个mixin的功能：</p>
<ul>
<li><code>GestureBinding</code>：处理手势。</li>
<li><code>SchedulerBinding</code>: 处理系统调度。</li>
<li><code>ServicesBinding</code>：处理与原生的交互。</li>
<li><code>PaintingBinding</code>：处理绘制。</li>
<li><code>SemanticsBinding</code>：处理语义化。</li>
<li><code>RendererBinding</code>：处理渲染。</li>
<li><code>WidgetsBinding</code>：<code>Widgets</code>相关。</li>
</ul>
<p>我们下面主要看<code>WidgetsBinding</code>和<code>RendererBinding</code>。</p>
<h4 id="WidgetsBinding"><a href="#WidgetsBinding" class="headerlink" title="WidgetsBinding"></a>WidgetsBinding</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> WidgetsBinding <span class="keyword">on</span> BindingBase, ServicesBinding, SchedulerBinding, GestureBinding, RendererBinding, SemanticsBinding &#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initInstances();</span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">assert</span>(() &#123;</span><br><span class="line">      _debugAddStackFilters();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;());</span><br><span class="line">    <span class="comment">// Initialization of [_buildOwner] has to be done after</span></span><br><span class="line">    <span class="comment">// [super.initInstances] is called, as it requires [ServicesBinding] to</span></span><br><span class="line">    <span class="comment">// properly setup the [defaultBinaryMessenger] instance.</span></span><br><span class="line">    _buildOwner = BuildOwner();</span><br><span class="line">    buildOwner!.onBuildScheduled = _handleBuildScheduled;</span><br><span class="line">    <span class="built_in">window</span>.onLocaleChanged = handleLocaleChanged;</span><br><span class="line">    <span class="built_in">window</span>.onAccessibilityFeaturesChanged = handleAccessibilityFeaturesChanged;</span><br><span class="line">    SystemChannels.navigation.setMethodCallHandler(_handleNavigationInvocation);</span><br><span class="line">    FlutterErrorDetails.propertiesTransformers.add(transformDebugCreator);</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="comment">///<span class="markdown">省略代码</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WidgetsBinding</code>初始化会创建一个<code>BuildOwner</code>对象，它的作用是管理<code>Widget</code>树和<code>Element</code>树。</p>
<h4 id="RendererBinding"><a href="#RendererBinding" class="headerlink" title="RendererBinding"></a>RendererBinding</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> RendererBinding <span class="keyword">on</span> BindingBase, ServicesBinding, SchedulerBinding, GestureBinding, SemanticsBinding, HitTestable &#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initInstances();</span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line">    _pipelineOwner = PipelineOwner(</span><br><span class="line">      onNeedVisualUpdate: ensureVisualUpdate,</span><br><span class="line">      onSemanticsOwnerCreated: _handleSemanticsOwnerCreated,</span><br><span class="line">      onSemanticsOwnerDisposed: _handleSemanticsOwnerDisposed,</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">window</span></span><br><span class="line">      ..onMetricsChanged = handleMetricsChanged</span><br><span class="line">      ..onTextScaleFactorChanged = handleTextScaleFactorChanged</span><br><span class="line">      ..onPlatformBrightnessChanged = handlePlatformBrightnessChanged</span><br><span class="line">      ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged</span><br><span class="line">      ..onSemanticsAction = _handleSemanticsAction;</span><br><span class="line">    initRenderView();</span><br><span class="line">    _handleSemanticsEnabledChanged();</span><br><span class="line">    <span class="keyword">assert</span>(renderView != <span class="keyword">null</span>);</span><br><span class="line">    addPersistentFrameCallback(_handlePersistentFrameCallback);</span><br><span class="line">    initMouseTracker();</span><br><span class="line">    <span class="keyword">if</span> (kIsWeb) &#123;</span><br><span class="line">      addPostFrameCallback(_handleWebFirstFrame);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">The current [RendererBinding], if one has been created.</span></span></span><br><span class="line">  <span class="keyword">static</span> RendererBinding? <span class="keyword">get</span> instance =&gt; _instance;</span><br><span class="line">  <span class="keyword">static</span> RendererBinding? _instance;</span><br><span class="line">  <span class="comment">///<span class="markdown">省略代码</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RendererBinding</code>初始化会创建一个<code>PipelineOwner</code>对象，用于管理<code>RenderObject</code>树。<code>PipelineOwner</code>和<code>BuildOwner</code>都位于<code>framework</code>层，它们通过<code>Bingding</code>(胶水层)与<code>engine</code>交互。</p>
<ul>
<li>初始化了一个PipelineOwner用于管理RenderObject.</li>
<li>将<code>_handlePersistentFrameCallback</code>这个callback传入<code>SchedulerBinding</code>中的<code>_postFrameCallbacks</code>中，这样在硬件每次发出<code>VSync</code>信号的时候都会调用<code>RenderBinding</code>中的<code>_handlePersistentFrameCallback</code>方法.<code>_handlePersistentFrameCallback</code>方法中直接调用了<code>drawFrame</code>方法。</li>
</ul>
<h3 id="scheduleAttachRootWidget"><a href="#scheduleAttachRootWidget" class="headerlink" title="scheduleAttachRootWidget"></a>scheduleAttachRootWidget</h3><p>实例化之后会调用<code>scheduleAttachRootWidget</code>方法。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@protected</span></span><br><span class="line"><span class="keyword">void</span> scheduleAttachRootWidget(Widget rootWidget) &#123;</span><br><span class="line">  Timer.run(() &#123;</span><br><span class="line">    attachRootWidget(rootWidget);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了<code>attachRootWidget</code>方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> attachRootWidget(Widget rootWidget) &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> isBootstrapFrame = renderViewElement == <span class="keyword">null</span>;</span><br><span class="line">  _readyToProduceFrames = <span class="keyword">true</span>;</span><br><span class="line">  _renderViewElement = RenderObjectToWidgetAdapter&lt;RenderBox&gt;(</span><br><span class="line">    container: renderView,</span><br><span class="line">    debugShortDescription: <span class="string">'[root]'</span>,</span><br><span class="line">    child: rootWidget,</span><br><span class="line">  ).attachToRenderTree(buildOwner!, renderViewElement <span class="keyword">as</span> RenderObjectToWidgetElement&lt;RenderBox&gt;?);</span><br><span class="line">  <span class="keyword">if</span> (isBootstrapFrame) &#123;</span><br><span class="line">    SchedulerBinding.instance!.ensureVisualUpdate();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>attachRootWidget方法用于是为根Widget生成一个根Element。生成Element调用了attachToRenderTree方法并传入了BuildOwner和Element。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RenderObjectToWidgetElement&lt;T&gt; attachToRenderTree(BuildOwner owner, [ RenderObjectToWidgetElement&lt;T&gt;? element ]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (element == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">///<span class="markdown">新创建一个 element</span></span></span><br><span class="line">      owner.lockState(() &#123;</span><br><span class="line">        element = createElement();</span><br><span class="line">        <span class="keyword">assert</span>(element != <span class="keyword">null</span>);</span><br><span class="line">        element!.assignOwner(owner);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 建立能更新widget 树的能力，可以回调 callback，构建所有标记为dirty的elment</span></span><br><span class="line">      owner.buildScope(element!, () &#123;</span><br><span class="line">        element!.mount(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element._newWidget = <span class="keyword">this</span>;</span><br><span class="line">      element.markNeedsBuild();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> element!;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要是<code>element</code>为空的时候新建一个<code>element</code>，新建后会调用<code>BuildOwner</code>的<code>buildScope</code>主要作用是建立能更新<code>widget</code> 树的能力，可以回调 <code>callback</code>，构建所有标记为<code>dirty</code>的<code>element</code>。</p>
<p><code>attachRootWidget</code>方法，最后会执行<code>SchedulerBinding.instance!.ensureVisualUpdate()</code>，</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ensureVisualUpdate() &#123;</span><br><span class="line">  <span class="keyword">switch</span> (schedulerPhase) &#123;</span><br><span class="line">    <span class="keyword">case</span> SchedulerPhase.idle:</span><br><span class="line">    <span class="keyword">case</span> SchedulerPhase.postFrameCallbacks:</span><br><span class="line">      scheduleFrame();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> SchedulerPhase.transientCallbacks:</span><br><span class="line">    <span class="keyword">case</span> SchedulerPhase.midFrameMicrotasks:</span><br><span class="line">    <span class="keyword">case</span> SchedulerPhase.persistentCallbacks:</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它主要是调用新的帧的调度管理。它会调用<code>scheduleFrame</code>方法</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> scheduleFrame() &#123;</span><br><span class="line">  <span class="keyword">if</span> (_hasScheduledFrame || !framesEnabled)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">assert</span>(() &#123;</span><br><span class="line">    <span class="keyword">if</span> (debugPrintScheduleFrameStacks)</span><br><span class="line">      debugPrintStack(label: <span class="string">'scheduleFrame() called. Current phase is <span class="subst">$schedulerPhase</span>.'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;());</span><br><span class="line">  <span class="comment">///<span class="markdown">给window设置回调</span></span></span><br><span class="line">  ensureFrameCallbacksRegistered();</span><br><span class="line">  <span class="comment">///<span class="markdown">调度更新</span></span></span><br><span class="line">  <span class="built_in">window</span>.scheduleFrame();</span><br><span class="line">  _hasScheduledFrame = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会给<code>window</code>设置<code>onBeginFrame</code>和<code>onDrawFrame</code>的回调，<code>window</code>会把回调传给<code>platformDispatcher</code>。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">set</span> onBeginFrame(ui.FrameCallback? callback) &#123;</span><br><span class="line">  platformDispatcher.onBeginFrame = callback;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">ui.VoidCallback? <span class="keyword">get</span> onDrawFrame =&gt; platformDispatcher.onDrawFrame;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">set</span> onDrawFrame(ui.VoidCallback? callback) &#123;</span><br><span class="line">  platformDispatcher.onDrawFrame = callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说<code>scheduleAttachRootWidget</code>经过一系列调用之后，会把<code>SchedulerBinding</code>的<code>_handleBeginFrame</code>和<code>_handleDrawFrame</code>传给<code>platformDispatcher</code>。<code>platformDispatcher</code>分发来自enginee的事件。而在这里<code>SingletonFlutterWindow</code>把<code>platformDispatcher</code>的<code>onBeginFrame</code>和<code>onDrawFrame</code>这两个事件交给<code>SchedulerBinding</code>处理。</p>
<p>当硬件发出<code>VSync</code>信号时，会调用<code>platformDispatcher的onDrawFrame</code>。实际上会调用<code>SchedulerBinding</code>中的<code>_handleDrawFrame</code>方法。<code>_handleDrawFrame</code>会调用<code>handleDrawFrame</code>方法:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> handleDrawFrame() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(_schedulerPhase == SchedulerPhase.midFrameMicrotasks);</span><br><span class="line">  Timeline.finishSync(); <span class="comment">// end the "Animate" phase</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// PERSISTENT FRAME CALLBACKS</span></span><br><span class="line">    _schedulerPhase = SchedulerPhase.persistentCallbacks;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> FrameCallback callback <span class="keyword">in</span> _persistentCallbacks)</span><br><span class="line">      _invokeFrameCallback(callback, _currentFrameTimeStamp!);</span><br><span class="line">    <span class="comment">// POST-FRAME CALLBACKS</span></span><br><span class="line">    _schedulerPhase = SchedulerPhase.postFrameCallbacks;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">List</span>&lt;FrameCallback&gt; localPostFrameCallbacks =</span><br><span class="line">        <span class="built_in">List</span>&lt;FrameCallback&gt;.from(_postFrameCallbacks);</span><br><span class="line">    _postFrameCallbacks.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> FrameCallback callback <span class="keyword">in</span> localPostFrameCallbacks)</span><br><span class="line">      _invokeFrameCallback(callback, _currentFrameTimeStamp!);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">///<span class="markdown">省略代码</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_postFrameCallbacks</code>里面存储的是<code>callback</code>，作用是硬件每次发出<code>VSync</code>信号的时候都会调用。这里的<code>_postFrameCallbacks</code>是在<code>RenderBinding</code>这个<code>mixin</code>的<code>initInstances</code>方法中传入的</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addPersistentFrameCallback(_handlePersistentFrameCallback);</span><br></pre></td></tr></table></figure>

<h3 id="scheduleWarmUpFrame"><a href="#scheduleWarmUpFrame" class="headerlink" title="scheduleWarmUpFrame"></a>scheduleWarmUpFrame</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> scheduleWarmUpFrame() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_warmUpFrame || schedulerPhase != SchedulerPhase.idle)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    _warmUpFrame = <span class="keyword">true</span>;</span><br><span class="line">    Timeline.startSync(<span class="string">'Warm-up frame'</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">bool</span> hadScheduledFrame = _hasScheduledFrame;</span><br><span class="line">    <span class="comment">// We use timers here to ensure that microtasks flush in between.</span></span><br><span class="line">    Timer.run(() &#123;</span><br><span class="line">      <span class="keyword">assert</span>(_warmUpFrame);</span><br><span class="line">      handleBeginFrame(<span class="keyword">null</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    Timer.run(() &#123;</span><br><span class="line">      <span class="keyword">assert</span>(_warmUpFrame);</span><br><span class="line">      handleDrawFrame();</span><br><span class="line">      <span class="comment">// We call resetEpoch after this frame so that, in the hot reload case,</span></span><br><span class="line">      <span class="comment">// the very next frame pretends to have occurred immediately after this</span></span><br><span class="line">      <span class="comment">// warm-up frame. The warm-up frame's timestamp will typically be far in</span></span><br><span class="line">      <span class="comment">// the past (the time of the last real frame), so if we didn't reset the</span></span><br><span class="line">      <span class="comment">// epoch we would see a sudden jump from the old time in the warm-up frame</span></span><br><span class="line">      <span class="comment">// to the new time in the "real" frame. The biggest problem with this is</span></span><br><span class="line">      <span class="comment">// that implicit animations end up being triggered at the old time and</span></span><br><span class="line">      <span class="comment">// then skipping every frame and finishing in the new time.</span></span><br><span class="line">      resetEpoch();</span><br><span class="line">      _warmUpFrame = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (hadScheduledFrame)</span><br><span class="line">        scheduleFrame();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// Lock events so touch events etc don't insert themselves until the</span></span><br><span class="line">    <span class="comment">// scheduled frame has finished.</span></span><br><span class="line">    lockEvents(() <span class="keyword">async</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> endOfFrame;</span><br><span class="line">      Timeline.finishSync();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要调用是<code>scheduleFrame</code>，跟进代码实际是调用的<code>window.scheduleFrame()</code>,</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> scheduleFrame() &#123;</span><br><span class="line">  platformDispatcher.scheduleFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>window.scheduleFrame()</code>调用了<code>platformDispatcher.scheduleFrame()</code>,通知<code>engine</code>层需要绘制。engine会根据情况尽快地调用platformDispatcher的onDrawFrame方法。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>runApp方法主要做了以下事情：</p>
<ul>
<li>创建<code>WidgetsFlutterBinding</code>它是连接<code>framework</code>和<code>engine</code>的胶水层。注册<code>Vsync</code>回调，后面每一帧的调用会出发<code>WidgetsFlutterBinding</code>的回调，最后传递到<code>framework</code>层处理逻辑。</li>
<li><code>attachRootWidget</code>：遍历挂载整个视图树，建立<code>widget</code>、<code>element</code>、<code>renderObjcect</code>的连接关系。</li>
<li><code>scheduleWarmUpFrame</code>：调度帧预热(warmUp)。执行帧绘制<code>handleBeginFrame</code>和<code>handleDrawFrame</code>方法。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/07/20/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E7%B1%BB%E7%9A%84%E6%89%A9%E5%B1%95%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/20/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E7%B1%BB%E7%9A%84%E6%89%A9%E5%B1%95%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">iOS底层探索-类的扩展和关联对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-20 09:24:28" itemprop="dateCreated datePublished" datetime="2021-07-20T09:24:28+08:00">2021-07-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-21 11:34:53" itemprop="dateModified" datetime="2021-07-21T11:34:53+08:00">2021-07-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前面几篇我们探索了<code>类</code>的加载过程，本篇我们研究类相关的两个点：<code>类的扩展</code>和<code>关联对象</code>。</p>
<h3 id="类扩展"><a href="#类扩展" class="headerlink" title="类扩展"></a>类扩展</h3><h4 id="clang编译"><a href="#clang编译" class="headerlink" title="clang编译"></a>clang编译</h4><p>我们首先在<code>main.m</code>文件中新建一个类<code>JSAnimal</code>,并给类定义扩展，注意<code>扩展</code>要在<code>声明之后</code>和<code>实现之后</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@interface JSAnimal : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic,copy)NSString *name;</span><br><span class="line"></span><br><span class="line">- (void)sayWow;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface JSAnimal ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic,copy)NSString *type;</span><br><span class="line"></span><br><span class="line">- (void)ex_sayWow;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation JSAnimal</span><br><span class="line"></span><br><span class="line">+ (void)classMethod&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sayWow&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)ex_sayWow&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        JSAnimal *animal &#x3D; [[JSAnimal alloc] init];</span><br><span class="line">        [animal ex_sayWow];</span><br><span class="line">        NSLog(@&quot;done&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用<code>clang</code>命令，将<code>main.m</code>转成<code>main.cpp</code>文件，看一下分类的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m -o main.cpp</span><br></pre></td></tr></table></figure>

<p><code>main.cpp</code>文件搜索<code>JSAnimal</code></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfcccacbc80a4621b82cd607c8089ade~tplv-k3u1fbpfcp-watermark.image" alt="1626779765218"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f79df3e864584213815b25cd6c2a5cbc~tplv-k3u1fbpfcp-watermark.image" alt="1626779854673"></p>
<p>发现<code>扩展</code>里声明的<code>属性</code>和<code>方法</code>编译后和<code>类</code>中的在一起，作为<code>类</code>的一部分，也就是说<code>扩展中的属性和方法</code>在<code>编译期</code>就添加到<code>本类</code>中了。</p>
<h4 id="通过源码探索运行时"><a href="#通过源码探索运行时" class="headerlink" title="通过源码探索运行时"></a>通过源码探索运行时</h4><p>定义一个<code>JSPerson</code>类和扩展，本类中实现扩展中声明的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface JSPerson : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line"></span><br><span class="line">- (void)saySomething;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;JSPerson.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation JSPerson</span><br><span class="line"></span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)saySomething&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)ext_instanceMethod&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)ext_classMethod&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface JSPerson ()</span><br><span class="line"></span><br><span class="line">- (void)ext_instanceMethod;</span><br><span class="line"></span><br><span class="line">+ (void)ext_classMethod;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>注意<code>JSPerson</code>类实现了<code>load</code>方法，目的是让其<code>非懒加载</code>。根据我们的经验，我们在<code>realizeClassWithoutSwift</code>添加断点调试</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af878f11eefc4b4b89daf2d446cba41d~tplv-k3u1fbpfcp-watermark.image" alt="1626781568401"></p>
<p>通过<code>lldb</code>打印<code>ro</code>中的方法列表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p ro</span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *) $<span class="number">0</span> = <span class="number">0x0000000100004790</span></span><br><span class="line">(lldb) p *$<span class="number">0</span></span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">class_ro_t</span>) $<span class="number">1</span> = &#123;</span><br><span class="line">  flags = <span class="number">0</span></span><br><span class="line">  instanceStart = <span class="number">8</span></span><br><span class="line">  instanceSize = <span class="number">16</span></span><br><span class="line">  reserved = <span class="number">0</span></span><br><span class="line">   = &#123;</span><br><span class="line">    ivarLayout = <span class="number">0x0000000000000000</span></span><br><span class="line">    nonMetaclass = nil</span><br><span class="line">  &#125;</span><br><span class="line">  name = &#123;</span><br><span class="line">    <span class="built_in">std</span>::__1::atomic&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; = <span class="string">"JSPerson"</span> &#123;</span><br><span class="line">      Value = <span class="number">0x0000000100003b58</span> <span class="string">"JSPerson"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  baseMethodList = <span class="number">0x00000001000047d8</span></span><br><span class="line">  baseProtocols = nil</span><br><span class="line">  ivars = <span class="number">0x0000000100004840</span></span><br><span class="line">  weakIvarLayout = <span class="number">0x0000000000000000</span></span><br><span class="line">  baseProperties = <span class="number">0x0000000100004868</span></span><br><span class="line">  _swiftMetadataInitializer_NEVER_USE = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">1.b</span>aseMethods()</span><br><span class="line">(<span class="keyword">method_list_t</span> *) $<span class="number">2</span> = <span class="number">0x00000001000047d8</span></span><br><span class="line">(lldb) p *$<span class="number">2</span></span><br><span class="line">(<span class="keyword">method_list_t</span>) $<span class="number">3</span> = &#123;</span><br><span class="line">  entsize_list_tt&lt;<span class="keyword">method_t</span>, <span class="keyword">method_list_t</span>, <span class="number">4294901763</span>, <span class="keyword">method_t</span>::pointer_modifier&gt; = (entsizeAndFlags = <span class="number">24</span>, count = <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">3.</span><span class="built_in">get</span>(<span class="number">0</span>).big()</span><br><span class="line">(<span class="keyword">method_t</span>::big) $<span class="number">4</span> = &#123;</span><br><span class="line">  name = <span class="string">"saySomething"</span></span><br><span class="line">  types = <span class="number">0x0000000100003d84</span> <span class="string">"v16@0:8"</span></span><br><span class="line">  imp = <span class="number">0x0000000100003600</span> (KCObjcBuild`-[JSPerson saySomething])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">3.</span><span class="built_in">get</span>(<span class="number">1</span>).big()</span><br><span class="line">(<span class="keyword">method_t</span>::big) $<span class="number">5</span> = &#123;</span><br><span class="line">  name = <span class="string">"ext_instanceMethod"</span></span><br><span class="line">  types = <span class="number">0x0000000100003d84</span> <span class="string">"v16@0:8"</span></span><br><span class="line">  imp = <span class="number">0x0000000100003630</span> (KCObjcBuild`-[JSPerson ext_instanceMethod])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">3.</span><span class="built_in">get</span>(<span class="number">2</span>).big()</span><br><span class="line">(<span class="keyword">method_t</span>::big) $<span class="number">6</span> = &#123;</span><br><span class="line">  name = <span class="string">"name"</span></span><br><span class="line">  types = <span class="number">0x0000000100003d98</span> <span class="string">"@16@0:8"</span></span><br><span class="line">  imp = <span class="number">0x0000000100003660</span> (KCObjcBuild`-[JSPerson name])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">3.</span><span class="built_in">get</span>(<span class="number">3</span>).big()</span><br><span class="line">(<span class="keyword">method_t</span>::big) $<span class="number">7</span> = &#123;</span><br><span class="line">  name = <span class="string">"setName:"</span></span><br><span class="line">  types = <span class="number">0x0000000100003da0</span> <span class="string">"v24@0:8@16"</span></span><br><span class="line">  imp = <span class="number">0x0000000100003690</span> (KCObjcBuild`-[JSPerson setName:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>扩展</code>中的方向现在已经加载了已知<code>ro</code>中的方法是<code>编译期</code>就确定的，所以也验证了<code>扩展</code>的方法是在<code>编译期</code>添加到<code>本类</code>的。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>类的扩展 在<code>编译期</code> 会作为类的一部分，和类一起编译进来</li>
<li>类的扩展只是<code>声明</code>，依赖于<code>本类</code>的实现。</li>
</ul>
<h3 id="分类的关联对象"><a href="#分类的关联对象" class="headerlink" title="分类的关联对象"></a>分类的关联对象</h3><p>我们知道<code>分类</code>正常是不能添加<code>属性</code>的，但是通过<code>关联对象</code>可以，其实现通过两个方法</p>
<ul>
<li>通过<code>objc_setAssociatedObject</code>方法设置值。</li>
<li>通过<code>objc_getAssociatedObject</code>方法取值。</li>
</ul>
<p>下面我们分别探索。</p>
<h4 id="objc-setAssociatedObject流程"><a href="#objc-setAssociatedObject流程" class="headerlink" title="objc_setAssociatedObject流程"></a>objc_setAssociatedObject流程</h4><p><code>objc_setAssociatedObject</code>有四个参数：</p>
<ul>
<li>参数1：要关联的对象</li>
<li>参数2：表示符，方便查找识别</li>
<li>参数3：value值</li>
<li>参数4：属性的<code>策略</code>,我们定义属性经常用到的如<code>nonatomic</code>、<code>strong</code>、<code>weak</code>。</li>
</ul>
<p>首先定义<code>JSPerson</code>的<code>分类</code>，定义一个属性<code>cateegory_name</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@interface JSPerson (JSCategory)</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *cateegory_name;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation JSPerson (JSCategory)</span><br><span class="line"></span><br><span class="line">- (void)setCateegory_name:(NSString *)category_name&#123;</span><br><span class="line">    objc_setAssociatedObject(self, &quot;category_name&quot;, category_name, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)category_name&#123;</span><br><span class="line">    return  objc_getAssociatedObject(self, &quot;category_name&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>在<code>main</code>函数赋值属性的地方添加断点，根据调用情况</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/565a6873ad724e6db775d38ea637c95a~tplv-k3u1fbpfcp-watermark.image" alt="1626783154111"></p>
<p>定位到<code>objc_setAssociatedObject</code>方法</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10b7f73974e746a6bedd5b3ab397f809~tplv-k3u1fbpfcp-watermark.image" alt="1626783226697"></p>
<p>调用的是<code>_object_set_associative_reference</code>方法，我们继续跟进查看源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_object_set_associative_reference(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key, id value, <span class="keyword">uintptr_t</span> policy)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This code used to work when nil was passed for object and key. Some code</span></span><br><span class="line">    <span class="comment">// probably relies on that to not crash. Check and handle it explicitly.</span></span><br><span class="line">    <span class="comment">// rdar://problem/44094390</span></span><br><span class="line">    <span class="keyword">if</span> (!object &amp;&amp; !value) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (object-&gt;getIsa()-&gt;forbidsAssociatedObjects())</span><br><span class="line">        _objc_fatal(<span class="string">"objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects"</span>, object, object_getClassName(object));</span><br><span class="line">		<span class="comment">///将object封装一下 类型为DisguisedPtr</span></span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; disguised&#123;(objc_object *)object&#125;;</span><br><span class="line">    <span class="comment">///包装policy  value</span></span><br><span class="line">    ObjcAssociation association&#123;policy, value&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// retain the new value (if any) outside the lock.</span></span><br><span class="line">    <span class="comment">//根据策略类型(strong、weak等)进行处理</span></span><br><span class="line">    association.acquireValue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isFirstAssociation = <span class="literal">false</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化manager变量，相当于自动调用AssociationsManager的构造函数进行初始化</span></span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">      	<span class="comment">///一个HashMap</span></span><br><span class="line">        <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.<span class="built_in">get</span>())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">          	<span class="comment">//返回的结果是一个类对</span></span><br><span class="line">            <span class="keyword">auto</span> refs_result = associations.try_emplace(disguised, ObjectAssociationMap&#123;&#125;);</span><br><span class="line">            <span class="keyword">if</span> (refs_result.second) &#123;</span><br><span class="line">                <span class="comment">/* it's the first association we make */</span></span><br><span class="line">                isFirstAssociation = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* establish or replace the association 建立或者替换关联*/</span></span><br><span class="line">            <span class="keyword">auto</span> &amp;refs = refs_result.first-&gt;second;<span class="comment">///得到一个空的桶，找到引用对象类型,即第一个元素的second值</span></span><br><span class="line">            <span class="keyword">auto</span> result = refs.try_emplace(key, <span class="built_in">std</span>::<span class="built_in">move</span>(association));<span class="comment">//查找当前的key是否有association关联对象</span></span><br><span class="line">            <span class="keyword">if</span> (!result.second) &#123;<span class="comment">///如果结果不存在</span></span><br><span class="line">                association.swap(result.first-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果传的是空值，则移除关联，相当于移除</span></span><br><span class="line">            <span class="keyword">auto</span> refs_it = associations.<span class="built_in">find</span>(disguised);</span><br><span class="line">            <span class="keyword">if</span> (refs_it != associations.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> &amp;refs = refs_it-&gt;second;</span><br><span class="line">                <span class="keyword">auto</span> it = refs.<span class="built_in">find</span>(key);</span><br><span class="line">                <span class="keyword">if</span> (it != refs.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    association.swap(it-&gt;second);</span><br><span class="line">                    refs.erase(it);</span><br><span class="line">                    <span class="keyword">if</span> (refs.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                        associations.erase(refs_it);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Call setHasAssociatedObjects outside the lock, since this</span></span><br><span class="line">    <span class="comment">// will call the object's _noteAssociatedObjects method if it</span></span><br><span class="line">    <span class="comment">// has one, and this may trigger +initialize which might do</span></span><br><span class="line">    <span class="comment">// arbitrary stuff, including setting more associated objects.</span></span><br><span class="line">    <span class="keyword">if</span> (isFirstAssociation)</span><br><span class="line">        object-&gt;setHasAssociatedObjects();</span><br><span class="line">    <span class="comment">// release the old value (outside of the lock).释放老的关联值</span></span><br><span class="line">    association.releaseHeldValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过源码我们看到大体的流程为：</p>
<ul>
<li>创建一个<code>AssociationsManager</code>管理类</li>
<li>获取<code>静态哈希表</code>:<code>associations</code></li>
<li>判断<code>关联值value</code>是否为空<ul>
<li>如果为空就走：<code>插入空值</code>流程。</li>
<li>如果不为空继续下一步</li>
</ul>
</li>
<li>通过<code>try_emplace</code>方法，创建一个空的 <code>ObjectAssociationMap</code> 去取查询的键值对</li>
<li>如果发现<code>没有</code> <code>key</code> 就<code>插入一个 空的 BucketT</code>进去并返回true</li>
<li>通过<code>setHasAssociatedObjects</code>方法<code>标记对象存在关联对象</code></li>
<li>用当前 <code>policy 和 value</code> 组成了一个 <code>ObjcAssociation</code> 替换原来 <code>BucketT</code>中的值</li>
<li>标记一下 <code>ObjectAssociationMap</code> 的<code>第一次</code>为 <code>false</code></li>
</ul>
<h4 id="源码调试"><a href="#源码调试" class="headerlink" title="源码调试"></a>源码调试</h4><p>对流程有了大概的认识，我们开始断点调试</p>
<h5 id="if-value-之前变量的值"><a href="#if-value-之前变量的值" class="headerlink" title="if (value) 之前变量的值"></a><strong>if</strong> (value) 之前变量的值</h5><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d0c1f116d8b4d999e54a29b275453cc~tplv-k3u1fbpfcp-watermark.image" alt="1626785173962"></p>
<p>通过<code>lldb</code>我们打印出了<code>disguised</code>、<code>association</code>、<code>manager</code>、<code>associations</code>、<code>value</code>的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p disguised</span><br><span class="line">(DisguisedPtr&lt;objc_object&gt;) $<span class="number">0</span> = (value = <span class="number">18446744069393517536</span>)</span><br><span class="line">(lldb) p association</span><br><span class="line">(objc::ObjcAssociation) $<span class="number">1</span> = &#123;</span><br><span class="line">  _policy = <span class="number">3</span></span><br><span class="line">  _value = <span class="number">0x0000000100004080</span> <span class="string">"哈哈哈"</span></span><br><span class="line">&#125;</span><br><span class="line">(lldb) p manager</span><br><span class="line">(objc::AssociationsManager) $<span class="number">2</span> = &#123;&#125;</span><br><span class="line">(lldb) p associations</span><br><span class="line">(objc::AssociationsHashMap) $<span class="number">3</span> = &#123;</span><br><span class="line">  Buckets = nil</span><br><span class="line">  NumEntries = <span class="number">0</span></span><br><span class="line">  NumTombstones = <span class="number">0</span></span><br><span class="line">  NumBuckets = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">(lldb) p value</span><br><span class="line">(__NSCFConstantString *) $<span class="number">4</span> = <span class="number">0x0000000100004080</span> <span class="string">"哈哈哈"</span></span><br></pre></td></tr></table></figure>

<h5 id="value不为空流程"><a href="#value不为空流程" class="headerlink" title="value不为空流程"></a><code>value</code>不为空流程</h5><p>上面我们看到<code>value</code>值不为空，我们进入<code>if</code>语句继续调试。</p>
<ul>
<li><code>p refs_result</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p refs_result</span><br><span class="line">(<span class="built_in">std</span>::pair&lt;objc::DenseMapIterator&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt;, objc::DenseMapValueInfo&lt;objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt;, objc::DenseMapInfo&lt;DisguisedPtr&lt;objc_object&gt; &gt;, objc::detail::DenseMapPair&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt;, <span class="literal">false</span>&gt;, <span class="keyword">bool</span>&gt;) $<span class="number">5</span> = &#123;</span><br><span class="line">  first = &#123;</span><br><span class="line">    Ptr = <span class="number">0x00000001012102a0</span></span><br><span class="line">    End = <span class="number">0x0000000101210300</span></span><br><span class="line">  &#125;</span><br><span class="line">  second = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到<code>refs_result</code>的数据结构看起来比较复杂，但是值比较简单，有两个属性<code>first</code>、<code>second</code>。其中<code>first</code>的值为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $<span class="number">5.f</span>irst.Ptr</span><br><span class="line">(objc::DenseMapIterator&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt;, objc::DenseMapValueInfo&lt;objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt;, objc::DenseMapInfo&lt;DisguisedPtr&lt;objc_object&gt; &gt;, objc::detail::DenseMapPair&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt;, <span class="literal">false</span>&gt;::pointer) $<span class="number">6</span> = <span class="number">0x00000001012102a0</span></span><br><span class="line"> (lldb) p $<span class="number">5.f</span>irst.End</span><br><span class="line">(objc::DenseMapIterator&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt;, objc::DenseMapValueInfo&lt;objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt;, objc::DenseMapInfo&lt;DisguisedPtr&lt;objc_object&gt; &gt;, objc::detail::DenseMapPair&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt;, <span class="literal">false</span>&gt;::pointer) $<span class="number">7</span> = <span class="number">0x0000000101210300</span></span><br></pre></td></tr></table></figure>

<p><code>second</code>值为<code>true</code>，所以会执行<code>isFirstAssociation = true</code>。</p>
<ul>
<li><p><code>try_emplace</code>方法，<code>associations</code>调用了<code>try_emplace</code>方法，我们看一下他的源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line">std::pair&lt;iterator, bool&gt; try_emplace(const KeyT &amp;Key, Ts &amp;&amp;... Args) &#123;</span><br><span class="line">  BucketT *TheBucket;</span><br><span class="line">  <span class="comment">///根据key找桶</span></span><br><span class="line">  <span class="keyword">if</span> (LookupBucketFor(Key, TheBucket))</span><br><span class="line">    <span class="comment">///如果桶存在 则返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(</span><br><span class="line">             makeIterator(TheBucket, getBucketsEnd(), <span class="literal">true</span>),</span><br><span class="line">             <span class="literal">false</span>); <span class="comment">// Already in map.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Otherwise, insert the new element.</span></span><br><span class="line">  <span class="comment">///如果不存在则插入桶 并返回</span></span><br><span class="line">  TheBucket = InsertIntoBucket(TheBucket, Key, <span class="built_in">std</span>::forward&lt;Ts&gt;(Args)...);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(</span><br><span class="line">           makeIterator(TheBucket, getBucketsEnd(), <span class="literal">true</span>),</span><br><span class="line">           <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两个返回，都是通过<code>std::make_pair</code>生成相应的键值对。</p>
<ol>
<li>通过<code>LookupBucketFor</code>方法<code>查找桶</code>，如果map中已经<code>存在</code>，则<code>直接返回</code>，其中<code>make_pair</code>的第二个参数<code>bool值为false</code></li>
<li>如果没<code>有找到</code>，则通过<code>InsertIntoBucket</code>插入map，其中<code>make_pair</code>的第二个参数<code>bool值为true</code></li>
</ol>
<p>我们断点进来使用<code>lldb</code>调试</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b57bcdf62c24de9932bddcc72f87cc9~tplv-k3u1fbpfcp-watermark.image" alt="1626787367239"></p>
<p><code>p TheBucket</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p TheBucket</span><br><span class="line">(objc::detail::DenseMapPair&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt; *) $<span class="number">1</span> = <span class="number">0x0000000101c04200</span></span><br><span class="line">(lldb) p *$<span class="number">1</span></span><br><span class="line">(objc::detail::DenseMapPair&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt;) $<span class="number">2</span> = &#123;</span><br><span class="line">  <span class="built_in">std</span>::__1::pair&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt; = &#123;</span><br><span class="line">    first = (value = <span class="number">18446744069384153152</span>)</span><br><span class="line">    second = &#123;</span><br><span class="line">      Buckets = nil</span><br><span class="line">      NumEntries = <span class="number">0</span></span><br><span class="line">      NumTombstones = <span class="number">0</span></span><br><span class="line">      NumBuckets = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到<code>TheBucket</code>的类型与 <code>refs_result</code>中属性的类型是一致的。</p>
</li>
<li><p><code>LookupBucketFor</code>方法</p>
<p>我们进入<code>LookupBucketFor</code>源码发现有两个实现，它们的区别是<code>FoundBucket</code>的参数类型第一个实现多<code>const</code>修饰。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63c705dadb7446558d8876e8bb63a56e~tplv-k3u1fbpfcp-watermark.image" alt="1626786329854"></p>
<p>我们通过断点调试，发现调用的是第2个实现，第2个方法内部调用了第1个实现。我们先看第1个实现源码，注释中有流程说明。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> LookupKeyT&gt;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">LookupBucketFor</span><span class="params">(<span class="keyword">const</span> LookupKeyT &amp;Val,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> BucketT *&amp;FoundBucket)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> BucketT *BucketsPtr = getBuckets();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> NumBuckets = getNumBuckets();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (NumBuckets == <span class="number">0</span>) &#123;</span><br><span class="line">      FoundBucket = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// FoundTombstone - Keep track of whether we find a tombstone while probing.</span></span><br><span class="line">    <span class="keyword">const</span> BucketT *FoundTombstone = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">const</span> KeyT EmptyKey = getEmptyKey();</span><br><span class="line">    <span class="keyword">const</span> KeyT TombstoneKey = getTombstoneKey();</span><br><span class="line">    assert(!KeyInfoT::isEqual(Val, EmptyKey) &amp;&amp;</span><br><span class="line">           !KeyInfoT::isEqual(Val, TombstoneKey) &amp;&amp;</span><br><span class="line">           <span class="string">"Empty/Tombstone value shouldn't be inserted into map!"</span>);</span><br><span class="line">  	<span class="comment">///通过哈希函数得到BucketNo</span></span><br><span class="line">    <span class="keyword">unsigned</span> BucketNo = getHashValue(Val) &amp; (NumBuckets<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> ProbeAmt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;<span class="comment">//与catche_t查找imp类似，通过哈希查找</span></span><br><span class="line">      <span class="keyword">const</span> BucketT *ThisBucket = BucketsPtr + BucketNo;</span><br><span class="line">      <span class="comment">// Found Val's bucket?  If so, return it. 如果找到直接返回 true</span></span><br><span class="line">      <span class="keyword">if</span> (LLVM_LIKELY(KeyInfoT::isEqual(Val, ThisBucket-&gt;getFirst()))) &#123;</span><br><span class="line">        FoundBucket = ThisBucket;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">			</span><br><span class="line">      <span class="comment">// If we found an empty bucket, the key doesn't exist in the set.</span></span><br><span class="line">      <span class="comment">// Insert it and return the default value.</span></span><br><span class="line">      <span class="comment">//如果是一个空桶 说明key不在集合中，将key插入 返回false</span></span><br><span class="line">      <span class="keyword">if</span> (LLVM_LIKELY(KeyInfoT::isEqual(ThisBucket-&gt;getFirst(), EmptyKey))) &#123;</span><br><span class="line">        <span class="comment">// If we've already seen a tombstone while probing, fill it in instead</span></span><br><span class="line">        <span class="comment">// of the empty bucket we eventually probed to.</span></span><br><span class="line">        FoundBucket = FoundTombstone ? FoundTombstone : ThisBucket;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If this is a tombstone, remember it.  If Val ends up not in the map, we</span></span><br><span class="line">      <span class="comment">// prefer to return it than something that would require more probing.</span></span><br><span class="line">      <span class="comment">// Ditto for zero values.</span></span><br><span class="line">      <span class="comment">// 以上条件都不满足 BucketNo调整进行平移、再哈希继续查找</span></span><br><span class="line">      <span class="keyword">if</span> (KeyInfoT::isEqual(ThisBucket-&gt;getFirst(), TombstoneKey) &amp;&amp;</span><br><span class="line">          !FoundTombstone)</span><br><span class="line">        FoundTombstone = ThisBucket;  <span class="comment">// Remember the first tombstone found.</span></span><br><span class="line">      <span class="keyword">if</span> (ValueInfoT::isPurgeable(ThisBucket-&gt;getSecond())  &amp;&amp;  !FoundTombstone)</span><br><span class="line">        FoundTombstone = ThisBucket;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Otherwise, it's a hash collision or a tombstone, continue quadratic</span></span><br><span class="line">      <span class="comment">// probing.</span></span><br><span class="line">      <span class="keyword">if</span> (ProbeAmt &gt; NumBuckets) &#123;</span><br><span class="line">        FatalCorruptHashTables(BucketsPtr, NumBuckets);</span><br><span class="line">      &#125;</span><br><span class="line">      BucketNo += ProbeAmt++;</span><br><span class="line">      BucketNo &amp;= (NumBuckets<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>第2个<code>LookupBucketFor</code>的实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LookupBucketFor</span><span class="params">(<span class="keyword">const</span> LookupKeyT &amp;Val, BucketT *&amp;FoundBucket)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> BucketT *ConstFoundBucket;<span class="comment">//空的桶</span></span><br><span class="line">  <span class="keyword">bool</span> Result = <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> DenseMapBase *&gt;(<span class="keyword">this</span>)</span><br><span class="line">    -&gt;LookupBucketFor(Val, ConstFoundBucket);<span class="comment">//调用第一个LookupBucketFor方法查找</span></span><br><span class="line">  FoundBucket = <span class="keyword">const_cast</span>&lt;BucketT *&gt;(ConstFoundBucket);<span class="comment">//如果找到复制给第二个参数，因为第二个参数是引用类型会直接让调用的地方获取到值。也就是try_emplace方法的TheBucket</span></span><br><span class="line">  <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>继续走<code>value</code>为<code>true</code>的流程</p>
<p>后面还会执行<code>try_emplace</code>方法，我们在执行之前查看一下<code>refs</code>的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p refs</span><br><span class="line">(objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt;) $<span class="number">3</span> = &#123;</span><br><span class="line">  Buckets = nil</span><br><span class="line">  NumEntries = <span class="number">0</span></span><br><span class="line">  NumTombstones = <span class="number">0</span></span><br><span class="line">  NumBuckets = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>try_emplace</code>方法之后<code>refs</code>的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p refs</span><br><span class="line">(objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt;) $<span class="number">4</span> = &#123;</span><br><span class="line">  Buckets = <span class="number">0x0000000100711390</span></span><br><span class="line">  NumEntries = <span class="number">1</span></span><br><span class="line">  NumTombstones = <span class="number">0</span></span><br><span class="line">  NumBuckets = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次执行<code>try_emplace</code>插入的是一个空桶，还没有值，第二次执行第一次执行<code>try_emplace</code>才插入值，即往空桶中插入<code>ObjectAssociationMap（value，policy）</code>，返回true。</p>
<p>此时<code>result.second</code>为<code>true</code>，此时属性的<code>value</code>就关联上了。</p>
</li>
</ul>
<h5 id="关联对象结构"><a href="#关联对象结构" class="headerlink" title="关联对象结构"></a>关联对象结构</h5><p>关联对象的设置图如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/518c45cdebd6464199f8f249c2f0a134~tplv-k3u1fbpfcp-watermark.image" alt="关联对象"></p>
<p>属性设计的哈希表结构如下：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0aee709a499d45c8a1aa14d9be1f626b~tplv-k3u1fbpfcp-watermark.image" alt="关联对象哈希表"></p>
<p>map中有很多的关联对象map，类型是<code>ObjectAssociationMap</code>，其中key为<code>DisguisedPtr&lt;objc_object&gt;</code>，例如<code>JSPerson</code>会对应一个<code>ObjectAssociationMap</code>，<code>JSTeacher</code>也会对应一个<code>ObjectAssociationMap</code>。</p>
<p><code>ObjectAssociationMap</code>哈希表中有很多<code>key-value</code>键值对，其中<code>key</code>的类型为<code>const void *</code>，其实这个<code>key</code>从底层这个方法<code>_object_set_associative_reference(id object, const void *key, id value, uintptr_t policy)</code>的参数就可以看出，<code>key</code>是我们关联属性时<code>设置的字符串</code>，<code>value</code>的类型为<code>ObjcAssociation</code></p>
<h5 id="value为空流程"><a href="#value为空流程" class="headerlink" title="value为空流程"></a><code>value</code>为空流程</h5><p>这个过程其实就是<code>else</code>流程，也就是我们对<code>value</code>设置为<code>nil</code>的流程，主要就是移除关联。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">auto</span> refs_it = associations.<span class="built_in">find</span>(disguised);</span><br><span class="line">     <span class="keyword">if</span> (refs_it != associations.<span class="built_in">end</span>()) &#123;</span><br><span class="line">         <span class="keyword">auto</span> &amp;refs = refs_it-&gt;second;</span><br><span class="line">         <span class="keyword">auto</span> it = refs.<span class="built_in">find</span>(key);</span><br><span class="line">         <span class="keyword">if</span> (it != refs.<span class="built_in">end</span>()) &#123;</span><br><span class="line">             association.swap(it-&gt;second);</span><br><span class="line">             refs.erase(it);</span><br><span class="line">             <span class="keyword">if</span> (refs.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                 associations.erase(refs_it);</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>根据 DisguisedPtr 找到 AssociationsHashMap 中的 iterator 迭代查询器</li>
<li>清理迭代器</li>
<li>实际上如果插入空置 相当于清除</li>
</ul>
<h4 id="objc-getAssociatedObject流程"><a href="#objc-getAssociatedObject流程" class="headerlink" title="objc_getAssociatedObject流程"></a>objc_getAssociatedObject流程</h4><h5 id="在main方法中添加一个取值的语句"><a href="#在main方法中添加一个取值的语句" class="headerlink" title="在main方法中添加一个取值的语句"></a>在<code>main</code>方法中添加一个取值的语句</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        JSPerson *person &#x3D; [[JSPerson alloc] init];</span><br><span class="line">        person.category_name &#x3D; @&quot;哈哈哈&quot;;</span><br><span class="line">        NSString *name &#x3D; person.category_name;</span><br><span class="line">        NSLog(@&quot;done&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="objc-getAssociatedObject源码实现"><a href="#objc-getAssociatedObject源码实现" class="headerlink" title="objc_getAssociatedObject源码实现"></a><code>objc_getAssociatedObject</code>源码实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">objc_getAssociatedObject(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _object_get_associative_reference(object, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>_object_get_associative_reference</code>函数。</p>
<h5 id="object-get-associative-reference源码"><a href="#object-get-associative-reference源码" class="headerlink" title="_object_get_associative_reference源码"></a><code>_object_get_associative_reference</code>源码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">_object_get_associative_reference(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    ObjcAssociation association&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      	<span class="comment">///创建AssociationsManager管理类</span></span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">      	<span class="comment">///获取静态哈希表</span></span><br><span class="line">        <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.<span class="built_in">get</span>())</span></span>;</span><br><span class="line">      	<span class="comment">/////找到迭代器，即获取buckets</span></span><br><span class="line">        AssociationsHashMap::iterator i = associations.<span class="built_in">find</span>((objc_object *)object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.<span class="built_in">end</span>()) &#123;<span class="comment">//如果这个迭代查询器不是最后一个 继续获取</span></span><br><span class="line">            <span class="comment">//找到ObjectAssociationMap的迭代查询器获取一个经过属性修饰符修饰的value</span></span><br><span class="line">            ObjectAssociationMap &amp;refs = i-&gt;second;</span><br><span class="line">          	<span class="comment">//根据key查找ObjectAssociationMap，即获取bucket</span></span><br><span class="line">            ObjectAssociationMap::iterator j = refs.<span class="built_in">find</span>(key);</span><br><span class="line">            <span class="keyword">if</span> (j != refs.<span class="built_in">end</span>()) &#123;</span><br><span class="line">              	<span class="comment">//获取ObjcAssociation</span></span><br><span class="line">                association = j-&gt;second;</span><br><span class="line">                association.retainReturnedValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">///返回值</span></span><br><span class="line">    <span class="keyword">return</span> association.autoreleaseReturnedValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看源码分析主要分为以下几步</p>
<ul>
<li>创建一个 <code>AssociationsManager</code> 管理类</li>
<li>获取静态哈希表：<code>AssociationsHashMap</code></li>
<li>通过<code>find</code>方法根据 <code>DisguisedPtr</code> 找到 <code>AssociationsHashMap</code> 中的 <code>iterator</code> 迭代查询器</li>
<li>如果这个迭代查询器不是最后一个 继续获取 : <code>ObjectAssociationMap (policy和value)</code></li>
<li>通过<code>find</code>方法找到<code>ObjectAssociationMap</code>的迭代查询器获取一个经过属性修饰符修饰的<code>value</code></li>
<li>返回 <code>value</code></li>
</ul>
<h5 id="查找方法find"><a href="#查找方法find" class="headerlink" title="查找方法find"></a>查找方法<code>find</code></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(<span class="keyword">const_arg_type_t</span>&lt;KeyT&gt; Val)</span> </span>&#123;</span><br><span class="line">  BucketT *TheBucket;</span><br><span class="line">  <span class="keyword">if</span> (LookupBucketFor(Val, TheBucket))</span><br><span class="line">    <span class="keyword">return</span> makeIterator(TheBucket, getBucketsEnd(), <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据关联对象迭代查找<code>AssociationsHashMap</code>，也就是<code>buckets</code></p>
<h5 id="通过源码看取值流程"><a href="#通过源码看取值流程" class="headerlink" title="通过源码看取值流程"></a>通过源码看取值流程</h5><p>我们直接断点到<code>_object_get_associative_reference</code>函数</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd50af8bbb204b1b92447fa2a245d626~tplv-k3u1fbpfcp-watermark.image" alt="1626789232319"></p>
<p>执行<code>p i</code>和<code>p i-&gt;second</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p i</span><br><span class="line">(objc::DenseMapBase&lt;objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt;, objc::DenseMapValueInfo&lt;objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt;, objc::DenseMapInfo&lt;DisguisedPtr&lt;objc_object&gt; &gt;, objc::detail::DenseMapPair&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt; &gt;, DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt;, objc::DenseMapValueInfo&lt;objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt;, objc::DenseMapInfo&lt;DisguisedPtr&lt;objc_object&gt; &gt;, objc::detail::DenseMapPair&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt; &gt;::iterator) $<span class="number">0</span> = &#123;</span><br><span class="line">  Ptr = <span class="number">0x0000000100631d60</span></span><br><span class="line">  End = <span class="number">0x0000000100631d80</span></span><br><span class="line">&#125;</span><br><span class="line">(lldb) p i-&gt;second</span><br><span class="line">(objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt;) $<span class="number">1</span> = &#123;</span><br><span class="line">  Buckets = <span class="number">0x0000000100631d80</span></span><br><span class="line">  NumEntries = <span class="number">1</span></span><br><span class="line">  NumTombstones = <span class="number">0</span></span><br><span class="line">  NumBuckets = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次执行<code>find</code>方法，在调用<code>find</code>方法之前，我们先打印<code>j</code>,此时<code>value</code>为<code>nil</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p j</span><br><span class="line">(objc::DenseMapBase&lt;objc::DenseMap&lt;const void *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;const void *&gt;, objc::detail::DenseMapPair&lt;const void *, objc::ObjcAssociation&gt; &gt;, const void *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;const void *&gt;, objc::detail::DenseMapPair&lt;const void *, objc::ObjcAssociation&gt; &gt;::iterator) $2 &#x3D; &#123;</span><br><span class="line">  Ptr &#x3D; 0x00007ffeefbff400</span><br><span class="line">  End &#x3D; 0x00000001002e70db</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p j-&gt;second</span><br><span class="line">(objc::ObjcAssociation) $3 &#x3D; &#123;</span><br><span class="line">  _policy &#x3D; 4294980472</span><br><span class="line">  _value &#x3D; nil</span><br><span class="line">&#125;</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>执行<code>find</code>方法之后再次打印,发现<code>value</code>已经有值，也就是取到了关联对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p j</span><br><span class="line">(objc::DenseMapBase&lt;objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt;, <span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt;::iterator) $<span class="number">4</span> = &#123;</span><br><span class="line">  Ptr = <span class="number">0x0000000100631d80</span></span><br><span class="line">  End = <span class="number">0x0000000100631de0</span></span><br><span class="line">&#125;</span><br><span class="line">(lldb) p j-&gt;second</span><br><span class="line">(objc::ObjcAssociation) $<span class="number">5</span> = &#123;</span><br><span class="line">  _policy = <span class="number">3</span></span><br><span class="line">  _value = <span class="number">0x0000000100004080</span> <span class="string">"哈哈哈"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇主要探索了<code>扩展</code>和<code>关联对象</code>，其中<code>类的扩展</code> 在<code>编译期</code> 会作为类的一部分，和类一起编译进来。</p>
<p>关联对象设置流程为：</p>
<ul>
<li>创建一个<code>AssociationsManager</code>管理类</li>
<li>获取<code>静态哈希表</code>:<code>associations</code></li>
<li>判断<code>关联值value</code>是否为空<ul>
<li>如果为空就走：<code>插入空值</code>流程。</li>
<li>如果不为空继续下一步</li>
</ul>
</li>
<li>通过<code>try_emplace</code>方法，创建一个空的 <code>ObjectAssociationMap</code> 去取查询的键值对</li>
<li>如果发现<code>没有</code> <code>key</code> 就<code>插入一个 空的 BucketT</code>进去并返回true</li>
<li>通过<code>setHasAssociatedObjects</code>方法<code>标记对象存在关联对象</code></li>
<li>用当前 <code>policy 和 value</code> 组成了一个 <code>ObjcAssociation</code> 替换原来 <code>BucketT</code>中的值</li>
<li>标记一下 <code>ObjectAssociationMap</code> 的<code>第一次</code>为 <code>false</code></li>
</ul>
<p>关联对象取值的流程为：</p>
<ul>
<li>创建一个 <code>AssociationsManager</code> 管理类</li>
<li>获取静态哈希表：<code>AssociationsHashMap</code></li>
<li>通过<code>find</code>方法根据 <code>DisguisedPtr</code> 找到 <code>AssociationsHashMap</code> 中的 <code>iterator</code> 迭代查询器</li>
<li>如果这个迭代查询器不是最后一个 继续获取 : <code>ObjectAssociationMap (policy和value)</code></li>
<li>通过<code>find</code>方法找到<code>ObjectAssociationMap</code>的迭代查询器获取一个经过属性修饰符修饰的<code>value</code></li>
<li>返回 <code>value</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/07/18/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD-%E4%B8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/18/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD-%E4%B8%8B/" class="post-title-link" itemprop="url">iOS底层探索-类的加载(下)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-18 14:03:41 / 修改时间：20:37:27" itemprop="dateCreated datePublished" datetime="2021-07-18T14:03:41+08:00">2021-07-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文我们研究分类的加载流程。</p>
<h3 id="分类的本质"><a href="#分类的本质" class="headerlink" title="分类的本质"></a>分类的本质</h3><p>在研究<code>对象</code>、<code>类</code>的本质的时候，我们都用<code>clang</code>命令将<code>main.m</code>转换成<code>main.cpp</code>文件查看其本质，<code>分类</code>也不例外，我们使用相同的方法分析。</p>
<p>首先我们定义一个<code>JSPerson</code>的分类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface JSPerson (TestLoad)</span><br><span class="line"></span><br><span class="line">- (void)sayCategory;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation JSPerson (TestLoad)</span><br><span class="line"></span><br><span class="line">- (void)sayCategory&#123;</span><br><span class="line">    NSLog(@&quot;JSPersonCategpry say : %s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    NSLog(@&quot;JSPersonCategpry load&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>然后在<code>main.m</code>文件中使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        JSPerson *p &#x3D; [JSPerson alloc];</span><br><span class="line">        [p sayCategory];</span><br><span class="line">        NSLog(@&quot;Hello, World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们执行：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m -o main.cpp</span><br></pre></td></tr></table></figure>

<p>我们打开<code>main.cpp</code>文件，找到分类相关的代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> *<span class="title">L_OBJC_LABEL_CATEGORY_</span>$ [1] __<span class="title">attribute__</span>((<span class="title">used</span>, <span class="title">section</span> ("__<span class="title">DATA</span>, __<span class="title">objc_catlist</span>,<span class="title">regular</span>,<span class="title">no_dead_strip</span>")))= &#123;</span></span><br><span class="line">	&amp;_OBJC_$_CATEGORY_JSPerson_$_TestLoad,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">class_t</span> *<span class="title">cls</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">method_list_t</span> *<span class="title">instance_methods</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">method_list_t</span> *<span class="title">class_methods</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">prop_list_t</span> *<span class="title">properties</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们从源码里也能搜索到它的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">classref_t</span> cls;</span><br><span class="line">    WrappedPtr&lt;<span class="keyword">method_list_t</span>, PtrauthStrip&gt; instanceMethods;</span><br><span class="line">    WrappedPtr&lt;<span class="keyword">method_list_t</span>, PtrauthStrip&gt; classMethods;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span></span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *_<span class="title">classProperties</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">method_list_t</span> *<span class="title">methodsForMeta</span><span class="params">(<span class="keyword">bool</span> isMeta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">property_list_t</span> *<span class="title">propertiesForMeta</span><span class="params">(<span class="keyword">bool</span> isMeta, struct header_info *hi)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protocol_list_t</span> *<span class="title">protocolsForMeta</span><span class="params">(<span class="keyword">bool</span> isMeta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> protocols;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>分类</code>的本质是<code>结构体</code>：<code>category_t</code>。</p>
<p>我们继续回到<code>_read_images</code>函数探索。</p>
<h3 id="rwe的赋值"><a href="#rwe的赋值" class="headerlink" title="rwe的赋值"></a>rwe的赋值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> rwe = cls-&gt;data()-&gt;extAllocIfNeeded();</span><br></pre></td></tr></table></figure>

<p><code>extAllocIfNeeded</code>方法的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class_rw_ext_t</span> *<span class="title">extAllocIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> v = get_ro_or_rwe();</span><br><span class="line">    <span class="keyword">if</span> (fastpath(v.is&lt;<span class="keyword">class_rw_ext_t</span> *&gt;())) &#123;</span><br><span class="line">          <span class="keyword">return</span> v.<span class="built_in">get</span>&lt;<span class="keyword">class_rw_ext_t</span> *&gt;(&amp;ro_or_rw_ext);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> extAlloc(v.<span class="built_in">get</span>&lt;<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *&gt;(&amp;ro_or_rw_ext));</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class_rw_ext_t</span> *</span><br><span class="line"><span class="keyword">class_rw_t</span>::extAlloc(<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro, <span class="keyword">bool</span> deepCopy)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> rwe = objc::zalloc&lt;<span class="keyword">class_rw_ext_t</span>&gt;();</span><br><span class="line"></span><br><span class="line">    rwe-&gt;version = (ro-&gt;flags &amp; RO_META) ? <span class="number">7</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">method_list_t</span> *<span class="built_in">list</span> = ro-&gt;baseMethods();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deepCopy) <span class="built_in">list</span> = <span class="built_in">list</span>-&gt;duplicate();</span><br><span class="line">        rwe-&gt;methods.attachLists(&amp;<span class="built_in">list</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See comments in objc_duplicateClass</span></span><br><span class="line">    <span class="comment">// property lists and protocol lists historically</span></span><br><span class="line">    <span class="comment">// have not been deep-copied</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This is probably wrong and ought to be fixed some day</span></span><br><span class="line">    <span class="keyword">property_list_t</span> *proplist = ro-&gt;baseProperties;</span><br><span class="line">    <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">        rwe-&gt;properties.attachLists(&amp;proplist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protocol_list_t</span> *protolist = ro-&gt;baseProtocols;</span><br><span class="line">    <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">        rwe-&gt;protocols.attachLists(&amp;protolist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set_ro_or_rwe(rwe, ro);</span><br><span class="line">    <span class="keyword">return</span> rwe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>auto rwe = cls-&gt;data()-&gt;extAllocIfNeeded();</code>是进行rwe的创建,那么为什么要在这里进行<code>rwe的初始化</code>？？因为我们现在要做一件事：往<code>本类</code>中<code>添加属性、方法、协议</code>等,即对原来的 clean memory要进行处理了</p>
<ul>
<li>进入<code>extAllocIfNeeded</code>方法的源码实现，判断rwe是否存在，如果存在则直接获取，如果不存在则开辟</li>
<li>进入<code>extAlloc</code>源码实现，即对rwe 0-1的过程，在此过程中，就将<code>本类的data数据</code>加载进去了</li>
<li>其中关键代码是<code>rwe-&gt;methods.attachLists(mlists + ATTACH_BUFSIZ - mcount, mcount);</code>即存入mlists的末尾，<code>mlists</code>的数据来源前面的<code>for循环</code></li>
<li>在调试运行时，发现<code>category_t</code>中的<code>name</code>编译时是<code>JSPerson</code>（参考clang编译时的那么），运行时是<code>TestLoad</code>即分类的名字</li>
<li>代码<code>mlists[ATTACH_BUFSIZ - ++mcount] = mlist;</code>，经过调试发现此时的<code>mcount</code>等于<code>1</code>，即可以理解为 <code>倒序插入</code>,<code>64</code>的原因是允许容纳64个（最多64个分类）</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>本类 中 需要添加属性、方法等，所以需要<code>初始化rwe</code>,rwe的初始化主要涉及：<code>分类、addMethod、addProperty、addprotocol</code> ， 即<code>对原始类进行修改或者处理时(运行时)，才会进行rwe的初始化</code></p>
<h3 id="attachCategories"><a href="#attachCategories" class="headerlink" title="attachCategories"></a>attachCategories</h3><p>通过<code>attachCategories</code>反推<code>分类的加载</code>，我们<code>libobjc</code>源码全局搜索<code>attachCategories</code>的调用，发现有两个地方调用：<code>attachToClass</code>和<code>load_categories_nolock</code>。</p>
<p>####attachToClass</p>
<p>调用<code>attachToClass</code>的方法只有一个<code>methodizeClass</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodizeClass</span><span class="params">(Class cls, Class previously)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">///省略代码</span></span><br><span class="line">    <span class="keyword">if</span> (previously) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) &#123;</span><br><span class="line">            objc::unattachedCategories.attachToClass(cls, previously,</span><br><span class="line">                                                     ATTACH_METACLASS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// When a class relocates, categories with class methods</span></span><br><span class="line">            <span class="comment">// may be registered on the class itself rather than on</span></span><br><span class="line">            <span class="comment">// the metaclass. Tell attachToClass to look for those.</span></span><br><span class="line">            objc::unattachedCategories.attachToClass(cls, previously,</span><br><span class="line">                                                     ATTACH_CLASS_AND_METACLASS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    objc::unattachedCategories.attachToClass(cls, cls,</span><br><span class="line">                                             isMeta ? ATTACH_METACLASS : ATTACH_CLASS);</span><br><span class="line">		<span class="comment">///省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个<code>previously</code>执行条件，我们依次网上查找调用链，发现<code>previously==nil</code>,<code>previously</code>参数只是方便动态化调试，所以实际调用的只有下面这一处代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc::unattachedCategories.attachToClass(cls, cls,</span><br><span class="line">                                             isMeta ? ATTACH_METACLASS : ATTACH_CLASS);</span><br></pre></td></tr></table></figure>

<h4 id="load-categories-nolock"><a href="#load-categories-nolock" class="headerlink" title="load_categories_nolock"></a>load_categories_nolock</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load_categories_nolock</span><span class="params">(header_info *hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    <span class="keyword">auto</span> processCatlist = [&amp;](<span class="keyword">category_t</span> * <span class="keyword">const</span> *catlist) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">category_t</span> *cat = catlist[i];</span><br><span class="line">            Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">            <span class="keyword">locstamped_category_t</span> lc&#123;cat, hi&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">                <span class="comment">// Category's target class is missing (probably weak-linked).</span></span><br><span class="line">                <span class="comment">// Ignore the category.</span></span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"CLASS: IGNORING category \?\?\?(%s) %p with "</span></span><br><span class="line">                                 <span class="string">"missing weak-linked target class"</span>,</span><br><span class="line">                                 cat-&gt;name, cat);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process this category.</span></span><br><span class="line">            <span class="keyword">if</span> (cls-&gt;isStubClass()) &#123;</span><br><span class="line">                <span class="comment">// Stub classes are never realized. Stub classes</span></span><br><span class="line">                <span class="comment">// don't know their metaclass until they're</span></span><br><span class="line">                <span class="comment">// initialized, so we have to add categories with</span></span><br><span class="line">                <span class="comment">// class methods or properties to the stub itself.</span></span><br><span class="line">                <span class="comment">// methodizeClass() will find them and add them to</span></span><br><span class="line">                <span class="comment">// the metaclass as appropriate.</span></span><br><span class="line">                <span class="keyword">if</span> (cat-&gt;instanceMethods ||</span><br><span class="line">                    cat-&gt;protocols ||</span><br><span class="line">                    cat-&gt;instanceProperties ||</span><br><span class="line">                    cat-&gt;classMethods ||</span><br><span class="line">                    cat-&gt;protocols ||</span><br><span class="line">                    (hasClassProperties &amp;&amp; cat-&gt;_classProperties))</span><br><span class="line">                &#123;</span><br><span class="line">                    objc::unattachedCategories.addForClass(lc, cls);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// First, register the category with its target class.</span></span><br><span class="line">                <span class="comment">// Then, rebuild the class's method lists (etc) if</span></span><br><span class="line">                <span class="comment">// the class is realized.</span></span><br><span class="line">                <span class="keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols</span><br><span class="line">                    ||  cat-&gt;instanceProperties)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cls-&gt;isRealized()) &#123;</span><br><span class="line">                        attachCategories(cls, &amp;lc, <span class="number">1</span>, ATTACH_EXISTING);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        objc::unattachedCategories.addForClass(lc, cls);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols</span><br><span class="line">                    ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">                        attachCategories(cls-&gt;ISA(), &amp;lc, <span class="number">1</span>, ATTACH_EXISTING | ATTACH_METACLASS);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        objc::unattachedCategories.addForClass(lc, cls-&gt;ISA());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    processCatlist(hi-&gt;catlist(&amp;count));</span><br><span class="line">    processCatlist(hi-&gt;catlist2(&amp;count));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局搜素<code>load_categories_nolock</code>,发现调用<code>load_categories_nolock</code>的地方有两处</p>
<ul>
<li><code>loadAllCategories</code></li>
<li><code>_read_images</code></li>
</ul>
<p>但是经过调试发现，是不会走<code>_read_images</code>方法中的if流程的，而是走的<code>loadAllCategories</code>方法中的。</p>
<h4 id="attachLists"><a href="#attachLists" class="headerlink" title="attachLists"></a>attachLists</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachLists</span><span class="params">(List* <span class="keyword">const</span> * addedLists, <span class="keyword">uint32_t</span> addedCount)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">         <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">         <span class="keyword">uint32_t</span> oldCount = <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">         <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">         <span class="keyword">array_t</span> *newArray = (<span class="keyword">array_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">array_t</span>::byteSize(newCount));</span><br><span class="line">         newArray-&gt;count = newCount;</span><br><span class="line">         <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                newArray-&gt;lists[i + addedCount] = <span class="built_in">array</span>()-&gt;lists[i];</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; addedCount; i++)</span><br><span class="line">             newArray-&gt;lists[i] = addedLists[i];</span><br><span class="line">         <span class="built_in">free</span>(<span class="built_in">array</span>());</span><br><span class="line">         setArray(newArray);</span><br><span class="line">         validate();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">list</span>  &amp;&amp;  addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">         <span class="comment">// 0 lists -&gt; 1 list</span></span><br><span class="line">         <span class="built_in">list</span> = addedLists[<span class="number">0</span>];</span><br><span class="line">         validate();</span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 1 list -&gt; many lists</span></span><br><span class="line">         Ptr&lt;List&gt; oldList = <span class="built_in">list</span>;</span><br><span class="line">         <span class="keyword">uint32_t</span> oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">         setArray((<span class="keyword">array_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">         <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">         <span class="keyword">if</span> (oldList) <span class="built_in">array</span>()-&gt;lists[addedCount] = oldList;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; addedCount; i++)</span><br><span class="line">             <span class="built_in">array</span>()-&gt;lists[i] = addedLists[i];</span><br><span class="line">         validate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个函数一共三部分我们分别看：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">list</span>  &amp;&amp;  addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 0 lists -&gt; 1 list</span></span><br><span class="line">      <span class="built_in">list</span> = addedLists[<span class="number">0</span>];</span><br><span class="line">       validate();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>把<code>addedLists[0]</code>赋值给<code>list</code>,<code>list</code>是一维数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 1 list -&gt; many lists</span></span><br><span class="line">      Ptr&lt;List&gt; oldList = <span class="built_in">list</span>;</span><br><span class="line">      <span class="keyword">uint32_t</span> oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">      setArray((<span class="keyword">array_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">      <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">      <span class="keyword">if</span> (oldList) <span class="built_in">array</span>()-&gt;lists[addedCount] = oldList;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; addedCount; i++)</span><br><span class="line">          <span class="built_in">array</span>()-&gt;lists[i] = addedLists[i];</span><br><span class="line">      validate();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这个情况是<code>list</code>不为空，新建一个扩容的数组，将之前的数据放在<code>lists[addedCount]</code>位置，新元素放到之前<code>list</code>的前面。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">    <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">    <span class="keyword">uint32_t</span> oldCount = <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">    <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">    <span class="keyword">array_t</span> *newArray = (<span class="keyword">array_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">array_t</span>::byteSize(newCount));</span><br><span class="line">    newArray-&gt;count = newCount;</span><br><span class="line">    <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">           newArray-&gt;lists[i + addedCount] = <span class="built_in">array</span>()-&gt;lists[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; addedCount; i++)</span><br><span class="line">        newArray-&gt;lists[i] = addedLists[i];</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">array</span>());</span><br><span class="line">    setArray(newArray);</span><br><span class="line">    validate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段其实和上次类似，依然将新数组插入到前面，新数组中的新元素在数组首部。</p>
<h3 id="分类加载的四种情况"><a href="#分类加载的四种情况" class="headerlink" title="分类加载的四种情况"></a>分类加载的四种情况</h3><p>根据<code>类</code>和<code>分类</code>是否实现<code>+load()</code>方法分为四种情况。</p>
<p>我们先定义<code>JSPerson</code>及它的<code>分类</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@interface JSPerson : NSObject</span><br><span class="line"></span><br><span class="line">- (void)sayHello;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">#import &quot;JSPerson.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation JSPerson</span><br><span class="line"></span><br><span class="line">- (void)sayHello&#123;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;JSPerson say : Hello!!!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)load&#123;&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@interface JSPerson (Test)</span><br><span class="line"></span><br><span class="line">- (void)saySomething;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">#import &quot;JSPerson+Test.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation JSPerson (Test)</span><br><span class="line"></span><br><span class="line">- (void)saySomething&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)load&#123;&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>



<h4 id="非懒加载分类和非懒加载类"><a href="#非懒加载分类和非懒加载类" class="headerlink" title="非懒加载分类和非懒加载类"></a>非懒加载分类和非懒加载类</h4><p>我们在<code>JSPerson</code>类和分类中都实现<code>load</code>，我们在<code>realizeClassWithoutSwift</code>添加断点</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbe0d82210524777a295602d1a33f6f7~tplv-k3u1fbpfcp-watermark.image" alt="类和分类都是非懒加载分类加载"></p>
<p>我们用<code>lldb</code>打印当前<code>ro</code>的方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">readClass JSPerson....</span><br><span class="line">_read_images JSPerson....</span><br><span class="line">(lldb) p ro</span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *) $<span class="number">0</span> = <span class="number">0x0000000100004280</span></span><br><span class="line">(lldb) p *$<span class="number">0</span></span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">class_ro_t</span>) $<span class="number">1</span> = &#123;</span><br><span class="line">  flags = <span class="number">0</span></span><br><span class="line">  instanceStart = <span class="number">8</span></span><br><span class="line">  instanceSize = <span class="number">8</span></span><br><span class="line">  reserved = <span class="number">0</span></span><br><span class="line">   = &#123;</span><br><span class="line">    ivarLayout = <span class="number">0x0000000000000000</span></span><br><span class="line">    nonMetaclass = nil</span><br><span class="line">  &#125;</span><br><span class="line">  name = &#123;</span><br><span class="line">    <span class="built_in">std</span>::__1::atomic&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; = <span class="string">"JSPerson"</span> &#123;</span><br><span class="line">      Value = <span class="number">0x0000000100003bbc</span> <span class="string">"JSPerson"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  baseMethodList = <span class="number">0x00000001000042c8</span></span><br><span class="line">  baseProtocols = <span class="number">0x0000000000000000</span></span><br><span class="line">  ivars = <span class="number">0x0000000000000000</span></span><br><span class="line">  weakIvarLayout = <span class="number">0x0000000000000000</span></span><br><span class="line">  baseProperties = <span class="number">0x0000000000000000</span></span><br><span class="line">  _swiftMetadataInitializer_NEVER_USE = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">1.b</span>aseMethods()</span><br><span class="line">(<span class="keyword">method_list_t</span> *) $<span class="number">2</span> = <span class="number">0x00000001000042c8</span></span><br><span class="line">(lldb) p *$<span class="number">2</span></span><br><span class="line">(<span class="keyword">method_list_t</span>) $<span class="number">3</span> = &#123;</span><br><span class="line">  entsize_list_tt&lt;<span class="keyword">method_t</span>, <span class="keyword">method_list_t</span>, <span class="number">4294901763</span>, <span class="keyword">method_t</span>::pointer_modifier&gt; = (entsizeAndFlags = <span class="number">24</span>, count = <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">3.</span><span class="built_in">get</span>(<span class="number">0</span>).big()</span><br><span class="line">(<span class="keyword">method_t</span>::big) $<span class="number">4</span> = &#123;</span><br><span class="line">  name = <span class="string">"sayHello"</span></span><br><span class="line">  types = <span class="number">0x0000000100003cfd</span> <span class="string">"v16@0:8"</span></span><br><span class="line">  imp = <span class="number">0x00000001000036b0</span> (KCObjcBuild`-[JSPerson sayHello])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现此时只有<code>类</code>的方法，并没有<code>分类</code>的方法，说明<code>分类</code>目前还没有加载。</p>
<p>我们在<code>attachCategories</code>添加断点，继续执行代码：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1dd3596aa214f329bc1ad2d90806c03~tplv-k3u1fbpfcp-watermark.image" alt="非懒加载分类"></p>
<p>继续用<code>lldb</code>调试程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p mlist</span><br><span class="line">(<span class="keyword">method_list_t</span> *) $<span class="number">5</span> = <span class="number">0x0000000100004420</span></span><br><span class="line">(lldb) p *$<span class="number">5</span></span><br><span class="line">(<span class="keyword">method_list_t</span>) $<span class="number">6</span> = &#123;</span><br><span class="line">  entsize_list_tt&lt;<span class="keyword">method_t</span>, <span class="keyword">method_list_t</span>, <span class="number">4294901763</span>, <span class="keyword">method_t</span>::pointer_modifier&gt; = (entsizeAndFlags = <span class="number">24</span>, count = <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">6.</span><span class="built_in">get</span>(<span class="number">0</span>).big()</span><br><span class="line">(<span class="keyword">method_t</span>::big) $<span class="number">7</span> = &#123;</span><br><span class="line">  name = <span class="string">"saySomething"</span></span><br><span class="line">  types = <span class="number">0x0000000100003cfd</span> <span class="string">"v16@0:8"</span></span><br><span class="line">  imp = <span class="number">0x00000001000037f0</span> (KCObjcBuild`-[JSPerson(Test) saySomething])</span><br><span class="line">&#125;</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>说明现在分类被加载了，被加载到了<code>rwe</code>中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rwe-&gt;methods.attachLists(mlists + ATTACH_BUFSIZ - mcount, mcount);</span><br></pre></td></tr></table></figure>

<p>注意：<code>ATTACH_BUFSIZ=64</code>也就是说<code>分类</code>的方法个数不能大于64。</p>
<h4 id="非懒加载分类和懒加载类"><a href="#非懒加载分类和懒加载类" class="headerlink" title="非懒加载分类和懒加载类"></a>非懒加载分类和懒加载类</h4><p>我们删除<code>JSPerson</code>类的<code>load</code>方法，重新运行程序。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbe0d82210524777a295602d1a33f6f7~tplv-k3u1fbpfcp-watermark.image" alt="类和分类都是非懒加载分类加载"></p>
<p>继续在我们第一个断点位置使用<code>lldb</code>调试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">_read_images JSPerson....</span><br><span class="line">(lldb) p ro</span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *) $<span class="number">0</span> = <span class="number">0x00000001000042a8</span></span><br><span class="line">(lldb) p *$<span class="number">0</span></span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">class_ro_t</span>) $<span class="number">1</span> = &#123;</span><br><span class="line">  flags = <span class="number">0</span></span><br><span class="line">  instanceStart = <span class="number">8</span></span><br><span class="line">  instanceSize = <span class="number">8</span></span><br><span class="line">  reserved = <span class="number">0</span></span><br><span class="line">   = &#123;</span><br><span class="line">    ivarLayout = <span class="number">0x0000000000000000</span></span><br><span class="line">    nonMetaclass = nil</span><br><span class="line">  &#125;</span><br><span class="line">  name = &#123;</span><br><span class="line">    <span class="built_in">std</span>::__1::atomic&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; = <span class="string">"JSPerson"</span> &#123;</span><br><span class="line">      Value = <span class="number">0x0000000100003bbc</span> <span class="string">"JSPerson"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  baseMethodList = <span class="number">0x0000000100004178</span></span><br><span class="line">  baseProtocols = <span class="number">0x0000000000000000</span></span><br><span class="line">  ivars = <span class="number">0x0000000000000000</span></span><br><span class="line">  weakIvarLayout = <span class="number">0x0000000000000000</span></span><br><span class="line">  baseProperties = <span class="number">0x0000000000000000</span></span><br><span class="line">  _swiftMetadataInitializer_NEVER_USE = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">1.b</span>aseMethods()</span><br><span class="line">(<span class="keyword">method_list_t</span> *) $<span class="number">2</span> = <span class="number">0x0000000100004178</span></span><br><span class="line">(lldb) p *$<span class="number">2</span></span><br><span class="line">(<span class="keyword">method_list_t</span>) $<span class="number">3</span> = &#123;</span><br><span class="line">  entsize_list_tt&lt;<span class="keyword">method_t</span>, <span class="keyword">method_list_t</span>, <span class="number">4294901763</span>, <span class="keyword">method_t</span>::pointer_modifier&gt; = (entsizeAndFlags = <span class="number">24</span>, count = <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">3.</span><span class="built_in">get</span>(<span class="number">0</span>).big()</span><br><span class="line">(<span class="keyword">method_t</span>::big) $<span class="number">4</span> = &#123;</span><br><span class="line">  name = <span class="string">"saySomething"</span></span><br><span class="line">  types = <span class="number">0x0000000100003cfd</span> <span class="string">"v16@0:8"</span></span><br><span class="line">  imp = <span class="number">0x00000001000037f0</span> (KCObjcBuild`-[JSPerson(Test) saySomething])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">3.</span><span class="built_in">get</span>(<span class="number">1</span>).big()</span><br><span class="line">(<span class="keyword">method_t</span>::big) $<span class="number">5</span> = &#123;</span><br><span class="line">  name = <span class="string">"sayHello"</span></span><br><span class="line">  types = <span class="number">0x0000000100003cfd</span> <span class="string">"v16@0:8"</span></span><br><span class="line">  imp = <span class="number">0x00000001000036b0</span> (KCObjcBuild`-[JSPerson sayHello])</span><br><span class="line">&#125;</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>发现<code>分类</code>已经加载了,<code>类</code>也加载了，说明<code>非懒加载类</code>会使<code>懒加载的类</code>在启动时提前加载（如果没有分类是第一次调用时加载），说明加载的时机是<code>编译期</code>。</p>
<h4 id="懒加载分类和非懒加载类"><a href="#懒加载分类和非懒加载类" class="headerlink" title="懒加载分类和非懒加载类"></a>懒加载分类和非懒加载类</h4><p>我们删除<code>JSPerson</code>分类的<code>load</code>方法，重新运行程序。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/faaa15082c19440daa4b8200bd9e935d~tplv-k3u1fbpfcp-watermark.image" alt="类和分类都是非懒加载分类加载"></p>
<p>使用<code>lldb</code>调试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p ro</span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *) $<span class="number">0</span> = <span class="number">0x00000001000042a8</span></span><br><span class="line">(lldb) p *$<span class="number">0</span></span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">class_ro_t</span>) $<span class="number">1</span> = &#123;</span><br><span class="line">  flags = <span class="number">0</span></span><br><span class="line">  instanceStart = <span class="number">8</span></span><br><span class="line">  instanceSize = <span class="number">8</span></span><br><span class="line">  reserved = <span class="number">0</span></span><br><span class="line">   = &#123;</span><br><span class="line">    ivarLayout = <span class="number">0x0000000000000000</span></span><br><span class="line">    nonMetaclass = nil</span><br><span class="line">  &#125;</span><br><span class="line">  name = &#123;</span><br><span class="line">    <span class="built_in">std</span>::__1::atomic&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; = <span class="string">"JSPerson"</span> &#123;</span><br><span class="line">      Value = <span class="number">0x0000000100003bbc</span> <span class="string">"JSPerson"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  baseMethodList = <span class="number">0x0000000100004158</span></span><br><span class="line">  baseProtocols = <span class="number">0x0000000000000000</span></span><br><span class="line">  ivars = <span class="number">0x0000000000000000</span></span><br><span class="line">  weakIvarLayout = <span class="number">0x0000000000000000</span></span><br><span class="line">  baseProperties = <span class="number">0x0000000000000000</span></span><br><span class="line">  _swiftMetadataInitializer_NEVER_USE = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">1.b</span>aseMethods()</span><br><span class="line">(<span class="keyword">method_list_t</span> *) $<span class="number">2</span> = <span class="number">0x0000000100004158</span></span><br><span class="line">(lldb) p *$<span class="number">2</span></span><br><span class="line">(<span class="keyword">method_list_t</span>) $<span class="number">3</span> = &#123;</span><br><span class="line">  entsize_list_tt&lt;<span class="keyword">method_t</span>, <span class="keyword">method_list_t</span>, <span class="number">4294901763</span>, <span class="keyword">method_t</span>::pointer_modifier&gt; = (entsizeAndFlags = <span class="number">24</span>, count = <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">3.</span><span class="built_in">get</span>(<span class="number">0</span>).big()</span><br><span class="line">(<span class="keyword">method_t</span>::big) $<span class="number">4</span> = &#123;</span><br><span class="line">  name = <span class="string">"saySomething"</span></span><br><span class="line">  types = <span class="number">0x0000000100003cfd</span> <span class="string">"v16@0:8"</span></span><br><span class="line">  imp = <span class="number">0x00000001000037f0</span> (KCObjcBuild`-[JSPerson(Test) saySomething])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">3.</span><span class="built_in">get</span>(<span class="number">1</span>).big()</span><br><span class="line">(<span class="keyword">method_t</span>::big) $<span class="number">5</span> = &#123;</span><br><span class="line">  name = <span class="string">"sayHello"</span></span><br><span class="line">  types = <span class="number">0x0000000100003cfd</span> <span class="string">"v16@0:8"</span></span><br><span class="line">  imp = <span class="number">0x00000001000036c0</span> (KCObjcBuild`-[JSPerson sayHello])</span><br><span class="line">&#125;</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>发现<code>分类</code>和<code>类</code>都已经加载了，说明加载的时机也是<code>编译期</code>。</p>
<h4 id="懒加载分类和懒加载类"><a href="#懒加载分类和懒加载类" class="headerlink" title="懒加载分类和懒加载类"></a>懒加载分类和懒加载类</h4><p>我们把<code>类</code>和<code>分类</code>的<code>load</code>方法都删除，重新运行程序</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61f7e74b7b9243e79e0e0037a439df38~tplv-k3u1fbpfcp-watermark.image" alt="懒加载分类第一次调用"></p>
<p>依然走到断点，注意观察左边的调用栈，发现是从<code>lookUpImpOrForward</code>,说明是在第一次调用方法的时候加载的。</p>
<h3 id="One-More-Condition"><a href="#One-More-Condition" class="headerlink" title="One More Condition"></a>One More Condition</h3><p>前面四种情况基本能包括了<code>分类</code>,但是还有种情况就是：有多个分类，部分分类实现了<code>load</code>方法主类也实现了<code>load</code>。我们就探索一下这个情况，新建一个<code>JSPerson</code>的分类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@interface JSPerson (Test2)</span><br><span class="line"></span><br><span class="line">- (void)saySomething2;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation JSPerson (Test2)</span><br><span class="line"></span><br><span class="line">- (void)saySomething2&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>根据前面我们其实应清楚，就是实现<code>load</code>的分类肯定会在运行时加载，我们关注的点就在于没有实现<code>load</code>方法的分类是什么时候加载的呢也就是<code>attachCategories</code>是否会加载未实现<code>load</code>方法的分类，运行程序</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5733fd8764141f1937743cd459a0382~tplv-k3u1fbpfcp-watermark.image" alt="多个分类加载"></p>
<p>使用<code>lldb</code>调试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">lldb) p cat</span><br><span class="line">(<span class="keyword">category_t</span> *) $<span class="number">1</span> = <span class="number">0x0000000100004448</span></span><br><span class="line">(lldb) p *$<span class="number">1</span></span><br><span class="line">(<span class="keyword">category_t</span>) $<span class="number">2</span> = &#123;</span><br><span class="line">  name = <span class="number">0x0000000100003b8f</span> <span class="string">"Test2"</span></span><br><span class="line">  cls = <span class="number">0x00000001000049a0</span></span><br><span class="line">  instanceMethods = &#123;</span><br><span class="line">    ptr = <span class="number">0x0000000100004428</span></span><br><span class="line">  &#125;</span><br><span class="line">  classMethods = &#123;</span><br><span class="line">    ptr = <span class="number">0x0000000000000000</span></span><br><span class="line">  &#125;</span><br><span class="line">  protocols = <span class="number">0x0000000000000000</span></span><br><span class="line">  instanceProperties = <span class="number">0x0000000000000000</span></span><br><span class="line">  _classProperties = <span class="number">0x0000000000000000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">operator</span>() -JSPerson....</span><br><span class="line">attachCategories -JSPerson....</span><br><span class="line">(lldb) p cat</span><br><span class="line">(<span class="keyword">category_t</span> *) $<span class="number">3</span> = <span class="number">0x00000001000044c8</span></span><br><span class="line">(lldb) p *$<span class="number">3</span></span><br><span class="line">(<span class="keyword">category_t</span>) $<span class="number">4</span> = &#123;</span><br><span class="line">  name = <span class="number">0x0000000100003b95</span> <span class="string">"Test"</span></span><br><span class="line">  cls = <span class="number">0x00000001000049a0</span></span><br><span class="line">  instanceMethods = &#123;</span><br><span class="line">    ptr = <span class="number">0x0000000100004488</span></span><br><span class="line">  &#125;</span><br><span class="line">  classMethods = &#123;</span><br><span class="line">    ptr = <span class="number">0x00000001000044a8</span></span><br><span class="line">  &#125;</span><br><span class="line">  protocols = <span class="number">0x0000000000000000</span></span><br><span class="line">  instanceProperties = <span class="number">0x0000000000000000</span></span><br><span class="line">  _classProperties = <span class="number">0x0000000000000000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调试我们发现，两个分类都加载了，也就是只要有一个分类实现了<code>load</code>，其他分类都会在<code>启动时</code>加载。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇主要是探索了<code>分类</code>的加载，主要分为5种情况</p>
<ul>
<li>非懒加载类和非懒加载分类：此时分类是在<code>运行时</code>,也就是<code>程序启动</code>的时候加载的。</li>
<li>懒加载类和非懒加载分类：此时分类是在<code>编译时</code>加载</li>
<li>非懒加载类和懒加载分类：此时分类也是在<code>编译时</code>加载</li>
<li>懒加载类和懒加载分类：此时分类在第一次调用时加载。</li>
<li>非懒加载类，多个分类，部分是非懒加载分类：此时所有分类都是在<code>程序启动</code>时加载。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/07/17/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD-%E4%B8%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/17/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD-%E4%B8%AD/" class="post-title-link" itemprop="url">iOS底层探索-类的加载（中）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-17 16:45:27" itemprop="dateCreated datePublished" datetime="2021-07-17T16:45:27+08:00">2021-07-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-18 14:10:11" itemprop="dateModified" datetime="2021-07-18T14:10:11+08:00">2021-07-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一篇我们探索到了<code>readClass</code>函数，只是对函数名字进行了赋值，并没有对<code>ro</code>和<code>rw</code>进行操作，本篇我们就继续探索<code>_read_images</code>函数剩下的调用。</p>
<h3 id="realizeClass的引入"><a href="#realizeClass的引入" class="headerlink" title="realizeClass的引入"></a>realizeClass的引入</h3><p>因为我们探索的目的是<code>类</code>的加载，我们先忽略<code>protocol</code>和<code>categories</code>的地方。为了调试代码，我们首先还是先创建一个<code>JSPerson</code>类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@interface JSPerson : NSObject</span><br><span class="line">@property (nonatomic, strong) NSString *nickName;</span><br><span class="line"></span><br><span class="line">- (void)say1;</span><br><span class="line">- (void)say2;</span><br><span class="line"></span><br><span class="line">+ (void)sayHappy;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;JSPerson.h&quot;</span><br><span class="line">@implementation JSPerson</span><br><span class="line"></span><br><span class="line">- (void)say1&#123;</span><br><span class="line">    NSLog(@&quot;JSPerson say : %s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">- (void)say2&#123;</span><br><span class="line">    NSLog(@&quot;JSPerson say : %s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    NSLog(@&quot;load&quot;);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)sayHappy&#123;</span><br><span class="line">    NSLog(@&quot;JSPerson say : %s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>接下来我们继续看<code>_read_images</code>函数，发现和类相关的地方有两个地方，<code>realize non-lazy classes</code>和<code>realize future classes</code>，我们在两段代码中加入我们调试的代码，为了观察我们自定义类的加载情况:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Realize non-lazy classes (for +load methods and static instances)</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist = hi-&gt;nlclslist(&amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Class cls = remapClass(classlist[i]);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">///调试代码 确定是我们自定义的类</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *mangledName = cls-&gt;nonlazyMangledName();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *customerClassName = <span class="string">"JSPerson"</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(mangledName, customerClassName) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//打印类名</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s -: non-lazy classes要研究的类: - %s\n"</span>,__func__,mangledName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addClassTableEntry(cls);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;isSwiftStable()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cls-&gt;swiftMetadataInitializer()) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">"Swift class %s with a metadata initializer "</span></span><br><span class="line">                            <span class="string">"is not allowed to be non-lazy"</span>,</span><br><span class="line">                            cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// fixme also disallow relocatable classes</span></span><br><span class="line">            <span class="comment">// We can't disallow all Swift classes because of</span></span><br><span class="line">            <span class="comment">// classes like Swift.__EmptyArrayStorage</span></span><br><span class="line">        &#125;</span><br><span class="line">        realizeClassWithoutSwift(cls, nil);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: realize non-lazy classes"</span>);</span><br><span class="line"><span class="comment">// Realize newly-resolved future classes, in case CF manipulates them</span></span><br><span class="line"><span class="keyword">if</span> (resolvedFutureClasses) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; resolvedFutureClassCount; i++) &#123;</span><br><span class="line">        Class cls = resolvedFutureClasses[i];</span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;isSwiftStable()) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">"Swift class is not allowed to be future"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">///调试代码 确定是我们自定义的类</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *mangledName = cls-&gt;nonlazyMangledName();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *customerClassName = <span class="string">"JSPerson"</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(mangledName, customerClassName) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//打印类名</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s -: realize future classes要研究的类: - %s\n"</span>,__func__,mangledName);</span><br><span class="line">        &#125;</span><br><span class="line">        realizeClassWithoutSwift(cls, nil);</span><br><span class="line">        cls-&gt;setInstancesRequireRawIsaRecursively(<span class="literal">false</span><span class="comment">/*inherited*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(resolvedFutureClasses);</span><br><span class="line">&#125;</span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: realize future classes"</span>);</span><br></pre></td></tr></table></figure>

<p>在两行<code>printf</code>的地方打断点，运行源码程序，看是否执行到断点位置。发现打印了<code>_read_images -: non-lazy classes要研究的类: - JSPerson</code>，代码执行到了<code>non-lazy classes</code>,里面类加载的核心代码在<code>realizeClassWithoutSwift</code>函数，我们继续探索<code>realizeClassWithoutSwift</code>函数。</p>
<h3 id="realizeClassWithoutSwift分析"><a href="#realizeClassWithoutSwift分析" class="headerlink" title="realizeClassWithoutSwift分析"></a>realizeClassWithoutSwift分析</h3><h4 id="操作之前的ro"><a href="#操作之前的ro" class="headerlink" title="操作之前的ro"></a>操作之前的ro</h4><p>我们从上到下依次阅读代码，定位到<code>auto ro = (const class_ro_t )cls-&gt;data();</code>,因为<code>ro</code>是<code>clean Memory</code>里的数据我们比较敏感，我们在图示位置打断点：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8991c702c2f6482999995e0ba0d1d7c1~tplv-k3u1fbpfcp-watermark.image" alt="ro赋值之前"></p>
<p>使用<code>LLDB</code>调试程序，查看<code>ro</code>里的信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p ro</span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *) $<span class="number">0</span> = <span class="number">0x00000001000080c0</span></span><br><span class="line">(lldb) p *$<span class="number">0</span></span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">class_ro_t</span>) $<span class="number">1</span> = &#123;</span><br><span class="line">  flags = <span class="number">0</span></span><br><span class="line">  instanceStart = <span class="number">8</span></span><br><span class="line">  instanceSize = <span class="number">16</span></span><br><span class="line">  reserved = <span class="number">0</span></span><br><span class="line">   = &#123;</span><br><span class="line">    ivarLayout = <span class="number">0x0000000000000000</span></span><br><span class="line">    nonMetaclass = nil</span><br><span class="line">  &#125;</span><br><span class="line">  name = &#123;</span><br><span class="line">    <span class="built_in">std</span>::__1::atomic&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; = <span class="string">"JSPerson"</span> &#123;</span><br><span class="line">      Value = <span class="number">0x0000000100003db0</span> <span class="string">"JSPerson"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  baseMethodList = <span class="number">0x0000000100008108</span></span><br><span class="line">  baseProtocols = <span class="number">0x0000000000000000</span></span><br><span class="line">  ivars = <span class="number">0x0000000100008170</span></span><br><span class="line">  weakIvarLayout = <span class="number">0x0000000000000000</span></span><br><span class="line">  baseProperties = <span class="number">0x0000000100008198</span></span><br><span class="line">  _swiftMetadataInitializer_NEVER_USE = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">1.b</span>aseMethodList</span><br><span class="line">(<span class="keyword">void</span> *<span class="keyword">const</span>) $<span class="number">2</span> = <span class="number">0x0000000100008108</span></span><br><span class="line">(lldb) p *$<span class="number">2</span></span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>通过打印我们发现此时<code>ro</code>里的<code>baseMethodList</code>为空，目前还不清楚什么时候赋值的，我们继续探索。</p>
<h4 id="rw的赋值"><a href="#rw的赋值" class="headerlink" title="rw的赋值"></a>rw的赋值</h4><p>接下来就是对<code>rw</code>的赋值，注意<code>rw</code>是<code>dirty Memory</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ro-&gt;flags &amp; RO_FUTURE) &#123;</span><br><span class="line">     <span class="comment">// This was a future class. rw data is already allocated.</span></span><br><span class="line">     rw = cls-&gt;data();</span><br><span class="line">     ro = cls-&gt;data()-&gt;ro();</span><br><span class="line">     ASSERT(!isMeta);</span><br><span class="line">     cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// Normal class. Allocate writeable class data.</span></span><br><span class="line">     rw = objc::zalloc&lt;<span class="keyword">class_rw_t</span>&gt;();</span><br><span class="line">     rw-&gt;set_ro(ro);</span><br><span class="line">     rw-&gt;flags = RW_REALIZED|RW_REALIZING|isMeta;</span><br><span class="line">     cls-&gt;setData(rw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="isa和superClass赋值"><a href="#isa和superClass赋值" class="headerlink" title="isa和superClass赋值"></a>isa和superClass赋值</h4><p>后面的代码就是对<code>isa</code>和<code>superClass</code>的赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">supercls = realizeClassWithoutSwift(remapClass(cls-&gt;getSuperclass()), nil);</span><br><span class="line">metacls = realizeClassWithoutSwift(remapClass(cls-&gt;ISA()), nil);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    <span class="keyword">if</span> (isMeta) &#123;</span><br><span class="line">        <span class="comment">// Metaclasses do not need any features from non pointer ISA</span></span><br><span class="line">        <span class="comment">// This allows for a faspath for classes in objc_retain/objc_release.</span></span><br><span class="line">        <span class="comment">///元类 不是non pointer ISA</span></span><br><span class="line">        cls-&gt;setInstancesRequireRawIsa();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Disable non-pointer isa for some classes and/or platforms.</span></span><br><span class="line">        <span class="comment">// Set instancesRequireRawIsa.</span></span><br><span class="line">        <span class="keyword">bool</span> instancesRequireRawIsa = cls-&gt;instancesRequireRawIsa();</span><br><span class="line">        <span class="keyword">bool</span> rawIsaIsInherited = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">bool</span> hackedDispatch = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DisableNonpointerIsa) &#123;</span><br><span class="line">            <span class="comment">//如果我们设置变量不使用 non pointer ISA 也会是纯的isa</span></span><br><span class="line">            <span class="comment">// Non-pointer isa disabled by environment or app SDK version</span></span><br><span class="line">            instancesRequireRawIsa = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!hackedDispatch  &amp;&amp;  <span class="number">0</span> == <span class="built_in">strcmp</span>(ro-&gt;getName(), <span class="string">"OS_object"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// hack for libdispatch et al - isa also acts as vtable pointer</span></span><br><span class="line">            hackedDispatch = <span class="literal">true</span>;</span><br><span class="line">            instancesRequireRawIsa = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (supercls  &amp;&amp;  supercls-&gt;getSuperclass()  &amp;&amp;</span><br><span class="line">                 supercls-&gt;instancesRequireRawIsa())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// This is also propagated by addSubclass()</span></span><br><span class="line">            <span class="comment">// but nonpointer isa setup needs it earlier.</span></span><br><span class="line">            <span class="comment">// Special case: instancesRequireRawIsa does not propagate</span></span><br><span class="line">            <span class="comment">// from root class to root metaclass</span></span><br><span class="line">            instancesRequireRawIsa = <span class="literal">true</span>;</span><br><span class="line">            rawIsaIsInherited = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (instancesRequireRawIsa) &#123;</span><br><span class="line">            cls-&gt;setInstancesRequireRawIsaRecursively(rawIsaIsInherited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// SUPPORT_NONPOINTER_ISA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// Update superclass and metaclass in case of remapping</span></span><br><span class="line">    cls-&gt;setSuperclass(supercls);</span><br><span class="line">    cls-&gt;initClassIsa(metacls);</span><br></pre></td></tr></table></figure>

<p>在<code>realizeClassWithoutSwift</code>函数最后会调用<code>methodizeClass</code>,我们下一小节探索<code>methodizeClass</code>。</p>
<h3 id="methodizeClass分析"><a href="#methodizeClass分析" class="headerlink" title="methodizeClass分析"></a>methodizeClass分析</h3><p><code>methodizeClass</code>顾名思义就是对方法的处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodizeClass</span><span class="params">(Class cls, Class previously)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    <span class="keyword">bool</span> isMeta = cls-&gt;isMetaClass();</span><br><span class="line">    <span class="keyword">auto</span> rw = cls-&gt;data();</span><br><span class="line">    <span class="keyword">auto</span> ro = rw-&gt;ro();</span><br><span class="line">    <span class="keyword">auto</span> rwe = rw-&gt;ext();</span><br><span class="line">    <span class="comment">// Methodizing for the first time</span></span><br><span class="line">    <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">        _objc_inform(<span class="string">"CLASS: methodizing class '%s' %s"</span>, </span><br><span class="line">                     cls-&gt;nameForLogging(), isMeta ? <span class="string">"(meta)"</span> : <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">///调试代码 确定是我们自定义的类</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mangledName = cls-&gt;nonlazyMangledName();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *customerClassName = <span class="string">"JSPerson"</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(mangledName, customerClassName) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//打印类名</span></span><br><span class="line">        <span class="keyword">if</span> (!isMeta) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s -: non-lazy classes要研究的类: - %s\n"</span>,__func__,mangledName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Install methods and properties that the class implements itself.</span></span><br><span class="line">    <span class="comment">//取出方法列表</span></span><br><span class="line">    <span class="keyword">method_list_t</span> *<span class="built_in">list</span> = ro-&gt;baseMethods();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">        prepareMethodLists(cls, &amp;<span class="built_in">list</span>, <span class="number">1</span>, YES, isBundleClass(cls), <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">if</span> (rwe) rwe-&gt;methods.attachLists(&amp;<span class="built_in">list</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">property_list_t</span> *proplist = ro-&gt;baseProperties;</span><br><span class="line">    <span class="keyword">if</span> (rwe &amp;&amp; proplist) &#123;</span><br><span class="line">        rwe-&gt;properties.attachLists(&amp;proplist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protocol_list_t</span> *protolist = ro-&gt;baseProtocols;</span><br><span class="line">    <span class="keyword">if</span> (rwe &amp;&amp; protolist) &#123;</span><br><span class="line">        rwe-&gt;protocols.attachLists(&amp;protolist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Root classes get bonus method implementations if they don't have </span></span><br><span class="line">    <span class="comment">// them already. These apply before category replacements.</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;isRootMetaclass()) &#123;</span><br><span class="line">        <span class="comment">// root metaclass</span></span><br><span class="line">        addMethod(cls, @selector(initialize), (IMP)&amp;objc_noop_imp, <span class="string">""</span>, NO);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Attach categories.</span></span><br><span class="line">    <span class="keyword">if</span> (previously) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) &#123;</span><br><span class="line">            objc::unattachedCategories.attachToClass(cls, previously,</span><br><span class="line">                                                     ATTACH_METACLASS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// When a class relocates, categories with class methods</span></span><br><span class="line">            <span class="comment">// may be registered on the class itself rather than on</span></span><br><span class="line">            <span class="comment">// the metaclass. Tell attachToClass to look for those.</span></span><br><span class="line">            objc::unattachedCategories.attachToClass(cls, previously,</span><br><span class="line">                                                     ATTACH_CLASS_AND_METACLASS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    objc::unattachedCategories.attachToClass(cls, cls,</span><br><span class="line">                                             isMeta ? ATTACH_METACLASS : ATTACH_CLASS);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">    <span class="comment">// Debug: sanity-check all SELs; log method list contents</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; meth : rw-&gt;methods()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"METHOD %c[%s %s]"</span>, isMeta ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(meth.name()));</span><br><span class="line">        &#125;</span><br><span class="line">        ASSERT(sel_registerName(sel_getName(meth.name())) == meth.name());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>断点进入图示位置，此时方法列表还是不能打印</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4210312aca44f2fa97bee1f1e2d6e3c~tplv-k3u1fbpfcp-watermark.image" alt="methodList打印"></p>
<h4 id="prepareMethodLists"><a href="#prepareMethodLists" class="headerlink" title="prepareMethodLists"></a>prepareMethodLists</h4><p>我们继续探索，后面执行<code>prepareMethodLists</code>函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> </span><br><span class="line">prepareMethodLists(Class cls, <span class="keyword">method_list_t</span> **addedLists, <span class="keyword">int</span> addedCount,</span><br><span class="line">                   <span class="keyword">bool</span> baseMethods, <span class="keyword">bool</span> methodsFromBundle, <span class="keyword">const</span> <span class="keyword">char</span> *why)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// There exist RR/AWZ/Core special cases for some class's base methods.</span></span><br><span class="line">    <span class="comment">// But this code should never need to scan base methods for RR/AWZ/Core:</span></span><br><span class="line">    <span class="comment">// default RR/AWZ/Core cannot be set before setInitialized().</span></span><br><span class="line">    <span class="comment">// Therefore we need not handle any special cases here.</span></span><br><span class="line">    <span class="keyword">if</span> (baseMethods) &#123;</span><br><span class="line">        ASSERT(cls-&gt;hasCustomAWZ() &amp;&amp; cls-&gt;hasCustomRR() &amp;&amp; cls-&gt;hasCustomCore());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cls-&gt;cache.isConstantOptimizedCache()) &#123;</span><br><span class="line">        cls-&gt;setDisallowPreoptCachesRecursively(why);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cls-&gt;allowsPreoptInlinedSels()) &#123;</span><br><span class="line">#<span class="keyword">if</span> CONFIG_USE_PREOPT_CACHES</span><br><span class="line">        SEL *sels = (SEL *)objc_opt_offsets[OBJC_OPT_INLINED_METHODS_START];</span><br><span class="line">        SEL *sels_end = (SEL *)objc_opt_offsets[OBJC_OPT_INLINED_METHODS_END];</span><br><span class="line">        <span class="keyword">if</span> (method_lists_contains_any(addedLists, addedLists + addedCount, sels, sels_end - sels)) &#123;</span><br><span class="line">            cls-&gt;setDisallowPreoptInlinedSelsRecursively(why);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add method lists to array.</span></span><br><span class="line">    <span class="comment">// Reallocate un-fixed method lists.</span></span><br><span class="line">    <span class="comment">// The new methods are PREPENDED to the method list array.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; addedCount; i++) &#123;</span><br><span class="line">        <span class="keyword">method_list_t</span> *mlist = addedLists[i];</span><br><span class="line">        ASSERT(mlist);</span><br><span class="line">        <span class="comment">// Fixup selectors if necessary</span></span><br><span class="line">        <span class="keyword">if</span> (!mlist-&gt;isFixedUp()) &#123;</span><br><span class="line">            <span class="comment">//核心代码</span></span><br><span class="line">            fixupMethodList(mlist, methodsFromBundle, <span class="literal">true</span><span class="comment">/*sort*/</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the class is initialized, then scan for method implementations</span></span><br><span class="line">    <span class="comment">// tracked by the class's flags. If it's not initialized yet,</span></span><br><span class="line">    <span class="comment">// then objc_class::setInitialized() will take care of it.</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;isInitialized()) &#123;</span><br><span class="line">        objc::AWZScanner::scanAddedMethodLists(cls, addedLists, addedCount);</span><br><span class="line">        objc::RRScanner::scanAddedMethodLists(cls, addedLists, addedCount);</span><br><span class="line">        objc::CoreScanner::scanAddedMethodLists(cls, addedLists, addedCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心调用是<code>fixupMethodList</code>函数。</p>
<h4 id="fixupMethodList"><a href="#fixupMethodList" class="headerlink" title="fixupMethodList"></a>fixupMethodList</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> </span><br><span class="line">fixupMethodList(<span class="keyword">method_list_t</span> *mlist, <span class="keyword">bool</span> bundleCopy, <span class="keyword">bool</span> sort)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    ASSERT(!mlist-&gt;isFixedUp());</span><br><span class="line">    <span class="comment">// fixme lock less in attachMethodLists ?</span></span><br><span class="line">    <span class="comment">// dyld3 may have already uniqued, but not sorted, the list</span></span><br><span class="line">    <span class="keyword">if</span> (!mlist-&gt;isUniqued()) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(selLock)</span></span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Unique selectors in list.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; meth : *mlist) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *name = sel_cname(meth.name());</span><br><span class="line">            meth.setName(sel_registerNameNoLock(name, bundleCopy));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Sort by selector address.</span></span><br><span class="line">    <span class="comment">// Don't try to sort small lists, as they're immutable.</span></span><br><span class="line">    <span class="comment">// Don't try to sort big lists of nonstandard size, as stable_sort</span></span><br><span class="line">    <span class="comment">// won't copy the entries properly.</span></span><br><span class="line">    <span class="keyword">if</span> (sort &amp;&amp; !mlist-&gt;isSmallList() &amp;&amp; mlist-&gt;entsize() == <span class="keyword">method_t</span>::bigSize) &#123;</span><br><span class="line">        <span class="keyword">method_t</span>::SortBySELAddress sorter;</span><br><span class="line">        <span class="built_in">std</span>::stable_sort(&amp;mlist-&gt;<span class="built_in">begin</span>()-&gt;big(), &amp;mlist-&gt;<span class="built_in">end</span>()-&gt;big(), sorter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Mark method list as uniqued and sorted.</span></span><br><span class="line">    <span class="comment">// Can't mark small lists, since they're immutable.</span></span><br><span class="line">    <span class="keyword">if</span> (!mlist-&gt;isSmallList()) &#123;</span><br><span class="line">        mlist-&gt;setFixedUp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心的代码是<code>stable_sort</code>，我们分别打印排序前后方法列表，如图示</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08916e32cc124e5e95fdeb0723a5ad4d~tplv-k3u1fbpfcp-watermark.image" alt="打印前后排序"></p>
<p>注意：这里一定要先在<code>realizeClassWithoutSwift</code>判断好是我们要研究的<code>JSPerson</code>类，然后再看打印结果，否则系统类也会有很多打印，影响我们分析。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">methodizeClass -: non-lazy classes要研究的类: - JSPerson</span><br><span class="line">****************sort之前 : say1 - <span class="number">0x100003dda</span></span><br><span class="line">sort之前 : say2 - <span class="number">0x100003ddf</span></span><br><span class="line">sort之前 : nickName - <span class="number">0x7fff73fb8a1c</span></span><br><span class="line">sort之前 : setNickName: - <span class="number">0x7fff73fb8362</span></span><br><span class="line">****************sort之后 : say1 - <span class="number">0x100003dda</span></span><br><span class="line">sort之后 : say2 - <span class="number">0x100003ddf</span></span><br><span class="line">sort之后 : setNickName: - <span class="number">0x7fff73fb8362</span></span><br><span class="line">sort之后 : nickName - <span class="number">0x7fff73fb8a1c</span></span><br></pre></td></tr></table></figure>

<p>通过上面打印结果：</p>
<ul>
<li>排序前：<code>say1 - 0x100003dda</code>、<code>say2 - 0x100003ddf</code>、<code>nickName - 0x7fff73fb8a1c</code>、<code>setNickName: - 0x7fff73fb8362</code></li>
<li>排序后：<code>say1 - 0x100003dda</code>、<code>say2 - 0x100003ddf</code>、<code>setNickName: - 0x7fff73fb8362</code>、<code>nickName - 0x7fff73fb8a1c</code></li>
<li>排序是根据地址由低到高排序的。</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>到目前为止，类的加载流程是：<code>_read_images</code>-&gt;<code>realizeClassWithoutSwift</code>-&gt;<code>methodizeClass</code>-&gt;<code>prepareMethodLists</code>-&gt;<code>fixupMethodList</code>。</p>
<h3 id="懒加载类和非懒加载类"><a href="#懒加载类和非懒加载类" class="headerlink" title="懒加载类和非懒加载类"></a>懒加载类和非懒加载类</h3><p>我们前面探索的其实都是<code>非懒加载的类</code>，<code>懒加载类</code>和<code>非懒加载的类</code>的区别就是<strong><em>是否实现了<code>load</code>方法</em></strong>。</p>
<h4 id="非懒加载"><a href="#非懒加载" class="headerlink" title="非懒加载"></a>非懒加载</h4><p>通过上面的分析，我们已经很清楚了，是在<code>_objc_init</code>方法里加载的，也就是程序启动的时候。这也就是为什么<code>load</code>方法过多，会影响我们应用的<code>启动速度</code>。</p>
<h4 id="懒加载类"><a href="#懒加载类" class="headerlink" title="懒加载类"></a>懒加载类</h4><p>因为<code>非懒加载类</code>效率低，会影响我们的启动速度，那<code>懒加载类</code>是什么时候加载的呢？我们删掉<code>JSPerson</code>类的<code>load</code>方法，然后在<code>main</code>函数中实例化一个<code>JSPerson</code>实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        JSPerson *p &#x3D; [JSPerson alloc];</span><br><span class="line">        [p say1];</span><br><span class="line">        NSLog(@&quot;Hello, World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先在<code>main</code>方法里添加断点，执行程序。走到<code>main</code>函数之后，然后再在<code>realizeClassWithoutSwift</code>添加断点：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5701b96b7a04b4ba9a69677f9034593~tplv-k3u1fbpfcp-watermark.image" alt="懒加载类断点"></p>
<p>断点走进来之后我们<code>bt</code>打印调用栈信息：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cd935a4a37144f29ec9af1d6a14f2ff~tplv-k3u1fbpfcp-watermark.image" alt="懒加载类"></p>
<p>发现调用是从<code>lookUpImpOrForward</code>开始。</p>
<p>所以我们的结论是<code>懒加载的类</code>是在第一次被使用的时候加载的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>非懒加载类：程序运行时加载，<code>_read_images</code>-&gt;<code>realizeClassWithoutSwift</code>-&gt;<code>methodizeClass</code>-&gt;<code>prepareMethodLists</code>-&gt;<code>fixupMethodList</code>。</li>
<li>懒加载类：第一次使用时加载，<code>lookUpImpOrForward</code>-&gt;<code>realizeClassWithoutSwift</code>-&gt;<code>methodizeClass</code>-&gt;<code>prepareMethodLists</code>-&gt;<code>fixupMethodList</code></li>
</ul>
<p>我们开发中经常会写<code>分类</code>，它是什么时候加载的及加载的流程，我们下一篇再探索。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/07/15/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD-%E4%B8%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/15/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD-%E4%B8%8A/" class="post-title-link" itemprop="url">iOS底层探索-类的加载（上）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-15 22:11:42" itemprop="dateCreated datePublished" datetime="2021-07-15T22:11:42+08:00">2021-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-17 16:54:52" itemprop="dateModified" datetime="2021-07-17T16:54:52+08:00">2021-07-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一篇我们主要探索了<code>dyld</code>的链接加载，本篇开始我们探索运行时类的加载过程，本篇只是引子。</p>
<h3 id="objc-init"><a href="#objc-init" class="headerlink" title="_objc_init"></a>_objc_init</h3><p>首先看一下<code>_objc_init</code>方法的源码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    <span class="comment">//读取影响运行时的环境变量 </span></span><br><span class="line">    environ_init();</span><br><span class="line">    <span class="comment">//关于线程key的绑定</span></span><br><span class="line">    tls_init();</span><br><span class="line">    <span class="comment">//运行C ++静态构造函数</span></span><br><span class="line">    static_init();</span><br><span class="line">  	<span class="comment">//runtime运行时环境初始化</span></span><br><span class="line">    runtime_init();</span><br><span class="line">    <span class="comment">//初始化libobjc的异常处理系统</span></span><br><span class="line">    exception_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">  	<span class="comment">//缓存条件初始化</span></span><br><span class="line">    <span class="keyword">cache_t</span>::init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//启动回调机制</span></span><br><span class="line">    _imp_implementationWithBlock_init();</span><br><span class="line">		<span class="comment">//dyld 注册的地方</span></span><br><span class="line">    <span class="comment">//map_images:dyld将image镜像文件加载进内存时，会触发该函数</span></span><br><span class="line">    <span class="comment">//load_images：dyld初始化image会触发该函数</span></span><br><span class="line">    <span class="comment">//unmap_image：dyld将image移除时会触发该函数</span></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    didCallDyldNotifyRegister = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，<code>_objc_init</code>主要是执行一些初始化方法，包括</p>
<ul>
<li><code>environ_init()</code>:读取影响运行时的环境变量,如果需要可以打印环境变量提供帮助。</li>
<li><code>tls_init()</code>:关于线程key的绑定,例如每线程数据的析构函数。</li>
<li><code>static_init()</code>:运行<code>C++</code>静态构造函数。</li>
<li><code>runtime_init()</code>:runtime运行时环境的初始化，后面我们详细分析。</li>
<li><code>exception_init()</code>:初始化<code>libobjc</code>的异常处理系统。</li>
<li><code>cache_t::init()</code>:缓存条件初始化。</li>
<li><code>_imp_implementationWithBlock_init()</code>:启动回调机制。</li>
<li><code>_dyld_objc_notify_register</code>：dyld的注册。</li>
</ul>
<p>####environ_init 环境变量初始化</p>
<p><code>environ_init</code>的源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">environ_init</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">///省略代码</span></span><br><span class="line">   <span class="comment">// Print OBJC_HELP and OBJC_PRINT_OPTIONS output.</span></span><br><span class="line">    <span class="keyword">if</span> (PrintHelp  ||  PrintOptions) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintHelp) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"Objective-C runtime debugging. Set variable=YES to enable."</span>);</span><br><span class="line">            _objc_inform(<span class="string">"OBJC_HELP: describe available environment variables"</span>);</span><br><span class="line">            <span class="keyword">if</span> (PrintOptions) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"OBJC_HELP is set"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            _objc_inform(<span class="string">"OBJC_PRINT_OPTIONS: list which options are set"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (PrintOptions) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"OBJC_PRINT_OPTIONS is set"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">			  <span class="comment">///这里如果满足条件 会打印所有的环境变量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(Settings)/<span class="keyword">sizeof</span>(Settings[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">option_t</span> *opt = &amp;Settings[i];            </span><br><span class="line">            <span class="keyword">if</span> (PrintHelp) _objc_inform(<span class="string">"%s: %s"</span>, opt-&gt;env, opt-&gt;help);</span><br><span class="line">            <span class="keyword">if</span> (PrintOptions &amp;&amp; *opt-&gt;var) _objc_inform(<span class="string">"%s is set"</span>, opt-&gt;env);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出来就是一些环境变量的初始化，参看这段代码，我们可以打印环境变量。</p>
<ul>
<li><p>将条件去掉直接调用<code>for</code>循环</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(Settings)/<span class="keyword">sizeof</span>(Settings[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">option_t</span> *opt = &amp;Settings[i];</span><br><span class="line">     _objc_inform(<span class="string">"%s: %s"</span>, opt-&gt;env, opt-&gt;help);</span><br><span class="line">     _objc_inform(<span class="string">"%s is set"</span>, opt-&gt;env);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过终端命令<code>export OBJC_hrlp = 1</code>,打印环境变量</p>
</li>
</ul>
<p>我们平时项目中可能会有几个环境变量可以在我们的xcode配置（<code>target -- Edit Scheme -- Run --Arguments -- Environment Variables</code>）一下对应的值，达到修改环境变量的目的：</p>
<ul>
<li><code>DYLD_PRINT_STATISTICS</code>：设置 <code>DYLD_PRINT_STATISTICS</code> 为<code>YES</code>，控制台就会打印 App 的加载时长，包括整体加载时长和动态库加载时长，即<code>main函数之前的启动时间（查看pre-main耗时）</code>，可以通过设置了解其耗时部分，这个我们做<code>启动优化</code>会用到。</li>
<li><code>OBJC_DISABLE_NONPOINTER_ISA</code>：不使用<code>nonpointer isa</code>（nonpointer isa指针地址 <code>末尾为1</code> ），生成的都是普通的isa，这个我们项目里一般不会改，探索源码的时候可以尝试查看两种<code>isa</code>结构的区别。</li>
<li><code>OBJC_PRINT_LOAD_METHODS</code>：打印 <code>Class</code> 及 <code>Category</code> 的 <code>+ (void)load</code> 方法的调用信息，<code>启动优化</code>也可以参考，因为<code>load</code>方法过多也会使启动变慢。</li>
</ul>
<h4 id="tls-init：线程key的绑定"><a href="#tls-init：线程key的绑定" class="headerlink" title="tls_init：线程key的绑定"></a>tls_init：线程key的绑定</h4><p>主要作用是本地线程池的初始化以及析构，源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tls_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line">    pthread_key_init_np(TLS_DIRECT_KEY, &amp;_objc_pthread_destroyspecific);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    _objc_pthread_key = tls_create(&amp;_objc_pthread_destroyspecific);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="static-init-运行系统级别的C-静态构造函数"><a href="#static-init-运行系统级别的C-静态构造函数" class="headerlink" title="static_init 运行系统级别的C++静态构造函数"></a>static_init 运行系统级别的C++静态构造函数</h4><p>主要是运行系统级别的C++静态构造函数，在<code>dyld</code>调用我们的静态构造函数之前，<code>libc</code>调用<code>_objc_init</code>方法，即<code>系统级别的C++构造函数 先于 自定义的C++构造函数 运行</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">static_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    <span class="keyword">auto</span> inits = getLibobjcInitializers(&amp;_mh_dylib_header, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        inits[i]();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> offsets = getLibobjcInitializerOffsets(&amp;_mh_dylib_header, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="function">UnsignedInitializer <span class="title">init</span><span class="params">(offsets[i])</span></span>;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="runtime-init-运行时环境初始化"><a href="#runtime-init-运行时环境初始化" class="headerlink" title="runtime_init 运行时环境初始化"></a>runtime_init 运行时环境初始化</h4><p>主要是运行时的初始化，主要分为两部分：<code>分类初始化</code>、<code>类的表初始化</code>,我们下一篇会详细探索。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runtime_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    objc::unattachedCategories.init(<span class="number">32</span>);</span><br><span class="line">    objc::allocatedClasses.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="exception-init-异常初始化"><a href="#exception-init-异常初始化" class="headerlink" title="exception_init 异常初始化"></a>exception_init 异常初始化</h4><p>主要是<code>初始化libobjc的异常处理系统，注册异常处理的回调，从而监控异常的处理</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* exception_init</span></span><br><span class="line"><span class="comment">* Initialize libobjc's exception handling system.</span></span><br><span class="line"><span class="comment">* Called by map_images().</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exception_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    old_terminate = <span class="built_in">std</span>::set_terminate(&amp;_objc_terminate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>_objc_terminate</code>的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _objc_terminate(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PrintExceptions) &#123;</span><br><span class="line">        _objc_inform(<span class="string">"EXCEPTIONS: terminating"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! __cxa_current_exception_type()) &#123;</span><br><span class="line">        <span class="comment">// No current exception.</span></span><br><span class="line">        (*old_terminate)();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// There is a current exception. Check if it's an objc exception.</span></span><br><span class="line">        @<span class="keyword">try</span> &#123;</span><br><span class="line">            __cxa_rethrow();</span><br><span class="line">        &#125; @<span class="keyword">catch</span> (id e) &#123;</span><br><span class="line">            <span class="comment">// It's an objc object. Call Foundation's handler, if any.</span></span><br><span class="line">            (*uncaught_handler)((id)e);</span><br><span class="line">            (*old_terminate)();</span><br><span class="line">        &#125; @<span class="keyword">catch</span> (...) &#123;</span><br><span class="line">            <span class="comment">// It's not an objc object. Continue to C++ terminate.</span></span><br><span class="line">            (*old_terminate)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>crash</code>的时候会执行<code>_objc_terminate</code>方法,最后会执行<code>uncaught_handler</code>抛出异常。</p>
</li>
<li><p><code>uncaught_handler</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">objc_uncaught_exception_handler </span><br><span class="line">objc_setUncaughtExceptionHandler(objc_uncaught_exception_handler fn)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    fn为设置的异常句柄 传入的函数，为外界给的</span></span><br><span class="line">    objc_uncaught_exception_handler result = uncaught_handler;</span><br><span class="line">    uncaught_handler = fn; <span class="comment">//赋值</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要用来处理异常，在我们的App中可以添加一个异常句柄<code>NSSetUncaughtExceptionHandler</code>来处理异常。</p>
</li>
</ul>
<h4 id="cache-init：缓存初始化"><a href="#cache-init：缓存初始化" class="headerlink" title="cache_init：缓存初始化"></a>cache_init：缓存初始化</h4><p>主要就是缓存初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_t::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> HAVE_TASK_RESTARTABLE_RANGES</span></span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (objc_restartableRanges[count].location) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kr = task_restartable_ranges_register(mach_task_self(),</span><br><span class="line">                                          objc_restartableRanges, count);</span><br><span class="line">    <span class="keyword">if</span> (kr == KERN_SUCCESS) <span class="keyword">return</span>;</span><br><span class="line">    _objc_fatal(<span class="string">"task_restartable_ranges_register failed (result 0x%x: %s)"</span>,</span><br><span class="line">                kr, mach_error_string(kr));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// HAVE_TASK_RESTARTABLE_RANGES</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="imp-implementationWithBlock-init：启动回调机制"><a href="#imp-implementationWithBlock-init：启动回调机制" class="headerlink" title="_imp_implementationWithBlock_init：启动回调机制"></a>_imp_implementationWithBlock_init：启动回调机制</h4><p>该方法主要是<code>启动回调机制</code>，看代码<code>iOS</code>端没做任何处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_imp_implementationWithBlock_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_OSX</span></span><br><span class="line">    <span class="comment">// Eagerly load libobjc-trampolines.dylib in certain processes. Some</span></span><br><span class="line">    <span class="comment">// programs (most notably QtWebEngineProcess used by older versions of</span></span><br><span class="line">    <span class="comment">// embedded Chromium) enable a highly restrictive sandbox profile which</span></span><br><span class="line">    <span class="comment">// blocks access to that dylib. If anything calls</span></span><br><span class="line">    <span class="comment">// imp_implementationWithBlock (as AppKit has started doing) then we'll</span></span><br><span class="line">    <span class="comment">// crash trying to load it. Loading it here sets it up before the sandbox</span></span><br><span class="line">    <span class="comment">// profile is enabled and blocks it.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This fixes EA Origin (rdar://problem/50813789)</span></span><br><span class="line">    <span class="comment">// and Steam (rdar://problem/55286131)</span></span><br><span class="line">    <span class="keyword">if</span> (__progname &amp;&amp;</span><br><span class="line">        (<span class="built_in">strcmp</span>(__progname, <span class="string">"QtWebEngineProcess"</span>) == <span class="number">0</span> ||</span><br><span class="line">         <span class="built_in">strcmp</span>(__progname, <span class="string">"Steam Helper"</span>) == <span class="number">0</span>)) &#123;</span><br><span class="line">        Trampolines.Initialize();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dyld-objc-notify-register：dyld注册"><a href="#dyld-objc-notify-register：dyld注册" class="headerlink" title="_dyld_objc_notify_register：dyld注册"></a>_dyld_objc_notify_register：dyld注册</h4><p>这个方法我们上一篇有提到过，主要是</p>
<ul>
<li>仅供<code>objc运行时</code>使用</li>
<li><code>注册处理程序</code>，以便在映射、取消映射和初始化objc图像时调用</li>
<li><code>dyld</code>将会通过一个包含objc-image-info的镜像文件的数组回调<code>mapped</code>函数</li>
</ul>
<p>三个参数的作用：</p>
<p><code>map_images</code>：dyld将image（镜像文件）加载进内存时，会触发该函数</p>
<p><code>load_image</code>：dyld初始化image会触发该函数</p>
<p><code>unmap_image</code>：dyld将image移除时，会触发该函数</p>
<p>我们<code>_objc_init</code>调用的方法有了初步认识，接下来我们开始探索类的加载。</p>
<h3 id="read-images"><a href="#read-images" class="headerlink" title="_read_images"></a>_read_images</h3><h4 id="read-images的引入"><a href="#read-images的引入" class="headerlink" title="_read_images的引入"></a>_read_images的引入</h4><p><code>_dyld_objc_notify_register</code>第一个参数是<code>&amp;map_images</code>,所以我们从<code>map_images</code>开始探索。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">map_images(<span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> paths[],</span><br><span class="line">           <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> map_images_nolock(count, paths, mhdrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>map_images</code>比较简单，调用<code>map_images_nolock</code>,我们继续探索。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">map_images_nolock(<span class="keyword">unsigned</span> mhCount, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> mhPaths[],</span><br><span class="line">                  <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> firstTime = YES;</span><br><span class="line">    header_info *hList[mhCount];</span><br><span class="line">    <span class="keyword">uint32_t</span> hCount;</span><br><span class="line">    <span class="keyword">size_t</span> selrefCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform first-time initialization if necessary.</span></span><br><span class="line">    <span class="comment">// This function is called before ordinary library initializers. </span></span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    <span class="keyword">if</span> (firstTime) &#123;</span><br><span class="line">        preopt_init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintImages) &#123;</span><br><span class="line">        _objc_inform(<span class="string">"IMAGES: processing %u newly-mapped images...\n"</span>, mhCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find all images with Objective-C metadata.</span></span><br><span class="line">    hCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Count classes. Size various table based on the total.</span></span><br><span class="line">    <span class="keyword">int</span> totalClasses = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> unoptimizedTotalClasses = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> i = mhCount;</span><br><span class="line">        <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">            <span class="keyword">const</span> headerType *mhdr = (<span class="keyword">const</span> headerType *)mhdrs[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> hi = addHeader(mhdr, mhPaths[i], totalClasses, unoptimizedTotalClasses);</span><br><span class="line">            <span class="keyword">if</span> (!hi) &#123;</span><br><span class="line">                <span class="comment">// no objc data in this entry</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (mhdr-&gt;filetype == MH_EXECUTE) &#123;</span><br><span class="line">                <span class="comment">// Size some data structures based on main executable's size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">                <span class="comment">// If dyld3 optimized the main executable, then there shouldn't</span></span><br><span class="line">                <span class="comment">// be any selrefs needed in the dynamic map so we can just init</span></span><br><span class="line">                <span class="comment">// to a 0 sized map</span></span><br><span class="line">                <span class="keyword">if</span> ( !hi-&gt;hasPreoptimizedSelectors() ) &#123;</span><br><span class="line">                  <span class="keyword">size_t</span> count;</span><br><span class="line">                  _getObjc2SelectorRefs(hi, &amp;count);</span><br><span class="line">                  selrefCount += count;</span><br><span class="line">                  _getObjc2MessageRefs(hi, &amp;count);</span><br><span class="line">                  selrefCount += count;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                _getObjcSelectorRefs(hi, &amp;selrefCount);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_GC_COMPAT</span></span><br><span class="line">                <span class="comment">// Halt if this is a GC app.</span></span><br><span class="line">                <span class="keyword">if</span> (shouldRejectGCApp(hi)) &#123;</span><br><span class="line">                    _objc_fatal_with_reason</span><br><span class="line">                        (OBJC_EXIT_REASON_GC_NOT_SUPPORTED, </span><br><span class="line">                         OS_REASON_FLAG_CONSISTENT_FAILURE, </span><br><span class="line">                         <span class="string">"Objective-C garbage collection "</span> </span><br><span class="line">                         <span class="string">"is no longer supported."</span>);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            hList[hCount++] = hi;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (PrintImages) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"IMAGES: loading image for %s%s%s%s%s\n"</span>, </span><br><span class="line">                             hi-&gt;fname(),</span><br><span class="line">                             mhdr-&gt;filetype == MH_BUNDLE ? <span class="string">" (bundle)"</span> : <span class="string">""</span>,</span><br><span class="line">                             hi-&gt;info()-&gt;isReplacement() ? <span class="string">" (replacement)"</span> : <span class="string">""</span>,</span><br><span class="line">                             hi-&gt;info()-&gt;hasCategoryClassProperties() ? <span class="string">" (has class properties)"</span> : <span class="string">""</span>,</span><br><span class="line">                             hi-&gt;info()-&gt;optimizedByDyld()?<span class="string">" (preoptimized)"</span>:<span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform one-time runtime initialization that must be deferred until </span></span><br><span class="line">    <span class="comment">// the executable itself is found. This needs to be done before </span></span><br><span class="line">    <span class="comment">// further initialization.</span></span><br><span class="line">    <span class="comment">// (The executable may not be present in this infoList if the </span></span><br><span class="line">    <span class="comment">// executable does not contain Objective-C code but Objective-C </span></span><br><span class="line">    <span class="comment">// is dynamically loaded later.</span></span><br><span class="line">    <span class="keyword">if</span> (firstTime) &#123;</span><br><span class="line">        sel_init(selrefCount);</span><br><span class="line">        arr_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_GC_COMPAT</span></span><br><span class="line">        <span class="comment">// Reject any GC images linked to the main executable.</span></span><br><span class="line">        <span class="comment">// We already rejected the app itself above.</span></span><br><span class="line">        <span class="comment">// Images loaded after launch will be rejected by dyld.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; hCount; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> hi = hList[i];</span><br><span class="line">            <span class="keyword">auto</span> mh = hi-&gt;mhdr();</span><br><span class="line">            <span class="keyword">if</span> (mh-&gt;filetype != MH_EXECUTE  &amp;&amp;  shouldRejectGCImage(mh)) &#123;</span><br><span class="line">                _objc_fatal_with_reason</span><br><span class="line">                    (OBJC_EXIT_REASON_GC_NOT_SUPPORTED, </span><br><span class="line">                     OS_REASON_FLAG_CONSISTENT_FAILURE, </span><br><span class="line">                     <span class="string">"%s requires Objective-C garbage collection "</span></span><br><span class="line">                     <span class="string">"which is no longer supported."</span>, hi-&gt;fname());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_OSX</span></span><br><span class="line">        <span class="comment">// Disable +initialize fork safety if the app is too old (&lt; 10.13).</span></span><br><span class="line">        <span class="comment">// Disable +initialize fork safety if the app has a</span></span><br><span class="line">        <span class="comment">//   __DATA,__objc_fork_ok section.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        if (!dyld_program_sdk_at_least(dyld_platform_version_macOS_10_13)) &#123;</span></span><br><span class="line"><span class="comment">//            DisableInitializeForkSafety = true;</span></span><br><span class="line"><span class="comment">//            if (PrintInitializing) &#123;</span></span><br><span class="line"><span class="comment">//                _objc_inform("INITIALIZE: disabling +initialize fork "</span></span><br><span class="line"><span class="comment">//                             "safety enforcement because the app is "</span></span><br><span class="line"><span class="comment">//                             "too old.)");</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; hCount; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> hi = hList[i];</span><br><span class="line">            <span class="keyword">auto</span> mh = hi-&gt;mhdr();</span><br><span class="line">            <span class="keyword">if</span> (mh-&gt;filetype != MH_EXECUTE) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line">            <span class="keyword">if</span> (getsectiondata(hi-&gt;mhdr(), <span class="string">"__DATA"</span>, <span class="string">"__objc_fork_ok"</span>, &amp;<span class="built_in">size</span>)) &#123;</span><br><span class="line">                DisableInitializeForkSafety = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (PrintInitializing) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"INITIALIZE: disabling +initialize fork "</span></span><br><span class="line">                                 <span class="string">"safety enforcement because the app has "</span></span><br><span class="line">                                 <span class="string">"a __DATA,__objc_fork_ok section"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// assume only one MH_EXECUTE image</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">///核心方法</span></span><br><span class="line">        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    firstTime = NO;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Call image load funcs after everything is set up.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> func : loadImageFuncs) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; mhCount; i++) &#123;</span><br><span class="line">            func(mhdrs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>map_images_nolock</code>方法比较长，很大一部分代码是读取镜像的准备，核心调用是<code>_read_images</code>方法。</p>
<h4 id="read-images分析"><a href="#read-images分析" class="headerlink" title="_read_images分析"></a>_read_images分析</h4><p><code>_read_images</code>有三百多行代码，一行行读容易迷失，我们先将方法内的<code>{}</code>语句隐藏，从全局看这个方法都做了什么：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb4ae662921c4152b253cff8c4042a2a~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-07-17 12.56.13"></p>
<p>这个方法有个特点就是没执行完一个代码块都会执行<code>ts.log()</code>函数打印代码段都做了什么，这样子我们大体知道<code>_read_images</code>的主流程：</p>
<ul>
<li>条件控制进⾏⼀次的加载</li>
<li>修复预编译阶段的 @selector 的混乱问题</li>
<li>错误混乱的类处理</li>
<li>修复重映射⼀些没有被镜像⽂件加载进来的类</li>
<li>修复⼀些消息</li>
<li>当我们类⾥⾯有协议的时候 : readProtocol</li>
<li>修复没有被加载的协议</li>
<li>分类处理</li>
<li>类的加载处理</li>
<li>没有被处理的类 优化那些被侵犯的类</li>
</ul>
<h4 id="first-time-tasks即：条件控制进⾏⼀次的加载"><a href="#first-time-tasks即：条件控制进⾏⼀次的加载" class="headerlink" title="first time tasks即：条件控制进⾏⼀次的加载"></a>first time tasks即：条件控制进⾏⼀次的加载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!doneOnce) &#123;</span><br><span class="line">        doneOnce = YES;</span><br><span class="line">        launchTime = YES;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">        <span class="comment">// Disable non-pointer isa under some conditions.</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class="line">        <span class="comment">// Disable nonpointer isa if any image contains old Swift code</span></span><br><span class="line">        <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hi-&gt;info()-&gt;containsSwift()  &amp;&amp;</span><br><span class="line">                hi-&gt;info()-&gt;swiftUnstableVersion() &lt; objc_image_info::SwiftVersion3)</span><br><span class="line">            &#123;</span><br><span class="line">                DisableNonpointerIsa = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (PrintRawIsa) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"RAW ISA: disabling non-pointer isa because "</span></span><br><span class="line">                                 <span class="string">"the app or a framework contains Swift code "</span></span><br><span class="line">                                 <span class="string">"older than Swift 3.0"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> TARGET_OS_OSX</span></span><br><span class="line">        <span class="comment">// Disable non-pointer isa if the app is too old</span></span><br><span class="line">        <span class="comment">// (linked before OS X 10.11)</span></span><br><span class="line"><span class="comment">//        if (!dyld_program_sdk_at_least(dyld_platform_version_macOS_10_11)) &#123;</span></span><br><span class="line"><span class="comment">//            DisableNonpointerIsa = true;</span></span><br><span class="line"><span class="comment">//            if (PrintRawIsa) &#123;</span></span><br><span class="line"><span class="comment">//                _objc_inform("RAW ISA: disabling non-pointer isa because "</span></span><br><span class="line"><span class="comment">//                             "the app is too old.");</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Disable non-pointer isa if the app has a __DATA,__objc_rawisa section</span></span><br><span class="line">        <span class="comment">// New apps that load old extensions may need this.</span></span><br><span class="line">        <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hi-&gt;mhdr()-&gt;filetype != MH_EXECUTE) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line">            <span class="keyword">if</span> (getsectiondata(hi-&gt;mhdr(), <span class="string">"__DATA"</span>, <span class="string">"__objc_rawisa"</span>, &amp;<span class="built_in">size</span>)) &#123;</span><br><span class="line">                DisableNonpointerIsa = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (PrintRawIsa) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"RAW ISA: disabling non-pointer isa because "</span></span><br><span class="line">                                 <span class="string">"the app has a __DATA,__objc_rawisa section"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// assume only one MH_EXECUTE image</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DisableTaggedPointers) &#123;</span><br><span class="line">            disableTaggedPointers();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">///初始化TaggedPointer混淆</span></span><br><span class="line">        initializeTaggedPointerObfuscator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"CLASS: found %d classes during launch"</span>, totalClasses);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// namedClasses</span></span><br><span class="line">        <span class="comment">// Preoptimized classes don't go in this table.</span></span><br><span class="line">        <span class="comment">// 4/3 is NXMapTable's load factor</span></span><br><span class="line">        <span class="comment">// objc::unattachedCategories.init(32);</span></span><br><span class="line">        <span class="comment">// objc::allocatedClasses.init();</span></span><br><span class="line">        <span class="comment">//负载因子</span></span><br><span class="line">        <span class="keyword">int</span> namedClassesSize = </span><br><span class="line">            (isPreoptimized() ? unoptimizedTotalClasses : totalClasses) * <span class="number">4</span> / <span class="number">3</span>;</span><br><span class="line">  	    <span class="comment">//创建一张类的总表，包含所有的类</span></span><br><span class="line">        gdb_objc_realized_classes =</span><br><span class="line">            NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);</span><br><span class="line">        ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: first time tasks"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>主要做了两件事情</p>
<ul>
<li>初始化小对象(<code>TaggedPointer</code>)</li>
<li>创建所有类的总表,注意这个表和<code>runtime_init</code>中<code>allocatedClassess</code>的表不一样，这里是所有类的表，而<code>allocatedClassess</code>是已经实现(<code>allocated</code>)的类的表。</li>
</ul>
<h4 id="fix-up-selector-references即：修复预编译阶段的-selector-的混乱问题"><a href="#fix-up-selector-references即：修复预编译阶段的-selector-的混乱问题" class="headerlink" title="fix up selector references即：修复预编译阶段的 @selector 的混乱问题"></a>fix up selector references即：修复预编译阶段的 @selector 的混乱问题</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> UnfixedSelectors;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(selLock)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hi-&gt;hasPreoptimizedSelectors()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> isBundle = hi-&gt;isBundle();</span><br><span class="line">        SEL *sels = _getObjc2SelectorRefs(hi, &amp;count);</span><br><span class="line">        UnfixedSelectors += count;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *name = sel_cname(sels[i]);</span><br><span class="line">            SEL sel = sel_registerNameNoLock(name, isBundle);</span><br><span class="line">            <span class="keyword">if</span> (sels[i] != sel) &#123;</span><br><span class="line">                sels[i] = sel;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: fix up selector references"</span>);</span><br></pre></td></tr></table></figure>

<p><code>selecotr</code>是类的名字+地址。</p>
<ul>
<li><code>SEL *sels = _getObjc2SelectorRefs(hi, &amp;count);</code>是从<code>Mach-o</code>文件读取的</li>
<li><code>SEL sel = sel_registerNameNoLock(name, isBundle);</code>是从<code>dyld</code>链接之后获取的</li>
<li>如果两个<code>sel</code>名字相等，地址不同就需要<code>fix up</code>。</li>
</ul>
<h4 id="discover-classes即：错误混乱的类处理"><a href="#discover-classes即：错误混乱的类处理" class="headerlink" title="discover classes即：错误混乱的类处理"></a>discover classes即：错误混乱的类处理</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discover classes. Fix up unresolved future classes. Mark bundle classes.</span></span><br><span class="line"><span class="keyword">bool</span> hasDyldRoots = dyld_shared_cache_some_image_overridden();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="keyword">if</span> (! mustReadClasses(hi, hasDyldRoots)) &#123;</span><br><span class="line">        <span class="comment">// Image is sufficiently optimized that we need not call readClass()</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从mach-o读取类</span></span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist = _getObjc2ClassList(hi, &amp;count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> headerIsBundle = hi-&gt;isBundle();</span><br><span class="line">    <span class="keyword">bool</span> headerIsPreoptimized = hi-&gt;hasPreoptimizedClasses();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">//cls 目前没有名字</span></span><br><span class="line">        Class cls = (Class)classlist[i];</span><br><span class="line">      	<span class="comment">//关联类cls的名字</span></span><br><span class="line">        Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newCls != cls  &amp;&amp;  newCls) &#123;</span><br><span class="line">            <span class="comment">// Class was moved but not deleted. Currently this occurs </span></span><br><span class="line">            <span class="comment">// only when the new class resolved a future class.</span></span><br><span class="line">            <span class="comment">// Non-lazily realize the class below.</span></span><br><span class="line">            resolvedFutureClasses = (Class *)</span><br><span class="line">                <span class="built_in">realloc</span>(resolvedFutureClasses, </span><br><span class="line">                        (resolvedFutureClassCount+<span class="number">1</span>) * <span class="keyword">sizeof</span>(Class));</span><br><span class="line">            resolvedFutureClasses[resolvedFutureClassCount++] = newCls;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: discover classes"</span>);</span><br></pre></td></tr></table></figure>

<p>修复未处理的将来的类。给类关联上名字。下面我们重点探索一下<code>readClass</code>:</p>
<h4 id="readClass"><a href="#readClass" class="headerlink" title="readClass"></a>readClass</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Class <span class="title">readClass</span><span class="params">(Class cls, <span class="keyword">bool</span> headerIsBundle, <span class="keyword">bool</span> headerIsPreoptimized)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mangledName = cls-&gt;nonlazyMangledName();</span><br><span class="line">    <span class="comment">///以下代码 为笔者添加 方便调试到自定义的类（因为所以类都会执行这里，我们只关心我们定义的类）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *customerClassName = <span class="string">"JSPerson"</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(mangledName, LGPersonName) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//打印类名</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s -: 要研究的类: - %s\n"</span>,__func__,mangledName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (missingWeakSuperclass(cls)) &#123;</span><br><span class="line">        <span class="comment">// No superclass (probably weak-linked). </span></span><br><span class="line">        <span class="comment">// Disavow any knowledge of this subclass.</span></span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"CLASS: IGNORING class '%s' with "</span></span><br><span class="line">                         <span class="string">"missing weak-linked superclass"</span>, </span><br><span class="line">                         cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        addRemappedClass(cls, nil);</span><br><span class="line">        cls-&gt;setSuperclass(nil);</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cls-&gt;fixupBackwardDeployingStableSwift();</span><br><span class="line"></span><br><span class="line">    Class replacing = nil;</span><br><span class="line">    <span class="keyword">if</span> (mangledName != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Class newCls = popFutureNamedClass(mangledName)) &#123;</span><br><span class="line">            <span class="comment">//断点调试 这里并没有执行</span></span><br><span class="line">            <span class="comment">// This name was previously allocated as a future class.</span></span><br><span class="line">            <span class="comment">// Copy objc_class to future class's struct.</span></span><br><span class="line">            <span class="comment">// Preserve future's rw data block.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newCls-&gt;isAnySwift()) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">"Can't complete future class request for '%s' "</span></span><br><span class="line">                            <span class="string">"because the real class is too big."</span>,</span><br><span class="line">                            cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">class_rw_t</span> *rw = newCls-&gt;data();</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *old_ro = rw-&gt;ro();</span><br><span class="line">            <span class="built_in">memcpy</span>(newCls, cls, <span class="keyword">sizeof</span>(objc_class));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Manually set address-discriminated ptrauthed fields</span></span><br><span class="line">            <span class="comment">// so that newCls gets the correct signatures.</span></span><br><span class="line">            newCls-&gt;setSuperclass(cls-&gt;getSuperclass());</span><br><span class="line">            newCls-&gt;initIsa(cls-&gt;getIsa());</span><br><span class="line"></span><br><span class="line">            rw-&gt;set_ro((<span class="keyword">class_ro_t</span> *)newCls-&gt;data());</span><br><span class="line">            newCls-&gt;setData(rw);</span><br><span class="line">            freeIfMutable((<span class="keyword">char</span> *)old_ro-&gt;getName());</span><br><span class="line">            <span class="built_in">free</span>((<span class="keyword">void</span> *)old_ro);</span><br><span class="line"></span><br><span class="line">            addRemappedClass(cls, newCls);</span><br><span class="line"></span><br><span class="line">            replacing = cls;</span><br><span class="line">            cls = newCls;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (headerIsPreoptimized  &amp;&amp;  !replacing) &#123;</span><br><span class="line">        <span class="comment">// class list built in shared cache</span></span><br><span class="line">        <span class="comment">// fixme strict assert doesn't work because of duplicates</span></span><br><span class="line">        <span class="comment">// ASSERT(cls == getClass(name));</span></span><br><span class="line">        ASSERT(mangledName == <span class="literal">nullptr</span> || getClassExceptSomeSwift(mangledName));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mangledName) &#123; <span class="comment">//some Swift generic classes can lazily generate their names</span></span><br><span class="line">            <span class="comment">///给类添加名字</span></span><br><span class="line">            addNamedClass(cls, mangledName, replacing);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	<span class="comment">///元类也处理</span></span><br><span class="line">            Class meta = cls-&gt;ISA();</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *metaRO = meta-&gt;bits.safe_ro();</span><br><span class="line">            ASSERT(metaRO-&gt;getNonMetaclass() &amp;&amp; <span class="string">"Metaclass with lazy name must have a pointer to the corresponding nonmetaclass."</span>);</span><br><span class="line">            ASSERT(metaRO-&gt;getNonMetaclass() == cls &amp;&amp; <span class="string">"Metaclass nonmetaclass pointer must equal the original class."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">///添加到class表</span></span><br><span class="line">        addClassTableEntry(cls);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for future reference: shared cache never contains MH_BUNDLEs</span></span><br><span class="line">    <span class="keyword">if</span> (headerIsBundle) &#123;</span><br><span class="line">        cls-&gt;data()-&gt;flags |= RO_FROM_BUNDLE;</span><br><span class="line">        cls-&gt;ISA()-&gt;data()-&gt;flags |= RO_FROM_BUNDLE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们从返回值开始看<code>cls</code>,<code>cls</code>也是入参，经过<code>readClass</code>之后有了名字，主要作用就是对类及元类赋值名字并放入方法表中。</p>
<h4 id="addNamedClass-添加方法名字"><a href="#addNamedClass-添加方法名字" class="headerlink" title="addNamedClass 添加方法名字"></a>addNamedClass 添加方法名字</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addNamedClass</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, Class replacing = nil)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    Class old;</span><br><span class="line">    <span class="keyword">if</span> ((old = getClassExceptSomeSwift(name))  &amp;&amp;  old != replacing) &#123;</span><br><span class="line">        inform_duplicate(name, old, cls);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// getMaybeUnrealizedNonMetaClass uses name lookups.</span></span><br><span class="line">        <span class="comment">// Classes not found by name lookup must be in the</span></span><br><span class="line">        <span class="comment">// secondary meta-&gt;nonmeta table.</span></span><br><span class="line">        addNonMetaClass(cls);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        NXMapInsert(gdb_objc_realized_classes, name, cls);</span><br><span class="line">    &#125;</span><br><span class="line">    ASSERT(!(cls-&gt;data()-&gt;flags &amp; RO_META));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wrong: constructed classes are already realized when they get here</span></span><br><span class="line">    <span class="comment">// ASSERT(!cls-&gt;isRealized());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="addClassTableEntry"><a href="#addClassTableEntry" class="headerlink" title="addClassTableEntry"></a>addClassTableEntry</h4><p>将类添加到表里面，如果addMeta为真，并且将当前类的元类也添加到所有的表中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">addClassTableEntry(Class cls, <span class="keyword">bool</span> addMeta = <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This class is allowed to be a known class via the shared cache or via</span></span><br><span class="line">    <span class="comment">// data segments, but it is not allowed to be in the dynamic table already.</span></span><br><span class="line">    <span class="comment">//// 该类允许通过共享缓存或数据段成为已知类，但不允许已经在动态表中。</span></span><br><span class="line">    <span class="keyword">auto</span> &amp;<span class="built_in">set</span> = objc::allocatedClasses.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    ASSERT(<span class="built_in">set</span>.<span class="built_in">find</span>(cls) == <span class="built_in">set</span>.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isKnownClass(cls))</span><br><span class="line">        <span class="built_in">set</span>.insert(cls);</span><br><span class="line">    <span class="keyword">if</span> (addMeta)</span><br><span class="line">        <span class="comment">//元类插入到所有类表中</span></span><br><span class="line">        addClassTableEntry(cls-&gt;ISA(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇我们主要是对<code>objc_init</code>的流程做了一个简单的梳理，分析了<code>readClass</code>方法的作用，下一篇我们开始详细分析类的加载过程。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/07/08/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-dyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/08/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-dyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">iOS底层探索 - dyld加载流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-08 21:00:24" itemprop="dateCreated datePublished" datetime="2021-07-08T21:00:24+08:00">2021-07-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-11 00:43:08" itemprop="dateModified" datetime="2021-07-11T00:43:08+08:00">2021-07-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文我们主要探索应用程序的加载流程，也就是<code>main</code>方法之前，链接器都做了什么。了解这些对我们项目的<code>启动优化</code>有很大帮助。</p>
<h3 id="编译过程和库"><a href="#编译过程和库" class="headerlink" title="编译过程和库"></a>编译过程和库</h3><h4 id="编译的过程"><a href="#编译的过程" class="headerlink" title="编译的过程"></a>编译的过程</h4><p>我们知道库是一种<code>可执行文件</code>,从源代码到可执行文件工经历了下面几个步骤：</p>
<ul>
<li><code>源文件</code>：主要就是我们写的代码，.h、.m、.cpp等文件。</li>
<li><code>预编译</code>：主要处理哪些源代码文件中以<code>#</code>开始的预编译指令，比如<code>#include</code>、<code>#define</code>、删除所有的注释<code>//</code>和<code>/* */</code>、添加行号和文件名标识、保留所有的<code>#pragma</code>编译期指令、产生<code>.i</code>文件。</li>
<li><code>编译</code>：将<code>预处理</code>完的文件进行<code>词法分析</code>、<code>语义分析</code>及优化后输出汇编代码文件即<code>.s</code>文件。</li>
<li><code>汇编</code>：将<code>汇编代码</code>转变成机器可以执行的指令即<code>.o</code>文件。</li>
<li><code>链接</code>：对.o文件中引用其他库的地方进行引用，生成最后的可执行文件</li>
</ul>
<h4 id="动态库和静态库"><a href="#动态库和静态库" class="headerlink" title="动态库和静态库"></a>动态库和静态库</h4><p>我们项目中经常会使用到<code>动态库</code>和<code>静态库</code>,它们的区别是：</p>
<ul>
<li>静态库：在链接阶段会将汇编生成的目标文件和引用的库一起链接打包到可执行文件中。即静态库在<code>链接</code>阶段就被载入了。<ul>
<li>优点：编译完成之后的目标程序没有<code>外部依赖</code>,可以直接运行。</li>
<li>缺点：静态库可以会有多份，会导致<code>目标程序</code>体积增加，对内存、性能、速度消耗较大。</li>
</ul>
</li>
<li>动态库：程序编译并不会链接到目标代码中，在程序可执行文件里面会保留对动态库的引用，在程序<code>运行时</code>才被载入，苹果大部分官方的库都是<code>动态库</code>。<ul>
<li>优点：<ol>
<li>可以减少<code>App</code>包体积大小：因为不需要拷贝到<code>目标程序</code>中，所以不会影响<code>目标程序</code>的体积.</li>
<li>共享内存，节约资源：同一份库可以被多个程序使用。</li>
<li>可以更新动态库，而目标程序不需要重新编译：这是因为动态库<code>运行时</code>才载入，可以随时对库进行替换，而·不需要重新编译代码。</li>
</ol>
</li>
<li>缺点：由于是<code>运行时</code>载入会带来一部分性能损失，使用动态库使得程序依赖于外部环境，如果环境缺少了动态库程序就无法运行。</li>
</ul>
</li>
</ul>
<h3 id="dyld是什么"><a href="#dyld是什么" class="headerlink" title="dyld是什么"></a>dyld是什么</h3><p><code>dyld</code>是<code>动态链接器</code>,目前最新的版本是<code>dyld3</code>,我们首先看一下<code>dyld</code>的版本演变。在<code>dyld</code>之前，<code>NeXT</code>使用的是<code>静态二进制</code>数据。</p>
<h4 id="dyld版本演变"><a href="#dyld版本演变" class="headerlink" title="dyld版本演变"></a><code>dyld</code>版本演变</h4><ul>
<li><code>dyld1.0</code>(1996-2004)<ul>
<li>包含在<code>NeXTStep 3.3</code>中</li>
<li>历史早于标准化<code>POSIX dlopen()</code>的调用</li>
<li><code>macOS 10</code>之前编写第三方包装器用来以支持标准<code>Unix</code>软件，但是这些包装器并不能完美的支持相同的语义，在边界情况不能正常工作。</li>
<li>在大多数使用<code>C++</code>动态库的系统之前编写的。</li>
<li>在<code>mac OS 10.0</code>增加了<code>预绑定</code>。使用<code>预绑定</code>技术为系统中所有的<code>dylib</code>和我们的程序找到<code>固定地址</code>,<code>动态加载器</code>将会加载这些地址的所有内容。</li>
</ul>
</li>
<li><code>dyld2.0</code>(2004-2007)<ul>
<li>包含在<code>macOS Tiger</code>中</li>
<li>相比<code>1.0</code>版本是完全重写(Complete rewrite)的。</li>
<li>支持了<code>C++</code>初始化语义，扩展了<code>mach-o</code>格式。</li>
<li>有完整的本地(native)<code>dlopen</code>和<code>dlsym</code>的实现。</li>
<li><code>2.0</code>版本设计的目标是<code>提高速度</code>，仅进行有限的及安全性检查。</li>
<li>提高了安全性。</li>
<li>减少<code>预编译</code>的工作量(时长)</li>
</ul>
</li>
<li><code>dyld2.x</code>(2007-2017)<ul>
<li>增加了更多的基础架构和平台，比如<code>x86</code>、<code>x86_64</code>、<code>arm</code>、<code>arm64</code>、<code>iOS</code>、<code>tvOS</code>、<code>watchOS</code>。</li>
<li>增强了安全性。增加<code>代码签名</code>和<code>ASLR</code>(地址空间配置随机加载)，增加了<code>mach-o</code>头文件中的项目<code>边界检查</code>功能它可以避免恶意二进制数据的加入。</li>
<li>增强了性能：用<code>共享缓存</code>代替了<code>预绑定</code>。<code>共享缓存</code>是一个包含大部分<code>系统dylib</code>的单文件(Single file)，可以节省大量内存，它实际是<code>预链接</code>库。</li>
</ul>
</li>
<li><code>dyld3</code>（2017-至今）<ul>
<li>完全改变<code>动态链接器</code>的概念</li>
<li>默认适用于大部分<code>Apple OS</code>系统应用。</li>
<li>完全替代了<code>dyld2.x</code>。</li>
<li>提高了性能，尽量提高启动速度和运行速度。</li>
<li>提高安全性：将大多数<code>dyld</code>移出进程，允许部分<code>dyld</code>驻留在进程之中，驻留部分尽可能小，从而减少受攻击的面积。</li>
<li>可测试性和可靠性</li>
</ul>
</li>
</ul>
<h4 id="dyld-2和dyld-3加载过程的区别"><a href="#dyld-2和dyld-3加载过程的区别" class="headerlink" title="dyld 2和dyld 3加载过程的区别"></a><code>dyld 2</code>和<code>dyld 3</code>加载过程的区别</h4><ul>
<li><p><code>dyld 2</code>的加载过程</p>
<ol>
<li><code>Parse mach-o headers</code>:分析<code>mach-o</code>文件，通过分析<code>mach-o</code>文件弄清楚需要那些库，这些库可能需要其他库，所以会进行递归分析，直到获得所有<code>dylib</code>的完整图。一般普通<code>iOS</code>程序需要3-600个<code>dylib</code>，数据庞大，需要进行大量的处理。</li>
<li><code>Map mach-o files</code>:映射所有<code>mach-o</code>文件，将它们放入地址空间</li>
<li><code>Perform symbol lookups</code>：执行符号查找，例如程序使用了<code>printf</code>函数，将会查找<code>printf</code>是否在库系统中，然后找到它的地址，将它复制到你的程序中的函数指针。</li>
<li><code>Bind and rebase</code>:绑定和基址重置，复制<code>3</code>步的指针，由于使用随机地址，所有指针必须使用基址。</li>
<li><code>Run initializers</code>:运行初始化器，接下来准备执行<code>main</code>函数。</li>
</ol>
<p>流程图如下图，其中红色表示影响性能和安全性的步骤：</p>
</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/073f41507a9245fca094630f0fceb1e3~tplv-k3u1fbpfcp-watermark.image" alt="dyld2process"></p>
<ul>
<li><p><code>dyld3</code>加载过程</p>
<p><code>dyld3</code>包括三个部分：</p>
<ul>
<li><p><code>An out of process MachO parser/compiler</code>：进程外<code>mach-o</code>分析器和编译器。</p>
<ol>
<li><code>Resolves all search paths, @rpaths, environment variables</code>:解析所有搜索路径、<code>rpaths</code>、环境变量。</li>
<li><code>Parses the mach-o binaries</code>:分析<code>mach-o</code>二进制数据</li>
<li><code>Perform symbol lookups</code>：执行符号查找，例如程序使用了<code>printf</code>函数，将会查找<code>printf</code>是否在库系统中，然后找到它的地址，将它复制到你的程序中的函数指针。</li>
<li><code>Creates a launch closure with results</code>：创建收尾处理</li>
</ol>
</li>
<li><p><code>An in-process engine that runs launch</code>：进程内引擎执行启动收尾处理，进驻在内存中。</p>
<ol start="5">
<li><code>Validates launch closure</code>：检查启动收尾处理是否正确。</li>
<li><code>Maps in all dylibs</code>：映射到所有的<code>dylib</code>中</li>
<li><code>Applies fixups</code>：应用修正</li>
<li><code>Run initializers</code>:运行初始化器，接下来准备执行<code>main</code>函数。</li>
</ol>
</li>
<li><p><code>A launch closure caching service</code>：启动收尾缓存服务。大部分程序启动会使用缓存但始终不需要调用进程外<code>mach-o</code>分析器和编译器，启动收尾比<code>mach-o</code>更简单，启动收尾文件是内存映射文件，不需要用复杂的方法进行分析从而提高速度。</p>
<p>流程图(来源WWDC ppt)如下：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8aecf047e2548d9b1940488215457e1~tplv-k3u1fbpfcp-watermark.image" alt="dyld3"></p>
</li>
</ul>
</li>
</ul>
<p>注：本小节内容来源于<a href="https://developer.apple.com/videos/play/wwdc2017/413" target="_blank" rel="noopener">WWDC2017 App Startup Time: Past, Present, and Future</a>感兴趣的童鞋可以查看视频。</p>
<h3 id="dyld加载流程分析"><a href="#dyld加载流程分析" class="headerlink" title="dyld加载流程分析"></a>dyld加载流程分析</h3><p>通过上一小节我们其实对<code>dyld</code>的加载有一个初步的了解了，本小节主要通过看源码来探索一下加载流程。本小节需要的源码有：</p>
<ul>
<li><code>dyld</code></li>
<li><code>libobjc</code></li>
<li><code>libSystem</code></li>
<li><code>libdispatch</code></li>
</ul>
<p>源码可直接去<a href="https://opensource.apple.com/tarballs/" target="_blank" rel="noopener">苹果<code>Source Browser</code></a>下载</p>
<h4 id="dyldstart探索"><a href="#dyldstart探索" class="headerlink" title="dyldstart探索"></a><code>dyld</code>start探索</h4><ul>
<li><p>通过<code>main</code>函数</p>
<p>因为我们程序的入口是<code>main</code>函数，<code>dyld</code>是在<code>main</code>之前执行的，我们很容易想到在<code>main</code>函数打一个断点，然后查看调用堆栈信息来查看<code>dyld</code>的具体调用方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) bt</span><br><span class="line">* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1</span><br><span class="line">  * frame #<span class="number">0</span>: <span class="number">0x000000010000339b</span> DyldTest`main(argc=<span class="number">3</span>, argv=<span class="number">0x00007ffeefbff500</span>) at main.m:<span class="number">13</span>:<span class="number">5</span></span><br><span class="line">    frame #<span class="number">1</span>: <span class="number">0x00007fff6e7d3cc9</span> libdyld.dylib`start + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>通过这个方式我们看到了<code>start</code>,但是通过打符号断点并没有找到<code>start</code>方法，所以这种方式无效。</p>
</li>
<li><p>通过<code>load</code>方法</p>
<p>根据我们的经验，我们知道<code>load</code>方法是在<code>main</code>函数之前执行的，我们通过<code>load</code>方法能不能找到<code>dyld</code>的入口呢，心动不如行动，我们试一下，在<code>ViewController</code>类加入<code>load</code>方法，打上断点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(lldb) bt</span><br><span class="line">* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1</span><br><span class="line">  * frame #<span class="number">0</span>: <span class="number">0x00000001000032d7</span> DyldTest`+[ViewController load](self=ViewController, _cmd=<span class="string">"load"</span>) at ViewController.m:<span class="number">19</span>:<span class="number">5</span></span><br><span class="line">    frame #<span class="number">1</span>: <span class="number">0x00007fff6d61e560</span> libobjc.A.dylib`load_images + <span class="number">1529</span></span><br><span class="line">    frame #<span class="number">2</span>: <span class="number">0x000000010001626c</span> dyld`dyld::notifySingle(dyld_image_states, ImageLoader <span class="keyword">const</span>*, ImageLoader::InitializerTimingList*) + <span class="number">418</span></span><br><span class="line">    frame #<span class="number">3</span>: <span class="number">0x0000000100029fe9</span> dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext <span class="keyword">const</span>&amp;, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">char</span> <span class="keyword">const</span>*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class="number">475</span></span><br><span class="line">    frame #<span class="number">4</span>: <span class="number">0x00000001000280b4</span> dyld`ImageLoader::processInitializers(ImageLoader::LinkContext <span class="keyword">const</span>&amp;, <span class="keyword">unsigned</span> <span class="keyword">int</span>, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class="number">188</span></span><br><span class="line">    frame #<span class="number">5</span>: <span class="number">0x0000000100028154</span> dyld`ImageLoader::runInitializers(ImageLoader::LinkContext <span class="keyword">const</span>&amp;, ImageLoader::InitializerTimingList&amp;) + <span class="number">82</span></span><br><span class="line">    frame #<span class="number">6</span>: <span class="number">0x00000001000166a8</span> dyld`dyld::initializeMainExecutable() + <span class="number">199</span></span><br><span class="line">    frame #<span class="number">7</span>: <span class="number">0x000000010001bbba</span> dyld`dyld::_main(macho_header <span class="keyword">const</span>*, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">int</span>, <span class="keyword">char</span> <span class="keyword">const</span>**, <span class="keyword">char</span> <span class="keyword">const</span>**, <span class="keyword">char</span> <span class="keyword">const</span>**, <span class="keyword">unsigned</span> <span class="keyword">long</span>*) + <span class="number">6667</span></span><br><span class="line">    frame #<span class="number">8</span>: <span class="number">0x0000000100015227</span> dyld`dyldbootstrap::start(dyld3::MachOLoaded <span class="keyword">const</span>*, <span class="keyword">int</span>, <span class="keyword">char</span> <span class="keyword">const</span>**, dyld3::MachOLoaded <span class="keyword">const</span>*, <span class="keyword">unsigned</span> <span class="keyword">long</span>*) + <span class="number">453</span></span><br><span class="line">    frame #<span class="number">9</span>: <span class="number">0x0000000100015025</span> dyld`_dyld_start + <span class="number">37</span></span><br></pre></td></tr></table></figure>

<p>通过这个堆栈我们看到了<code>_dyld_start</code>就是<code>dyld</code>开始的函数，我们依次探讨堆栈里的方法。</p>
</li>
</ul>
<h4 id="dyld-start"><a href="#dyld-start" class="headerlink" title="_dyld_start"></a>_dyld_start</h4><p>我们首先在<code>dyld</code>源码中搜索<code>_dyld_start</code>,发现是一段汇编代码</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bfcb961c63f48f781b22bf363917866~tplv-k3u1fbpfcp-watermark.image" alt="dyld_start汇编"></p>
<p>通过注释我们可以看到，调用的是<code>dyldbootstrap</code>的<code>start</code>函数。</p>
<h4 id="dyldbootstrap-start"><a href="#dyldbootstrap-start" class="headerlink" title="dyldbootstrap::start"></a>dyldbootstrap::start</h4><p>我们在源码中搜索<code>dyldbootstrap</code>找到<code>命名空间</code>，继续查找<code>start</code>函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  This is code to bootstrap dyld.  This work in normally done for a program by dyld and crt.</span></span><br><span class="line"><span class="comment">//  In dyld we have to do this manually.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">uintptr_t</span> <span class="title">start</span><span class="params">(<span class="keyword">const</span> dyld3::MachOLoaded* appsMachHeader, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[],</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">const</span> dyld3::MachOLoaded* dyldsMachHeader, <span class="keyword">uintptr_t</span>* startGlue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">///省略代码</span></span><br><span class="line">	<span class="comment">// now that we are done bootstrapping dyld, call dyld's main</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> appsSlide = appsMachHeader-&gt;getSlide();</span><br><span class="line">	<span class="keyword">return</span> dyld::_main((macho_header*)appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数关键是最后一行，调用了<code>dyld::_main</code>。</p>
<h4 id="dyld-main"><a href="#dyld-main" class="headerlink" title="dyld::_main"></a><code>dyld::_main</code></h4><p>这个方法很长(900+行)，可以从返回值倒退看这个方法都做了什么。方法太长我们省略大部分代码(因为返回值和<code>mainExecutable</code>相关，所以截取的代码基本都和<code>mainExecutable</code>相关)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">		<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">		<span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">///省略代码</span></span><br><span class="line">  <span class="comment">// Grab the cdHash of the main executable from the environment</span></span><br><span class="line">  <span class="comment">// 创建主程序cdHash的空间</span></span><br><span class="line">	<span class="keyword">uint8_t</span> mainExecutableCDHashBuffer[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">uint8_t</span>* mainExecutableCDHash = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">if</span> ( <span class="keyword">const</span> <span class="keyword">char</span>* mainExeCdHashStr = _simple_getenv(apple, <span class="string">"executable_cdhash"</span>) ) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> bufferLenUsed;</span><br><span class="line">		<span class="keyword">if</span> ( hexStringToBytes(mainExeCdHashStr, mainExecutableCDHashBuffer, <span class="keyword">sizeof</span>(mainExecutableCDHashBuffer), bufferLenUsed) )</span><br><span class="line">			mainExecutableCDHash = mainExecutableCDHashBuffer;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/////配置信息，获取主程序的mach-o header、silder（ASLR的偏移值）</span></span><br><span class="line">	getHostInfo(mainExecutableMH, mainExecutableSlide);</span><br><span class="line">  <span class="comment">///通过silder+ASLR可以找到信息</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> result = <span class="number">0</span>;</span><br><span class="line">	sMainExecutableMachHeader = mainExecutableMH;</span><br><span class="line">	sMainExecutableSlide = mainExecutableSlide;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">///省略代码</span></span><br><span class="line">  <span class="comment">//设置上下文，将这里所有的变量放到了gLinkContext中了，保存起来</span></span><br><span class="line">  setContext(mainExecutableMH, argc, argv, envp, apple);</span><br><span class="line">  <span class="comment">//配置进程是否受限，envp是环境变量</span></span><br><span class="line">  configureProcessRestrictions(mainExecutableMH, envp);</span><br><span class="line">      configureProcessRestrictions(mainExecutableMH, envp);</span><br><span class="line">	<span class="comment">///检测是否强制dyld3</span></span><br><span class="line">	<span class="comment">// Check if we should force dyld3.  Note we have to do this outside of the regular env parsing due to AMFI</span></span><br><span class="line">	<span class="keyword">if</span> ( dyld3::internalInstall() ) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">const</span> <span class="keyword">char</span>* useClosures = _simple_getenv(envp, <span class="string">"DYLD_USE_CLOSURES"</span>)) &#123;</span><br><span class="line">			<span class="keyword">if</span> ( <span class="built_in">strcmp</span>(useClosures, <span class="string">"0"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">				sClosureMode = ClosureMode::Off;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(useClosures, <span class="string">"1"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">	#<span class="keyword">if</span> !__i386__ <span class="comment">// don't support dyld3 for 32-bit macOS</span></span><br><span class="line">				sClosureMode = ClosureMode::On;</span><br><span class="line">				sClosureKind = ClosureKind::full;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(useClosures, <span class="string">"2"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">				sClosureMode = ClosureMode::On;</span><br><span class="line">				sClosureKind = ClosureKind::minimal;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				dyld::warn(<span class="string">"unknown option to DYLD_USE_CLOSURES.  Valid options are: 0 and 1\n"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_OSX</span></span><br><span class="line">    <span class="comment">///受限制的进程，环境变量可能会变化，需要重新设置</span></span><br><span class="line">    <span class="keyword">if</span> ( !gLinkContext.allowEnvVarsPrint &amp;&amp; !gLinkContext.allowEnvVarsPath &amp;&amp; !gLinkContext.allowEnvVarsSharedCache ) &#123;</span><br><span class="line">		pruneEnvironmentVariables(envp, &amp;apple);</span><br><span class="line">		<span class="comment">// set again because envp and apple may have changed or moved</span></span><br><span class="line">		setContext(mainExecutableMH, argc, argv, envp, apple);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">#endif</span><br><span class="line">	&#123;</span><br><span class="line">    <span class="comment">///检查环境变量</span></span><br><span class="line">		checkEnvironmentVariables(envp);</span><br><span class="line">    <span class="comment">///default value for DYLD_FALLBACK_FRAMEWORK_PATH, if not set in environment</span></span><br><span class="line">    <span class="comment">///如果没有环境变量 设置默认值</span></span><br><span class="line">		defaultUninitializedFallbackPaths(envp);</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// load shared cache 加载共享缓存</span></span><br><span class="line">	checkSharedRegionDisable((dyld3::MachOLoaded*)mainExecutableMH, mainExecutableSlide)</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> !TARGET_OS_SIMULATOR</span></span><br><span class="line">  <span class="comment">///是否有启动闭包 dyld3有闭包</span></span><br><span class="line">	<span class="keyword">if</span> ( sClosureMode == ClosureMode::Off ) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( gLinkContext.verboseWarnings )</span><br><span class="line">			dyld::<span class="built_in">log</span>(<span class="string">"dyld: not using closures\n"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">///dyld3有闭包</span></span><br><span class="line">    <span class="comment">///设置加载启动模式</span></span><br><span class="line">		sLaunchModeUsed = DYLD_LAUNCH_MODE_USING_CLOSURE;</span><br><span class="line">    <span class="comment">///配置闭包</span></span><br><span class="line">		<span class="keyword">const</span> dyld3::closure::LaunchClosure* mainClosure = <span class="literal">nullptr</span>;</span><br><span class="line">		dyld3::closure::LoadedFileInfo mainFileInfo;</span><br><span class="line">		mainFileInfo.fileContent = mainExecutableMH;</span><br><span class="line">		mainFileInfo.path = sExecPath;</span><br><span class="line">    <span class="comment">// check for closure in cache first</span></span><br><span class="line">    <span class="comment">// 判断缓存中是否已经有闭包</span></span><br><span class="line">		<span class="keyword">if</span> ( sSharedCacheLoadInfo.loadAddress != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">			mainClosure = sSharedCacheLoadInfo.loadAddress-&gt;findClosure(sExecPath);</span><br><span class="line">			<span class="keyword">if</span> ( gLinkContext.verboseWarnings &amp;&amp; (mainClosure != <span class="literal">nullptr</span>) )</span><br><span class="line">				dyld::<span class="built_in">log</span>(<span class="string">"dyld: found closure %p (size=%lu) in dyld shared cache\n"</span>, mainClosure, mainClosure-&gt;<span class="built_in">size</span>());</span><br><span class="line">			<span class="keyword">if</span> ( mainClosure != <span class="literal">nullptr</span> )</span><br><span class="line">				sLaunchModeUsed |= DYLD_LAUNCH_MODE_CLOSURE_FROM_OS;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">///如果闭包已失效</span></span><br><span class="line">    <span class="keyword">if</span> ( (mainClosure != <span class="literal">nullptr</span>) &amp;&amp; !closureValid(mainClosure, mainFileInfo, mainExecutableCDHash, <span class="literal">true</span>, envp) ) &#123;</span><br><span class="line">			mainClosure = <span class="literal">nullptr</span>;</span><br><span class="line">			sLaunchModeUsed &amp;= ~DYLD_LAUNCH_MODE_CLOSURE_FROM_OS;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">///没有闭包创建一个</span></span><br><span class="line">    <span class="keyword">if</span> ( (mainClosure == <span class="literal">nullptr</span>) &amp;&amp; allowClosureRebuilds ) &#123;</span><br><span class="line">			<span class="comment">// if forcing closures, and no closure in cache, or it is invalid, check for cached closure</span></span><br><span class="line">			<span class="keyword">if</span> ( !sForceInvalidSharedCacheClosureFormat )</span><br><span class="line">				mainClosure = findCachedLaunchClosure(mainExecutableCDHash, mainFileInfo, envp, bootToken);</span><br><span class="line">			<span class="keyword">if</span> ( mainClosure == <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">				<span class="comment">// if  no cached closure found, build new one</span></span><br><span class="line">				mainClosure = buildLaunchClosure(mainExecutableCDHash, mainFileInfo, envp, bootToken);</span><br><span class="line">				<span class="keyword">if</span> ( mainClosure != <span class="literal">nullptr</span> )</span><br><span class="line">					sLaunchModeUsed |= DYLD_LAUNCH_MODE_BUILT_CLOSURE_AT_LAUNCH;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// try using launch closure 使用启动闭包</span></span><br><span class="line">		<span class="keyword">if</span> ( mainClosure != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">			CRSetCrashLogMessage(<span class="string">"dyld3: launch started"</span>);</span><br><span class="line">			<span class="keyword">if</span> ( mainClosure-&gt;topImage()-&gt;fixupsNotEncoded() )</span><br><span class="line">				sLaunchModeUsed |= DYLD_LAUNCH_MODE_MINIMAL_CLOSURE;</span><br><span class="line">      <span class="keyword">bool</span> closureOutOfDate;</span><br><span class="line">			<span class="keyword">bool</span> recoverable;</span><br><span class="line">      <span class="comment">///启动闭包</span></span><br><span class="line">			<span class="keyword">bool</span> launched = launchWithClosure(mainClosure, sSharedCacheLoadInfo.loadAddress, (dyld3::MachOLoaded*)mainExecutableMH,</span><br><span class="line">											  mainExecutableSlide, argc, argv, envp, apple, diag, &amp;result, startGlue, &amp;closureOutOfDate, &amp;recoverable);</span><br><span class="line">      <span class="comment">/// 如果启动失败</span></span><br><span class="line">      <span class="keyword">if</span> ( !launched &amp;&amp; closureOutOfDate &amp;&amp; allowClosureRebuilds ) &#123;</span><br><span class="line">				<span class="comment">// closure is out of date, build new one</span></span><br><span class="line">				mainClosure = buildLaunchClosure(mainExecutableCDHash, mainFileInfo, envp, bootToken);</span><br><span class="line">        <span class="comment">///重新启动</span></span><br><span class="line">        launched = launchWithClosure(mainClosure, sSharedCacheLoadInfo.loadAddress, (dyld3::MachOLoaded*)mainExecutableMH,</span><br><span class="line">												 mainExecutableSlide, argc, argv, envp, apple, diag, &amp;result, startGlue, &amp;closureOutOfDate, &amp;recoverable);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">///启动成功 返回main函数</span></span><br><span class="line">      <span class="keyword">if</span> ( launched ) &#123;</span><br><span class="line">				gLinkContext.startedInitializingMainExecutable = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">if</span> (sSkipMain)</span><br><span class="line">					result = (<span class="keyword">uintptr_t</span>)&amp;fake_main;</span><br><span class="line">				<span class="keyword">return</span> result;</span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">///不是dyld3的省略代码</span></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   <span class="comment">///省略代码</span></span><br><span class="line">   <span class="comment">// load any inserted libraries插入动态库</span></span><br><span class="line">		<span class="keyword">if</span>	( sEnv.DYLD_INSERT_LIBRARIES != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class="literal">NULL</span>; ++lib) </span><br><span class="line">				loadInsertedDylib(*lib);</span><br><span class="line">		&#125;</span><br><span class="line">   <span class="comment">///弱引用绑定主程序</span></span><br><span class="line">   sMainExecutable-&gt;weakBind(gLinkContext);</span><br><span class="line">    <span class="comment">// run all initializers</span></span><br><span class="line">    <span class="comment">// 运行所有initializers</span></span><br><span class="line">		initializeMainExecutable(); </span><br><span class="line">    <span class="comment">// notify any montoring proccesses that this process is about to enter main()</span></span><br><span class="line">    <span class="comment">/// 通知可以进入main函数了</span></span><br><span class="line">		notifyMonitoringDyldMain();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大体流程就是：</p>
<ul>
<li>配置环境变量</li>
<li>检查共享缓存是否开启，以及共享缓存是否映射到共享区域</li>
<li>主程序初始化即<code>instantiateFromLoadedImage</code></li>
<li>插入动态库</li>
<li>link主程序</li>
<li>link动态库</li>
<li>弱符号绑定</li>
<li>执行初始化方法</li>
<li>主程序入口</li>
</ul>
<h4 id="dyld-initializeMainExecutable"><a href="#dyld-initializeMainExecutable" class="headerlink" title="dyld::initializeMainExecutable"></a>dyld::initializeMainExecutable</h4><p>主要是循环遍历执行<code>runInitializers</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initializeMainExecutable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// record that we've reached this step</span></span><br><span class="line">	gLinkContext.startedInitializingMainExecutable = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// run initialzers for any inserted dylibs</span></span><br><span class="line">	ImageLoader::InitializerTimingList initializerTimes[allImagesCount()];</span><br><span class="line">	initializerTimes[<span class="number">0</span>].count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">size_t</span> rootCount = sImageRoots.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> ( rootCount &gt; <span class="number">1</span> ) &#123;</span><br><span class="line">    <span class="comment">///遍历 执行</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">1</span>; i &lt; rootCount; ++i) &#123;</span><br><span class="line">			sImageRoots[i]-&gt;runInitializers(gLinkContext, initializerTimes[<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// run initializers for main executable and everything it brings up </span></span><br><span class="line">	sMainExecutable-&gt;runInitializers(gLinkContext, initializerTimes[<span class="number">0</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// register cxa_atexit() handler to run static terminators in all loaded images when this process exits</span></span><br><span class="line">	<span class="keyword">if</span> ( gLibSystemHelpers != <span class="literal">NULL</span> ) </span><br><span class="line">		(*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// dump info if requested</span></span><br><span class="line">	<span class="keyword">if</span> ( sEnv.DYLD_PRINT_STATISTICS )</span><br><span class="line">		ImageLoader::printStatistics((<span class="keyword">unsigned</span> <span class="keyword">int</span>)allImagesCount(), initializerTimes[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">if</span> ( sEnv.DYLD_PRINT_STATISTICS_DETAILS )</span><br><span class="line">		ImageLoaderMachO::printStatisticsDetails((<span class="keyword">unsigned</span> <span class="keyword">int</span>)allImagesCount(), initializerTimes[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ImageLoader-runInitializers"><a href="#ImageLoader-runInitializers" class="headerlink" title="ImageLoader::runInitializers"></a>ImageLoader::runInitializers</h4><p>核心代码是调用<code>processInitializers</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageLoader::runInitializers</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context, InitializerTimingList&amp; timingInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line">	<span class="keyword">mach_port_t</span> thisThread = mach_thread_self();</span><br><span class="line">	ImageLoader::UninitedUpwards up;</span><br><span class="line">	up.count = <span class="number">1</span>;</span><br><span class="line">	up.imagesAndPaths[<span class="number">0</span>] = &#123; <span class="keyword">this</span>, <span class="keyword">this</span>-&gt;getPath() &#125;;</span><br><span class="line">  <span class="comment">///调用</span></span><br><span class="line">	processInitializers(context, thisThread, timingInfo, up);</span><br><span class="line">	context.notifyBatch(dyld_image_state_initialized, <span class="literal">false</span>);</span><br><span class="line">	mach_port_deallocate(mach_task_self(), thisThread);</span><br><span class="line">	<span class="keyword">uint64_t</span> t2 = mach_absolute_time();</span><br><span class="line">	fgTotalInitTime += (t2 - t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ImageLoader-processInitializers"><a href="#ImageLoader-processInitializers" class="headerlink" title="ImageLoader::processInitializers"></a>ImageLoader::processInitializers</h4><p>对镜像列表调用<code>recursiveInitialization</code>函数进行递归实例化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageLoader::processInitializers</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context, <span class="keyword">mach_port_t</span> thisThread,</span></span></span><br><span class="line"><span class="function"><span class="params">									 InitializerTimingList&amp; timingInfo, ImageLoader::UninitedUpwards&amp; images)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> maxImageCount = context.imageCount()+<span class="number">2</span>;</span><br><span class="line">	ImageLoader::UninitedUpwards upsBuffer[maxImageCount];</span><br><span class="line">	ImageLoader::UninitedUpwards&amp; ups = upsBuffer[<span class="number">0</span>];</span><br><span class="line">	ups.count = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// Calling recursive init on all images in images list, building a new list of</span></span><br><span class="line">	<span class="comment">// uninitialized upward dependencies.</span></span><br><span class="line">  <span class="comment">// 递归实例化</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">uintptr_t</span> i=<span class="number">0</span>; i &lt; images.count; ++i) &#123;</span><br><span class="line">		images.imagesAndPaths[i].first-&gt;recursiveInitialization(context, thisThread, images.imagesAndPaths[i].second, timingInfo, ups);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// If any upward dependencies remain, init them.</span></span><br><span class="line">	<span class="keyword">if</span> ( ups.count &gt; <span class="number">0</span> )</span><br><span class="line">		processInitializers(context, thisThread, timingInfo, ups);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ImageLoader-recursiveInitialization"><a href="#ImageLoader-recursiveInitialization" class="headerlink" title="ImageLoader::recursiveInitialization"></a>ImageLoader::recursiveInitialization</h4><p>主要是加载完镜像后通知出去</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageLoader::recursiveInitialization</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context, <span class="keyword">mach_port_t</span> this_thread, <span class="keyword">const</span> <span class="keyword">char</span>* pathToInitialize,</span></span></span><br><span class="line"><span class="function"><span class="params">										  InitializerTimingList&amp; timingInfo, UninitedUpwards&amp; uninitUps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">///递归锁</span></span><br><span class="line">	<span class="function">recursive_lock <span class="title">lock_info</span><span class="params">(this_thread)</span></span>;</span><br><span class="line">	recursiveSpinLock(lock_info);</span><br><span class="line">	<span class="keyword">if</span> ( fState &lt; dyld_image_state_dependents_initialized<span class="number">-1</span> ) &#123;</span><br><span class="line">		<span class="keyword">uint8_t</span> oldState = fState;</span><br><span class="line">		<span class="comment">// break cycles 结束递归</span></span><br><span class="line">		fState = dyld_image_state_dependents_initialized<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// initialize lower level libraries first</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; libraryCount(); ++i) &#123;</span><br><span class="line">				ImageLoader* dependentImage = libImage(i);</span><br><span class="line">				<span class="keyword">if</span> ( dependentImage != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">					<span class="comment">// don't try to initialize stuff "above" me yet</span></span><br><span class="line">					<span class="keyword">if</span> ( libIsUpward(i) ) &#123;</span><br><span class="line">						uninitUps.imagesAndPaths[uninitUps.count] = &#123; dependentImage, libPath(i) &#125;;</span><br><span class="line">						uninitUps.count++;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> ( dependentImage-&gt;fDepth &gt;= fDepth ) &#123;</span><br><span class="line">						dependentImage-&gt;recursiveInitialization(context, this_thread, libPath(i), timingInfo, uninitUps);</span><br><span class="line">					&#125;</span><br><span class="line">                &#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// record termination order</span></span><br><span class="line">			<span class="keyword">if</span> ( <span class="keyword">this</span>-&gt;needsTermination() )</span><br><span class="line">				context.terminationRecorder(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// let objc know we are about to initialize this image</span></span><br><span class="line">      <span class="comment">// 让objc知道我们要初始化此镜像</span></span><br><span class="line">			<span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line">			fState = dyld_image_state_dependents_initialized;</span><br><span class="line">			oldState = fState;</span><br><span class="line">			context.notifySingle(dyld_image_state_dependents_initialized, <span class="keyword">this</span>, &amp;timingInfo);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// initialize this image</span></span><br><span class="line">      <span class="comment">/// 初始化镜像</span></span><br><span class="line">			<span class="keyword">bool</span> hasInitializers = <span class="keyword">this</span>-&gt;doInitialization(context);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// let anyone know we finished initializing this image</span></span><br><span class="line">      <span class="comment">/// 让任何人都知道我们完成了这个镜像的初始化</span></span><br><span class="line">			fState = dyld_image_state_initialized;</span><br><span class="line">			oldState = fState;</span><br><span class="line">			context.notifySingle(dyld_image_state_initialized, <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> ( hasInitializers ) &#123;</span><br><span class="line">				<span class="keyword">uint64_t</span> t2 = mach_absolute_time();</span><br><span class="line">				timingInfo.addTime(<span class="keyword">this</span>-&gt;getShortName(), t2-t1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line">			<span class="comment">// this image is not initialized</span></span><br><span class="line">			fState = oldState;</span><br><span class="line">			recursiveSpinUnLock();</span><br><span class="line">			<span class="keyword">throw</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	recursiveSpinUnLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dyld-notifySingle"><a href="#dyld-notifySingle" class="headerlink" title="dyld::notifySingle"></a>dyld::notifySingle</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notifySingle</span><span class="params">(dyld_image_states state, <span class="keyword">const</span> ImageLoader* <span class="built_in">image</span>, ImageLoader::InitializerTimingList* timingInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//dyld::log("notifySingle(state=%d, image=%s)\n", state, image-&gt;getPath());</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;dyld_image_state_change_handler&gt;* handlers = stateToHandlers(state, sSingleHandlers);</span><br><span class="line">	<span class="keyword">if</span> ( handlers != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">		dyld_image_info info;</span><br><span class="line">		info.imageLoadAddress	= <span class="built_in">image</span>-&gt;machHeader();</span><br><span class="line">		info.imageFilePath		= <span class="built_in">image</span>-&gt;getRealPath();</span><br><span class="line">		info.imageFileModDate	= <span class="built_in">image</span>-&gt;lastModified();</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;dyld_image_state_change_handler&gt;::iterator it = handlers-&gt;<span class="built_in">begin</span>(); it != handlers-&gt;<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">char</span>* result = (*it)(state, <span class="number">1</span>, &amp;info);</span><br><span class="line">			<span class="keyword">if</span> ( (result != <span class="literal">NULL</span>) &amp;&amp; (state == dyld_image_state_mapped) ) &#123;</span><br><span class="line">				<span class="comment">//fprintf(stderr, "  image rejected by handler=%p\n", *it);</span></span><br><span class="line">				<span class="comment">// make copy of thrown string so that later catch clauses can free it</span></span><br><span class="line">				<span class="keyword">const</span> <span class="keyword">char</span>* str = strdup(result);</span><br><span class="line">				<span class="keyword">throw</span> str;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ( state == dyld_image_state_mapped ) &#123;</span><br><span class="line">		<span class="comment">// &lt;rdar://problem/7008875&gt; Save load addr + UUID for images from outside the shared cache</span></span><br><span class="line">		<span class="comment">// &lt;rdar://problem/50432671&gt; Include UUIDs for shared cache dylibs in all image info when using private mapped shared caches</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">image</span>-&gt;inSharedCache()</span><br><span class="line">			|| (gLinkContext.sharedRegionMode == ImageLoader::kUsePrivateSharedRegion)) &#123;</span><br><span class="line">			dyld_uuid_info info;</span><br><span class="line">			<span class="keyword">if</span> ( <span class="built_in">image</span>-&gt;getUUID(info.imageUUID) ) &#123;</span><br><span class="line">				info.imageLoadAddress = <span class="built_in">image</span>-&gt;machHeader();</span><br><span class="line">				addNonSharedCacheImageUUID(info);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ( (state == dyld_image_state_dependents_initialized) &amp;&amp; (sNotifyObjCInit != <span class="literal">NULL</span>) &amp;&amp; <span class="built_in">image</span>-&gt;notifyObjC() ) &#123;</span><br><span class="line">		<span class="keyword">uint64_t</span> t0 = mach_absolute_time();</span><br><span class="line">		<span class="function">dyld3::ScopedTimer <span class="title">timer</span><span class="params">(DBG_DYLD_TIMING_OBJC_INIT, (<span class="keyword">uint64_t</span>)<span class="built_in">image</span>-&gt;machHeader(), <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">///重点操作</span></span><br><span class="line">		(*sNotifyObjCInit)(<span class="built_in">image</span>-&gt;getRealPath(), <span class="built_in">image</span>-&gt;machHeader());</span><br><span class="line">		<span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line">		<span class="keyword">uint64_t</span> t2 = mach_absolute_time();</span><br><span class="line">		<span class="keyword">uint64_t</span> timeInObjC = t1-t0;</span><br><span class="line">		<span class="keyword">uint64_t</span> emptyTime = (t2-t1)*<span class="number">100</span>;</span><br><span class="line">		<span class="keyword">if</span> ( (timeInObjC &gt; emptyTime) &amp;&amp; (timingInfo != <span class="literal">NULL</span>) ) &#123;</span><br><span class="line">			timingInfo-&gt;addTime(<span class="built_in">image</span>-&gt;getShortName(), timeInObjC);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// mach message csdlc about dynamically unloaded images</span></span><br><span class="line">	<span class="keyword">if</span> ( <span class="built_in">image</span>-&gt;addFuncNotified() &amp;&amp; (state == dyld_image_state_terminated) ) &#123;</span><br><span class="line">		notifyKernel(*<span class="built_in">image</span>, <span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mach_header</span>* <span class="title">loadAddress</span>[] = &#123;</span> <span class="built_in">image</span>-&gt;machHeader() &#125;;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span>* loadPath[] = &#123; <span class="built_in">image</span>-&gt;getPath() &#125;;</span><br><span class="line">		notifyMonitoringDyld(<span class="literal">true</span>, <span class="number">1</span>, loadAddress, loadPath);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其重点是<code>(*sNotifyObjCInit)(image-&gt;getRealPath(), image-&gt;machHeader());</code>，我们全局搜索<code>sNotifyObjCInit</code>并没有实现，但是有赋值操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerObjCNotifiers</span><span class="params">(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// record functions to call</span></span><br><span class="line">	sNotifyObjCMapped	= mapped;</span><br><span class="line">  <span class="comment">///赋值操作</span></span><br><span class="line">	sNotifyObjCInit		= init;</span><br><span class="line">	sNotifyObjCUnmapped = unmapped;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// call 'mapped' function with all images mapped so far</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		notifyBatchPartial(dyld_image_state_bound, <span class="literal">true</span>, <span class="literal">NULL</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line">		<span class="comment">// ignore request to abort during registration</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// &lt;rdar://problem/32209809&gt; call 'init' function on all images already init'ed (below libSystem)</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ImageLoader*&gt;::iterator it=sAllImages.<span class="built_in">begin</span>(); it != sAllImages.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		ImageLoader* <span class="built_in">image</span> = *it;</span><br><span class="line">		<span class="keyword">if</span> ( (<span class="built_in">image</span>-&gt;getState() == dyld_image_state_initialized) &amp;&amp; <span class="built_in">image</span>-&gt;notifyObjC() ) &#123;</span><br><span class="line">			<span class="function">dyld3::ScopedTimer <span class="title">timer</span><span class="params">(DBG_DYLD_TIMING_OBJC_INIT, (<span class="keyword">uint64_t</span>)<span class="built_in">image</span>-&gt;machHeader(), <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">			(*sNotifyObjCInit)(<span class="built_in">image</span>-&gt;getRealPath(), <span class="built_in">image</span>-&gt;machHeader());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>registerObjCNotifiers</code>是在<code>_dyld_objc_notify_register</code>调用，而<code>_dyld_objc_notify_register</code>函数是在<code>libobjc</code>源码<code>_objc_init</code>代用的，所以<code>sNotifyObjCInit</code>的<code>赋值</code>的就是<code>objc</code>中的<code>load_images</code>，而<code>load_images</code>会调用所有的<code>+load</code>方法。所以综上所述，<code>notifySingle</code>是一个<code>回调函数</code>,所以我们继续看<code>load_images</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    runtime_init();</span><br><span class="line">    exception_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    <span class="keyword">cache_t</span>::init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    _imp_implementationWithBlock_init();</span><br><span class="line"></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    didCallDyldNotifyRegister = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="load-images"><a href="#load-images" class="headerlink" title="load_images"></a>load_images</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">load_images(<span class="keyword">const</span> <span class="keyword">char</span> *path __unused, <span class="keyword">const</span> struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!didInitialAttachCategories &amp;&amp; didCallDyldNotifyRegister) &#123;</span><br><span class="line">        didInitialAttachCategories = <span class="literal">true</span>;</span><br><span class="line">        loadAllCategories();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return without taking locks if there are no +load methods here.</span></span><br><span class="line">    <span class="keyword">if</span> (!hasLoadMethods((<span class="keyword">const</span> headerType *)mh)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">recursive_mutex_locker_t</span> <span class="title">lock</span><span class="params">(loadMethodLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Discover load methods</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock2</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">        prepare_load_methods((<span class="keyword">const</span> headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class="line"> 		<span class="comment">// 调用了load方法</span></span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法比较简单，主要调用了<code>call_load_methods</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = NO;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = YES;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>call_load_methods</code>方法的核心就是循环调用<code>load</code>方法。</p>
<p>###总结</p>
<p>load的源码链为：<code>_dyld_start</code> –&gt; <code>dyldbootstrap::start</code> –&gt; <code>dyld::_main</code> –&gt; <code>dyld::initializeMainExecutable</code> –&gt; <code>ImageLoader::runInitializers</code> –&gt; <code>ImageLoader::processInitializers</code> –&gt; <code>ImageLoader::recursiveInitialization</code> –&gt; <code>dyld::notifySingle</code>(是一个回调处理) –&gt; <code>sNotifyObjCInit</code> –&gt; <code>load_images(libobjc.A.dylib)</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jason</p>
  <div class="site-description" itemprop="description">个人技术博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
