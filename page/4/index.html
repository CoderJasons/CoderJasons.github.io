<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yujiusheng.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="个人技术博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Jason的博客">
<meta property="og:url" content="http://yujiusheng.com/page/4/index.html">
<meta property="og:site_name" content="Jason的博客">
<meta property="og:description" content="个人技术博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yujiusheng.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Jason的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jason的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/06/06/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-alloc%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/06/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-alloc%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">iOS底层探索-alloc方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-06 16:23:12" itemprop="dateCreated datePublished" datetime="2021-06-06T16:23:12+08:00">2021-06-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-11 00:27:14" itemprop="dateModified" datetime="2021-07-11T00:27:14+08:00">2021-07-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>alloc</code>是我们日常开发中经常遇到，下面我们从源码层面分析一下，<code>alloc</code>方法的底层。</p>
<h3 id="准备工作-获取源码"><a href="#准备工作-获取源码" class="headerlink" title="准备工作-获取源码"></a>准备工作-获取源码</h3><ul>
<li>从苹果<a href="https://opensource.apple.com/tarballs/" target="_blank" rel="noopener">开源网站</a>下载<code>objc</code>的源码。</li>
<li>根据<a href="https://juejin.cn/post/6914265121183236104" target="_blank" rel="noopener">这个教程</a>将源码调试成可编译的状态<h3 id="开始探究"><a href="#开始探究" class="headerlink" title="开始探究"></a>开始探究</h3>我们新建一个类JSPerson<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;.h</span><br><span class="line">@interface JSPerson : NSObject</span><br><span class="line">@end</span><br><span class="line">&#x2F;&#x2F;.m</span><br><span class="line">@implementation JSPerson</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
在<code>main</code>方法中初始化<code>JSPerson</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        JSPerson *person &#x3D; [JSPerson alloc];</span><br><span class="line">        NSLog(@&quot;%@&quot;,person);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在<code>JSPerson *person = [JSPerson alloc];</code>这行添加断点运行。<br>按<code>control</code>键发现断点走到了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KCObjcBuild&#96;objc_alloc:</span><br><span class="line">-&gt;  0x100003f44 &lt;+0&gt;: jmpq   *0x40be(%rip)             ; (void *)0x0000000100003f76</span><br></pre></td></tr></table></figure>
说明这个时候调用了<code>objc_alloc</code>方法，我们打一个<code>objc_alloc</code>的符号断点，继续执行程序，发现断点来到了<code>objc_alloc</code>的源码部分。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Calls [cls alloc].</span><br><span class="line">id</span><br><span class="line">objc_alloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    return callAlloc(cls, true&#x2F;*checkNil*&#x2F;, false&#x2F;*allocWithZone*&#x2F;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们继续进入<code>callAlloc</code>方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE id</span><br><span class="line">callAlloc(Class cls, bool checkNil, bool allocWithZone&#x3D;false)</span><br><span class="line">&#123;</span><br><span class="line">#if __OBJC2__</span><br><span class="line">    if (slowpath(checkNil &amp;&amp; !cls)) return nil;</span><br><span class="line">    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        return _objc_rootAllocWithZone(cls, nil);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; No shortcuts available.</span><br><span class="line">    if (allocWithZone) &#123;</span><br><span class="line">        return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil);</span><br><span class="line">    &#125;</span><br><span class="line">    return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们继续走断点，发现走到了<code>return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc));</code>即又调用了alloc方法，也就是说<code>callAlloc</code>也会再次调用。<br>继续调试这次走到了<code>return _objc_rootAllocWithZone(cls, nil);</code>,断点进入<code>_objc_rootAllocWithZone</code>方法看一下源码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone __unused)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; allocWithZone under __OBJC2__ ignores the zone parameter</span><br><span class="line">    return _class_createInstanceFromZone(cls, 0, nil,</span><br><span class="line">                                         OBJECT_CONSTRUCT_CALL_BADALLOC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
代码很简单，我们继续跟进到<code>_class_createInstanceFromZone</code>方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE id</span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,</span><br><span class="line">                              int construct_flags &#x3D; OBJECT_CONSTRUCT_NONE,</span><br><span class="line">                              bool cxxConstruct &#x3D; true,</span><br><span class="line">                              size_t *outAllocatedSize &#x3D; nil)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line">    &#x2F;&#x2F; Read class&#39;s info bits all at once for performance</span><br><span class="line">    bool hasCxxCtor &#x3D; cxxConstruct &amp;&amp; cls-&gt;hasCxxCtor();</span><br><span class="line">    bool hasCxxDtor &#x3D; cls-&gt;hasCxxDtor();</span><br><span class="line">    bool fast &#x3D; cls-&gt;canAllocNonpointer();</span><br><span class="line">    size_t size;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;获取实例大小</span><br><span class="line">    size &#x3D; cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    if (outAllocatedSize) *outAllocatedSize &#x3D; size;</span><br><span class="line">    id obj;</span><br><span class="line">    if (zone) &#123;</span><br><span class="line">        obj &#x3D; (id)malloc_zone_calloc((malloc_zone_t *)zone, 1, size);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;分配内存</span><br><span class="line">        obj &#x3D; (id)calloc(1, size);</span><br><span class="line">    &#125;</span><br><span class="line">    if (slowpath(!obj)) &#123;</span><br><span class="line">        if (construct_flags &amp; OBJECT_CONSTRUCT_CALL_BADALLOC) &#123;</span><br><span class="line">            return _objc_callBadAllocHandler(cls);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;关联isa指针</span><br><span class="line">    if (!zone &amp;&amp; fast) &#123;</span><br><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; Use raw pointer isa on the assumption that they might be</span><br><span class="line">        &#x2F;&#x2F; doing something weird with the zone or RR.</span><br><span class="line">        obj-&gt;initIsa(cls);</span><br><span class="line">    &#125;</span><br><span class="line">    if (fastpath(!hasCxxCtor)) &#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">    construct_flags |&#x3D; OBJECT_CONSTRUCT_FREE_ONFAILURE;</span><br><span class="line">    return object_cxxConstructFromClass(obj, cls, construct_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>_class_createInstanceFromZone</code>方法有三个关键的点，我们下面分别分析：<h4 id="获取实例大小-size-cls-gt-instanceSize-extraBytes"><a href="#获取实例大小-size-cls-gt-instanceSize-extraBytes" class="headerlink" title="获取实例大小 size = cls-&gt;instanceSize(extraBytes)"></a>获取实例大小 <code>size = cls-&gt;instanceSize(extraBytes)</code></h4>内联函数<code>instanceSize</code>的作用是获取实例的大小，对象的大小取决于其<code>ivars</code>(成员变量)的大小。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; May be unaligned depending on class&#39;s ivars.</span><br><span class="line">uint32_t unalignedInstanceSize() const &#123;</span><br><span class="line">    ASSERT(isRealized());</span><br><span class="line">    return data()-&gt;ro()-&gt;instanceSize;</span><br><span class="line">&#125;</span><br><span class="line">inline size_t instanceSize(size_t extraBytes) const &#123;</span><br><span class="line">    if (fastpath(cache.hasFastInstanceSize(extraBytes))) &#123;</span><br><span class="line">        return cache.fastInstanceSize(extraBytes);</span><br><span class="line">    &#125;</span><br><span class="line">    size_t size &#x3D; alignedInstanceSize() + extraBytes;</span><br><span class="line">    &#x2F;&#x2F; CF requires all objects be at least 16 bytes.</span><br><span class="line">    if (size &lt; 16) size &#x3D; 16;</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
根据<code>if (size &lt; 16) size = 16;</code>可以看出，对象最小大小为16，这个就是内存对齐的概念，上面的<code>alignedInstanceSize()</code>函数,会继续调用内联函数<code>word_align</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; __LP64__</span><br><span class="line">#   define WORD_MASK 7UL</span><br><span class="line">static inline uint32_t word_align(uint32_t x) &#123;</span><br><span class="line">    return (x + WORD_MASK) &amp; ~WORD_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里就引入一个概念就是字节对齐。可以看到<code>WORD_MASK=7</code>,它的作用是保证字节的大小为8的倍数。<h4 id="给对象分配内存空间"><a href="#给对象分配内存空间" class="headerlink" title="给对象分配内存空间"></a>给对象分配内存空间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (zone) &#123;</span><br><span class="line">    obj &#x3D; (id)malloc_zone_calloc((malloc_zone_t *)zone, 1, size);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    obj &#x3D; (id)calloc(1, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="给对象关联isa指针"><a href="#给对象关联isa指针" class="headerlink" title="给对象关联isa指针"></a>给对象关联isa指针</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (!zone &amp;&amp; fast) &#123;</span><br><span class="line">    obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; Use raw pointer isa on the assumption that they might be</span><br><span class="line">    &#x2F;&#x2F; doing something weird with the zone or RR.</span><br><span class="line">    obj-&gt;initIsa(cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>总结来看<code>alloc</code>的流程图即为下图所示：</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62281d7404a940a9bcf2390166545e97~tplv-k3u1fbpfcp-watermark.image" alt="alloc流程.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/06/01/Swift-RxSwift%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/01/Swift-RxSwift%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Swift - RxSwift源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-01 15:35:58" itemprop="dateCreated datePublished" datetime="2021-06-01T15:35:58+08:00">2021-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-03 21:54:22" itemprop="dateModified" datetime="2021-06-03T21:54:22+08:00">2021-06-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="RxSwift简介"><a href="#RxSwift简介" class="headerlink" title="RxSwift简介"></a>RxSwift简介</h3><p><code>RxSwift</code> 是 <a href="http://reactivex.io/" target="_blank" rel="noopener"><code>ReactiveX</code></a> 家族的重要一员, <code>ReactiveX</code> 是 <code>Reactive Extensions</code> 的缩写，一般简写为 <code>Rx</code>。<code>ReactiveX</code> 官方给<code>Rx</code>的定义是：<strong>Rx是一个使用可观察数据流进行异步编程的编程接口。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactiveX&#96; 不仅仅是一个编程接口，它是一种编程思想的突破，它影响了许多其它的程序库和框架以及编程语言。它拓展了&#96;观察者模式&#96;，使你能够&#96;自由组合多个异步事件&#96;，而&#96;不需要去关心线程&#96;，&#96;同步，线程安全&#96;，&#96;并发数据以及I&#x2F;O阻塞</span><br></pre></td></tr></table></figure>

<p><code>RxSwift</code> 是 <code>Rx</code> 为 <code>Swift</code> 语言开发的一门函数响应式编程语言， 它可以代替iOS系统的 <code>Target Action</code> / <code>代理</code> / <code>闭包</code> / <code>通知</code> / <code>KVO</code>,同时还提供<code>网络</code>、<code>数据绑定</code>、<code>UI事件处理</code>、<code>UI的展示和更新</code>、<code>多线程</code>……</p>
<p><code>Swift</code>为值类型，在传值与方法回调上有影响，<code>RxSwift</code>一定程度上弥补<code>Swift</code>的灵活性</p>
<ul>
<li><code>RxSwift</code>使得代码复用性较强，减少代码量</li>
<li><code>RxSwift</code>因为声明都是不可变更，增加代码可读性</li>
<li><code>RxSwift</code>使得更易于理解业务代码，抽象异步编程，统一代码风格</li>
<li><code>RxSwift</code>使得代码更易于编写集成单元测试，增加代码稳定性</li>
</ul>
<h3 id="RxSwift核心流程"><a href="#RxSwift核心流程" class="headerlink" title="RxSwift核心流程"></a>RxSwift核心流程</h3><p>RxSwift的api设计非常精简，流程就是：</p>
<p>1、创建序列（）</p>
<p>2、订阅序列</p>
<p>3、发送信号</p>
<p>4、销毁</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1: 创建序列</span></span><br><span class="line"><span class="number">_</span> = <span class="type">Observable</span>&lt;<span class="type">String</span>&gt;.create &#123; (obserber) -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// 3:发送信号</span></span><br><span class="line">    obserber.onNext(<span class="string">"RxSwift 研究"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create()  <span class="comment">// 4、销毁</span></span><br><span class="line">    <span class="comment">// 2: 订阅序列</span></span><br><span class="line">    &#125;.subscribe(onNext: &#123; (text) <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"订阅到:\(text)"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台打印：“订阅到:RxSwift 研究”</span></span><br></pre></td></tr></table></figure>

<h3 id="创建序列"><a href="#创建序列" class="headerlink" title="创建序列"></a>创建序列</h3><p>我们先看Create.swift文件的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ObservableType</span> </span>&#123;</span><br><span class="line">    <span class="comment">// MARK: create</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     Creates an observable sequence from a specified subscribe method implementation.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     - seealso: [create operator on reactivex.io](http://reactivex.io/documentation/operators/create.html)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     - parameter subscribe: Implementation of the resulting observable sequence's `subscribe` method.</span></span><br><span class="line"><span class="comment">     - returns: The observable sequence with the specified implementation for the `subscribe` method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(<span class="number">_</span> subscribe: @escaping <span class="params">(AnyObserver&lt;Element&gt;)</span></span></span> -&gt; <span class="type">Disposable</span>) -&gt; <span class="type">Observable</span>&lt;<span class="type">Element</span>&gt; &#123;</span><br><span class="line">        <span class="type">AnonymousObservable</span>(subscribe)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousObservable</span>&lt;<span class="title">Element</span>&gt;: <span class="title">Producer</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">SubscribeHandler</span> = (<span class="type">AnyObserver</span>&lt;<span class="type">Element</span>&gt;) -&gt; <span class="type">Disposable</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> subscribeHandler: <span class="type">SubscribeHandler</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> subscribeHandler: @escaping <span class="type">SubscribeHandler</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.subscribeHandler = subscribeHandler</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">run</span>&lt;Observer: ObserverType&gt;<span class="params">(<span class="number">_</span> observer: Observer, cancel: Cancelable)</span></span> -&gt; (sink: <span class="type">Disposable</span>, subscription: <span class="type">Disposable</span>) <span class="keyword">where</span> <span class="type">Observer</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> sink = <span class="type">AnonymousObservableSink</span>(observer: observer, cancel: cancel)</span><br><span class="line">        <span class="keyword">let</span> subscription = sink.run(<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">return</span> (sink: sink, subscription: subscription)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，可观察序列的创建是利用扩展<code>ObservableType</code>协议的<code>create</code>方法实现的,里面创建了<code>AnonymousObservable</code>(匿名可观察序列) ，这个命名体现了作者的思维，这是一个内部类，具备一些通用特性（具有自己功能的类才会命名）可以总结一下：</p>
<ul>
<li><code>create</code>方法的时候创建了一个内部对象<code>AnonymousObservable</code></li>
<li><code>AnonymousObservable</code>保存了外界传入的闭包</li>
<li><code>AnonymousObservable</code>继承了<code>Producer</code></li>
</ul>
<p>接下来我们看一下<code>Producer</code>类</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span>&lt;<span class="title">Element</span>&gt;: <span class="title">Observable</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span>&lt;Observer: ObserverType&gt;<span class="params">(<span class="number">_</span> observer: Observer)</span></span> -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">Observer</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !<span class="type">CurrentThreadScheduler</span>.isScheduleRequired &#123;</span><br><span class="line">            <span class="comment">// The returned disposable needs to release all references once it was disposed.</span></span><br><span class="line">            <span class="keyword">let</span> disposer = <span class="type">SinkDisposer</span>()</span><br><span class="line">            <span class="keyword">let</span> sinkAndSubscription = <span class="keyword">self</span>.run(observer, cancel: disposer)</span><br><span class="line">            disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink, subscription: sinkAndSubscription.subscription)</span><br><span class="line">            <span class="keyword">return</span> disposer</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">CurrentThreadScheduler</span>.instance.schedule(()) &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">let</span> disposer = <span class="type">SinkDisposer</span>()</span><br><span class="line">                <span class="keyword">let</span> sinkAndSubscription = <span class="keyword">self</span>.run(observer, cancel: disposer)</span><br><span class="line">                disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink, subscription: sinkAndSubscription.subscription)</span><br><span class="line">                <span class="keyword">return</span> disposer</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span>&lt;Observer: ObserverType&gt;<span class="params">(<span class="number">_</span> observer: Observer, cancel: Cancelable)</span></span> -&gt; (sink: <span class="type">Disposable</span>, subscription: <span class="type">Disposable</span>) <span class="keyword">where</span> <span class="type">Observer</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">        rxAbstractMethod()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到Producer有一个很重要的方法<code>subscribe</code>(订阅)，<code>subscribe</code>方法最后返回一个<code>Disposable</code>对象。</p>
<h3 id="订阅序列"><a href="#订阅序列" class="headerlink" title="订阅序列"></a>订阅序列</h3><p>我们看一下<code>ObservableType</code>拓展（ObservableType+Extensions.swift）的功能，订阅的方法<code>subscribe</code>（注意这个方法和<code>Producer</code>的<code>subscribe</code>不是同一个）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     Subscribes an element handler, an error handler, a completion handler and disposed handler to an observable sequence.</span></span><br><span class="line"><span class="comment">     - parameter onNext: Action to invoke for each element in the observable sequence.</span></span><br><span class="line"><span class="comment">     - parameter onError: Action to invoke upon errored termination of the observable sequence.</span></span><br><span class="line"><span class="comment">     - parameter onCompleted: Action to invoke upon graceful termination of the observable sequence.</span></span><br><span class="line"><span class="comment">     - parameter onDisposed: Action to invoke upon any type of termination of sequence (if the sequence has</span></span><br><span class="line"><span class="comment">     gracefully completed, errored, or if the generation is canceled by disposing subscription).</span></span><br><span class="line"><span class="comment">     - returns: Subscription object used to unsubscribe from the observable sequence.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        onNext: <span class="params">(<span class="params">(Element)</span></span></span></span> -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span>,</span><br><span class="line">        onError: ((<span class="type">Swift</span>.<span class="type">Error</span>) -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span>,</span><br><span class="line">        onCompleted: (() -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span>,</span><br><span class="line">        onDisposed: (() -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span></span><br><span class="line">    ) -&gt; <span class="type">Disposable</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> disposable: <span class="type">Disposable</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> disposed = onDisposed &#123;</span><br><span class="line">                disposable = <span class="type">Disposables</span>.create(with: disposed)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                disposable = <span class="type">Disposables</span>.create()</span><br><span class="line">            &#125;</span><br><span class="line">            #<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line">                <span class="keyword">let</span> synchronizationTracker = <span class="type">SynchronizationTracker</span>()</span><br><span class="line">            #endif</span><br><span class="line">            <span class="keyword">let</span> callStack = <span class="type">Hooks</span>.recordCallStackOnError ? <span class="type">Hooks</span>.customCaptureSubscriptionCallstack() : []</span><br><span class="line">      			<span class="comment">///以下重点关注的代码 创建匿名观察者</span></span><br><span class="line">            <span class="keyword">let</span> observer = <span class="type">AnonymousObserver</span>&lt;<span class="type">Element</span>&gt; &#123; event <span class="keyword">in</span> </span><br><span class="line">                #<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line">                    synchronizationTracker.register(synchronizationErrorMessage: .<span class="keyword">default</span>)</span><br><span class="line">                    <span class="keyword">defer</span> &#123; synchronizationTracker.unregister() &#125;</span><br><span class="line">                #endif</span><br><span class="line">                <span class="keyword">switch</span> event &#123;</span><br><span class="line">                <span class="keyword">case</span> .next(<span class="keyword">let</span> value):</span><br><span class="line">                    onNext?(value)</span><br><span class="line">                <span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> onError = onError &#123;</span><br><span class="line">                        onError(error)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="type">Hooks</span>.defaultErrorHandler(callStack, error)</span><br><span class="line">                    &#125;</span><br><span class="line">                    disposable.dispose()</span><br><span class="line">                <span class="keyword">case</span> .completed:</span><br><span class="line">                    onCompleted?()</span><br><span class="line">                    disposable.dispose()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Disposables</span>.create(</span><br><span class="line">                <span class="keyword">self</span>.asObservable().subscribe(observer),</span><br><span class="line">                disposable</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码说明：</p>
<ul>
<li><p><code>E</code>是<code>Swift</code>的关联类型，这个如果仔细看过可观察序列的继承链源码应该不难得出：这个<code>E</code> 就是我们的 序列类型，我们这里就是<code>String</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span>&lt;<span class="title">Element</span>&gt; : <span class="title">ObservableType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Type of elements in sequence.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">E</span> = <span class="type">Element</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建<code>AnonymousObserver</code>对象，可以类比前面<code>create</code>的<code>AnonymousObservable</code>对象，初始化参数为闭包，保存了外界传入的<code>onNext</code>,<code>onError</code>,<code>onComplete</code>,<code>onDisposed</code>的处理回调闭包。</p>
</li>
<li><p><code>self.asObservable()</code>是我们的<code>RxSwift</code>为了保持一致性的写法。</p>
</li>
<li><p><code>self.asObservable().subscribe(observer)</code>其实本质就是<code>self.</code>subscribe(observer),通过可观察序列的继承关系，我们可以快速定位到<code>Producer</code>订阅代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span>&lt;Observer: ObserverType&gt;<span class="params">(<span class="number">_</span> observer: Observer)</span></span> -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">Observer</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !<span class="type">CurrentThreadScheduler</span>.isScheduleRequired &#123;</span><br><span class="line">        <span class="comment">// The returned disposable needs to release all references once it was disposed.</span></span><br><span class="line">        <span class="keyword">let</span> disposer = <span class="type">SinkDisposer</span>()</span><br><span class="line">        <span class="keyword">let</span> sinkAndSubscription = <span class="keyword">self</span>.run(observer, cancel: disposer)</span><br><span class="line">        disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink, subscription: sinkAndSubscription.subscription)</span><br><span class="line">        <span class="keyword">return</span> disposer</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CurrentThreadScheduler</span>.instance.schedule(()) &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> disposer = <span class="type">SinkDisposer</span>()</span><br><span class="line">            <span class="keyword">let</span> sinkAndSubscription = <span class="keyword">self</span>.run(observer, cancel: disposer)</span><br><span class="line">            disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink, subscription: sinkAndSubscription.subscription)</span><br><span class="line">            <span class="keyword">return</span> disposer</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>销毁代码后面在分析</p>
</li>
<li><p><code>self.run</code>这个代码最终由我们生产者<code>Producer</code>(抽象方法找子类)延伸到具体事务代码<code>AnonymousObservable.run</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">run</span>&lt;Observer: ObserverType&gt;<span class="params">(<span class="number">_</span> observer: Observer, cancel: Cancelable)</span></span> -&gt; (sink: <span class="type">Disposable</span>, subscription: <span class="type">Disposable</span>) <span class="keyword">where</span> <span class="type">Observer</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> sink = <span class="type">AnonymousObservableSink</span>(observer: observer, cancel: cancel)</span><br><span class="line">      <span class="keyword">let</span> subscription = sink.run(<span class="keyword">self</span>)</span><br><span class="line">      <span class="keyword">return</span> (sink: sink, subscription: subscription)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里调用了<code>sink.run(self)</code>方法，将业务处理下沉，分工更加明确。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(<span class="number">_</span> parent: Parent)</span></span> -&gt; <span class="type">Disposable</span> &#123;</span><br><span class="line">    parent.subscribeHandler(<span class="type">AnyObserver</span>(<span class="keyword">self</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>parent</code>是上面传入进来的<code>AnonymousObservable</code>对象</p>
</li>
<li><p>这个地方我们可以看到调用了<code>AnonymousObservable</code>对象的<code>subscribeHandler</code>方法，这里我们清楚了，为什么<code>序列订阅</code>的时候流程会执行我们的<code>序列闭包</code>，然后去执行<code>发送响应</code></p>
</li>
<li><p>发送响应的代码后面再分析，下面还有个点是<code>AnyObserver(self)</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Construct an instance whose `on(event)` calls `observer.on(event)`</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - parameter observer: Observer that receives sequence events.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">Observer</span>: <span class="type">ObserverType</span>&gt;(<span class="number">_</span> observer: <span class="type">Observer</span>) <span class="keyword">where</span> <span class="type">Observer</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">     <span class="keyword">self</span>.observer = observer.on</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个构造方法里面，我们创建了一个结构体<code>AnyObserver</code>保存了一个信息<code>AnonymousObservableSink.on</code>函数。注意不是<code>AnonymousObservableSink</code></p>
</li>
</ul>
<h3 id="发送响应"><a href="#发送响应" class="headerlink" title="发送响应"></a>发送响应</h3><p>通过上面的分析，我们清楚了<code>observer.onNext(&quot;&quot;)</code>本质是<code>AnyObserver.onNext(&quot;&quot;)</code>,我们发现AnyObserver没有这个方法，顺着思路找父类，找<code>ObserverType</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Convenience API extensions to provide alternate next, error, completed events</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ObserverType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Convenience method equivalent to `on(.next(element: Element))`</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - parameter element: Next element to send to observer(s)</span></span><br><span class="line">  	<span class="comment">///这里是我们关注的点 AnyObserver.onNext("")实际调用这里</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">onNext</span><span class="params">(<span class="number">_</span> element: Element)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.on(.next(element))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Convenience method equivalent to `on(.completed)`</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">onCompleted</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.on(.completed)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Convenience method equivalent to `on(.error(Swift.Error))`</span></span><br><span class="line">    <span class="comment">/// - parameter error: Swift.Error to send to observer(s)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">onError</span><span class="params">(<span class="number">_</span> error: Swift.Error)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.on(.error(error))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>外界调用的<code>observer.onNext(&quot;&quot;)</code>再次变形：<code>AnyObserver.on(.next(&quot;&quot;))</code>,<code>AnyObserver</code>调用了<code>on</code>里面的<code>.next</code>函数，<code>.next</code>函数带有我们最终的参数</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Construct an instance whose `on(event)` calls `observer.on(event)`</span></span><br><span class="line"><span class="comment">/// - parameter observer: Observer that receives sequence events.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">Observer</span>: <span class="type">ObserverType</span>&gt;(<span class="number">_</span> observer: <span class="type">Observer</span>) <span class="keyword">where</span> <span class="type">Observer</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.observer = observer.on</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// Send `event` to this observer.</span></span><br><span class="line"><span class="comment">/// - parameter event: Event instance.</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">on</span><span class="params">(<span class="number">_</span> event: Event&lt;Element&gt;)</span></span> &#123;</span><br><span class="line">     <span class="keyword">self</span>.observer(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>self.observer</code> 构造初始化就是：<code>AnonymousObservableSink .on 函数</code></p>
</li>
<li><p><code>self.observer(event)</code> -&gt; <code>AnonymousObservableSink .on(event)</code> 其中 <code>event = .next(&quot;&quot;)</code> 最终我们的核心逻辑又回到了 <code>sink</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousObservableSink</span>&lt;<span class="title">Observer</span>: <span class="title">ObserverType</span>&gt;: <span class="title">Sink</span>&lt;<span class="title">Observer</span>&gt;, <span class="title">ObserverType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">on</span><span class="params">(<span class="number">_</span> event: Event&lt;Element&gt;)</span></span> &#123;</span><br><span class="line">        #<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line">            <span class="keyword">self</span>.synchronizationTracker.register(synchronizationErrorMessage: .<span class="keyword">default</span>)</span><br><span class="line">            <span class="keyword">defer</span> &#123; <span class="keyword">self</span>.synchronizationTracker.unregister() &#125;</span><br><span class="line">        #endif</span><br><span class="line">        <span class="keyword">switch</span> event &#123;</span><br><span class="line">        <span class="keyword">case</span> .next:</span><br><span class="line">            <span class="keyword">if</span> load(<span class="keyword">self</span>.isStopped) == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.forwardOn(event)</span><br><span class="line">        <span class="keyword">case</span> .error, .completed:</span><br><span class="line">            <span class="keyword">if</span> fetchOr(<span class="keyword">self</span>.isStopped, <span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.forwardOn(event)</span><br><span class="line">                <span class="keyword">self</span>.dispose()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>self.forwardOn(event)</code> 这也是执行的核心代码，因为 <code>AnonymousObservableSink</code> 继承 <code>Sink</code> 这里还有封装，请看下面的代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sink</span>&lt;<span class="title">Observer</span>: <span class="title">ObserverType</span>&gt;: <span class="title">Disposable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="function"><span class="keyword">func</span> <span class="title">forwardOn</span><span class="params">(<span class="number">_</span> event: Event&lt;Observer.Element&gt;)</span></span> &#123;</span><br><span class="line">        #<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line">            <span class="keyword">self</span>.synchronizationTracker.register(synchronizationErrorMessage: .<span class="keyword">default</span>)</span><br><span class="line">            <span class="keyword">defer</span> &#123; <span class="keyword">self</span>.synchronizationTracker.unregister() &#125;</span><br><span class="line">        #endif</span><br><span class="line">        <span class="keyword">if</span> isFlagSet(<span class="keyword">self</span>.disposed, <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.observer.on(event)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其中 <code>self.observer</code> 就是我们初始化保存的 <code>观察者：AnonymousObserver</code></p>
</li>
<li><p>到这里我们得出了发送序列的本质就是<code>AnonymousObserver.on（.next(&quot;&quot;)）</code>,这个逻辑又回到了我们<code>订阅序列</code>时候创建的<code>AnonymousObserver</code>参数闭包的调用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="type">AnonymousObserver</span>&lt;<span class="type">E</span>&gt; &#123; event <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> event &#123;</span><br><span class="line">    <span class="keyword">case</span> .next(<span class="keyword">let</span> value):</span><br><span class="line">        onNext?(value)</span><br><span class="line">    <span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> onError = onError &#123;</span><br><span class="line">            onError(error)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Hooks</span>.defaultErrorHandler(callStack, error)</span><br><span class="line">        &#125;</span><br><span class="line">        disposable.dispose()</span><br><span class="line">    <span class="keyword">case</span> .completed:</span><br><span class="line">        onCompleted?()</span><br><span class="line">        disposable.dispose()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断<code>event</code>进而调用<code>onNext?(value)</code>,因为枚举的关联值<code>value=&quot;&quot;</code>,接下来外界<code>onNext</code>的调用参数。</p>
</li>
</ul>
<h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><p>我们先看一下创建序列到销毁的执行代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建序列</span></span><br><span class="line"><span class="keyword">let</span> ob = <span class="type">Observable</span>&lt;<span class="type">Any</span>&gt;.create &#123; (observer) -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">    observer.onNext(<span class="string">"Jason"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"销毁释放了"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 序列订阅</span></span><br><span class="line"><span class="keyword">let</span> dispose = ob.subscribe(onNext: &#123; (anything) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"订阅到了:\(anything)"</span>)</span><br><span class="line">&#125;, onError: &#123; (error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"订阅到了:\(error)"</span>)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"完成了"</span>)</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"销毁回调"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这段代码里面关于销毁相关的代码就是<code>Disposables.create {print(&quot;销毁释放了&quot;)}</code>,所以我们直接定位到<code>Disposables</code>类（AnonymousDisposable.swift文件）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Disposables</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Constructs a new disposable with the given action used for disposal.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - parameter dispose: Disposal action which will be run upon calling `dispose`.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(with dispose: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Cancelable</span> &#123;</span><br><span class="line">        <span class="type">AnonymousDisposable</span>(disposeAction: dispose)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以看出，这里创建了一个匿名销毁序列<code>AnonymousDisposable</code>,和订阅一样的手法。继续看<code>AnonymousDisposable</code>代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// When dispose method is called, disposal action will be dereferenced.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousDisposable</span> : <span class="title">DisposeBase</span>, <span class="title">Cancelable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Non-deprecated version of the constructor, used by `Disposables.create(with:)`</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">init</span>(disposeAction: @escaping <span class="type">DisposeAction</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.disposeAction = disposeAction</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Calls the disposal action if and only if the current instance hasn't been disposed yet.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// After invoking disposal action, disposal action will be dereferenced.</span></span><br><span class="line">    <span class="comment">///销毁核心的逻辑</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">dispose</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> fetchOr(<span class="keyword">self</span>.disposed, <span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> action = <span class="keyword">self</span>.disposeAction &#123;</span><br><span class="line">                <span class="keyword">self</span>.disposeAction = <span class="literal">nil</span></span><br><span class="line">                action()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上我们看到，初始化方法里保存了销毁响应闭包，什么时候调用，我们看下面的<code>dispose()</code>方法。</p>
</li>
<li><p>fetchOr(self.disposed, 1)是一个单项标记手段，这里利用了牛逼的算法标记可以降低依赖和更加快速。</p>
</li>
<li><p>主要就是保证只会销毁一次</p>
</li>
<li><p>销毁会首先<code>self.disposeAction = nil</code>,将回调闭包置空</p>
</li>
<li><p>最后调用闭包调用<code>action()</code>,这里是一个局部变量不需要再置空</p>
</li>
</ul>
<p>下面我们看一下<code>dispose()</code>是什么时候调用的</p>
<p>上面的流程，我们再序列的回调闭包：<code>subscriberHandle</code>里面，这个流程之前有一个重要的流程就是订阅<code>subscriber</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> disposed = onDisposed &#123;</span><br><span class="line">  disposable = <span class="type">Disposables</span>.create(with: disposed)  </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  disposable = <span class="type">Disposables</span>.create()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这里保存外界传入的销毁闭包</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> event &#123;</span><br><span class="line"><span class="keyword">case</span> .next(<span class="keyword">let</span> value):</span><br><span class="line">    onNext?(value)</span><br><span class="line"><span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">  <span class="comment">// 响应外界调回闭包</span></span><br><span class="line">    disposable.dispose()</span><br><span class="line"><span class="keyword">case</span> .completed:</span><br><span class="line">  <span class="comment">// 响应外界调回闭包</span></span><br><span class="line">    disposable.dispose()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>观察者回调里面调用， 响应外界调回闭包</p>
</li>
</ul>
<ul>
<li><code>return Disposables.create(self.asObservable().subscribe(observer),disposable)</code> 综合来看，我们的重点必然在这句代码，沟通下面流程的 <code>subscribe</code>, 外界订阅返回的销毁者（可以随时随地进行 <code>dispose.dispose()</code> ）</li>
<li>上面代码跟进去看到<code>BinaryDisposable(disposable1, disposable2)</code> 原来创建的二元销毁者！</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dispose</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> fetchOr(<span class="keyword">self</span>._isDisposed, <span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>._disposable1?.dispose()</span><br><span class="line">        <span class="keyword">self</span>._disposable2?.dispose()</span><br><span class="line">        <span class="keyword">self</span>._disposable1 = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>._disposable2 = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>二元销毁者的 <code>dispose</code> 方法也在预料之中，分别销毁</p>
</li>
<li><p>那么我们的重点就应该探索，在 <code>subscribe</code> 这里面创建的关键销毁者是什么?</p>
</li>
<li><p>下面我们进入非常熟悉的：<code>Producer</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> disposer = <span class="type">SinkDisposer</span>()</span><br><span class="line"><span class="keyword">let</span> sinkAndSubscription = <span class="keyword">self</span>.run(observer, cancel: disposer)</span><br><span class="line">disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink,</span><br><span class="line"> subscription: sinkAndSubscription.subscription)</span><br><span class="line"><span class="comment">// 返回销毁者</span></span><br><span class="line"><span class="keyword">return</span> disposer</span><br></pre></td></tr></table></figure>
</li>
<li><p>看到 <code>SinkDisposer</code> 就熟悉了，普通销毁者：<code>AnonymousDisposable</code> , 关键销毁者： <code>SinkDisposer</code></p>
</li>
<li><p>先看什么东西进入了 <code>SinkDisposer</code></p>
</li>
<li><p><code>self.run(observer, cancel: disposer)</code> 证明里面需要用到 <code>SinkDisposer</code></p>
</li>
<li><p><code>disposer.setSinkAndSubscription</code> 常规操作</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setSinkAndSubscription</span><span class="params">(sink: Disposable, subscription: Disposable)</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>._sink = sink</span><br><span class="line">    <span class="keyword">self</span>._subscription = subscription</span><br><span class="line"><span class="comment">// 获取状态 </span></span><br><span class="line">    <span class="keyword">let</span> previousState = fetchOr(<span class="keyword">self</span>._state, </span><br><span class="line"><span class="type">DisposeState</span>.sinkAndSubscriptionSet.rawValue)</span><br><span class="line"><span class="comment">// 如果状态满足就销毁</span></span><br><span class="line">    <span class="keyword">if</span> (previousState &amp; <span class="type">DisposeState</span>.disposed.rawValue) != <span class="number">0</span> &#123;</span><br><span class="line">        sink.dispose()</span><br><span class="line">        subscription.dispose()</span><br><span class="line">        <span class="keyword">self</span>._sink = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>._subscription = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>保存了两个属性 : <code>sink</code> 和 <code>subscription</code>(就是外界创建序列的闭包的返回销毁者)</p>
</li>
<li><p>取了某一个状态：<code>previousState</code>,判断状态的条件，然后执行 这两个保存属性的销毁和置空释放销毁 ： <code>.dispose() + = nil</code></p>
</li>
<li><p>其实是可以理解，就是我们在加入的东西其实需要销毁的，不应该保留的，那么没必要给它继续保留生命迹象</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 sink 保存了销毁者</span></span><br><span class="line"><span class="keyword">let</span> sink = <span class="type">AnonymousObservableSink</span>(observer: observer, cancel: cancel)</span><br><span class="line"><span class="comment">// 省略不相管代码。。。。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">on</span><span class="params">(<span class="number">_</span> event: Event&lt;Element&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> event &#123;</span><br><span class="line">    <span class="keyword">case</span> .next:</span><br><span class="line">        <span class="keyword">self</span>.forwardOn(event)</span><br><span class="line">    <span class="keyword">case</span> .error, .completed:</span><br><span class="line">        <span class="keyword">if</span> fetchOr(<span class="keyword">self</span>._isStopped, <span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.forwardOn(event)</span><br><span class="line">            <span class="comment">// 关键点：完成和错误信号的响应式必然会直接开启销毁的</span></span><br><span class="line">            <span class="keyword">self</span>.dispose()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>完成和错误信号的响应式必然会直接开启销毁的 ： <code>self.dispose()</code>! 这里也解释了：一旦我们的序列发出完成或者错误就无法再次响应了！</p>
</li>
<li><p>剩下一个问题： <strong>到底我们的销毁的是什么</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dispose</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> previousState = fetchOr(<span class="keyword">self</span>._state, <span class="type">DisposeState</span>.disposed.rawValue)</span><br><span class="line">    <span class="keyword">if</span> (previousState &amp; <span class="type">DisposeState</span>.sinkAndSubscriptionSet.rawValue) != <span class="number">0</span> &#123;</span><br><span class="line">        sink.dispose()</span><br><span class="line">        subscription.dispose()</span><br><span class="line">        <span class="keyword">self</span>._sink = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>._subscription = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>无论我们直接销毁还是系统帮助我们销毁必然会调用：<code>dispose()</code></p>
</li>
<li><p>我们查看 <code>dispose()</code> 得出: 就是在初始化初期我们保留的两个属性的操作</p>
</li>
<li><p><code>sink.dispose() + self._sink = nil</code> &amp; <code>subscription.dispose() + self._subscription = nil</code> 执行相关释放和销毁</p>
</li>
</ul>
<h4 id="总结一下销毁"><a href="#总结一下销毁" class="headerlink" title="总结一下销毁"></a>总结一下销毁</h4><p>第一：内部创建的临时序列和观察者都会随着对外的观察者和序列的生命周期而销毁释放。</p>
<p>第二：外界观察者和序列会随着他们的作用域空间而释放</p>
<p>第三：释放不了只是对象的释放有问题，常规内存管理问题</p>
<p>第四：最为一个再牛逼的框架也不能对程序员写的代码直接管理控制</p>
<p>第五：<code>RxSwift</code> 的观察和序列以及销毁者就是普通对象。</p>
<p>到这里RxSwift从创建序列-&gt;订阅序列-&gt;发送信号-&gt;销毁的源码解析就结束了，里面的精妙还是需要细细品味的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/28/GitHub-s-file-size-limit-of-100-00-MB%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/28/GitHub-s-file-size-limit-of-100-00-MB%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/" class="post-title-link" itemprop="url">GitHub's file size limit of 100.00 MB解决办法(转)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-28 14:42:48 / 修改时间：17:32:00" itemprop="dateCreated datePublished" datetime="2021-05-28T14:42:48+08:00">2021-05-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">遇到的问题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上传github发现不给上传100m以上文件的错误,按着提示进行了,用到一个叫lfs的工具专门用来上传大文件的！附<a href="https://github.com/git-lfs/git-lfs" target="_blank" rel="noopener">git-lfs</a> 1.安装 mac</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install git-lfs</span><br><span class="line">git lfs install</span><br></pre></td></tr></table></figure>

<p>找出超过100m的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 目标项目path</span><br><span class="line">find .&#x2F; -size +100M</span><br></pre></td></tr></table></figure>

<p>大文件加入git large file storage上面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git lfs track &quot;name_of_a_giant_file&quot;</span><br><span class="line">#example:</span><br><span class="line">git lfs track &quot;.&#x2F;&#x2F;huanxin&#x2F;HXTest&#x2F;Hyphenate.framework&#x2F;Hyphenate&quot;</span><br></pre></td></tr></table></figure>

<p>添加到git上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add path_of_a_giant_file</span><br><span class="line">#example:</span><br><span class="line">git add .&#x2F;&#x2F;huanxin&#x2F;HXTest&#x2F;Hyphenate.framework&#x2F;Hyphenate</span><br></pre></td></tr></table></figure>

<p>仅供记录以后遇到类似问题查找。</p>
<p><a href="https://juejin.cn/post/6844904205476478989" target="_blank" rel="noopener">原文地址</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/21/flutter%E6%8E%A2%E7%B4%A2-%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/21/flutter%E6%8E%A2%E7%B4%A2-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">flutter探索  - 多线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-21 10:36:00 / 修改时间：16:06:28" itemprop="dateCreated datePublished" datetime="2021-05-21T10:36:00+08:00">2021-05-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Flutter默认是单线程任务处理的，如果不开启新的线程，任务默认在主线程中处理。</p>
<h3 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a>事件队列</h3><p>和iOS应用很像，在<code>Dart</code>的线程中也存在事件循环和消息队列的概念，但在<code>Dart</code>中线程叫做<code>isolate</code>。应用程序启动后，开始执行<code>main</code>函数并运行<code>main isolate</code>。</p>
<p>每个<code>isolate</code>包含一个事件循环以及两个事件队列，<code>event loop</code>事件循环，以及<code>event queue</code>和<code>microtask queue</code>事件队列，<code>event</code>和<code>microtask</code>队列有点类似iOS的<code>source0</code>和<code>source1</code>。</p>
<ul>
<li>event queue：负责处理I/O事件、绘制事件、手势事件、接收其他<code>isolate</code>消息等外部事件。</li>
<li>microtask queue：可以自己向<code>isolate</code>内部添加事件，事件的优先级比<code>event queue</code>高。</li>
</ul>
<p>这两个队列也是有优先级的，当<code>isolate</code>开始执行后，会先处理<code>microtask</code>的事件，当<code>microtask</code>队列中没有事件后，才会处理<code>event</code>队列中的事件，并按照这个顺序反复执行。但需要注意的是，当执行<code>microtask</code>事件时，会阻塞<code>event</code>队列的事件执行，这样就会导致渲染、手势响应等<code>event</code>事件响应延时。为了保证渲染和手势响应，应该尽量将耗时操作放在<code>event</code>队列中。</p>
<h3 id="async、await"><a href="#async、await" class="headerlink" title="async、await"></a>async、await</h3><p>在异步调用中有三个关键词，<code>async</code>、<code>await</code>、<code>Future</code>，其中<code>async</code>和<code>await</code>需要一起使用。在<code>Dart</code>中可以通过<code>async</code>和<code>await</code>进行异步操作，<code>async</code>表示开启一个异步操作，也可以返回一个<code>Future</code>结果。如果没有返回值，则默认返回一个返回值为<code>null</code>的<code>Future</code>。</p>
<p><code>async</code>、<code>await</code>本质上就是<code>Dart</code>对异步操作的一个语法糖，可以减少异步调用的嵌套调用，并且由<code>async</code>修饰后返回一个<code>Future</code>，外界可以以链式调用的方式调用。这个语法是<code>JS</code>的<code>ES7</code>标准中推出的，<code>Dart</code>的设计和<code>JS</code>相同。</p>
<p>下面封装了一个网络请求的异步操作，并且将请求后的<code>Response</code>类型的<code>Future</code>返回给外界，外界可以通过<code>await</code>调用这个请求，并获取返回数据。从代码中可以看到，即便直接返回一个字符串，<code>Dart</code>也会对其进行包装并成为一个<code>Future</code>。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Response&gt; dataReqeust() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="built_in">String</span> requestURL = <span class="string">'https://jsonplaceholder.typicode.com/posts'</span>;</span><br><span class="line">    Client client = Client();</span><br><span class="line">    Future&lt;Response&gt; response = client.<span class="keyword">get</span>(requestURL);</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; loadData() <span class="keyword">async</span> &#123;</span><br><span class="line">    Response response = <span class="keyword">await</span> dataReqeust();</span><br><span class="line">    <span class="keyword">return</span> response.body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码示例中，执行到<code>loadData</code>方法时，会同步进入方法内部进行执行，当执行到<code>await</code>时就会停止<code>async</code>内部的执行，从而继续执行外面的代码。当<code>await</code>有返回后，会继续从<code>await</code>的位置继续执行。所以<code>await</code>的操作，不会影响后面代码的执行。</p>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p><code>Future</code>就是延时操作的一个封装，可以将异步任务封装为<code>Future</code>对象。获取到<code>Future</code>对象后，最简单的方法就是用<code>await</code>修饰，并等待返回结果继续向下执行。正如上面<code>async、await</code>中讲到的，使用<code>await</code>修饰时需要配合<code>async</code>一起使用。</p>
<p>在<code>Dart</code>中，和时间相关的操作基本都和<code>Future</code>有关，例如延时操作、异步操作等。下面是一个很简单的延时操作，通过<code>Future</code>的<code>delayed</code>方法实现。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">loadData() &#123;</span><br><span class="line">    <span class="comment">// DateTime.now()，获取当前时间</span></span><br><span class="line">    <span class="built_in">DateTime</span> now = <span class="built_in">DateTime</span>.now();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'request begin <span class="subst">$now</span>'</span>);</span><br><span class="line">    Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">1</span>), ()&#123;</span><br><span class="line">      now = <span class="built_in">DateTime</span>.now();</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'request response <span class="subst">$now</span>'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Dart</code>还支持对<code>Future</code>的链式调用，通过追加一个或多个<code>then</code>方法来实现，这个特性非常实用。例如一个延时操作完成后，会调用<code>then</code>方法，并且可以传递一个参数给<code>then</code>。调用方式是链式调用，也就代表可以进行很多层的处理。这有点类似于iOS的<code>RAC</code>框架，链式调用进行信号处理。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">1</span>), ()&#123;</span><br><span class="line">  <span class="built_in">int</span> age = <span class="number">18</span>;</span><br><span class="line">  <span class="keyword">return</span> age;</span><br><span class="line">&#125;).then((onValue)&#123;</span><br><span class="line">  onValue++;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'age <span class="subst">$onValue</span>'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>如果想要了解<code>async</code>、<code>await</code>的原理，就要先了解协程的概念，<code>async</code>、<code>await</code>本质上就是协程的一种语法糖。协程，也叫作<code>coroutine</code>，是一种比线程更小的单元。如果从单元大小来说，基本可以理解为进程-&gt;线程-&gt;协程。</p>
<h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>在弄懂协程之前，首先要明白并发和并行的概念，并发指的是由系统来管理多个IO的切换，并交由CPU去处理。并行指的是多核CPU在同一时间里执行多个任务。</p>
<p>并发的实现由非阻塞操作+事件通知来完成，事件通知也叫做“中断”。操作过程分为两种，一种是CPU对IO进行操作，在操作完成后发起中断告诉IO操作完成。另一种是IO发起中断，告诉CPU可以进行操作。</p>
<p>线程本质上也是依赖于中断来进行调度的，线程还有一种叫做“阻塞式中断”，就是在执行IO操作时将线程阻塞，等待执行完成后再继续执行。但线程的消耗是很大的，并不适合大量并发操作的处理，而通过单线程并发可以进行大量并发操作。当多核CPU出现后，单个线程就无法很好的利用多核CPU的优势了，所以又引入了线程池的概念，通过线程池来管理大量线程。</p>
<h3 id="协程-1"><a href="#协程-1" class="headerlink" title="协程"></a>协程</h3><p>在程序执行过程中，离开当前的调用位置有两种方式，继续调用其他函数和<code>return</code>返回离开当前函数。但是执行<code>return</code>时，当前函数在调用栈中的局部变量、形参等状态则会被销毁。</p>
<p>协程分为无线协程和有线协程，无线协程在离开当前调用位置时，会将当前变量放在堆区，当再次回到当前位置时，还会继续从堆区中获取到变量。所以，一般在执行当前函数时就会将变量直接分配到堆区，而<code>async</code>、<code>await</code>就属于无线协程的一种。有线协程则会将变量继续保存在栈区，在回到指针指向的离开位置时，会继续从栈中取出调用。</p>
<h3 id="async、await原理"><a href="#async、await原理" class="headerlink" title="async、await原理"></a>async、await原理</h3><p>以<code>async</code>、<code>await</code>为例，协程在执行时，执行到<code>async</code>则表示进入一个协程，会同步执行<code>async</code>的代码块。<code>async</code>的代码块本质上也相当于一个函数，并且有自己的上下文环境。当执行到<code>await</code>时，则表示有任务需要等待，CPU则去调度执行其他IO，也就是后面的代码或其他协程代码。过一段时间CPU就会轮训一次，看某个协程是否任务已经处理完成，有返回结果可以被继续执行，如果可以被继续执行的话，则会沿着上次离开时指针指向的位置继续执行，也就是<code>await</code>标志的位置。</p>
<p>由于并没有开启新的线程，只是进行IO中断改变CPU调度，所以网络请求这样的异步操作可以使用<code>async</code>、<code>await</code>，但如果是执行大量耗时同步操作的话，应该使用<code>isolate</code>开辟新的线程去执行。</p>
<p>如果用协程和iOS的<code>dispatch_async</code>进行对比，可以发现二者是比较相似的。从结构定义来看，协程需要将当前<code>await</code>的代码块相关的变量进行存储，<code>dispatch_async</code>也可以通过<code>block</code>来实现临时变量的存储能力。</p>
<p>我之前还在想一个问题，苹果为什么不引入协程的特性呢？后来想了一下，<code>await</code>和<code>dispatch_async</code>都可以简单理解为异步操作，OC的线程是基于<code>Runloop</code>实现的，<code>Dart</code>本质上也是有事件循环的，而且二者都有自己的事件队列，只是队列数量和分类不同。</p>
<p>我觉得当执行到<code>await</code>时，保存当前的上下文，并将当前位置标记为待处理任务，用一个指针指向当前位置，并将待处理任务放入当前<code>isolate</code>的队列中。在每个事件循环时都去询问这个任务，如果需要进行处理，就恢复上下文进行任务处理。</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>这里想提一下<code>JS</code>里的<code>Promise</code>语法，在iOS中会出现很多<code>if</code>判断或者其他的嵌套调用，而<code>Promise</code>可以把之前横向的嵌套调用，改成纵向链式调用。如果能把<code>Promise</code>引入到OC里，可以让代码看起来更简洁，直观。</p>
<h3 id="isolate"><a href="#isolate" class="headerlink" title="isolate"></a>isolate</h3><p><code>isolate</code>是<code>Dart</code>平台对线程的实现方案，但和普通<code>Thread</code>不同的是，<code>isolate</code>拥有独立的内存，<code>isolate</code>由线程和独立内存构成。正是由于<code>isolate</code>线程之间的内存不共享，所以<code>isolate</code>线程之间并不存在资源抢夺的问题，所以也不需要锁。</p>
<p>通过<code>isolate</code>可以很好的利用多核CPU，来进行大量耗时任务的处理。<code>isolate</code>线程之间的通信主要通过<code>port</code>来进行，这个<code>port</code>消息传递的过程是异步的。通过<code>Dart</code>源码也可以看出，实例化一个<code>isolate</code>的过程包括，实例化<code>isolate</code>结构体、在堆中分配线程内存、配置<code>port</code>等过程。</p>
<p><code>isolate</code>看起来其实和进程比较相似，之前请教阿里架构师宗心问题时，宗心也说过“<code>isolate</code>的整体模型我自己的理解其实更像进程，而<code>async</code>、<code>await</code>更像是线程”。如果对比一下<code>isolate</code>和进程的定义，会发现确实<code>isolate</code>很像是进程。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>下面是一个<code>isolate</code>的例子，例子中新创建了一个<code>isolate</code>，并且绑定了一个方法进行网络请求和数据解析的处理，并通过<code>port</code>将处理好的数据返回给调用方。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">loadData() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// 通过spawn新建一个isolate，并绑定静态方法</span></span><br><span class="line">    ReceivePort receivePort =ReceivePort();</span><br><span class="line">    <span class="keyword">await</span> Isolate.spawn(dataLoader, receivePort.sendPort);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取新isolate的监听port</span></span><br><span class="line">    SendPort sendPort = <span class="keyword">await</span> receivePort.first;</span><br><span class="line">    <span class="comment">// 调用sendReceive自定义方法</span></span><br><span class="line">    <span class="built_in">List</span> dataList = <span class="keyword">await</span> sendReceive(sendPort, <span class="string">'https://jsonplaceholder.typicode.com/posts'</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'dataList <span class="subst">$dataList</span>'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// isolate的绑定方法</span></span><br><span class="line"><span class="keyword">static</span> dataLoader(SendPort sendPort) <span class="keyword">async</span>&#123;</span><br><span class="line">    <span class="comment">// 创建监听port，并将sendPort传给外界用来调用</span></span><br><span class="line">    ReceivePort receivePort =ReceivePort();</span><br><span class="line">    sendPort.send(receivePort.sendPort);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 监听外界调用</span></span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> msg <span class="keyword">in</span> receivePort) &#123;</span><br><span class="line">      <span class="built_in">String</span> requestURL =msg[<span class="number">0</span>];</span><br><span class="line">      SendPort callbackPort =msg[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">      Client client = Client();</span><br><span class="line">      Response response = <span class="keyword">await</span> client.<span class="keyword">get</span>(requestURL);</span><br><span class="line">      <span class="built_in">List</span> dataList = json.decode(response.body);</span><br><span class="line">      <span class="comment">// 回调返回值给调用者</span></span><br><span class="line">      callbackPort.send(dataList);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建自己的监听port，并且向新isolate发送消息</span></span><br><span class="line">Future sendReceive(SendPort sendPort, <span class="built_in">String</span> url) &#123;</span><br><span class="line">    ReceivePort receivePort =ReceivePort();</span><br><span class="line">    sendPort.send([url, receivePort.sendPort]);</span><br><span class="line">    <span class="comment">// 接收到返回值，返回给调用者</span></span><br><span class="line">    <span class="keyword">return</span> receivePort.first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>isolate</code>和iOS中的线程还不太一样，<code>isolate</code>的线程更偏底层。当生成一个<code>isolate</code>后，其内存是各自独立的，相互之间并不能进行访问。但<code>isolate</code>提供了基于<code>port</code>的消息机制，通过建立通信双方的<code>sendPort</code>和<code>receiveport</code>，进行相互的消息传递，在<code>Dart</code>中叫做消息传递。</p>
<p>从上面例子中可以看出，在进行<code>isolate</code>消息传递的过程中，本质上就是进行<code>port</code>的传递。将<code>port</code>传递给其他<code>isolate</code>，其他<code>isolate</code>通过<code>port</code>拿到<code>sendPort</code>，向调用方发送消息来进行相互的消息传递。</p>
<h3 id="Embedder"><a href="#Embedder" class="headerlink" title="Embedder"></a>Embedder</h3><p>正如其名，<code>Embedder</code>是一个嵌入层，将<code>Flutter</code>嵌入到各个平台上。<code>Embedder</code>负责范围包括原生平台插件、线程管理、事件循环等。</p>
<p><code>Embedder</code>中存在四个<code>Runner</code>，四个<code>Runner</code>分别如下。其中每个<code>Flutter Engine</code>各自对应一个<code>UI Runner</code>、<code>GPU Runner</code>、<code>IO Runner</code>，但所有<code>Engine</code>共享一个<code>Platform Runner</code>。</p>
<p><code>Runner</code>和<code>isolate</code>并不是一码事，彼此相互独立。以iOS平台为例，<code>Runner</code>的实现就是<code>CFRunLoop</code>，以一个事件循环的方式不断处理任务。并且<code>Runner</code>不只处理<code>Engine</code>的任务，还有<code>Native Plugin</code>带来的原生平台的任务。而<code>isolate</code>则由<code>Dart VM</code>进行管理，和原生平台线程并无关系。</p>
<h3 id="Platform-Runner"><a href="#Platform-Runner" class="headerlink" title="Platform Runner"></a>Platform Runner</h3><p><code>Platform Runner</code>和iOS平台的<code>Main Thread</code>非常相似，在<code>Flutter</code>中除耗时操作外，所有任务都应该放在<code>Platform</code>中，<code>Flutter</code>中的很多API并不是线程安全的，放在其他线程中可能会导致一些bug。</p>
<p>但例如IO之类的耗时操作，应该放在其他线程中完成，否则会影响<code>Platform</code>的正常执行，甚至于被<code>watchdog</code>干掉。但需要注意的是，由于<code>Embedder Runner</code>的机制，<code>Platform</code>被阻塞后并不会导致页面卡顿。</p>
<p>不只是<code>Flutter Engine</code>的代码在<code>Platform</code>中执行，<code>Native Plugin</code>的任务也会派发到<code>Platform</code>中执行。实际上，在原生侧的代码运行在<code>Platform Runner</code>中，而<code>Flutter</code>侧的代码运行在<code>Root Isolate</code>中，如果在<code>Platform</code>中执行耗时代码，则会卡原生平台的主线程。 </p>
<h3 id="UI-Runner"><a href="#UI-Runner" class="headerlink" title="UI Runner"></a>UI Runner</h3><p><code>UI Runner</code>负责为<code>Flutter Engine</code>执行<code>Root Isolate</code>的代码，除此之外，也处理来自<code>Native Plugin</code>的任务。<code>Root Isolate</code>为了处理自身事件，绑定了很多函数方法。程序启动时，<code>Flutter Engine</code>会为<code>Root</code>绑定<code>UI Runner</code>的处理函数，使<code>Root Isolate</code>具备提交渲染帧的能力。</p>
<p>当<code>Root Isolate</code>向<code>Engine</code>提交一次渲染帧时，<code>Engine</code>会等待下次vsync，当下次vsync到来时，由<code>Root Isolate</code>对<code>Widgets</code>进行布局操作，并生成页面的显示信息的描述，并将信息交给<code>Engine</code>去处理。</p>
<p>由于对<code>widgets</code>进行<code>layout</code>并生成<code>layer tree</code>是<code>UI Runner</code>进行的，如果在<code>UI Runner</code>中进行大量耗时处理，会影响页面的显示，所以应该将耗时操作交给其他<code>isolate</code>处理，例如来自<code>Native Plugin</code>的事件。</p>
<h3 id="GPU-Runner"><a href="#GPU-Runner" class="headerlink" title="GPU Runner"></a>GPU Runner</h3><p><code>GPU Runner</code>并不直接负责渲染操作，其负责GPU相关的管理和调度。当<code>layer tree</code>信息到来时，<code>GPU Runner</code>将其提交给指定的渲染平台，渲染平台是Skia配置的，不同平台可能有不同的实现。</p>
<p><code>GPU Runner</code>相对比较独立，除了<code>Embedder</code>外其他线程均不可向其提交渲染信息。</p>
<h3 id="IO-Runner"><a href="#IO-Runner" class="headerlink" title="IO Runner"></a>IO Runner</h3><p>一些<code>GPU Runner</code>中比较耗时的操作，就放在<code>IO Runner</code>中进行处理，例如图片读取、解压、渲染等操作。但是只有<code>GPU Runner</code>才能对GPU提交渲染信息，为了保证<code>IO Runner</code>也具备这个能力，所以<code>IO Runner</code>会引用<code>GPU Runner</code>的<code>context</code>，这样就具备向GPU提交渲染信息的能力</p>
<p><a href="https://www.jianshu.com/p/54da18ed1a9e" target="_blank" rel="noopener">本文地址</a></p>
<p><a href="https://www.jianshu.com/p/aaa6a8b1d6b0" target="_blank" rel="noopener">闲鱼讲解</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/20/flutter%E6%8E%A2%E7%B4%A2-Provider%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/20/flutter%E6%8E%A2%E7%B4%A2-Provider%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">flutter探索  - Provider源码解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-20 10:00:34" itemprop="dateCreated datePublished" datetime="2021-05-20T10:00:34+08:00">2021-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-01 21:29:37" itemprop="dateModified" datetime="2021-08-01T21:29:37+08:00">2021-08-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一篇中我们列举了几种状态管理，我们已经知道Provider是对InheritedWidget的包装，只是让InheritedWidget用起来更加简单且高可复用。我们上一篇也提到过InheritedWidget的缺点。</p>
<p>我们这篇主要带着问题，看Provider是如果规避InheritedWidget的缺点，而且Provider提供了dispose回调，你可以在该函数中主动关闭，如何做到的呢。带着这些问题，我们寻找答案。</p>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>我们先看怎么使用provider。</p>
<h4 id="1、定义一个ChangeNotifier"><a href="#1、定义一个ChangeNotifier" class="headerlink" title="1、定义一个ChangeNotifier"></a>1、定义一个ChangeNotifier</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="title">with</span> <span class="title">ChangeNotifier</span>, <span class="title">DiagnosticableTreeMixin</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _count = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> count =&gt; _count;</span><br><span class="line">  <span class="keyword">void</span> increment() &#123;</span><br><span class="line">    _count++;</span><br><span class="line">    notifyListeners();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Makes <span class="code">`Counter`</span> readable inside the devtools by listing all of its properties</span></span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> debugFillProperties(DiagnosticPropertiesBuilder properties) &#123;</span><br><span class="line">    <span class="keyword">super</span>.debugFillProperties(properties);</span><br><span class="line">    properties.add(IntProperty(<span class="string">'count'</span>, count));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、用ChangeNotifierProvider来订阅Counter"><a href="#2、用ChangeNotifierProvider来订阅Counter" class="headerlink" title="2、用ChangeNotifierProvider来订阅Counter"></a>2、用ChangeNotifierProvider来订阅Counter</h4><p>不难猜出，ChangeNotifierProvider肯定是InheritedWidget的包装类，负责将Counter的状态共享给子Widget。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(</span><br><span class="line">    <span class="comment">/// <span class="markdown">Providers are above [MyApp] instead of inside it, so that tests</span></span></span><br><span class="line">    <span class="comment">/// <span class="markdown">can use [MyApp] while mocking the providers</span></span></span><br><span class="line">    MultiProvider(</span><br><span class="line">      providers: [</span><br><span class="line">        ChangeNotifierProvider(create: (_) =&gt; Counter()),</span><br><span class="line">      ],</span><br><span class="line">      child: <span class="keyword">const</span> MyApp(),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、接收数据通过Consumer&lt;Counter&gt;</p>
<p>Consumer是个消费者，它负责消费ChangeNotifierProvider生产的数据。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> MyApp(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const</span> MaterialApp(</span><br><span class="line">      home: MyHomePage(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> MyHomePage(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: <span class="keyword">const</span> Text(<span class="string">'Example'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisSize: MainAxisSize.min,</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: <span class="keyword">const</span> &lt;Widget&gt;[</span><br><span class="line">            Text(<span class="string">'You have pushed the button this many times:'</span>),</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// <span class="markdown">Extracted as a separate widget for performance optimization.</span></span></span><br><span class="line">            <span class="comment">/// <span class="markdown">As a separate widget, it will rebuild independently from [MyHomePage].</span></span></span><br><span class="line">            <span class="comment">///</span></span><br><span class="line">            <span class="comment">/// <span class="markdown">This is totally optional (and rarely needed).</span></span></span><br><span class="line">            <span class="comment">/// <span class="markdown">Similarly, we could also use [Consumer] or [Selector].</span></span></span><br><span class="line">            Consume&lt;Counter&gt;(</span><br><span class="line">            	builder:(BuildContext context,Counter value,Widget child)&#123;</span><br><span class="line">                <span class="keyword">return</span> Text(<span class="string">'<span class="subst">$&#123;value.count&#125;</span>'</span>)</span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">            Count(),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        key: <span class="keyword">const</span> Key(<span class="string">'increment_floatingActionButton'</span>),</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// <span class="markdown">Calls <span class="code">`context.read`</span> instead of <span class="code">`context.watch`</span> so that it does not rebuild</span></span></span><br><span class="line">        <span class="comment">/// <span class="markdown">when [Counter] changes.</span></span></span><br><span class="line">        onPressed: () =&gt; context.read&lt;Counter&gt;().increment(),</span><br><span class="line">        tooltip: <span class="string">'Increment'</span>,</span><br><span class="line">        child: <span class="keyword">const</span> Icon(Icons.add),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Count(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Text(</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// <span class="markdown">Calls <span class="code">`context.watch`</span> to make [Count] rebuild when [Counter] changes.</span></span></span><br><span class="line">        <span class="string">'<span class="subst">$&#123;context.watch&lt;Counter&gt;().count&#125;</span>'</span>,</span><br><span class="line">        key: <span class="keyword">const</span> Key(<span class="string">'counterState'</span>),</span><br><span class="line">        style: Theme.of(context).textTheme.headline4);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过看Provider的用法例子，可以判断出Provider的封装足够易用，而且Counter作为Model层使用with ChangeNotifier而不是继承，所以说它的侵入性也比较低。下面我们看InheritedWidget的缺点看是否已经规避</p>
<h5 id="1、-容易造成不必要的刷新（看是否已经解决）"><a href="#1、-容易造成不必要的刷新（看是否已经解决）" class="headerlink" title="1、 容易造成不必要的刷新（看是否已经解决）"></a>1、 容易造成不必要的刷新（看是否已经解决）</h5><p>我们家两个子Widget进去，排在Consumer的后面，OtherWidget什么都不干，不去订阅Counter，OtherWidget2通过contex.watch&lt;Counter&gt;().count函数监听而不是Consumer，来看一下效果一样不，然后在build函数中都加入<code>print</code></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OtherWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'OtherWidget build'</span>);</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">return</span> Text(<span class="string">'OtherWidget'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OtherWidget2</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'OtherWidget2 build'</span>);</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">return</span> Text(<span class="string">'OtherWidget2 <span class="subst">$&#123;context.watch&lt;Counter&gt;().count&#125;</span>'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出几个结论</p>
<ul>
<li>Consumer、context.watch都可以监听Counter变化</li>
<li>Consumer只会刷新自己</li>
<li>context.watch所在的子widget不管是否是const都会被重建后刷新数据</li>
<li>OtherWidget并没有被重建，因为它没有订阅Counter</li>
</ul>
<p>局部刷新确实实现了通过Consumer，第二个问题不支持跨页面router的状态，这个不支持，第三个问题数据是不可变的（只读），经过这个例子可以分辨出数据确实是可变的，如何变化的我们分析源码找本质。</p>
<p>ChangeNotifier和ChangeNotifierProvider是被观察者和观察者的关系。ChangeNotifierProvider和Cosumer是生产者和消费者的关系。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="ChangeNotifier"><a href="#ChangeNotifier" class="headerlink" title="ChangeNotifier"></a>ChangeNotifier</h4><p>在包package:meta/meta.dart下，是flutter sdk的代码，并不属于Provider框架的一部分。通过查看代码可以看出，这是一个标准的观察者模型，而真正的监听者就是typedef VoidCallback = void Function();是dart.ui包下定义的一个函数，没有任何返回参数的函数。ChangeNotifer实现抽象类Listenable，通过源码注释我们看到Listenable是一个转么负责维护监听列表的一个抽象类。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ListenerEntry</span> <span class="keyword">extends</span> <span class="title">LinkedListEntry</span>&lt;<span class="title">_ListenerEntry</span>&gt; </span>&#123;</span><br><span class="line">  _ListenerEntry(<span class="keyword">this</span>.listener);</span><br><span class="line">  <span class="keyword">final</span> VoidCallback listener;<span class="comment">//真正的监听者</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// <span class="markdown">A class that can be extended or mixed in that provides a change notification</span></span></span><br><span class="line"><span class="comment">/// <span class="markdown">API using [VoidCallback] for notifications.</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="markdown">It is O(1) for adding listeners and O(N) for removing listeners and dispatching</span></span></span><br><span class="line"><span class="comment">/// <span class="markdown">notifications (where N is the number of listeners).</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="markdown">See also:</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///  <span class="markdown"><span class="bullet">* </span>[ValueNotifier], which is a [ChangeNotifier] that wraps a single value.</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangeNotifier</span> <span class="keyword">implements</span> <span class="title">Listenable</span> </span>&#123;</span><br><span class="line">  LinkedList&lt;_ListenerEntry&gt;? _listeners = LinkedList&lt;_ListenerEntry&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> _debugAssertNotDisposed() &#123;</span><br><span class="line">    <span class="keyword">assert</span>(() &#123;</span><br><span class="line">      <span class="keyword">if</span> (_listeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> FlutterError(</span><br><span class="line">          <span class="string">'A <span class="subst">$runtimeType</span> was used after being disposed.\n'</span></span><br><span class="line">          <span class="string">'Once you have called dispose() on a <span class="subst">$runtimeType</span>, it can no longer be used.'</span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Whether any listeners are currently registered.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">Clients should not depend on this value for their behavior, because having</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">one listener's logic change when another listener happens to start or stop</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">listening will lead to extremely hard-to-track bugs. Subclasses might use</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">this information to determine whether to do any work when there are no</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">listeners, however; for example, resuming a [Stream] when a listener is</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">added and pausing it when a listener is removed.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">Typically this is used by overriding [addListener], checking if</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">[hasListeners] is false before calling <span class="code">`super.addListener()`</span>, and if so,</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">starting whatever work is needed to determine when to call</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">[notifyListeners]; and similarly, by overriding [removeListener], checking</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">if [hasListeners] is false after calling <span class="code">`super.removeListener()`</span>, and if</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">so, stopping that same work.</span></span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> hasListeners &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_debugAssertNotDisposed());</span><br><span class="line">    <span class="keyword">return</span> _listeners!.isNotEmpty;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Register a closure to be called when the object changes.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">This method must not be called after [dispose] has been called.</span></span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> addListener(VoidCallback listener) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_debugAssertNotDisposed());</span><br><span class="line">    _listeners!.add(_ListenerEntry(listener));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Remove a previously registered closure from the list of closures that are</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">notified when the object changes.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">If the given listener is not registered, the call is ignored.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">This method must not be called after [dispose] has been called.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">If a listener had been added twice, and is removed once during an</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">iteration (i.e. in response to a notification), it will still be called</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">again. If, on the other hand, it is removed as many times as it was</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">registered, then it will no longer be called. This odd behavior is the</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">result of the [ChangeNotifier] not being able to determine which listener</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">is being removed, since they are identical, and therefore conservatively</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">still calling all the listeners when it knows that any are still</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">registered.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">This surprising behavior can be unexpectedly observed when registering a</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">listener on two separate objects which are both forwarding all</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">registrations to a common upstream object.</span></span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> removeListener(VoidCallback listener) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_debugAssertNotDisposed());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> _ListenerEntry entry <span class="keyword">in</span> _listeners!) &#123;</span><br><span class="line">      <span class="keyword">if</span> (entry.listener == listener) &#123;</span><br><span class="line">        entry.unlink();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Discards any resources used by the object. After this is called, the</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">object is not in a usable state and should be discarded (calls to</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">[addListener] and [removeListener] will throw after the object is</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">disposed).</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">This method should only be called by the object's owner.</span></span></span><br><span class="line">  <span class="meta">@mustCallSuper</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_debugAssertNotDisposed());</span><br><span class="line">    _listeners = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Call all the registered listeners.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">Call this method whenever the object changes, to notify any clients the</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">object may have changed. Listeners that are added during this iteration</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">will not be visited. Listeners that are removed during this iteration will</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">not be visited after they are removed.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">Exceptions thrown by listeners will be caught and reported using</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">[FlutterError.reportError].</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">This method must not be called after [dispose] has been called.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">Surprising behavior can result when reentrantly removing a listener (i.e.</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">in response to a notification) that has been registered multiple times.</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">See the discussion at [removeListener].</span></span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="meta">@visibleForTesting</span></span><br><span class="line">  <span class="keyword">void</span> notifyListeners() &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_debugAssertNotDisposed());</span><br><span class="line">    <span class="keyword">if</span> (_listeners!.isEmpty)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">List</span>&lt;_ListenerEntry&gt; localListeners = <span class="built_in">List</span>&lt;_ListenerEntry&gt;.from(_listeners!);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> _ListenerEntry entry <span class="keyword">in</span> localListeners) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.list != <span class="keyword">null</span>)</span><br><span class="line">          entry.listener();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (exception, stack) &#123;</span><br><span class="line">        FlutterError.reportError(FlutterErrorDetails(</span><br><span class="line">          exception: exception,</span><br><span class="line">          stack: stack,</span><br><span class="line">          <span class="keyword">library</span>: <span class="string">'foundation library'</span>,</span><br><span class="line">          context: ErrorDescription(<span class="string">'while dispatching notifications for <span class="subst">$runtimeType</span>'</span>),</span><br><span class="line">          informationCollector: () <span class="keyword">sync</span>* &#123;</span><br><span class="line">            <span class="keyword">yield</span> DiagnosticsProperty&lt;ChangeNotifier&gt;(</span><br><span class="line">              <span class="string">'The <span class="subst">$runtimeType</span> sending notification was'</span>,</span><br><span class="line">              <span class="keyword">this</span>,</span><br><span class="line">              style: DiagnosticsTreeStyle.errorProperty,</span><br><span class="line">            );</span><br><span class="line">          &#125;,</span><br><span class="line">        ));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ChangeNotifierProvider"><a href="#ChangeNotifierProvider" class="headerlink" title="ChangeNotifierProvider"></a>ChangeNotifierProvider</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangeNotifierProvider</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">ChangeNotifier</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">ListenableProvider</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Creates a [ChangeNotifier] using <span class="code">`create`</span> and automatically</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">dispose it when [ChangeNotifierProvider] is removed from the widget tree.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown"><span class="code">`create`</span> must not be <span class="code">`null`</span>.</span></span></span><br><span class="line">  ChangeNotifierProvider(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> Create&lt;T&gt; create,</span><br><span class="line">    <span class="built_in">bool</span> lazy,</span><br><span class="line">    TransitionBuilder builder,</span><br><span class="line">    Widget child,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(</span><br><span class="line">          key: key,</span><br><span class="line">          create: create,</span><br><span class="line">          dispose: _dispose,</span><br><span class="line">          lazy: lazy,</span><br><span class="line">          builder: builder,</span><br><span class="line">          child: child,</span><br><span class="line">        );</span><br><span class="line">  <span class="comment">/// <span class="markdown">Provides an existing [ChangeNotifier].</span></span></span><br><span class="line">  ChangeNotifierProvider.value(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> T value,</span><br><span class="line">    TransitionBuilder builder,</span><br><span class="line">    Widget child,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>.value(</span><br><span class="line">          key: key,</span><br><span class="line">          builder: builder,</span><br><span class="line">          value: value,</span><br><span class="line">          child: child,</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> _dispose(BuildContext context, ChangeNotifier notifier) &#123;</span><br><span class="line">    notifier?.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析一下构造</p>
<ul>
<li><p>Create&lt;T&gt; create</p>
<p>是个通用函数typedef Create&lt;T&gt; = T Function(BuildContext context)用于创建T类，这里负责创建ChangeNotifier</p>
</li>
<li><p>bool lazy</p>
<p>是否是懒加载</p>
</li>
<li><p>TransitionBuilder builder</p>
<p>当builder存在时将不会用child作为子widget，追溯源码实现，根据继承关系找到InheritedProvider：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget buildWithChild(BuildContext context, Widget child) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(</span><br><span class="line">    builder != <span class="keyword">null</span> || child != <span class="keyword">null</span>,</span><br><span class="line">    <span class="string">'<span class="subst">$runtimeType</span> used outside of MultiProvider must specify a child'</span>,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> _InheritedProviderScope&lt;T&gt;(</span><br><span class="line">    owner: <span class="keyword">this</span>,</span><br><span class="line">    child: builder != <span class="keyword">null</span></span><br><span class="line">        ? Builder(</span><br><span class="line">            builder: (context) =&gt; builder(context, child),</span><br><span class="line">          )</span><br><span class="line">        : child,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Widget child</p>
<p>builder不存在时就用child。</p>
</li>
</ul>
<p>ChangeNotifierProvider继承 ListenableProvider,我们我们继续看ListenableProvider：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListenableProvider</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Listenable</span>&gt; <span class="keyword">extends</span> <span class="title">InheritedProvider</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Creates a [Listenable] using [create] and subscribes to it.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">[dispose] can optionally passed to free resources</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">when [ListenableProvider] is removed from the tree.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">[create] must not be <span class="code">`null`</span>.</span></span></span><br><span class="line">  ListenableProvider(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> Create&lt;T&gt; create,</span><br><span class="line">    Dispose&lt;T&gt; dispose,</span><br><span class="line">    <span class="built_in">bool</span> lazy,</span><br><span class="line">    TransitionBuilder builder,</span><br><span class="line">    Widget child,</span><br><span class="line">  &#125;)  : <span class="keyword">assert</span>(create != <span class="keyword">null</span>),</span><br><span class="line">        <span class="keyword">super</span>(</span><br><span class="line">          key: key,</span><br><span class="line">          startListening: _startListening,</span><br><span class="line">          create: create,</span><br><span class="line">          dispose: dispose,</span><br><span class="line">          lazy: lazy,</span><br><span class="line">          builder: builder,</span><br><span class="line">          child: child,</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Provides an existing [Listenable].</span></span></span><br><span class="line">  ListenableProvider.value(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> T value,</span><br><span class="line">    UpdateShouldNotify&lt;T&gt; updateShouldNotify,</span><br><span class="line">    TransitionBuilder builder,</span><br><span class="line">    Widget child,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>.value(</span><br><span class="line">          key: key,</span><br><span class="line">          builder: builder,</span><br><span class="line">          value: value,</span><br><span class="line">          updateShouldNotify: updateShouldNotify,</span><br><span class="line">          startListening: _startListening,</span><br><span class="line">          child: child,</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> VoidCallback _startListening(</span><br><span class="line">    InheritedContext&lt;Listenable&gt; e,</span><br><span class="line">    Listenable value,</span><br><span class="line">  ) &#123;</span><br><span class="line">    value?.addListener(e.markNeedsNotifyDependents);</span><br><span class="line">    <span class="keyword">return</span> () =&gt; value?.removeListener(e.markNeedsNotifyDependents);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Listenable上面已经分析，它是负责管理观察者列表的抽象</li>
<li>它比子类ChangeNotifierProvider多了一个构造函数dispose，这个函数是 typedef Dispose&lt;T&gt; = void Function(BuildContext context, T value);是个回调，应该是当页面被销毁时出发（需要继续探究源码，目前只是猜测）。</li>
</ul>
<p>因为ListenableProvider是继承自InheritedProvider，我们继续看InheritedProvider的实现：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">A generic implementation of an [InheritedWidget].</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="markdown">Any descendant of this widget can obtain <span class="code">`value`</span> using [Provider.of].</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="markdown">Do not use this class directly unless you are creating a custom "Provider".</span></span></span><br><span class="line"><span class="comment">/// <span class="markdown">Instead use [Provider] class, which wraps [InheritedProvider].</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="markdown">See also:</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///  <span class="markdown"><span class="bullet">- </span>[DeferredInheritedProvider], a variant of this object where the provided</span></span></span><br><span class="line"><span class="comment">///    <span class="markdown">object and the created object are two different entity.</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InheritedProvider</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SingleChildStatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Creates a value, then expose it to its descendants.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">The value will be disposed of when [InheritedProvider] is removed from</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">the widget tree.</span></span></span><br><span class="line">  InheritedProvider(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    Create&lt;T&gt; create,</span><br><span class="line">    T <span class="built_in">Function</span>(BuildContext context, T value) update,</span><br><span class="line">    UpdateShouldNotify&lt;T&gt; updateShouldNotify,</span><br><span class="line">    <span class="keyword">void</span> <span class="built_in">Function</span>(T value) debugCheckInvalidValueType,</span><br><span class="line">    StartListening&lt;T&gt; startListening,</span><br><span class="line">    Dispose&lt;T&gt; dispose,</span><br><span class="line">    <span class="keyword">this</span>.builder,</span><br><span class="line">    <span class="built_in">bool</span> lazy,</span><br><span class="line">    Widget child,</span><br><span class="line">  &#125;)  : _lazy = lazy,</span><br><span class="line">        _delegate = _CreateInheritedProvider(</span><br><span class="line">          create: create,</span><br><span class="line">          update: update,</span><br><span class="line">          updateShouldNotify: updateShouldNotify,</span><br><span class="line">          debugCheckInvalidValueType: debugCheckInvalidValueType,</span><br><span class="line">          startListening: startListening,</span><br><span class="line">          dispose: dispose,</span><br><span class="line">        ),</span><br><span class="line">        <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Expose to its descendants an existing value,</span></span></span><br><span class="line">  InheritedProvider.value(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> T value,</span><br><span class="line">    UpdateShouldNotify&lt;T&gt; updateShouldNotify,</span><br><span class="line">    StartListening&lt;T&gt; startListening,</span><br><span class="line">    <span class="built_in">bool</span> lazy,</span><br><span class="line">    <span class="keyword">this</span>.builder,</span><br><span class="line">    Widget child,</span><br><span class="line">  &#125;)  : _lazy = lazy,</span><br><span class="line">        _delegate = _ValueInheritedProvider(</span><br><span class="line">          value: value,</span><br><span class="line">          updateShouldNotify: updateShouldNotify,</span><br><span class="line">          startListening: startListening,</span><br><span class="line">        ),</span><br><span class="line">        <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  InheritedProvider._constructor(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    _Delegate&lt;T&gt; delegate,</span><br><span class="line">    <span class="built_in">bool</span> lazy,</span><br><span class="line">    <span class="keyword">this</span>.builder,</span><br><span class="line">    Widget child,</span><br><span class="line">  &#125;)  : _lazy = lazy,</span><br><span class="line">        _delegate = delegate,</span><br><span class="line">        <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> _Delegate&lt;T&gt; _delegate;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> _lazy;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Syntax sugar for obtaining a [BuildContext] that can read the provider</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">created.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">This code:</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown"><span class="code">```dart</span></span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">Provider<span class="xml"><span class="tag">&lt;<span class="name">int</span>&gt;</span></span>(</span></span></span><br><span class="line">  <span class="comment">///   <span class="markdown">create: (context) =&gt; 42,</span></span></span><br><span class="line">  <span class="comment">///   <span class="markdown">builder: (context, child) &#123;</span></span></span><br><span class="line">  <span class="comment">///     <span class="markdown">final value = context.watch<span class="xml"><span class="tag">&lt;<span class="name">int</span>&gt;</span></span>();</span></span></span><br><span class="line">  <span class="comment">///     <span class="markdown">return Text('$value');</span></span></span><br><span class="line">  <span class="comment">///   <span class="markdown">&#125;</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">)</span></span></span><br><span class="line">  <span class="comment">///</span></span><br></pre></td></tr></table></figure>
<p>  ///<br>  /// is strictly equivalent to:<br>  ///<br>  /// <code>dart
  /// Provider&lt;int&gt;(
  ///   create: (context) =&gt; 42,
  ///   child: Builder(
  ///     builder: (context) {
  ///       final value = context.watch&lt;int&gt;();
  ///       return Text(&#39;$value&#39;);
  ///     },
  ///   ),
  /// )
  ///</code><br>  ///<br>  /// For an explanation on the <code>child</code> parameter that <code>builder</code> receives,<br>  /// see the “Performance optimizations” section of [AnimatedBuilder].<br>  final TransitionBuilder builder;</p>
<p>  @override<br>  void debugFillProperties(DiagnosticPropertiesBuilder properties) {<br>    super.debugFillProperties(properties);<br>    _delegate.debugFillProperties(properties);<br>  }</p>
<p>  @override<br>  _InheritedProviderElement<T> createElement() {<br>    return _InheritedProviderElement<T>(this);<br>  }</p>
<p>  @override<br>  Widget buildWithChild(BuildContext context, Widget child) {<br>    assert(<br>      builder != null || child != null,<br>      ‘$runtimeType used outside of MultiProvider must specify a child’,<br>    );<br>    return _InheritedProviderScope<T>(<br>      owner: this,<br>      child: builder != null<br>          ? Builder(<br>              builder: (context) =&gt; builder(context, child),<br>            )<br>          : child,<br>    );<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">构造函数中多出来的参数：</span><br><span class="line"></span><br><span class="line">*  T Function(BuildContext context, T value) update，该函数返回数据变更值value，具体实现在\_CreateInheritedProvider类中，说白了InheritedProvider\&lt;T&gt;是无状态的，他要变更的话依赖于\_CreateInheritedProvider类，\_CreateInheritedProvider是\_Delegate的实现类，\_Delegate是一个状态代理类，来看一下\_Delegate的实现</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;dart</span><br><span class="line">  @immutable</span><br><span class="line">  abstract class _Delegate&lt;T&gt; &#123;</span><br><span class="line">    _DelegateState&lt;T, _Delegate&lt;T&gt;&gt; createState();</span><br><span class="line">  </span><br><span class="line">    void debugFillProperties(DiagnosticPropertiesBuilder properties) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  abstract class _DelegateState&lt;T, D extends _Delegate&lt;T&gt;&gt; &#123;</span><br><span class="line">    _InheritedProviderScopeElement&lt;T&gt; element;</span><br><span class="line">  </span><br><span class="line">    T get value;</span><br><span class="line">  </span><br><span class="line">    D get delegate &#x3D;&gt; element.widget.owner._delegate as D;</span><br><span class="line">  </span><br><span class="line">    bool get hasValue;</span><br><span class="line">  </span><br><span class="line">    bool debugSetInheritedLock(bool value) &#123;</span><br><span class="line">      return element._debugSetInheritedLock(value);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    bool willUpdateDelegate(D newDelegate) &#x3D;&gt; false;</span><br><span class="line">  </span><br><span class="line">    void dispose() &#123;&#125;</span><br><span class="line">  </span><br><span class="line">    void debugFillProperties(DiagnosticPropertiesBuilder properties) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">    void build(&#123;@required bool isBuildFromExternalSources&#125;) &#123;&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>  这里用到了委托模式，这里就有点类似StatefulWidget和State的关系，同样的_DelegateState提供了类似生命周期的函数，如willUpdateDelegate更新新的委托，dispose注销等。</p>
<ul>
<li>UpdateShouldNotify&lt;T&gt; updateShouldNotify,<br>   void Function(T value) debugCheckInvalidValueType,<br>   StartListening&lt;T&gt; startListening,<br>   Dispose&lt;T&gt; dispose,这些函数全部交给了委托类。</li>
<li>最关键的实现来了，到目前为止还没看到InheritedWidget的逻辑，他来了Widget buildWithChild(BuildContext context, Widget child)，我们传入的Widget就被叫_InheritedProviderScope的类包裹了，看一下源码：</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_InheritedProviderScope</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">InheritedWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> _InheritedProviderScope(&#123;</span><br><span class="line">    <span class="keyword">this</span>.owner,</span><br><span class="line">    <span class="meta">@required</span> Widget child,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(child: child);</span><br><span class="line">  <span class="keyword">final</span> InheritedProvider&lt;T&gt; owner;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> updateShouldNotify(InheritedWidget oldWidget) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _InheritedProviderScopeElement&lt;T&gt; createElement() &#123;</span><br><span class="line">    <span class="keyword">return</span> _InheritedProviderScopeElement&lt;T&gt;(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此你有没有发现一个特点，所有的函数都被_Delegate带走了，剩下的只有Widget交给了_InheritedProviderScope,这个设计很好，毕竟InheritedWidget其实也就只能做到数据共享，跟函数并没有关系，唯一有关系的地方，猜测在InheritedWidget提供的Widget中调用。</p>
<p>一个细节：this在buildWithChild函数中，将InheritedProvider本身传递给InheritedWidget，应该是为了方便调用它的_Delegate委托类，用来回调各种函数。</p>
<p>_InheritedProviderScope唯一特殊的地方，我们发现它自己创建了一个Element实现通过覆盖createElement函数，返回_InheritedProviderScopeElement实例，flutter三板斧Widget、Element、RenderObject，该框架自己实现一层Element，我们知道Widget是配置文件，只有build和rebuild以及remove from the tree，而Element作为一层虚拟Dom，主要负责优化，优化页面刷新的逻辑，我们详细看有一下_InheritedProviderScopeElement的源码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承自InheritedElement，因为InheritedWidget对应的Element就是它</span></span><br><span class="line"><span class="comment">//实现InheritedContext，InheritedContext继承自BuildContext，多了个T泛型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_InheritedProviderScopeElement</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">InheritedElement</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">InheritedContext</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">//构造函数，将Element对应的Widget传进来</span></span><br><span class="line">  _InheritedProviderScopeElement(_InheritedProviderScope&lt;T&gt; widget)</span><br><span class="line">      : <span class="keyword">super</span>(widget);</span><br><span class="line">  <span class="comment">//是否需要通知依赖的Element变更</span></span><br><span class="line">  <span class="built_in">bool</span> _shouldNotifyDependents = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">bool</span> _debugInheritLocked = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">//是否允许通知变更</span></span><br><span class="line">  <span class="built_in">bool</span> _isNotifyDependentsEnabled = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">//是否第一次构建</span></span><br><span class="line">  <span class="built_in">bool</span> _firstBuild = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">//是否更新newWidget的Delegate委托</span></span><br><span class="line">  <span class="built_in">bool</span> _updatedShouldNotify = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">//这个变量就是控制的数据变更，在Widget变更和Element依赖变更的时候都会被设置为true</span></span><br><span class="line">  <span class="built_in">bool</span> _isBuildFromExternalSources = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">//委托类的状态 this就是为了那到上层的委托类</span></span><br><span class="line">  _DelegateState&lt;T, _Delegate&lt;T&gt;&gt; _delegateState;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _InheritedProviderScope&lt;T&gt; <span class="keyword">get</span> widget =&gt;</span><br><span class="line">      <span class="keyword">super</span>.widget <span class="keyword">as</span> _InheritedProviderScope&lt;T&gt;;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> reassemble() &#123;</span><br><span class="line">    <span class="keyword">super</span>.reassemble();</span><br><span class="line">    <span class="keyword">final</span> value = _delegateState.hasValue ? _delegateState.value : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">is</span> ReassembleHandler) &#123;</span><br><span class="line">      value.reassemble();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> updateDependencies(<span class="built_in">Element</span> dependent, <span class="built_in">Object</span> aspect) &#123;</span><br><span class="line">    <span class="keyword">final</span> dependencies = getDependencies(dependent);</span><br><span class="line">    <span class="comment">// once subscribed to everything once, it always stays subscribed to everything</span></span><br><span class="line">    <span class="keyword">if</span> (dependencies != <span class="keyword">null</span> &amp;&amp; dependencies <span class="keyword">is</span>! _Dependency&lt;T&gt;) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (aspect <span class="keyword">is</span> _SelectorAspect&lt;T&gt;) &#123;</span><br><span class="line">      <span class="keyword">final</span> selectorDependency =</span><br><span class="line">          (dependencies ?? _Dependency&lt;T&gt;()) <span class="keyword">as</span> _Dependency&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (selectorDependency.shouldClearSelectors) &#123;</span><br><span class="line">        selectorDependency.shouldClearSelectors = <span class="keyword">false</span>;</span><br><span class="line">        selectorDependency.selectors.clear();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (selectorDependency.shouldClearMutationScheduled == <span class="keyword">false</span>) &#123;</span><br><span class="line">        selectorDependency.shouldClearMutationScheduled = <span class="keyword">true</span>;</span><br><span class="line">        SchedulerBinding.instance.addPostFrameCallback((_) &#123;</span><br><span class="line">          selectorDependency</span><br><span class="line">            ..shouldClearMutationScheduled = <span class="keyword">false</span></span><br><span class="line">            ..shouldClearSelectors = <span class="keyword">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      selectorDependency.selectors.add(aspect);</span><br><span class="line">      setDependencies(dependent, selectorDependency);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// subscribes to everything</span></span><br><span class="line">      setDependencies(dependent, <span class="keyword">const</span> <span class="built_in">Object</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> notifyDependent(InheritedWidget oldWidget, <span class="built_in">Element</span> dependent) &#123;</span><br><span class="line">    <span class="keyword">final</span> dependencies = getDependencies(dependent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> shouldNotify = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (dependencies != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dependencies <span class="keyword">is</span> _Dependency&lt;T&gt;) &#123;</span><br><span class="line">        <span class="comment">// select can never be used inside `didChangeDependencies`, so if the</span></span><br><span class="line">        <span class="comment">// dependent is already marked as needed build, there is no point</span></span><br><span class="line">        <span class="comment">// in executing the selectors.</span></span><br><span class="line">        <span class="keyword">if</span> (dependent.dirty) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> updateShouldNotify <span class="keyword">in</span> dependencies.selectors) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span>(() &#123;</span><br><span class="line">              _debugIsSelecting = <span class="keyword">true</span>;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;());</span><br><span class="line">            shouldNotify = updateShouldNotify(value);</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span>(() &#123;</span><br><span class="line">              _debugIsSelecting = <span class="keyword">false</span>;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (shouldNotify) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shouldNotify = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldNotify) &#123;</span><br><span class="line">      dependent.didChangeDependencies();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> performRebuild() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_firstBuild) &#123;</span><br><span class="line">      _firstBuild = <span class="keyword">false</span>;</span><br><span class="line">      _delegateState = widget.owner._delegate.createState()..element = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.performRebuild();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> update(_InheritedProviderScope&lt;T&gt; newWidget) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(() &#123;</span><br><span class="line">      <span class="keyword">if</span> (widget.owner._delegate.runtimeType !=</span><br><span class="line">          newWidget.owner._delegate.runtimeType) &#123;</span><br><span class="line">        <span class="keyword">throw</span> StateError(<span class="string">'''</span></span><br><span class="line"><span class="string">Rebuilt <span class="subst">$widget</span> using a different constructor.</span></span><br><span class="line"><span class="string">      </span></span><br><span class="line"><span class="string">This is likely a mistake and is unsupported.</span></span><br><span class="line"><span class="string">If you're in this situation, consider passing a `key` unique to each individual constructor.</span></span><br><span class="line"><span class="string">'''</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;());</span><br><span class="line"></span><br><span class="line">    _isBuildFromExternalSources = <span class="keyword">true</span>;</span><br><span class="line">    _updatedShouldNotify =</span><br><span class="line">        _delegateState.willUpdateDelegate(newWidget.owner._delegate);</span><br><span class="line">    <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">    _updatedShouldNotify = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> updated(InheritedWidget oldWidget) &#123;</span><br><span class="line">    <span class="keyword">super</span>.updated(oldWidget);</span><br><span class="line">    <span class="keyword">if</span> (_updatedShouldNotify) &#123;</span><br><span class="line">      notifyClients(oldWidget);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didChangeDependencies() &#123;</span><br><span class="line">    _isBuildFromExternalSources = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">super</span>.didChangeDependencies();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build() &#123;</span><br><span class="line">    <span class="keyword">if</span> (widget.owner._lazy == <span class="keyword">false</span>) &#123;</span><br><span class="line">      value; <span class="comment">// this will force the value to be computed.</span></span><br><span class="line">    &#125;</span><br><span class="line">    _delegateState.build(</span><br><span class="line">      isBuildFromExternalSources: _isBuildFromExternalSources,</span><br><span class="line">    );</span><br><span class="line">    _isBuildFromExternalSources = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (_shouldNotifyDependents) &#123;</span><br><span class="line">      _shouldNotifyDependents = <span class="keyword">false</span>;</span><br><span class="line">      notifyClients(widget);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> unmount() &#123;</span><br><span class="line">    _delegateState.dispose();</span><br><span class="line">    <span class="keyword">super</span>.unmount();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> hasValue =&gt; _delegateState.hasValue;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> markNeedsNotifyDependents() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_isNotifyDependentsEnabled) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    markNeedsBuild();</span><br><span class="line">    _shouldNotifyDependents = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> _debugSetInheritedLock(<span class="built_in">bool</span> value) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(() &#123;</span><br><span class="line">      _debugInheritLocked = value;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  T <span class="keyword">get</span> value =&gt; _delegateState.value;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  InheritedWidget dependOnInheritedElement(</span><br><span class="line">    InheritedElement ancestor, &#123;</span><br><span class="line">    <span class="built_in">Object</span> aspect,</span><br><span class="line">  &#125;) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(() &#123;</span><br><span class="line">      <span class="keyword">if</span> (_debugInheritLocked) &#123;</span><br><span class="line">        <span class="keyword">throw</span> FlutterError.fromParts(</span><br><span class="line">          &lt;DiagnosticsNode&gt;[</span><br><span class="line">            ErrorSummary(</span><br><span class="line">              <span class="string">'Tried to listen to an InheritedWidget '</span></span><br><span class="line">              <span class="string">'in a life-cycle that will never be called again.'</span>,</span><br><span class="line">            ),</span><br><span class="line">            ErrorDescription(<span class="string">'''</span></span><br><span class="line"><span class="string">This error typically happens when calling Provider.of with `listen` to `true`,</span></span><br><span class="line"><span class="string">in a situation where listening to the provider doesn't make sense, such as:</span></span><br><span class="line"><span class="string">- initState of a StatefulWidget</span></span><br><span class="line"><span class="string">- the "create" callback of a provider</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This is undesired because these life-cycles are called only once in the</span></span><br><span class="line"><span class="string">lifetime of a widget. As such, while `listen` is `true`, the widget has</span></span><br><span class="line"><span class="string">no mean to handle the update scenario.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">To fix, consider:</span></span><br><span class="line"><span class="string">- passing `listen: false` to `Provider.of`</span></span><br><span class="line"><span class="string">- use a life-cycle that handles updates (like didChangeDependencies)</span></span><br><span class="line"><span class="string">- use a provider that handles updates (like ProxyProvider).</span></span><br><span class="line"><span class="string">'''</span>),</span><br><span class="line">          ],</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dependOnInheritedElement(ancestor, aspect: aspect);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> debugFillProperties(DiagnosticPropertiesBuilder properties) &#123;</span><br><span class="line">    <span class="keyword">super</span>.debugFillProperties(properties);</span><br><span class="line">    _delegateState.debugFillProperties(properties);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>void update(_InheritedProviderScope&lt;T&gt; newWidget)让页面重新build是在这里，因为InheritedElement继承自ProxyElement，而ProxyElement的update函数调用了两个函数updated(已更新完成)，rebuild函数出发重新build逻辑，下面是代码</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyElement</span> <span class="keyword">extends</span> <span class="title">ComponentElement</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Initializes fields for subclasses.</span></span></span><br><span class="line">  ProxyElement(ProxyWidget widget) : <span class="keyword">super</span>(widget);</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ProxyWidget <span class="keyword">get</span> widget =&gt; <span class="keyword">super</span>.widget <span class="keyword">as</span> ProxyWidget;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build() =&gt; widget.child;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> update(ProxyWidget newWidget) &#123;</span><br><span class="line">    <span class="keyword">final</span> ProxyWidget oldWidget = widget;</span><br><span class="line">    <span class="keyword">assert</span>(widget != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">assert</span>(widget != newWidget);</span><br><span class="line">    <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">    <span class="keyword">assert</span>(widget == newWidget);</span><br><span class="line">    updated(oldWidget);</span><br><span class="line">    _dirty = <span class="keyword">true</span>;</span><br><span class="line">    rebuild();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Called during build when the [widget] has changed.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">By default, calls [notifyClients]. Subclasses may override this method to</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">avoid calling [notifyClients] unnecessarily (e.g. if the old and new</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">widgets are equivalent).</span></span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="keyword">void</span> updated(<span class="keyword">covariant</span> ProxyWidget oldWidget) &#123;</span><br><span class="line">    notifyClients(oldWidget);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>performRebuild()是在update触发真正调用rebuild之后被调用。</p>
</li>
<li><p>updateDependencies、notifyDependent处理Element依赖逻辑</p>
</li>
<li><p>update、updated处理widget更新逻辑</p>
</li>
<li><p>didChangeDependencies当此State对象的依赖项更改时调用，子类很少重写此方法，因为框架总是在依赖项更改后调用build。一些子类确实重写了此方法，因为当他们的依存关系发生变化时，他们需要做一些昂贵的工作（如：网络获取），并且对于每个构建而言这些工作将太昂贵。</p>
</li>
<li><p>build()构建需要的widget，Element在调用build的时候也会触发Widget的build</p>
</li>
<li><p>void unmount（）这里看到了_delegateState.dispose();的调用，当Element从树上移除的时候，回调了dispose函数</p>
</li>
</ul>
<p>来看一个生命周期的图：</p>
<p><img src="/images/widget_lifecycle.png" alt="widget_lifecycle"></p>
<ul>
<li><p>notifyClients是InheritedElement中实现的函数，通过官方文档了解到，它是通过调用Element.didChangeDependencies通知所有从属Element此继承的widget已更改，此方法只能在构建阶段调用，通常，在重建Inherited widget时自动调用此方法，还有InheritedNotifier，它是InheritedWidget的子类，在其Listenable发送通知时也调用此方法。</p>
</li>
<li><p>markNeedsNotifyDependents，如果调用它，会强制build后，通知所有依赖Element刷新widget，看下面代码，发现该函数在InheritedContext中定义，所以我们可以通过InheritedContext上下文来强制页面的构建。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritedContext</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BuildContext</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">The current value exposed by [InheritedProvider].</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">This property is lazy loaded, and reading it the first time may trigger</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">some side-effects such as creating a [T] instance or start a subscription.</span></span></span><br><span class="line">  T <span class="keyword">get</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Marks the [InheritedProvider] as needing to update dependents.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">This bypass [InheritedWidget.updateShouldNotify] and will force widgets</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">that depends on [T] to rebuild.</span></span></span><br><span class="line">  <span class="keyword">void</span> markNeedsNotifyDependents();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Wether <span class="code">`setState`</span> was called at least once or not.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">It can be used by [DeferredStartListening] to differentiate between the</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">very first listening, and a rebuild after <span class="code">`controller`</span> changed.</span></span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> hasValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>我们先回顾一下我们是如何使用InheritedWidget的，为了能让InheritedWidget的子Widget能够刷新，我们不得不依赖于Statefulwidget，并通过State控制刷新Element，调用setState刷新页面，其实是底层调用_element.markNeedsBuild()函数，这样我们明白了，其实最终控制页面的还是Element，那么Provider它也巧妙的封装了自己的_delegateState,是私有的，并没有给我们公开是用，也没有提供类似setState，单可以通过markNeedsNotifyDependents大号和setState一样的调用效果，一样的都是让所有子Widget进行重建，可我们要局部刷新呢，那就是Consumer。</p>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SingleChildStatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">&#123;@template provider.consumer.constructor&#125;</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">Consumes a [Provider<span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span></span>]</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">&#123;@endtemplate&#125;</span></span></span><br><span class="line">  Consumer(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.builder,</span><br><span class="line">    Widget child,</span><br><span class="line">  &#125;)  : <span class="keyword">assert</span>(builder != <span class="keyword">null</span>),</span><br><span class="line">        <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">&#123;@template provider.consumer.builder&#125;</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">Build a widget tree based on the value from a [Provider<span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span></span>].</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">Must not be <span class="code">`null`</span>.</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">&#123;@endtemplate&#125;</span></span></span><br><span class="line">  <span class="keyword">final</span> Widget <span class="built_in">Function</span>(BuildContext context, T value, Widget child) builder;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget buildWithChild(BuildContext context, Widget child) &#123;</span><br><span class="line">    <span class="keyword">return</span> builder(</span><br><span class="line">      context,</span><br><span class="line">      Provider.of&lt;T&gt;(context),</span><br><span class="line">      child,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这里源码有点绕，widget child传给了父类 SingleChildStatelessWidget，最终通过buildWithChild函数的参数child传递回来，而Builder函数收到了此child，然后再组合child和需要刷新的widget组合一个新的widget给Consumer。一句话就是Consumer的构造函数可以传两个widget，一个是buider，一个是child，最终是通过builder构建最终的widget，如果child不为空，那么你需要自己组织child和builder中返回widget的关系。</p>
</li>
<li><p>Provider.of&lt;T&gt;(context)获取共享数据，怎么获取的，继续看代码</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用_inheritedElementOf函数</span></span><br><span class="line"><span class="keyword">static</span> T of&lt;T&gt;(BuildContext context, &#123;<span class="built_in">bool</span> listen = <span class="keyword">true</span>&#125;) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(context != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">assert</span>(</span><br><span class="line">      context.owner.debugBuilding ||</span><br><span class="line">          listen == <span class="keyword">false</span> ||</span><br><span class="line">          debugIsInInheritedProviderUpdate,</span><br><span class="line">      <span class="string">'''</span></span><br><span class="line"><span class="string">Tried to listen to a value exposed with provider, from outside of the widget tree.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This is likely caused by an event handler (like a button's onPressed) that called</span></span><br><span class="line"><span class="string">Provider.of without passing `listen: false`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">To fix, write:</span></span><br><span class="line"><span class="string">Provider.of&lt;<span class="subst">$T</span>&gt;(context, listen: false);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">It is unsupported because may pointlessly rebuild the widget associated to the</span></span><br><span class="line"><span class="string">event handler, when the widget tree doesn't care about the value.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The context used was: <span class="subst">$context</span></span></span><br><span class="line"><span class="string">'''</span>,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> inheritedElement = _inheritedElementOf&lt;T&gt;(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen) &#123;</span><br><span class="line">      context.dependOnInheritedElement(inheritedElement);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inheritedElement.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> _InheritedProviderScopeElement&lt;T&gt; _inheritedElementOf&lt;T&gt;(</span><br><span class="line">    BuildContext context,</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(context != <span class="keyword">null</span>, <span class="string">'''</span></span><br><span class="line"><span class="string">Tried to call context.read/watch/select or similar on a `context` that is null.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This can happen if you used the context of a StatefulWidget and that</span></span><br><span class="line"><span class="string">StatefulWidget was disposed.</span></span><br><span class="line"><span class="string">'''</span>);</span><br><span class="line">    <span class="keyword">assert</span>(</span><br><span class="line">      _debugIsSelecting == <span class="keyword">false</span>,</span><br><span class="line">      <span class="string">'Cannot call context.read/watch/select inside the callback of a context.select'</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">assert</span>(</span><br><span class="line">      T != <span class="built_in">dynamic</span>,</span><br><span class="line">      <span class="string">'''</span></span><br><span class="line"><span class="string">Tried to call Provider.of&lt;dynamic&gt;. This is likely a mistake and is therefore</span></span><br><span class="line"><span class="string">unsupported.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">If you want to expose a variable that can be anything, consider changing</span></span><br><span class="line"><span class="string">`dynamic` to `Object` instead.</span></span><br><span class="line"><span class="string">'''</span>,</span><br><span class="line">    );</span><br><span class="line">    _InheritedProviderScopeElement&lt;T&gt; inheritedElement;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context.widget <span class="keyword">is</span> _InheritedProviderScope&lt;T&gt;) &#123;</span><br><span class="line">      <span class="comment">// An InheritedProvider&lt;T&gt;'s update tries to obtain a parent provider of</span></span><br><span class="line">      <span class="comment">// the same type.</span></span><br><span class="line">      context.visitAncestorElements((parent) &#123;</span><br><span class="line">        inheritedElement = parent.getElementForInheritedWidgetOfExactType&lt;</span><br><span class="line">            _InheritedProviderScope&lt;T&gt;&gt;() <span class="keyword">as</span> _InheritedProviderScopeElement&lt;T&gt;;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      inheritedElement = context.getElementForInheritedWidgetOfExactType&lt;</span><br><span class="line">          _InheritedProviderScope&lt;T&gt;&gt;() <span class="keyword">as</span> _InheritedProviderScopeElement&lt;T&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inheritedElement == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ProviderNotFoundException(T, context.widget.runtimeType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inheritedElement;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过visitAncestorElements往复机查找_InheritedProviderScope的实现类也就是InheritedWidget，当找到时就返回_InheritedProviderScopeElement,而_InheritedProviderScopeElement正好可以拿到value，这个value也就是_delegateState的value</p>
</li>
</ul>
<p>走到这里只是实现了读取数据，那么数据到底是如何刷新的呢？我们回过头来看下面极端代码：</p>
<p>1、Model数据调用ChangeNotifier提供的函数notifyListeners</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@protected</span></span><br><span class="line"><span class="meta">@visibleForTesting</span></span><br><span class="line"><span class="keyword">void</span> notifyListeners() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(_debugAssertNotDisposed());</span><br><span class="line">  <span class="keyword">if</span> (_listeners!.isEmpty)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;_ListenerEntry&gt; localListeners = <span class="built_in">List</span>&lt;_ListenerEntry&gt;.from(_listeners!);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> _ListenerEntry entry <span class="keyword">in</span> localListeners) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (entry.list != <span class="keyword">null</span>)</span><br><span class="line">        entry.listener();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (exception, stack) &#123;</span><br><span class="line">      FlutterError.reportError(FlutterErrorDetails(</span><br><span class="line">        exception: exception,</span><br><span class="line">        stack: stack,</span><br><span class="line">        <span class="keyword">library</span>: <span class="string">'foundation library'</span>,</span><br><span class="line">        context: ErrorDescription(<span class="string">'while dispatching notifications for <span class="subst">$runtimeType</span>'</span>),</span><br><span class="line">        informationCollector: () <span class="keyword">sync</span>* &#123;</span><br><span class="line">          <span class="keyword">yield</span> DiagnosticsProperty&lt;ChangeNotifier&gt;(</span><br><span class="line">            <span class="string">'The <span class="subst">$runtimeType</span> sending notification was'</span>,</span><br><span class="line">            <span class="keyword">this</span>,</span><br><span class="line">            style: DiagnosticsTreeStyle.errorProperty,</span><br><span class="line">          );</span><br><span class="line">        &#125;,</span><br><span class="line">      ));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候遍历所有的监听，然后执行函数listener(),这里其实等于执行VoidCallback的实例，那这个listener到底是哪个函数？</p>
<p>2、在ChangeNotifierProvider父类ListenableProvider的静态函数中，自动订阅了观察者，前面说了观察者就是一个普通函数，而e.markNeedsNotifyDependents就是InheritedContext的一个函数，当你notifyListemers的时候执行的就是它markNeedsNotifyDependents，上面我们知道了markNeedsNotifyDependents类似setState效果，就这样实现了UI的刷新。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ListenableProvider 的静态函数</span></span><br><span class="line"><span class="keyword">static</span> VoidCallback _startListening(</span><br><span class="line">  InheritedContext&lt;Listenable&gt; e,</span><br><span class="line">  Listenable value,</span><br><span class="line">) &#123;</span><br><span class="line">  value?.addListener(e.markNeedsNotifyDependents);</span><br><span class="line">  <span class="keyword">return</span> () =&gt; value?.removeListener(e.markNeedsNotifyDependents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在还有一个点就是局部刷新，我们继续寻找</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget buildWithChild(BuildContext context, Widget child) &#123;</span><br><span class="line">  <span class="keyword">return</span> builder(</span><br><span class="line">    context,</span><br><span class="line">    Provider.of&lt;T&gt;(context),</span><br><span class="line">    child,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Consumer通过Provider.of&lt;T&gt;(context)这段代码才能监听到数据，而且刷新的内容也只是这一部分，我们再看下它的实现发现另一个细节</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">static</span> T of&lt;T&gt;(BuildContext context, &#123;<span class="built_in">bool</span> listen = <span class="keyword">true</span>&#125;) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(context != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">assert</span>(</span><br><span class="line">      context.owner.debugBuilding ||</span><br><span class="line">          listen == <span class="keyword">false</span> ||</span><br><span class="line">          debugIsInInheritedProviderUpdate,</span><br><span class="line">      <span class="string">'''</span></span><br><span class="line"><span class="string">Tried to listen to a value exposed with provider, from outside of the widget tree.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This is likely caused by an event handler (like a button's onPressed) that called</span></span><br><span class="line"><span class="string">Provider.of without passing `listen: false`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">To fix, write:</span></span><br><span class="line"><span class="string">Provider.of&lt;<span class="subst">$T</span>&gt;(context, listen: false);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">It is unsupported because may pointlessly rebuild the widget associated to the</span></span><br><span class="line"><span class="string">event handler, when the widget tree doesn't care about the value.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The context used was: <span class="subst">$context</span></span></span><br><span class="line"><span class="string">'''</span>,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> inheritedElement = _inheritedElementOf&lt;T&gt;(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen) &#123;</span><br><span class="line">      context.dependOnInheritedElement(inheritedElement);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inheritedElement.value;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>它调用了BuildContext的dependOnInheritedElement函数，这个函数做了什么</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">InheritedWidget dependOnInheritedElement(InheritedElement ancestor, &#123; <span class="built_in">Object</span> aspect &#125;);</span><br><span class="line"><span class="comment">/// <span class="markdown">Obtains the nearest widget of the given type, which must be the type of a</span></span></span><br><span class="line"><span class="comment">/// <span class="markdown">concrete [InheritedWidget] subclass, and registers this build context with</span></span></span><br><span class="line"><span class="comment">/// <span class="markdown">that widget such that when that widget changes (or a new widget of that</span></span></span><br><span class="line"><span class="comment">/// <span class="markdown">type is introduced, or the widget goes away), this build context is</span></span></span><br><span class="line"><span class="comment">/// <span class="markdown">rebuilt so that it can obtain new values from that widget.</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="markdown">This method is deprecated. Please use [dependOnInheritedWidgetOfExactType] instead.</span></span></span><br><span class="line"><span class="comment">// TODO(a14n): Remove this when it goes to stable, https://github.com/flutter/flutter/pull/44189</span></span><br><span class="line"><span class="meta">@Deprecated</span>(</span><br><span class="line">  <span class="string">'Use dependOnInheritedWidgetOfExactType instead. '</span></span><br><span class="line">  <span class="string">'This feature was deprecated after v1.12.1.'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>触发updateDependencies，通过setDependencies，将Element缓存到_dependetns Map中，最后通过下面代码更新：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> notifyDependent(InheritedWidget oldWidget, <span class="built_in">Element</span> dependent) &#123;</span><br><span class="line">  <span class="keyword">final</span> dependencies = getDependencies(dependent);</span><br><span class="line">  <span class="keyword">var</span> shouldNotify = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (dependencies != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dependencies <span class="keyword">is</span> _Dependency&lt;T&gt;) &#123;</span><br><span class="line">      <span class="comment">// select can never be used inside `didChangeDependencies`, so if the</span></span><br><span class="line">      <span class="comment">// dependent is already marked as needed build, there is no point</span></span><br><span class="line">      <span class="comment">// in executing the selectors.</span></span><br><span class="line">      <span class="keyword">if</span> (dependent.dirty) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> updateShouldNotify <span class="keyword">in</span> dependencies.selectors) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">assert</span>(() &#123;</span><br><span class="line">            _debugIsSelecting = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;());</span><br><span class="line">          shouldNotify = updateShouldNotify(value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">assert</span>(() &#123;</span><br><span class="line">            _debugIsSelecting = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (shouldNotify) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      shouldNotify = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (shouldNotify) &#123;</span><br><span class="line">    dependent.didChangeDependencies();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以说整体流程是这样，当notifyListeners的时候其实是出发了InheritedWidget的performRebuild，再到build，build后触发notifyClients，notifyClients触发notifyDependent，notifyDependent这个时候通过getDependencies获取缓存好的Element，最终确定是否需要刷新然后调用dependent.didChangeDependencies()更新，只要widget中通过Provider.of函数订阅后，就会被InheritedWidget缓存在一个Map中，然后刷新页面的时候，如果子Widget不在缓存的Map中，就不会走刷新，而且如果shouldNotify变量是false也不会刷新，这个控制可能是虽然widget订阅了，但它自己就是不刷新，可以更加细粒度的控制。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Provider通过缓存inheritedElement实现局部刷新。</li>
<li>通过控制自己实现的Element层来更新UI</li>
<li>通过Element提供的unmount函数回调dispose，实现选择性释放。</li>
</ul>
<p><img src="/images/provider_class_view.png" alt="provider_class_view"></p>
<p><a href="https://www.jianshu.com/p/bf2f33b2b5ef" target="_blank" rel="noopener">转载自</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/19/flutter%E6%8E%A2%E7%B4%A2-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/19/flutter%E6%8E%A2%E7%B4%A2-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Flutter探索  - 状态管理分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-19 16:05:48" itemprop="dateCreated datePublished" datetime="2021-05-19T16:05:48+08:00">2021-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-20 09:57:51" itemprop="dateModified" datetime="2021-05-20T09:57:51+08:00">2021-05-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="状态管理是什么"><a href="#状态管理是什么" class="headerlink" title="状态管理是什么"></a>状态管理是什么</h3><p>我们知道最基本的程序是什么</p>
<ul>
<li><p>程序 = 算法 + 数据结构</p>
<p>数据是程序的中心。数据结构和算法两个概念间的逻辑关系贯穿整个程序世界，首先两者表现为不可分割的关系。flutter也是一个程序。由此得出</p>
</li>
<li><p>Flutter = 算法 + 数据结构</p>
<p>那状态管理是什么？我们也用公式表示一下：</p>
</li>
<li><p>Flutter状态管理 = 算法 + 数据结构 + UI绑定</p>
<p>来看一段代码例子：</p>
</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThemeBloc</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> _themeStreamController = StreamController&lt;AppTheme&gt;();</span><br><span class="line">  <span class="keyword">get</span> changeTheTheme =&gt; _themeStreamController.sink.add;</span><br><span class="line">  <span class="keyword">get</span> darkThemIsEnABLE =&gt; _themeStreamController.stream;</span><br><span class="line">  dispose()&#123;</span><br><span class="line">    _themStreamController.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> bloc = ThemeBloc();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppTheme</span> </span>&#123;</span><br><span class="line">  ThemeData themeData;</span><br><span class="line">  AppTheme(<span class="keyword">this</span>.themeData);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//绑定到UI</span></span><br><span class="line">StreamBulder&lt;AppTheme&gt;(</span><br><span class="line">	initialData:AppTheme.LIGHT_THEME,</span><br><span class="line">  stream:bloc.dartThemeIsEnabled,</span><br><span class="line">  builder:(contenxt,AsyncSnapshot&lt;AppTheme&gt; snapshot)&#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title:<span class="string">"Jason"</span>,</span><br><span class="line">      theme:snapshot.data.themeData,</span><br><span class="line">      home:PageHome(),</span><br><span class="line">      routes:&lt;<span class="built_in">String</span>,WidgetBuilder&gt;&#123;</span><br><span class="line">        <span class="string">"/pageChatGroup"</span>:(context) =&gt; PageChatGroup(),</span><br><span class="line">        <span class="string">"/laoYu"</span>:(context) =&gt; LaoYu(),</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>AppTheme 是数据结构</li>
<li>changeTheTheme 是算法</li>
<li>StreamBuilder 是绑定UI</li>
</ul>
<p>这样一整套代码的逻辑就是我们所说的Flutter状态管理。算法就是我们如何管理，数据结构是数据状态，状态管理的本质还是如何通过合理的算法管理数据，如何取，如何接收等，最终展示在UI上，通过UI的变更来提现状态的管理逻辑。</p>
<h3 id="为什么需要状态管理"><a href="#为什么需要状态管理" class="headerlink" title="为什么需要状态管理"></a>为什么需要状态管理</h3><p>状态管理可以实现组件通信、跨组件数据储存。原生的状态变更是通过具体的组件直接复制，如果页面全部变更，是不是需要每一个都设置一遍，而Flutter的变更就简单粗暴 ，setState搞定，它背后的逻辑是重新build整个页面，发现有变更，再将新的数据复制。其实原生开发与Flutter的本质的区别就是数据与视图完全分离，目前原生也出现了UI绑定框架。说明flutter的设计的先进性。这样设计的弊端是什么？</p>
<p>答案就是<code>页面如何刷新才是Flutter的关键</code>，原生也面临这个问题，页面的重绘导致丢帧问题，为了效果更好，我们很多时候都选择局部刷新，原生已经很明确的告诉UI要刷新什么更新什么，而对于Flutter来说，这一点恨不清晰，虽然Flutter也做了类似虚拟Dom优化重绘逻辑，但这远远不够，如何合理的更新UI才是最主要的，这个时候一大堆的状态管理就出来了，当然状态管理也不是仅仅为了解决更新问题。我们再思考一个问题，如果我有一个widget A，我想在另外一个widget B中改变widget A的一个状态，或者从网络、数据库取到数据，然后刷新它。</p>
<p>一个糟糕的写法是，A widget的 state为全局的，当B widget 需要刷新的时候 直接调用 AState对象的 <code>setState</code> 方法.</p>
<p>这样写有几个问题：</p>
<p>1、违背了封装的概念，其他所有类都可以拿到A的state对象。</p>
<p>2、A和B强耦合了。</p>
<p>3、每次都是重绘整个widget A 性能变差。</p>
<p>4、不利于测试。</p>
<p>如何变好了，这就需要我们选择一种合适的状态管理方式。</p>
<h4 id="状态管理的目标"><a href="#状态管理的目标" class="headerlink" title="状态管理的目标"></a>状态管理的目标</h4><p>其实我们做状态管理，不仅仅是因为它的特点，也是更好地架构。</p>
<ul>
<li>代码层次分明，易维护，易阅读。</li>
<li>可扩展，可以动态替换UI而不影响算法逻辑。</li>
<li>安全可靠，保持数据的稳定伸缩</li>
<li>性能佳，局部刷新。</li>
</ul>
<p>这不仅仅是状态管理的目的，也是我们做一款优秀应用的基础架构。</p>
<h3 id="状态管理的基本分类"><a href="#状态管理的基本分类" class="headerlink" title="状态管理的基本分类"></a>状态管理的基本分类</h3><ul>
<li>局部管理 官方也称Ephemeral State，意思是短暂的状态，这种状态根本不需要做全局处理，StatefulWidget处理即可完成。</li>
<li>全局管理 官方称App state ，即应用状态，非短暂状态，你要在应用程序的许多部分之间共享，以及希望在用户会话之间保持的状态，就是我们所说的应用程序状态（也称共享状态）。例如：<ul>
<li>用户偏好</li>
<li>登录信息</li>
<li>购物车</li>
<li>新闻阅读状态</li>
</ul>
</li>
</ul>
<p>总之，任何Flutter应用程序中都有两种概念性的状态类型。临时状态可以使用State和setState来事项，并且通常是单个窗口小部件的本地状态。剩下的就是应用的状态。两种类型在任何Flutter应用程序中都有自己的位置，两者之间的划分取决于你自己的喜好和应用程序的复杂性。没有最好的管理方式，只有最合适的管理方式。</p>
<h3 id="底层逻辑"><a href="#底层逻辑" class="headerlink" title="底层逻辑"></a>底层逻辑</h3><p>底层逻辑主要讲，Flutter中目前有哪些可以做到状态管理，有什么缺点，适合做什么不适合做什么，完全明白底层逻辑才不会畏惧复杂的逻辑，即使逻辑复杂也能选择合理的方式去管理状态。</p>
<ul>
<li><p>State</p>
<p>StatefulWidget、SteamBuilder状态管理方式。</p>
</li>
<li><p>InheritedWidget</p>
<p>专门负责Widget树种数据共享的功能型Widget，如Provider、scoped_model就是基于它开发</p>
</li>
<li><p>Notification</p>
<p>与InheritedWidget正好相反，InheritedWidget是从上往下传递数据，Notification是从下往上，但两者都是在自己的Widget树种传递，无法跨越树传递。</p>
</li>
<li><p>Stream</p>
<p>数据流 如Bloc、flutter_redux、fish_redux等也都基于它来做实现。</p>
</li>
</ul>
<p>下面一一分析</p>
<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>State是我们常用而且使用最频繁的一个状态管理类，它必须结合StatefulWidget一起使用，StreamBuilder继承自StatefulWidget，同样使用setState来管理状态。</p>
<p>为什么用State管理状态，而不是Widget本身。Flutter设计时让Widget本身是不变的，类似固定的配置信息，那么就需要一个角色来控制它，State就出现了，但State的任何更改都会强制整个Widget重新构建，当然也可以覆盖必要的方法自己控制逻辑。</p>
<p>注意：setState是整个Widget重新构建（子Widget也会销毁重建），这个点也是为什么不推荐大量使用StatefulWidget的原因。如果页面足够复杂，就会导致严重的性能损耗。建议使用StreamBuilder，它原理上是State，但它做到了子Widget的局部刷新，不会导致整个页面的重建。</p>
<h4 id="State的缺点"><a href="#State的缺点" class="headerlink" title="State的缺点"></a>State的缺点</h4><ul>
<li>无法做到夸组件共享数据（这个夸是无关联的，如果是直接的父子关系，不算是跨组件）。一般我们将State的子类设置为私有，所以无法做到让别的组件调用State的setState函数来刷新。</li>
<li>setState会成为维护的难点，因为到处都有。随着页面状态的增多，可能调用的setState的地方会越来越多，不能统一管理。</li>
<li>处理数据逻辑和视图混合在一起，违反代码设计原则。比如网络的数据取出来setState的UI上，这样编写代码，导致状态和UI耦合在一起，不利于测试和复用。</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>反过来讲，State简单高效，当复杂到需要更好地管理的时候再重构，一个基本原则就是，状态是否需要跨组件使用，如果需要那就用别的方法管理状态而不是State管理。</p>
<h3 id="InheritedWidget"><a href="#InheritedWidget" class="headerlink" title="InheritedWidget"></a>InheritedWidget</h3><p>InheritedWidget是一个无私的Widget，它可以把自己的状态数据，无私交给所有的子Widget，所有的子Widget可以无条件的继承它的状态。它的数据是只读的，子widget不能修改。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>缺点：</p>
<ul>
<li>容易造成不必要的刷新。</li>
<li>不支持跨页面（router）的状态，不是同一个树的状态无法获取。</li>
<li>数据不可变，必须结合StatefulWidget、ChangeNotifier或者Steam使用。</li>
</ul>
<p>比较适合在一个属性Widget中，抽象出公有状态，每一个子Widget或者孙Widget都可以获取该状态，我们可以通过手段控制rebuild的粒度来优化重绘逻辑，但它更适合从上往下传递，如果从下往上传递，如何做，下面解答。</p>
<h3 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h3><p>它是flutter中跨层数据共享的一种机制，它不是widget，它提供了dispatch方法，来让我们沿着context对应的Element节点向上逐层发送通知。</p>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p>缺点</p>
<ul>
<li>不支持跨页面的状态，准确的说不支持NotificationListener同级或者父级Widget的状态通知</li>
<li>本身不支持刷新UI,需要结合State使用</li>
<li>如果结合State，会导致整个UI的重绘，效率低下不科学。</li>
</ul>
<p>使用起来简单，如果页面复杂度高不推荐。</p>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p>Stream其实是一个生产者消费者模型，一端负责生产，一端负责消费，而且是纯Dart的实现，跟Flutter没什么关系，扯上关系的就是StreamBuilder来构建一个Stream通道的Widget，像知名的rxdart、Bloc、flutter_redux全都用到了Stream的api。所以学习它才是我们掌握状态管理的关键。</p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>缺点</p>
<ul>
<li>api生涩，不好理解。</li>
<li>需要定制化，才能满足更复杂的场景。</li>
<li>没有自动dispose逻辑。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上所有的状态更新都离不开State的支持。</p>
<h3 id="状态管理的使用原则"><a href="#状态管理的使用原则" class="headerlink" title="状态管理的使用原则"></a>状态管理的使用原则</h3><h4 id="局部管理优于全局"><a href="#局部管理优于全局" class="headerlink" title="局部管理优于全局"></a>局部管理优于全局</h4><p>这个原则来源于，Flutter的性能优化，局部刷新肯定比全局刷新要好很多，那么我们在管理状态的同时，也要考虑该状态到底是局部还是全局，从而编写正确的逻辑。</p>
<h4 id="保持数据安全性"><a href="#保持数据安全性" class="headerlink" title="保持数据安全性"></a>保持数据安全性</h4><p>用<code>_</code>私有化状态，因为当开发人员众多，当别人看到你的变量的时候，第一反应可能不是找你提供的方法，而是直接对变量操作，那就有可能出现想不到的后果，如果他只能调用你提供的方法，那他就要遵循你方法的逻辑，避免数据被处理错误。</p>
<h4 id="考虑页面重新build带来的影响"><a href="#考虑页面重新build带来的影响" class="headerlink" title="考虑页面重新build带来的影响"></a>考虑页面重新build带来的影响</h4><p>很多时候页面的重建都会调用build函数，也就是说，在一个生命周期内，build函数是多次被调用的，所以你就要考虑数据的初始化或者刷新怎么样才能合理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/19/iOS%E6%8E%A2%E7%B4%A2-Block/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/19/iOS%E6%8E%A2%E7%B4%A2-Block/" class="post-title-link" itemprop="url">iOS探索 - Block</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-19 11:06:45" itemprop="dateCreated datePublished" datetime="2021-05-19T11:06:45+08:00">2021-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-11 00:31:12" itemprop="dateModified" datetime="2021-07-11T00:31:12+08:00">2021-07-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在Objective-C中，block是一个很常见的东西，说白了就是个匿名函数，网上有很多关于block如何使用的文章，讲的都非常精彩，这里主要探讨下block的实现原理。</p>
<h3 id="先看一个例子"><a href="#先看一个例子" class="headerlink" title="先看一个例子"></a>先看一个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">void blockFunc1() &#123;</span><br><span class="line">    int num &#x3D; 100;</span><br><span class="line">    void (^block)(void) &#x3D; ^() &#123;</span><br><span class="line">        NSLog(@&quot;num &#x3D; %d\n&quot;, num);</span><br><span class="line">    &#125;;</span><br><span class="line">    num &#x3D; 200;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void blockFunc2() &#123;</span><br><span class="line">    __block int num &#x3D; 100;</span><br><span class="line">    void (^block)(void) &#x3D; ^() &#123;</span><br><span class="line">        NSLog(@&quot;num &#x3D; %d\n&quot;, num);</span><br><span class="line">    &#125;;</span><br><span class="line">    num &#x3D; 200;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int num &#x3D; 100;</span><br><span class="line">void blockFunc3() &#123;</span><br><span class="line">    void (^block)(void) &#x3D; ^() &#123;</span><br><span class="line">        NSLog(@&quot;num &#x3D; %d\n&quot;, num);</span><br><span class="line">    &#125;;</span><br><span class="line">    num &#x3D; 200;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void blockFunc4()</span><br><span class="line">&#123;</span><br><span class="line">    static int num &#x3D; 100;</span><br><span class="line">    void (^block)(void) &#x3D; ^&#123;</span><br><span class="line">        NSLog(@&quot;num &#x3D; %d&quot;, num);</span><br><span class="line">    &#125;;</span><br><span class="line">    num &#x3D; 200;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        ^&#123; printf(&quot;Hello, World!\n&quot;); &#125; ();</span><br><span class="line">        blockFunc1();</span><br><span class="line">        blockFunc2();</span><br><span class="line">        blockFunc3();</span><br><span class="line">        blockFunc4();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-19</span> <span class="number">11</span>:<span class="number">25</span>:<span class="number">19.532572</span>+<span class="number">0800</span> OCDemo[<span class="number">60496</span>:<span class="number">2272335</span>] num = <span class="number">100</span></span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-19</span> <span class="number">11</span>:<span class="number">25</span>:<span class="number">19.534041</span>+<span class="number">0800</span> OCDemo[<span class="number">60496</span>:<span class="number">2272335</span>] num = <span class="number">200</span></span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-19</span> <span class="number">11</span>:<span class="number">25</span>:<span class="number">19.534166</span>+<span class="number">0800</span> OCDemo[<span class="number">60496</span>:<span class="number">2272335</span>] num = <span class="number">200</span></span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-19</span> <span class="number">11</span>:<span class="number">25</span>:<span class="number">19.534292</span>+<span class="number">0800</span> OCDemo[<span class="number">60496</span>:<span class="number">2272335</span>] num = <span class="number">200</span></span><br></pre></td></tr></table></figure>

<p>我们先简单解释一下：</p>
<p>1、”Hello, World!”应该很简单，执行block直接打印。</p>
<p>2、<code>blockFunc1</code>里面,<code>num</code>是以值传递的方式被block获取，所以尽管后面更改了<code>num</code>的值，但是在block里面还是保持保持原来的值。</p>
<p>3、<code>blockFunc2</code>里面，num由<code>__block</code>修饰，<code>num</code>在block变成了外部的一个引用（后面会通过源码解释），所以在block外部改变<code>num</code>的值时，block里面的<code>num</code>也随着改变。</p>
<p>4、<code>blockFunc3</code>里面，block引用的是一个全局的num，所以，num改变的时候也会改变block内部num的值。</p>
<p>5、<code>blockFunc3</code>里面，block引用的是一个static的num，所以，num改变也会改变block内部的num的值。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>也许大家看到上面的解释还是不知道为啥会这样，所以接下，我通过源码来分析下其中的缘由，我们先把这段先转换成c++文件，cd到main.m所在的目录，并执行这条命令<code>clang -rewrite-objc main.m</code>，</p>
<p>如果上面的命令报错<code>&#39;UIKit/UIKit.h&#39; file not found</code>,可以使用下面命令</p>
<p><code>clang -x objective-c -rewrite-objc -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk main.m</code></p>
<p>通过这条命令可以把main.m文件转换成cpp文件，里面可以看到block的结构。我们打开这份文件，这个文件比较长，直接拉到最后。可以看到在文件的最后是main函数的入口，代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA)) ();</span><br><span class="line">        blockFunc1();</span><br><span class="line">        blockFunc2();</span><br><span class="line"></span><br><span class="line">        blockFunc3();</span><br><span class="line">        blockFunc4();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看第一行代码，构造了一个<strong>main_block_impl_0对象，</strong>main_block_impl_0是一个结构体。相关代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从代码可知，最后block会转化成一个__block_impl对象，而block执行的代码会转化成一个静态函数，__block_impl里面的FuncPtr会指向这个静态函数。在这里<code>printf(&quot;Hello, World!\n&quot;);</code>这个block转换后的静态函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以整个过程是这样的：<br>1、先构造一个<code>__main_block_impl_0</code>对象，构造的时候把<code>__main_block_func_0</code>传进去，当然还有别的参数，这里先不考虑。</p>
<p>2、在<code>__main_block_impl_0</code>的构造方法中，再把<code>__main_block_func_0</code>赋给<code>__block_impl</code>的FuncPtr。</p>
<p>3、调用FuncPtr。</p>
<p>所以，从上面可以看出，block实际上是转化为了一个<code>__block_impl</code>对象，这个对象有isa指针，用来表示block的类型，上面的block的isa指向&amp;_NSConcreteStackBlock。同时block对象还有一个FuncPtr指针，用来指向block执行的方法（转换后的静态函数）。</p>
<p>再来看看blockFunc1相关的内容</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc1_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc1_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  __blockFunc1_block_impl_0(<span class="keyword">void</span> *fp, struct __blockFunc1_block_desc_0 *desc, <span class="keyword">int</span> _num, <span class="keyword">int</span> flags=<span class="number">0</span>) : num(_num) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __blockFunc1_block_func_0(struct __blockFunc1_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> num = __cself-&gt;num; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders__s_l_p47fxn36j8d2_n75spyb7c0000gn_T_main_324f63_mi_0, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc1_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __blockFunc1_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __blockFunc1_block_impl_0)&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blockFunc1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">void</span> (*block)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__blockFunc1_block_impl_0((<span class="keyword">void</span> *)__blockFunc1_block_func_0, &amp;__blockFunc1_block_desc_0_DATA, num));</span><br><span class="line">    num = <span class="number">200</span>;</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个函数里面，构造block的时候把num传了进去，而且是普通值传递，这样的话其实是拷贝了一份num。然后在执行block方法的时候，使用的是拷贝的那份num，从<code>int num = __cself-&gt;num; // bound by copy</code>可以看出。这个block也是_NSConcreteStackBlock类型的。</p>
<p>再来看看__block修饰过的num在block里面是怎么传递的，我们看看blockFunc2相关的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_num_0</span> &#123;</span></span><br><span class="line"> <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_num_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc2_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc2_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __Block_byref_num_0 *num; <span class="comment">// by ref</span></span><br><span class="line">  __blockFunc2_block_impl_0(<span class="keyword">void</span> *fp, struct __blockFunc2_block_desc_0 *desc, __Block_byref_num_0 *_num, <span class="keyword">int</span> flags=<span class="number">0</span>) : num(_num-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __blockFunc2_block_func_0(struct __blockFunc2_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_num_0 *num = __cself-&gt;num; <span class="comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders__s_l_p47fxn36j8d2_n75spyb7c0000gn_T_main_324f63_mi_1, (num-&gt;__forwarding-&gt;num));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __blockFunc2_block_copy_0(struct __blockFunc2_block_impl_0*dst, struct __blockFunc2_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;num, (<span class="keyword">void</span>*)src-&gt;num, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __blockFunc2_block_dispose_0(struct __blockFunc2_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;num, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc2_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*copy)(struct __blockFunc2_block_impl_0*, struct __blockFunc2_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(struct __blockFunc2_block_impl_0*);</span><br><span class="line">&#125; __blockFunc2_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __blockFunc2_block_impl_0), __blockFunc2_block_copy_0, __blockFunc2_block_dispose_0&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blockFunc2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_num_0 num = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_num_0 *)&amp;num, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_num_0), <span class="number">100</span>&#125;;</span><br><span class="line">    <span class="keyword">void</span> (*block)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__blockFunc2_block_impl_0((<span class="keyword">void</span> *)__blockFunc2_block_func_0, &amp;__blockFunc2_block_desc_0_DATA, (__Block_byref_num_0 *)&amp;num, <span class="number">570425344</span>));</span><br><span class="line">    (num.__forwarding-&gt;num) = <span class="number">200</span>;</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看到，__block修饰的num在内部被包装成一个__Block_byref_num_0的对象，假设叫a，原来num的值100存储在对象a的num字段中，同时这个对象a有一个<strong>forwarding字段，指向a本身。当改变num的值的时候（源代码是<code>num = 200;</code>），这段代码变为`(num.</strong>forwarding-&gt;num) = 200;<code>，也就是说把对象a里面的num字段的值变为了200。同时，在block的执行函数__blockFunc2_block_func_0中，打印出来的取值是从</code><strong>Block_byref_num_0 *num = __cself-&gt;num;`取出，也就是取得是改变后的值，所以打印结果是200。这就是为什么用</strong>block修饰的变量可以在block内部被修改。</p>
<p>那当num为全局变量的时候，block又是怎样的呢？请看代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc3_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc3_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __blockFunc3_block_impl_0(<span class="keyword">void</span> *fp, struct __blockFunc3_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __blockFunc3_block_func_0(struct __blockFunc3_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders__s_l_p47fxn36j8d2_n75spyb7c0000gn_T_main_324f63_mi_2, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc3_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __blockFunc3_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __blockFunc3_block_impl_0)&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blockFunc3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (*block)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__blockFunc3_block_impl_0((<span class="keyword">void</span> *)__blockFunc3_block_func_0, &amp;__blockFunc3_block_desc_0_DATA));</span><br><span class="line">    num = <span class="number">200</span>;</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码里可以看出，这种情况很简单，block对象根本没有num字段，也就是打印的时候直接取得全局的num。</p>
<p>最后一种情况也很简单，当num时static的时候，构造block对象的时候直接用引用传值的方式把num放到block对象中。所以，当外部改变num的值的时候，也能反映到block内部。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc4_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc4_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> *num;</span><br><span class="line">  __blockFunc4_block_impl_0(<span class="keyword">void</span> *fp, struct __blockFunc4_block_desc_0 *desc, <span class="keyword">int</span> *_num, <span class="keyword">int</span> flags=<span class="number">0</span>) : num(_num) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __blockFunc4_block_func_0(struct __blockFunc4_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> *num = __cself-&gt;num; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders__s_l_p47fxn36j8d2_n75spyb7c0000gn_T_main_324f63_mi_3, (*num));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">blockFunc4_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __blockFunc4_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __blockFunc4_block_impl_0)&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blockFunc4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">void</span> (*block)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__blockFunc4_block_impl_0((<span class="keyword">void</span> *)__blockFunc4_block_func_0, &amp;__blockFunc4_block_desc_0_DATA, &amp;num));</span><br><span class="line">    num = <span class="number">200</span>;</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章主要从源码的角度讲述了block的实现机制，并针对四种情况分析了block是如何引用外部变量的，分别是:<br>1、当引用局部变量的时候，如果没有__block修饰，那么在block内部获取的是外部变量的一份拷贝，改变外部变量不影响block内部的那份拷贝。</p>
<p>2、当引用局部变量的时候，同时局部变量用__block修饰，那么在block内部使用的实际上是外部变量的一个引用，所以改变外部变量会影响block内部变量的值。</p>
<p>3、当引用全局变量的时候，block并不持有这个变量。</p>
<p>4、当引用static变量的时候，block会以引用的方式持有这个变量。当在外部修改这个变量的时候，会影响block内部持有的这个变量的值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/18/iOS-Runloop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/18/iOS-Runloop/" class="post-title-link" itemprop="url">iOS  - Runloop</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-18 15:33:42" itemprop="dateCreated datePublished" datetime="2021-05-18T15:33:42+08:00">2021-05-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/18/iOS-%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/18/iOS-%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">iOS  - 线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-18 14:36:21" itemprop="dateCreated datePublished" datetime="2021-05-18T14:36:21+08:00">2021-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-01 21:30:21" itemprop="dateModified" datetime="2021-08-01T21:30:21+08:00">2021-08-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>多线程是我们开发和面试中都会遇到的一个重要概念，相比于其他编程语言和平台，iOS 的多线程使用起来要比较友好和易用一些。但是对于多线程的基本概念，我们还是需要重视起来，这对于我们探索 <code>pthread</code>、<code>NSThread</code>、<code>GCD</code> 以及 <code>RunLoop</code> 都大有裨益。</p>
<h3 id="前导知识"><a href="#前导知识" class="headerlink" title="前导知识"></a>前导知识</h3><ul>
<li>POSIX</li>
</ul>
<blockquote>
<p>POSIX Threads, usually referred to as pthreads, is an execution model that exists independently from a language, as well as a parallel execution model. It allows a program to control multiple different flows of work that overlap in time. Each flow of work is referred to as a thread, and creation and control over these flows is achieved by making calls to the POSIX Threads API.</p>
</blockquote>
<blockquote>
<p>– POSIX Threads, Wikipedia</p>
</blockquote>
<blockquote>
<p>译：</p>
</blockquote>
<blockquote>
<p>POSIX（Portable Operating System Interface of UNIX，可移植操作系统接口）线程，即 pthreads，是一种<strong>不依赖于语言的执行模型</strong>，也称作并行（Parallel）执行模型。其允许一个程序控制多个时间重叠的不同工作流。每个工作流即为一个线程，通过调用 POSIX 线程 API 创建并控制这些流。</p>
</blockquote>
<blockquote>
<p>– POSIX 线程，维基百科</p>
</blockquote>
<ul>
<li>detached 和 joinable</li>
</ul>
<blockquote>
<p>无论在windows中还是Posix中，主线程和子线程的默认关系是：无论子线程执行完毕与否，一旦主线程执行完毕退出，所有子线程执行都会终止。这时整个进程结束或僵死，部分线程保持一种终止执行但还未销毁的状态，而进程必须在其所有线程销毁后销毁，这时进程处于僵死状态。线程函数执行完毕退出，或以其他非常方式终止，线程进入终止态，但是为线程分配的系统资源不一定释放，可能在系统重启之前，一直都不能释放，终止态的线程，仍旧作为一个线程实体存在于操作系统中，什么时候销毁，取决于线程属性。在这种情况下，主线程和子线程通常定义以下两种关系：</p>
</blockquote>
<blockquote>
<p>1、<strong>可会合（joinable</strong>）：这种关系下，主线程需要明确执行等待操作，在子线程结束后，主线程的等待操作执行完毕，子线程和主线程会合，这时主线程继续执行等待操作之后的下一步操作。主线程必须会合可会合的子线程。在主线程的线程函数内部调用子线程对象的wait函数实现，即使子线程能够在主线程之前执行完毕，进入终止态，也必须执行会合操作，否则，系统永远不会主动销毁线程，分配给该线程的系统资源也永远不会释放。</p>
</blockquote>
<blockquote>
<p>2、<strong>相分离（detached）</strong>：表示子线程无需和主线程会合，也就是相分离的，这种情况下，子线程一旦进入终止状态，这种方式常用在线程数较多的情况下，有时让主线程逐个等待子线程结束，或者让主线程安排每个子线程结束的等待顺序，是很困难或不可能的，所以在并发子线程较多的情况下，这种方式也会经常使用。</p>
</blockquote>
<blockquote>
<p>在任何一个时间点上，线程是可结合（joinable）或者是可分离的（detached），一个可结合的线程能够被其他线程回收资源和杀死，在被其他线程回收之前，它的存储器资源如栈，是不释放的，相反，一个分离的线程是不能被其他线程回收或杀死的，它的存储器资源在它终止时由系统自动释放。</p>
</blockquote>
<blockquote>
<p>线程的分离状态决定一个线程以什么样的方式来终止自己，在默认的情况下，线程是非分离状态的，这种情况下，原有的线程等待创建的线程结束，只有当pthread_join函数返回时，创建的线程才算终止，释放自己占用的系统资源，而分离线程没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。</p>
</blockquote>
<p>joinable 和 detaced 其实是主线程与子线程之间的一种关系。app 退出后，detached 线程直接进入终止态，其栈空间资源被系统回收，但是 joinable 线程资源不会被回收，所以可以在 app 退出的时候使用 joinable 线程也就是 pthread 来做一些保存资源到磁盘的操作。也就是说在主线程执行完毕要退出之前，会去处理joinable的线程。</p>
<h3 id="线程初探"><a href="#线程初探" class="headerlink" title="线程初探"></a>线程初探</h3><h4 id="线程定义"><a href="#线程定义" class="headerlink" title="线程定义"></a>线程定义</h4><p>要先了解什么是线程，我们需要先了解什么是进程。对于 iOS 来说，每一个 <code>app</code> 其实就是一个进程，这一点和 <code>Android</code> 有很大的区别。除了单进程之外，在未越狱之前，每个 <code>app</code> 只能访问每个 <code>app</code> 自身的沙盒环境，不能访问之外的内容。得益于这样的设计，<code>iOS</code> 成为了世界上最安全的操作系统（苹果是这么的说的🐶）。</p>
<p>下面给出苹果官方对于线程的定义</p>
<blockquote>
<p>Threads are a relatively lightweight way to implement multiple paths of execution inside of an application.</p>
<p>【译】线程是在应用程序内部实现多个执行路径的相对轻量的方法。</p>
</blockquote>
<blockquote>
<p>From a technical standpoint, a thread is a combination of the kernel-level and application-level data structures needed to manage the execution of code. The kernel-level structures coordinate the dispatching of events to the thread and the preemptive scheduling of the thread on one of the available cores. The application-level structures include the call stack for storing function calls and the structures the application needs to manage and manipulate the thread’s attributes and state.</p>
<p>【译】从技术角度来看，线程是管理代码执行所需的<strong>内核级和应用程序级</strong>数据结构的组合。内核负责线程事件的分发和线程优先级的调度，应用层则负责存储线程函数中断时的状态和属性的存储方便下次内核切换时再从存储的地方运行。</p>
</blockquote>
<p>线程的定义可以总结为以下三点:</p>
<ul>
<li>线程是进程的基本执行单元，一个进程的所有任务都在线程中执行。</li>
<li>进程想要执行任务，必须得有线程，进程至少要有一条线程。</li>
<li>程序启动会默认开启一条线程，这条线程被称为主线程或 UI 线程。</li>
</ul>
<p>下面我们看一下进程的定义：</p>
<ul>
<li>进程是指在系统中正在运行的一个应用程序</li>
<li>每个进程之间是独立的，每个进程均运行在其专用的且受保护的内存空间内</li>
</ul>
<p>这两句话不难理解，只针对于 <code>iOS</code> 来说，一个 <code>app</code> 就是一个进程，而由于有沙盒机制，每个 <code>app</code> 所对应的进程只能访问当前 <code>app</code> 沙盒所对应的内存空间，是相互独立的。</p>
<p>我们的 <code>app</code> 只有一条进程，而线程的话，默认只有一条主线程。我们可以通过多线程技术来开线程然后启动线程来执行任务。而进程与线程之间的关系可以总结为下列几点：</p>
<ul>
<li>地址空间：同一进程的<strong>线程共享本进程</strong>的地址空间，而<strong>进程之间则是独立的</strong>地址空间。</li>
<li>资源拥有：同一进程内的线程共享本进程的资源如内存、I/O、CPU 等，但是进程之间资源是独立的。</li>
<li>一个线程崩溃后，在保护模式下不会对其它进程产生影响，但是一个线程崩溃后会导致整个进程的崩溃，所以多进程相比多线程更加健壮。</li>
<li>进程切换时，消耗的资源大，效率低。所以涉及到频繁的上下文切换的时候，使用线程要好于进程。同样的，如果要求同时进行且要共享某些变量的并发操作，只能用线程，不能用进程。</li>
<li>执行过程：每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存于应用程序中，由应用程序提供多个线程执行控制。</li>
<li>线程是 CPU 调度的基本单位，进程不是。</li>
</ul>
<h4 id="线程相关的术语"><a href="#线程相关的术语" class="headerlink" title="线程相关的术语"></a>线程相关的术语</h4><p>在深入讨论线程及其支持技术之前，有必要弄清楚一些基本术语。</p>
<p>如果你熟悉 <code>UNIX</code> 系统，术语 <code>任务</code> 于表示正在运行的进程，但在本文中并不是这样定义的。</p>
<p>本文采用的术语如下:</p>
<ul>
<li>术语 <code>线程</code> 用于指代代码的独立执行路径。</li>
<li>术语 <code>进程</code> 用于指代一个正在运行的可执行文件，它可以包含多个线程。</li>
<li>术语 <code>任务</code> 用于指代需要执行的工作的抽象概念。</li>
</ul>
<h4 id="线程的替代方案"><a href="#线程的替代方案" class="headerlink" title="线程的替代方案"></a>线程的替代方案</h4><p>手动创建线程会给我们的代码带来一定的<strong>不确定性</strong>。相对来说线程属于<strong>抽象层次比较低</strong>且使用起来比较麻烦的一种让应用程序支持并发的方案。如果你对于直接使用线程不熟悉的话，那么很容易遇到线程同步和时序问题，其严重性可能从细微的问题到应用程序崩溃和用户数据损坏。</p>
<p>所以如上图所示，苹果官方给出了以下几种线程的替代方案:</p>
<ul>
<li><code>Operation Objects</code>: 任务对象(<code>NSOpeartion</code>)是 <code>OS X 10.5</code> 推出的一个特性。通过封装在子线程执行的任务，隐藏底层的线程管理的具体细节，让开发者聚焦于任务执行的本身。通常来说任务对象会与任务对象队列(<code>NSOperationQueue</code>)结合使用，来实现在一个或多个线程上任务的执行。</li>
<li><code>GCD</code>: <code>OS 10.6</code> 正式推出，<code>GCD</code> 是另外一种可以让开发者无需知道线程细节而专注于任务本身的一项技术。通过使用 <code>GCD</code>，你可以定义你需要执行的任务，然后把这个任务加入到一个队列中来让 <code>GCD</code> 选择在一个合适的线程上执行这个任务。队列考虑了可用核心的数量和当前负载，这样与直接使用线程相比可以更有效地执行任务。</li>
<li><code>Idle-time notifications</code>: 空闲时通知，对于优先级和复杂度相对来说不高的任务，空闲时通知技术可以在应用程序空闲时执行任务。<code>Cocoa</code> 使用 <code>NSNotificationQueue</code> 来实现这一技术。为了获得空闲时通知，你需要使用 <code>NSPostWhenIdle</code> 选项来向 <code>NSNotificationQueue</code> 队列发送通知，然后直到 <code>Runloop</code> 空闲时，队列才会执行的通知里面的具体任务。</li>
</ul>
<blockquote>
<p><code>NSNotificationQueue</code> 官方定义</p>
<p>Whereas a notification center distributes notifications when posted, notifications placed into the queue can be delayed until the end of the current pass through the run loop or until the run loop is idle. Duplicate notifications can be coalesced so that only one notification is sent although multiple notifications are posted.</p>
<p>【译】通知中心收到发出的通知后会向在通知中心注册的观察者分发这些通知，而添加到 <code>NSNotificationQueue</code> 队列中的通知只会在两种情况下分发出去，分别是当前 <code>Runloop</code> 即将退出或者 <code>Runloop</code> 处于空闲状态时。重复的向 <code>NSNotificationQueue</code> 队列中加入通知会导致相同的通知被合并，这样到了发送时机，对于重复的通知只会发送一条出去。</p>
<p>A notification queue maintains notifications in first in, first out (FIFO) order. When a notification moves to the front of the queue, the queue posts it to the notification center, which in turn dispatches the notification to all objects registered as observers.</p>
<p>【译】一个通知队列以先进先出的方式维护着通知。当一个通知移动到了队列的头部，队列会将这个通知发往通知中心，通知中心将通知分派给所有注册为观察者的对象。</p>
<p>Every thread has a default notification queue, which is associated with the default notification center for the process. You can create your own notification queues and have multiple queues per center and thread.</p>
<p>【译】每一个线程都有一个默认的通知队列，并且这个通知队列会与当前进程的默认的通知中心相关联。但是你可以创建自己的通知队列，使得每个通知中心和线程有多条通知队列</p>
</blockquote>
<blockquote>
<p>关于 <code>NSNotificationQueue</code> 的更多底层细节，可以参考这篇文章 <a href="https://www.jianshu.com/p/ce8ea320ec69" target="_blank" rel="noopener">一文全解iOS通知机制</a></p>
</blockquote>
<ul>
<li><code>Asynchronous functions</code>: 异步的函数。系统自带的 <code>api</code> 包含许多可以为你提供自动并发功能的函数。这些函数的实现你无需关心，它们依托于系统的守护进程和进程或者会创建子线程来执行你所需要的任务。</li>
<li><code>Timers</code>: 定时器。你可以在应用程序的主线程上使用定时器来执行周期性的任务，这些任务虽然琐碎而无法使用线程，但仍需要定期进行维护。</li>
<li><code>Separate processes</code>: 尽管比线程更重，但是在任务仅与应用程序有切线关系的情况下，创建单独的进程可能会很有用。 如果任务需要大量内存或必须使用 root 特权执行，则可以使用进程。 例如，当 32 位应用程序将结果显示给用户时，你可以使用 64 位服务器进程来计算大型数据集。</li>
</ul>
<h4 id="线程支持"><a href="#线程支持" class="headerlink" title="线程支持"></a>线程支持</h4><h5 id="Cocoa-中线程相关的技术"><a href="#Cocoa-中线程相关的技术" class="headerlink" title="Cocoa 中线程相关的技术"></a><code>Cocoa</code> 中线程相关的技术</h5><ul>
<li><code>Cocoa Threads</code>: <code>Cocoa</code> 使用 <code>NSThread</code> 来实现线程。除此之外，<code>NSObject</code> 还提供了一揽子方法来派生线程和在已存在线程上执行任务。</li>
<li><code>POSIX threads</code>: <code>POSIX</code> 提供了基于 <code>C</code> 语言的一套创建线程的 <code>API</code>。如果不是创建 <code>Cocoa</code> 程序，那么这将是最好的创建线程的方案。<code>POSIX</code> 接口使用起来非常简单，并且为配置线程提供了足够的灵活性</li>
<li><code>Multiprocessing Services</code>: 多处理服务是从旧版 <code>Mac OS</code> 过渡到的应用程序使用的基于 <code>C</code> 的旧接口。此技术仅在 <code>OS X</code> 中可用，任何新开发都应避免使用。</li>
</ul>
<p>线程启动之后，主要以三种状态运行，分别是:</p>
<ul>
<li>运行态</li>
<li>就绪态</li>
<li>阻塞态</li>
</ul>
<p>如果线程当前未在运行态，则它要么被阻塞并等待输入，要么准备运行，但尚未计划这样做。线程继续在这些状态之间来回移动，直到最终退出并进入终止状态。</p>
<h5 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h5><blockquote>
<p>A run loop is a piece of infrastructure used to manage events arriving asynchronously on a thread. A run loop works by monitoring one or more event sources for the thread. As events arrive, the system wakes up the thread and dispatches the events to the run loop, which then dispatches them to the handlers you specify. If no events are present and ready to be handled, the run loop puts the thread to sleep.</p>
<p>【译】一个运行循环是一个处理线程上所接收到的异步的事件的结构。运行循环管理线程上的一个或多个事件源。当事件到达时，系统将唤醒线程并将事件分配给运行循环，然后运行循环将其分配给你指定的处理程序。如果不存在任何事件或有待处理的事件，则运行循环会将线程置于睡眠状态。</p>
</blockquote>
<blockquote>
<p>You are not required to use a run loop with any threads you create but doing so can provide a better experience for the user. Run loops make it possible to create long-lived threads that use a minimal amount of resources. Because a run loop puts its thread to sleep when there is nothing to do, it eliminates the need for polling, which wastes CPU cycles and prevents the processor itself from sleeping and saving power.</p>
<p>【译】你不需要对你所创建的线程使用运行循环，但是使用运行循环可以提高用户体验。运行循环可以创建使用最少资源的常驻线程。因为当没事做的时候，运行循环会让线程休眠，这样就不许需要通过轮询这种需要消耗 CPU 的低效操作从而节能。</p>
</blockquote>
<blockquote>
<p>To configure a run loop, all you have to do is launch your thread, get a reference to the run loop object, install your event handlers, and tell the run loop to run. The infrastructure provided by OS X handles the configuration of the main thread’s run loop for you automatically. If you plan to create long-lived secondary threads, however, you must configure the run loop for those threads yourself.</p>
<p>【译】要配置运行循环，你要做的就是启动线程，获取运行循环对象的引用，安装事件处理程序，并告诉运行循环运行。 OS X 提供的基础结构会自动为你处理主线程运行循环的。但是，如果计划创建寿命长的辅助线程，则必须自己为这些线程配置运行循环。</p>
</blockquote>
<p>通过上面官方文档的描述，runloop 其实和线程是紧密关联的，通过 runloop 可以让子线程一直存活而不被系统回收。同时，runloop 还能提升用户体验，可以重复的在子线程工作而无需为了执行任务多次开同样工作内容的线程。</p>
<h5 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h5><p>使用多线程技术会遇到多个线程同时访问同一份资源的情况，而如果这些线程同时尝试使用或修改资源，则会出现严重的问题。解决此问题的办法通常来说有两种，一种是消除共享资源，让每个线程独享其特有的资源进行操作。第二种就是通过 locks(锁), conditions(条件), atomic operations(原子操作)等其它技术。显然第二种方案使用频率更高。</p>
<p>苹果官方给出了几种线程间通信的方式，简单总结一下如下：</p>
<ul>
<li><strong>直接消息传递</strong>: 通过 <code>performSelector</code> 的一系列方法，可以实现由某一线程指定在另外的线程上执行任务。因为任务的执行上下文是目标线程，这种方式发送的消息将会自动的被序列化。</li>
<li><strong>全局变量、共享内存块和对象</strong>: 在两个线程之间传递信息的另一种简单方法是使用全局变量，共享对象或共享内存块。尽管共享变量既快速又简单，但是它们比直接消息传递更脆弱。必须使用锁或其他同步机制仔细保护共享变量，以确保代码的正确性。 否则可能会导致竞争状况，数据损坏或崩溃。</li>
<li><strong>条件执行</strong>: 条件是一种<strong>同步工具</strong>，可用于控制线程何时执行代码的特定部分。您可以将条件视为关守，让线程仅在满足指定条件时运行。</li>
<li><strong><code>Runloop sources</code></strong>: 一个自定义的 <code>Runloop source</code> 配置可以让一个线程上收到特定的应用程序消息。由于 <code>Runloop source</code> 是事件驱动的，因此在无事可做时，线程会自动进入睡眠状态，从而提高了线程的效率。</li>
<li><code>Ports and sockets</code>: 基于端口的通信是在两个线程之间进行通信的一种更为复杂的方法，但它也是一种非常可靠的技术。更重要的是，端口和套接字可用于与外部实体（例如其他进程和服务）进行通信。为了提高效率，使用 <code>Runloop source</code> 来实现端口，因此当端口上没有数据等待时，线程将进入睡眠状态。</li>
<li><strong>消息队列</strong>: 传统的多处理服务定义了先进先出（<code>FIFO</code>）队列抽象，用于管理传入和传出数据。尽管消息队列既简单又方便，但是它们不如其他一些通信技术高效。</li>
<li><strong><code>Cocoa</code> 分布式对象</strong>: 分布式对象是一种 <code>Cocoa</code> 技术，可提供基于端口的通信的高级实现。尽管可以将这种技术用于线程间通信，但是强烈建议不要这样做，因为它会产生大量开销。分布式对象更适合与其他进程进行通信，尽管在这些进程之间进行事务的开销也很高</li>
</ul>
<h4 id="使用线程的注意点"><a href="#使用线程的注意点" class="headerlink" title="使用线程的注意点"></a>使用线程的注意点</h4><ul>
<li>避免显式的创建线程</li>
</ul>
<blockquote>
<p>手动编写线程创建代码很繁琐，并且可能容易出错，因此应尽可能避免这样做。</p>
<p><code>OS X</code> 和 <code>iOS</code> 通过其他 <code>API</code> 为并发提供隐式支持。与其自己创建一个线程，不如考虑使用异步 <code>API</code>，<code>GCD</code> 或操作对象来完成工作。这些技术可以在底层为您完成与线程相关的工作，并且可以保证正确进行。此外，<code>GCD</code> 和操作对象等技术旨在根据当前系统负载调整活动线程的数量，从而比您自己的代码更有效地管理线程。</p>
</blockquote>
<ul>
<li>让线程合理的执行任务</li>
</ul>
<blockquote>
<p>如果决定手动创建和管理线程，请记住线程会消耗宝贵的系统资源。您应该尽力确保分配给线程的所有任务都可以长期有效地工作。同时，您不必担心终止花费大部分空闲时间的线程。线程占用的内存非常少，其中一些是 <code>wired memory</code>，因此释放空闲线程不仅有助于减少应用程序的内存占用，还可以释放更多的物理内存供其他系统进程使用。</p>
</blockquote>
<blockquote>
<p>PS: Mac 中的内存使用可以分为四大类</p>
<ul>
<li><strong>Wired</strong>(联动): 系统核心占用的，永远不会从系统物理内存中驱除。</li>
<li><strong>Active</strong>(活跃): 表示这些内存数据正在使用中，或者刚被使用过。</li>
<li><strong>Inactive</strong>(非活跃): 表示这些内存中的数据是有效的，但是最近没有被使用。</li>
<li><strong>Free</strong>(可用空间): 表示这些内存中的数据是无效的，即内存剩余量。</li>
</ul>
</blockquote>
<blockquote>
<p>开始终止空闲线程之前，应始终记录一组应用程序当前性能的基准测量值。 尝试更改后，请进行其他测量以确认更改实际上在提高性能，而不是损害性能。</p>
</blockquote>
<ul>
<li>避免共享数据结构</li>
</ul>
<blockquote>
<p>避免与线程相关的资源冲突的最简单和容易的方法是为程序中的每个线程提供所需数据的自己的副本。当您最小化线程之间的通信和资源争用时，并行代码最有效。</p>
</blockquote>
<ul>
<li>线程和用户界面</li>
</ul>
<blockquote>
<p>如果你的应用有图形化的用户界面，强烈建议在应用程序的主线程上接收用户相关的事件和启动界面更新的操作。这种方法有助于避免与处理用户事件和绘制窗口内容相关的同步问题。某些框架（例如 <code>Cocoa</code>）通常需要此行为，但是即使对于那些不需要的框架，在主线程上保留此行为也具有简化管理用户界面的逻辑的优势。</p>
</blockquote>
<blockquote>
<p>当然，在某些情况下，在非主线程上执行图形操作是有助于提高性能的。例如，您可以使用子线程来创建和处理图像以及执行其他与图像有关的计算操作。但是遇到不确定的图形操作的时候，最好在主线程上执行。</p>
</blockquote>
<ul>
<li>注意线程退出时的问题</li>
</ul>
<blockquote>
<p>进程一直运行到所有<strong>非分离线程</strong>都退出为止。默认情况下，仅将应用程序的主线程创建为<strong>非分离式</strong>。当然，你也可以创建<strong>非分离</strong>的子线程。 当用户退出应用程序时，通常认为立即终止所有分离的线程是适当的行为，因为分离的线程完成的工作被认为是可选的。但是，如果你的应用程序正在使用后台线程将数据保存到磁盘或执行其他关键工作，则可能需要将这些线程创建为非分离线程，以防止在应用程序退出时丢失数据。</p>
</blockquote>
<blockquote>
<p>将线程创建为<strong>非分离线程</strong>（也称为<strong>可连接线程</strong>）需要你进行额外的工作。因为大多数高级线程技术默认情况下都不创建<strong>可连接线程</strong>，所以你可能必须使用 <code>POSIX API</code> 创建线程。此外，你必须在应用程序的主线程中添加代码，以便在非分离线程最终退出时加入它们。</p>
</blockquote>
<ul>
<li>处理异常</li>
</ul>
<blockquote>
<p>抛出异常时，异常处理机制依赖于当前的调用堆栈来执行任何必要的清除工作。因为每个线程都有自己的调用堆栈，所以每个线程负责捕获自己的异常。在辅助线程中未能捕获异常与在主线程中未能捕获异常会有相同的后果：进程终止。你不能将未捕获的异常抛出到另一个线程进行处理。</p>
</blockquote>
<blockquote>
<p>如果你需要在当前线程中将异常情况通知另一个线程（例如主线程），则应捕获该异常，并简单地向该另一个线程发送一条消息，指出发生了什么。 根据您的模型和您要执行的操作，捕获到异常的线程可以继续处理（如果可能的话），等待指令或直接退出。</p>
</blockquote>
<blockquote>
<p>在某些情况下，可能会自动为你创建一个异常处理程序。 例如，<code>Objective-C</code> 中的<code>@synchronized</code> 指令包含一个隐式异常处理程序。</p>
</blockquote>
<ul>
<li>彻底的退出线程</li>
</ul>
<blockquote>
<p>退出线程的最佳方法自然是让线程到达其主入口点例程的末尾。尽管有立即终止线程的功能，但这些功能仅应作为最后的手段使用。在线程到达其自然终点之前终止该线程会阻止该线程自身的清理。如果线程已分配内存，打开文件或获取其他类型的资源，则您的代码可能无法回收这些资源，从而导致内存泄漏或其他潜在问题。</p>
</blockquote>
<ul>
<li>库中的线程安全</li>
</ul>
<blockquote>
<p>尽管应用程序开发人员可以控制应用程序是否使用多线程执行，但库开发人员不能。在开发库时，必须假设调用应用程序是多线程的，或者可以随时切换到多线程的。因此，你应该始终对代码的关键部分使用锁。</p>
</blockquote>
<p>对于库开发人员来说，仅当应用程序变成多线程时才创建锁是不明智的。如果你需要在某个时候锁定代码，请在使用库的早期创建 lock 对象，最好是通过某种显式调用来初始化库。尽管你也可以使用静态库初始化函数来创建此类锁，但只有在没有其他方法时才尝试这样做。执行初始化函数会增加加载库所需的时间，并可能对性能产生不利影响。</p>
<blockquote>
<p>始终记住在库中平衡互斥锁的加锁和解锁。你还应该记住对库中的数据结构加锁，而不是依赖调用代码来提供线程安全的环境。</p>
<p>如果你正在开发 <code>Cocoa</code> 库，那么如果你希望在应用程序变为多线程时得到通知，则可以注册为 <code>NSWillBecomeMultiThreadedNotification</code> 的观察者。但是，你不应该依赖于接收此通知，因为它可能在调用库代码之前被发送。</p>
</blockquote>
<h3 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h3><h4 id="线程开销"><a href="#线程开销" class="headerlink" title="线程开销"></a>线程开销</h4><ul>
<li>内核层的数据结构：开销为 1KB。这部分用于存储线程数据结构和属性，其中大部分是作为有线内存分配的，因此无法分页到磁盘。</li>
<li>栈空间：iOS 程序主线程开销为 1MB，macOS 程序主线程开销为 8MB，子线程开销为 512KB。</li>
<li>创建时间：大约 90ms，此值反映创建线程的初始调用与线程的入口点例程开始执行之间的时间。这些数字是通过分析在基于英特尔的 iMac 上创建线程时生成的平均值和中值来确定的，iMac 具有一个 2GHz 的双核处理器和一个运行 OSX V10.5 的 1GB RAM。</li>
</ul>
<blockquote>
<p>由于其底层内核支持，<code>Operation</code> 对象通常可以更快地创建线程。它们不是每次都从头开始创建线程，而是使用已经驻留在内核中的线程池来节省分配时间。</p>
</blockquote>
<h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><p>线程创建出来后必须要执行任务才有意义，下面介绍几种创建线程的方式。</p>
<h5 id="使用-NSThread-创建线程"><a href="#使用-NSThread-创建线程" class="headerlink" title="使用 NSThread 创建线程"></a>使用 NSThread 创建线程</h5><p>通过 <code>NSThread</code> 创建线程有两种方式：</p>
<ul>
<li>使用 <code>detachNewThreadSelector:toTarget:withObject:</code> 类方法来派生新的线程。</li>
<li>创建一个 <code>NSThread</code> 实例对象，然后调用 <code>start</code> 方法。</li>
</ul>
<blockquote>
<p>这两种技术都会在应用程序中创建<strong>分离式线程</strong>。分离的线程意味着当线程退出时，系统会自动回收该线程的资源。这也意味着您的代码以后不必显式地与线程联接。</p>
</blockquote>
<p>下面给出两种方式的实际用法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[NSThread detachNewThreadSelector:@selector(myThreadMainMethod:) toTarget:self withObject:nil];</span><br><span class="line"></span><br><span class="line">NSThread* myThread = [[NSThread alloc] initWithTarget:self</span><br><span class="line">                                        selector:@selector(myThreadMainMethod:)</span><br><span class="line">                                        object:nil];</span><br><span class="line">[myThread start];  <span class="comment">// Actually create the thread</span></span><br></pre></td></tr></table></figure>

<p>这里有一个注意点，采用实例化 <code>NSThread</code> 对象的方式，只有调用 <code>start</code> 方法后，在底层线程才会被创建出来。</p>
<p>使用 <code>initWithTarget:selector:object:method</code> 的另一种方法是将 <code>NSThread</code> 子类化并重写其 <code>main</code> 方法。你可以使用此方法的重写版本来作为线程的主入口点。</p>
<p>如果你有一个已经创建好并且在运行中的 <code>NSThread</code> 线程对象，你可以通过 <code>performSelector:onThread:withObject:waitUntilDone:</code> 方法来向这个线程发送消息。这个方法是 <code>NSObject</code> 的分类中的方法，也就意味着几乎任何对象都能适用。使用这个方法发送的消息将由另一个线程直接执行，作为其正常运行循环处理的一部分。当然，这意味着目标线程必须在其运行循环中运行）。在这过程中你可能还需要适用锁来进行线程同步，当然，这比适用基于 port 的线程间通信要简单一些。</p>
<p>虽然 <code>performSelector:onThread:withObject:waitUntilDone:</code> 方法用起来很简单，但是对于频繁间的线程通信或时间敏感类的任务执行，请不要使用这个方法。</p>
<h5 id="使用-POSIX-创建线程"><a href="#使用-POSIX-创建线程" class="headerlink" title="使用 POSIX 创建线程"></a>使用 POSIX 创建线程</h5><blockquote>
<p>OS X 和 iOS 为使用 POSIX 线程 API 创建线程提供了基于 C 的支持。这种技术实际上可以用于任何类型的应用程序（包括 Cocoa 和 Cocoa Touch 应用程序），如果您为多个平台编写软件，则可能更方便。用于创建线程的 <code>POSIX</code> 例程被适当地调用为 <code>pthread_create</code>。</p>
</blockquote>
<p>下面是对于 <code>pthread_create</code> 的简单使用示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 线程要执行的任务 </span><br><span class="line">void* PosixThreadMainRoutine(void* data)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Do some work here.</span><br><span class="line"> </span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 启动线程 </span><br><span class="line">void LaunchThread()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 线程属性</span><br><span class="line">    pthread_attr_t  attr;</span><br><span class="line">    &#x2F;&#x2F; 线程对象</span><br><span class="line">    pthread_t       posixThreadID;</span><br><span class="line">    &#x2F;&#x2F; 返回值</span><br><span class="line">    int             returnVal;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 初始化线程属性</span><br><span class="line">    returnVal &#x3D; pthread_attr_init(&amp;attr);</span><br><span class="line">    assert(!returnVal);</span><br><span class="line">    &#x2F;&#x2F; 设置线程为 detach 状态</span><br><span class="line">    returnVal &#x3D; pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">    assert(!returnVal);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 创建线程，传入属性和要执行的任务</span><br><span class="line">    int     threadError &#x3D; pthread_create(&amp;posixThreadID, &amp;attr, &amp;PosixThreadMainRoutine, NULL);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 销毁属性</span><br><span class="line">    returnVal &#x3D; pthread_attr_destroy(&amp;attr);</span><br><span class="line">    assert(!returnVal);</span><br><span class="line">    if (threadError !&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">         &#x2F;&#x2F; Report an error.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 <code>pthread</code> 详细的使用请参考这篇文章 <a href="https://kingcos.me/posts/2019/multithreading_techs_in_ios-1/" target="_blank" rel="noopener">iOS 多线程技术实践之 pthreads（一)</a></p>
<h5 id="使用-NSObject-派生线程"><a href="#使用-NSObject-派生线程" class="headerlink" title="使用 NSObject 派生线程"></a>使用 NSObject 派生线程</h5><p>所有继承于 <code>NSObject</code> 的对象都可以通过 <code>performSelectorInBackground:withObject:</code> 来在子线程上执行任务。</p>
<p>这个方法底层实际上是调用的 <code>NSThread</code> 类方法 <code>detachNewThreadSelector:toTarget:withObject:</code> 来创建线程并执行任务。</p>
<h5 id="在-Cocoa-应用程序中使用-POSIX-线程"><a href="#在-Cocoa-应用程序中使用-POSIX-线程" class="headerlink" title="在 Cocoa 应用程序中使用 POSIX 线程"></a>在 <code>Cocoa</code> 应用程序中使用 <code>POSIX</code> 线程</h5><p>虽然在 <code>Cocoa</code> 中使用 <code>NSThread</code> 是创建线程的主要方式，但是当需要的时候，还是可以使用 <code>POSIX</code> 线程的。但是需要遵守以下几点:</p>
<ul>
<li><code>Protecting the Cocoa Frameworks</code>: 保护 <code>Cocoa</code> 中的框架<ul>
<li>对于多线程应用程序，<code>Cocoa</code> 框架使用锁和其他形式的内部同步来确保它们的行为正确。但是，为了防止这些锁在单线程情况下降低性能，在应用程序使用 <code>NSThread</code> 类生成其第一个新线程之前，<code>Cocoa</code> 不会创建这些同步的元素。如果只使用 <code>POSIX</code> 线程例程生成线程，<code>Cocoa</code> 将不会收到需要知道应用程序现在是多线程的通知。当这种情况发生时，涉及 <code>Cocoa</code> 框架的操作可能会破坏应用程序的稳定性或崩溃。</li>
<li>要让 <code>Cocoa</code> 知道你打算使用个线程，你只需使用 <code>NSThread</code> 类生成一个线程，并让该线程立即退出。你的线程入口点不需要做任何事情。使用 <code>NSThread</code> 生成一个线程的行为就足以确保 <code>Cocoa</code> 框架所需的锁被放置到位。</li>
<li>如果不确定 <code>Cocoa</code> 是否认为你的应用程序是多线程的，则可以使用 <code>NSThread</code> 的 <code>isMultiThreaded</code> 方法进行检查。</li>
</ul>
</li>
<li>混合使用 <code>Cocoa</code> 中的锁与 <code>POSIX</code> 锁<ul>
<li>在同一个应用程序中混合使用 <code>POSIX</code> 和 <code>Cocoa</code> 锁是安全的。<code>Cocoa</code> 锁和条件对象本质上只是 <code>POSIX</code> 互斥锁和条件对象的包装。但是，对于给定的锁，必须始终使用相同的接口来创建和操作该锁。换句话说，不能使用 <code>Cocoa</code> 的 <code>NSLock</code> 对象来操作使用 <code>pthread_mutex_init</code> 函数创建的互斥锁对象，反之亦然。</li>
</ul>
</li>
</ul>
<h4 id="配置线程属性"><a href="#配置线程属性" class="headerlink" title="配置线程属性"></a>配置线程属性</h4><p>在线程创建之前或者之后，你可能想要配置一些线程相关的属性，具体内容如下:</p>
<h5 id="配置线程所占栈空间大小"><a href="#配置线程所占栈空间大小" class="headerlink" title="配置线程所占栈空间大小"></a>配置线程所占栈空间大小</h5><blockquote>
<p>对于你创建的每个新线程，系统都会在进程空间中分配特定数量的内存，以充当该线程的堆栈。</p>
<p>堆栈管理堆栈帧，线程内部声明的局部变量就会存于此处。</p>
</blockquote>
<p>要设置线程所占用的栈空间大小，只能在线程创建之前指定。</p>
<ul>
<li>Cocoa</li>
</ul>
<p>通过实例化 <code>NSThread</code> 对象，然后在调用 <code>start</code> 方法之前调用 <code>setStackSize:</code> 来设置栈空间大小。</p>
<ul>
<li>POSIX</li>
</ul>
<p>创建 <code>pthread_attr_t</code> 结构体对象，然后将其传入 <code>pthread_attr_setstacksize</code> 方法来设置栈大小，然后将 <code>pthread_attr_t</code> 传入 <code>pthread_create</code> 函数来创建 POSIX 线程。</p>
<h5 id="配置-TLS"><a href="#配置-TLS" class="headerlink" title="配置 TLS"></a>配置 TLS</h5><p>每个线程会维护一个键值对的字典，用来在线程执行过程中存储一些内容，这个字典</p>
<p><code>Cocoa</code> 和 <code>POSIX</code> 以不同的方式存储线程字典，因此你不能混合和匹配对这两种技术的调用。 但是，只要您在线程代码中坚持使用一种技术，最终结果应该是相似的。在 <code>Cocoa</code> 中，你可以使用 <code>NSThread</code> 对象的 <code>threadDictionary</code> 方法来获取 <code>TLS</code>，你可以在该对象中添加线程所需的任何键。在 <code>POSIX</code> 中，使用 <code>pthread_setspecific</code> 和<code>pthread_getspecific</code> 函数来设置和获取 <code>TLS</code>。</p>
<h5 id="设置线程的分离状态"><a href="#设置线程的分离状态" class="headerlink" title="设置线程的分离状态"></a>设置线程的分离状态</h5><p>通过 <code>NSThread</code> 创建的线程默认是分离式的，当应用程序退出时，这种类型的线程也将退出，所以为了执行诸如在应用程序退出时保存数据的任务，需要创建 <code>joinable</code> 类型的线程。而目前的方案只有通过 <code>POSIX</code> 来实现，通过 <code>pthread_attr_setdetachstate</code> 方法来设置 <code>pthread_t</code> 的属性来达到非分离式的效果。当然，如果想改变线程的状态，可以通过 <code>pthread_attr_setdetachstate</code> 来将线程设置为分离式的。</p>
<h5 id="设置线程优先级"><a href="#设置线程优先级" class="headerlink" title="设置线程优先级"></a>设置线程优先级</h5><p>你所创建的线程都有与之关联默认的优先级，内核在调度线程的时候，优先级高的线程相比于优先级低的线程更有可能性执行。但是优先级高的线程并不能保证有固定的运行时间，只是更可能被调度而已。</p>
<blockquote>
<p>It is generally a good idea to leave the priorities of your threads at their default values. Increasing the priorities of some threads also increases the likelihood of starvation among lower-priority threads. If your application contains high-priority and low-priority threads that must interact with each other, the starvation of lower-priority threads may block other threads and create performance bottlenecks</p>
<p>【译】 通常最好将线程的优先级保留为默认值。增加某些线程的优先级也增加了低优先级线程之间出现饥饿的可能性。如果你的应用程序包含必须相互交互的高优先级和低优先级线程，则低优先级线程的饥饿可能会阻塞其他线程并造成性能瓶颈。</p>
<p>这里可以联想到已经不再安全的自旋锁 OSSpinLock，具体内容参见 YYKit 作者的博文 <a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的 OSSpinLock</a></p>
</blockquote>
<p>如果你确实想修改线程优先级，对于 <code>Cocoa</code> 线程，可以使用 <code>NSThread</code> 的<code>setThreadPriority</code> 类方法设置当前正在运行的线程的优先级。对于 <code>POSIX</code> 线程，使用 <code>pthread_setschedparam</code> 函数。</p>
<h4 id="编写线程入口方法"><a href="#编写线程入口方法" class="headerlink" title="编写线程入口方法"></a>编写线程入口方法</h4><blockquote>
<p>在大多数情况下，OS X 中线程的入口点例程的结构与其他平台上的相同。你可以初始化数据结构，进行一些工作或有选择地设置运行循环，并在线程代码完成后进行清理。根据你的设计，编写输入例程时可能需要采取一些其他步骤。</p>
</blockquote>
<ul>
<li>创建一个自动释放池</li>
</ul>
<p>在 <code>Objective-C</code> 框架中链接的应用程序通常必须在其<strong>每个线程中至少创建一个自动释放池</strong>。如果应用程序使用 <code>ARC</code>，则自动释放池将捕获从该线程自动释放的所有对象。</p>
<p>下面的代码演示了在 <code>MRC</code> 下需要在线程入口方法里面创建一个自动释放池</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)myThreadMainRoutine</span><br><span class="line">&#123;</span><br><span class="line">    NSAutoreleasePool *pool &#x3D; [[NSAutoreleasePool alloc] init]; &#x2F;&#x2F; Top-level pool</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Do thread work here.</span><br><span class="line"> </span><br><span class="line">    [pool release];  &#x2F;&#x2F; Release the objects in the pool.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为顶层的自动释放池直到线程退出之后才会释放对象，所以常驻线程需要创建一些额外的自动释放池来达到经常性的清理效果。例如，使用运行循环的线程可能每次通过该运行循环都会创建并释放一个自动释放池。频繁释放对象可以防止应用程序的内存占用过大，从而导致性能问题。 但是，与任何与性能相关的行为一样，你应该衡量代码的实际性能，并适当调整自动释放池的使用。</p>
<ul>
<li>设置异常处理</li>
</ul>
<p>如果在你的应用程序里面捕获并抛出了异常，那么在线程的入口方法中也需要做相应的处理，如果有抛出的异常在线程内部没有被捕获到将会导致程序的退出。你可以使用 <code>C++</code> 和 <code>OC</code> 风格的 <code>final-try&amp;catch</code> 代码块来处理。</p>
<ul>
<li>设置 RunLoop</li>
</ul>
<p>在子线程上执行任务的时候，有两种选择，一种是执行完之后线程会自动退出，一种是希望线程可以一直存活来处理任务。第一种方式不需要额外的操作，而第二种方式则需要 runloop 的配合。而 <code>iOS</code> 和 <code>macOS</code> 中的每个线程都有对应的 runloop 对象，<code>app</code> 的主线程启动之后，其对应的主运行循环也会自动开启，但是对于子线程来说，则需要手动开启。</p>
<h4 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h4><p>退出线程的建议方法是让其正常退出其入口方法。尽管 <code>Cocoa</code>，<code>POSIX</code> 和<code>Multiprocessing Services</code> 提供了直接杀死线程的例程，但是强烈建议不要使用此类例程。直接杀死线程会防止它自己清理掉从而导致线程分配的内存可能会泄漏，线程当前使用的任何其他资源可能无法正确清理，从而在以后产生潜在问题。</p>
<p>如果你预计需要在操作过程中终止线程，则应从一开始就设计线程以响应取消或退出消息。对于长时间运行的操作，这可能意味着要定期停止工作并检查是否收到此消息。如果确实有消息要求线程退出，则该线程将有机会执行所需的清理并正常退出；否则，它可以简单地返回工作并处理下一个数据块。</p>
<p>下面是通过 runloop 以及 threadDictionary 来实现定时检查是否要退出线程的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (void)threadMainRoutine</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 是否还有更多工作要做</span><br><span class="line">    BOOL moreWorkToDo &#x3D; YES;</span><br><span class="line">    &#x2F;&#x2F; 是否要退出线程</span><br><span class="line">    BOOL exitNow &#x3D; NO;</span><br><span class="line">    &#x2F;&#x2F; 获取当前线程对应的 runloop 对象</span><br><span class="line">    NSRunLoop* runLoop &#x3D; [NSRunLoop currentRunLoop];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 将 exitNow 存入 threadDictionary 中</span><br><span class="line">    NSMutableDictionary* threadDict &#x3D; [[NSThread currentThread] threadDictionary];</span><br><span class="line">    [threadDict setValue:[NSNumber numberWithBool:exitNow] forKey:@&quot;ThreadShouldExitNow&quot;];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 设置 runloop 的输入源</span><br><span class="line">    [self myInstallCustomInputSource];</span><br><span class="line"> </span><br><span class="line">    while (moreWorkToDo &amp;&amp; !exitNow)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 具体要做的工作</span><br><span class="line">        &#x2F;&#x2F; 完成时改变 moreWorkToDo 的值</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 让 runloop 跑起来，但如果没有要触发的输入源，则立即超时。</span><br><span class="line">        [runLoop runUntilDate:[NSDate date]];</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 检查输入源处理程序是否更改了 exitNow 值</span><br><span class="line">        exitNow &#x3D; [[threadDict valueForKey:@&quot;ThreadShouldExitNow&quot;] boolValue];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/05/17/iOS-%E5%BA%95%E5%B1%82-%E7%B1%BB%E6%8B%93%E5%B1%95%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/17/iOS-%E5%BA%95%E5%B1%82-%E7%B1%BB%E6%8B%93%E5%B1%95%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">iOS 底层 - 类拓展和关联对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-17 13:39:24 / 修改时间：14:02:24" itemprop="dateCreated datePublished" datetime="2021-05-17T13:39:24+08:00">2021-05-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jason</p>
  <div class="site-description" itemprop="description">个人技术博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
