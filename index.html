<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yujiusheng.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="个人技术博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Jason的博客">
<meta property="og:url" content="http://yujiusheng.com/index.html">
<meta property="og:site_name" content="Jason的博客">
<meta property="og:description" content="个人技术博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yujiusheng.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Jason的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jason的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/08/21/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-GCD-%E4%B8%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/21/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-GCD-%E4%B8%89/" class="post-title-link" itemprop="url">iOS多线程 - GCD(三)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-21 17:38:29" itemprop="dateCreated datePublished" datetime="2021-08-21T17:38:29+08:00">2021-08-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-23 23:19:34" itemprop="dateModified" datetime="2021-08-23T23:19:34+08:00">2021-08-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前两篇我们主要探索了<code>GCD</code>的函数和队列的调度及死锁和单例，本篇我们开始探索<code>GCD</code>的其他函数。</p>
<h3 id="栅栏函数"><a href="#栅栏函数" class="headerlink" title="栅栏函数"></a>栅栏函数</h3><p>栅栏函数最直接的作用是：控制任务执行顺序，同步</p>
<ul>
<li>dispatch_battier_async 前面的任务执行完毕才会来到这里。</li>
<li>dispatch_battier_sync 作用相同，但是会阻塞线程，影响后面的任务执行。 </li>
<li>栅栏函数只能控制同一并发队列。</li>
</ul>
<h4 id="栅栏函数的使用"><a href="#栅栏函数的使用" class="headerlink" title="栅栏函数的使用"></a>栅栏函数的使用</h4><p>我们一般会如下使用栅栏函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t concurrentQueue &#x3D; dispatch_queue_create(&quot;jason&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;123&quot;);</span><br><span class="line">&#125;); </span><br><span class="line">dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">    sleep(1);</span><br><span class="line">    NSLog(@&quot;456&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_barrier_async(concurrentQueue1, ^&#123;</span><br><span class="line">    NSLog(@&quot;----%@-----&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;789&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;10 11 12&quot;);</span><br></pre></td></tr></table></figure>

<p>我们打印结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">10</span> <span class="number">11</span> <span class="number">12</span></span><br><span class="line"><span class="number">456</span></span><br><span class="line">----&lt;NSThread: <span class="number">0x6000012ca180</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125;-----</span><br><span class="line"><span class="number">789</span></span><br></pre></td></tr></table></figure>

<p>可以看到栅栏函数阻塞了自己的<code>block</code>和后续异步函数的执行，也就是必须前面的函数执行之后才会执行后续操作。</p>
<p>我们换成同步栅栏函数再执行一次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_barrier_sync(concurrentQueue1, ^&#123;</span><br><span class="line">    NSLog(@&quot;----%@-----&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">456</span><br><span class="line">----&lt;NSThread: 0x6000025a4140&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;-----</span><br><span class="line">10 11 12</span><br><span class="line">789</span><br></pre></td></tr></table></figure>

<p>可以看到<code>dispatch_battier_sync</code>阻塞了<code>NSLog(@&quot;10 11 12&quot;);</code>代码的执行。</p>
<p>注意：还有一个点需要注意就是<code>栅栏函数</code>不能阻塞<code>全局并发队列</code>。</p>
<p>接下来我们从源码层面看<code>栅栏函数</code>的实现以及为什么全局并发队列不能被<code>栅栏函数</code>阻塞。</p>
<h4 id="栅栏函数底层原理"><a href="#栅栏函数底层原理" class="headerlink" title="栅栏函数底层原理"></a>栅栏函数底层原理</h4><p>我们还是以同步函数<code>dispatch_barrier_sync</code>为例探索</p>
<p>调试代码如图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fccfb4fa9b1f495aacd0d7731e726902~tplv-k3u1fbpfcp-watermark.image" alt="1629551309944"></p>
<p>调试代码有个点就是<code>sleep(30)</code>方便调试等待前面方法执行完成之前的调用。</p>
<p>我们从<code>libdispatch</code>源码中搜索<code>dispatch_barrier_sync</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_barrier_sync(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_block_t</span> work)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uintptr_t</span> dc_flags = DC_FLAG_BARRIER | DC_FLAG_BLOCK;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(_dispatch_block_has_private_data(work))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_block_with_privdata(dq, work, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_barrier_sync_f(dq, work, _dispatch_Block_invoke(work), dc_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了<code>_dispatch_barrier_sync_f</code>函数，继续跟进去：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_barrier_sync_f(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	_dispatch_barrier_sync_f_inline(dq, ctxt, func, dc_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>_dispatch_barrier_sync_f_inline</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_barrier_sync_f_inline(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_tid tid = _dispatch_tid_self();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(dx_metatype(dq) != _DISPATCH_LANE_TYPE)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(<span class="number">0</span>, <span class="string">"Queue type doesn't support dispatch_sync"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">dispatch_lane_t</span> dl = upcast(dq)._dl;</span><br><span class="line">	<span class="comment">// The more correct thing to do would be to merge the qos of the thread</span></span><br><span class="line">	<span class="comment">// that just acquired the barrier lock into the queue state.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// However this is too expensive for the fast path, so skip doing it.</span></span><br><span class="line">	<span class="comment">// The chosen tradeoff is that if an enqueue on a lower priority thread</span></span><br><span class="line">	<span class="comment">// contends with this fast path, this thread may receive a useless override.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Global concurrent queues and queues bound to non-dispatch threads</span></span><br><span class="line">	<span class="comment">// always fall into the slow case, see DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!_dispatch_queue_try_acquire_barrier_sync(dl, tid))) &#123;</span><br><span class="line">    <span class="comment">//经过断点调试执行了这里</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_f_slow(dl, ctxt, func, DC_FLAG_BARRIER, dl,</span><br><span class="line">				DC_FLAG_BARRIER | dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(dl-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_recurse(dl, ctxt, func,</span><br><span class="line">				DC_FLAG_BARRIER | dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_introspection_sync_begin(dl);</span><br><span class="line">	_dispatch_lane_barrier_sync_invoke_and_complete(dl, ctxt, func</span><br><span class="line">			DISPATCH_TRACE_ARG(_dispatch_trace_item_sync_push_pop(</span><br><span class="line">					dq, ctxt, func, dc_flags | DC_FLAG_BARRIER)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们加两个符号断点调试一下看看执行的是<code>_dispatch_sync_f_slow</code>还是<code>_dispatch_sync_recurse</code>,经过添加符号断点实际调用了<code>_dispatch_sync_f_slow</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_f_slow(<span class="keyword">dispatch_queue_class_t</span> top_dqu, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func, <span class="keyword">uintptr_t</span> top_dc_flags,</span><br><span class="line">		<span class="keyword">dispatch_queue_class_t</span> dqu, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> top_dq = top_dqu._dq;</span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> dq = dqu._dq;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!dq-&gt;do_targetq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_function_invoke(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pthread_priority_t</span> pp = _dispatch_get_priority();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_sync_context_s</span> <span class="title">dsc</span> = &#123;</span></span><br><span class="line">		.dc_flags    = DC_FLAG_SYNC_WAITER | dc_flags,</span><br><span class="line">		.dc_func     = _dispatch_async_and_wait_invoke,</span><br><span class="line">		.dc_ctxt     = &amp;dsc,</span><br><span class="line">		.dc_other    = top_dq,</span><br><span class="line">		.dc_priority = pp | _PTHREAD_PRIORITY_ENFORCE_FLAG,</span><br><span class="line">		.dc_voucher  = _voucher_get(),</span><br><span class="line">		.dsc_func    = func,</span><br><span class="line">		.dsc_ctxt    = ctxt,</span><br><span class="line">		.dsc_waiter  = _dispatch_tid_self(),</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	_dispatch_trace_item_push(top_dq, &amp;dsc);</span><br><span class="line">	__DISPATCH_WAIT_FOR_QUEUE__(&amp;dsc, dq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dsc.dsc_func == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">// dsc_func being cleared means that the block ran on another thread ie.</span></span><br><span class="line">		<span class="comment">// case (2) as listed in _dispatch_async_and_wait_f_slow.</span></span><br><span class="line">		<span class="keyword">dispatch_queue_t</span> stop_dq = dsc.dc_other;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_complete_recurse(top_dq, stop_dq, top_dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_introspection_sync_begin(top_dq);</span><br><span class="line">	_dispatch_trace_item_pop(top_dq, &amp;dsc);</span><br><span class="line">	_dispatch_sync_invoke_and_complete_recurse(top_dq, ctxt, func,top_dc_flags</span><br><span class="line">			DISPATCH_TRACE_ARG(&amp;dsc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_dispatch_sync_f_slow</code>函数我们比较熟悉了，在上一篇探索过，我们继续添加符号断点，</p>
<p><strong>这里有个细节</strong>，就是会先调用<code>__DISPATCH_WAIT_FOR_QUEUE__</code>等待<code>sleep(300);</code>的调用结束说明等待的过程是<code>__DISPATCH_WAIT_FOR_QUEUE__</code>处理，接着会调用到<code>dq_push</code>及<code>_dispatch_lane_concurrent_push</code>函数-&gt;<code>_dispatch_lane_push</code>-&gt;<code>_dispatch_lane_push_waiter</code>也就是阻塞了当前队列。</p>
<ul>
<li>自定义并发队列会执行<code>_dispatch_lane_wakeup</code>会有等待<code>barrier</code>的判断。</li>
<li>全局并发队列会执行<code>_dispatch_root_queue_wakeup</code>方法，所以不会有等待的方法,所以不会阻塞</li>
</ul>
<p>等待执行的队列完成之后会调用<code>_dispatch_lane_class_barrier_complete</code>函数-&gt;<code>dx_wakeup</code>-&gt;<code>_dispatch_lane_wakeup</code>-&gt;<code>_dispatch_queue_wakeup</code>。</p>
<p>这里会调用<code>_dispatch_client_callout</code>函数，然后同步函数就接着被执行了。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><h4 id="信号量的使用"><a href="#信号量的使用" class="headerlink" title="信号量的使用"></a>信号量的使用</h4><p>先看使用代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">dispatch_semaphore_t sem &#x3D; dispatch_semaphore_create(0);</span><br><span class="line"> &#x2F;&#x2F;任务1</span><br><span class="line"> dispatch_async(queue, ^&#123;</span><br><span class="line">     dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER); &#x2F;&#x2F; sem开始为0 需要等待等待</span><br><span class="line">     NSLog(@&quot;执行任务1&quot;);</span><br><span class="line">     NSLog(@&quot;任务1完成&quot;);</span><br><span class="line"> &#125;);</span><br><span class="line"> &#x2F;&#x2F;任务2</span><br><span class="line"> dispatch_async(queue, ^&#123;</span><br><span class="line">     sleep(2);</span><br><span class="line">     NSLog(@&quot;执行任务2&quot;);</span><br><span class="line">     NSLog(@&quot;任务2完成&quot;);</span><br><span class="line">     dispatch_semaphore_signal(sem); &#x2F;&#x2F; 发信号 sem+1</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<p>信号量主要有三个函数：</p>
<ul>
<li>dispatch_semaphore_create：创建信号量</li>
<li>dispatch_semaphore_wait：等待信号量</li>
<li>dispatch_semaphore_signal：信号量释放</li>
</ul>
<p>它可以控制<code>GCD</code>的最大并发数。</p>
<h4 id="信号量的底层原理"><a href="#信号量的底层原理" class="headerlink" title="信号量的底层原理"></a>信号量的底层原理</h4><p>底层原理其实就是三个方法的探索，我们依次探索</p>
<h5 id="dispatch-semaphore-wait"><a href="#dispatch-semaphore-wait" class="headerlink" title="dispatch_semaphore_wait"></a>dispatch_semaphore_wait</h5><p>全局搜索<code>dispatch_semaphore_wait</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">intptr_t</span></span><br><span class="line">dispatch_semaphore_wait(<span class="keyword">dispatch_semaphore_t</span> dsema, <span class="keyword">dispatch_time_t</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//--1</span></span><br><span class="line">	<span class="keyword">long</span> value = os_atomic_dec2o(dsema, dsema_value, acquire);</span><br><span class="line">	<span class="keyword">if</span> (likely(value &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_semaphore_wait_slow(dsema, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面的例子我们创建的信号量为0，经过–操作&lt;0，会执行<code>_dispatch_semaphore_wait_slow</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">intptr_t</span></span><br><span class="line">_dispatch_semaphore_wait_slow(<span class="keyword">dispatch_semaphore_t</span> dsema,</span><br><span class="line">		<span class="keyword">dispatch_time_t</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">long</span> orig;</span><br><span class="line"></span><br><span class="line">	_dispatch_sema4_create(&amp;dsema-&gt;dsema_sema, _DSEMA4_POLICY_FIFO);</span><br><span class="line">	<span class="keyword">switch</span> (timeout) &#123;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">if</span> (!_dispatch_sema4_timedwait(&amp;dsema-&gt;dsema_sema, timeout)) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Fall through and try to undo what the fast path did to</span></span><br><span class="line">		<span class="comment">// dsema-&gt;dsema_value</span></span><br><span class="line">	<span class="keyword">case</span> DISPATCH_TIME_NOW:</span><br><span class="line">    <span class="comment">//超时操作</span></span><br><span class="line">		orig = dsema-&gt;dsema_value;</span><br><span class="line">		<span class="keyword">while</span> (orig &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (os_atomic_cmpxchgv2o(dsema, dsema_value, orig, orig + <span class="number">1</span>,</span><br><span class="line">					&amp;orig, relaxed)) &#123;</span><br><span class="line">				<span class="keyword">return</span> _DSEMA4_TIMEOUT();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Another thread called semaphore_signal().</span></span><br><span class="line">		<span class="comment">// Fall through and drain the wakeup.</span></span><br><span class="line">	<span class="keyword">case</span> DISPATCH_TIME_FOREVER:</span><br><span class="line">     <span class="comment">//一直等待</span></span><br><span class="line">		_dispatch_sema4_wait(&amp;dsema-&gt;dsema_sema);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见等待的函数是<code>_dispatch_sema4_wait</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_sema4_wait(<span class="keyword">_dispatch_sema4_t</span> *sema)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		ret = sem_wait(sema);</span><br><span class="line">	&#125; <span class="keyword">while</span> (ret == <span class="number">-1</span> &amp;&amp; errno == EINTR);</span><br><span class="line">	DISPATCH_SEMAPHORE_VERIFY_RET(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sem_wait</code>是c语言的方法，这里是一个do-while循环事宜等待信号量的值满足条件。</p>
<p>#####dispatch_semaphore_signal</p>
<p>全局搜索<code>dispatch_semaphore_signal</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">intptr_t</span></span><br><span class="line">dispatch_semaphore_signal(<span class="keyword">dispatch_semaphore_t</span> dsema)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//++1</span></span><br><span class="line">	<span class="keyword">long</span> value = os_atomic_inc2o(dsema, dsema_value, <span class="built_in">release</span>);</span><br><span class="line">	<span class="keyword">if</span> (likely(value &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(value == LONG_MIN)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(value,</span><br><span class="line">				<span class="string">"Unbalanced call to dispatch_semaphore_signal()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_semaphore_signal_slow(dsema);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里信号量++一次，如果信号量&gt;0就可以正常执行了，如果信号量还是&lt;=0,会进入函数<code>_dispatch_semaphore_signal_slow</code>,它是异常的处理一直++信号量的值，直到返回的值为正值。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li><code>dispatch_semaphore_create</code>:初始化信号量。</li>
<li><code>dispatch_semaphore_wait</code>：对信号量的value–</li>
<li><code>dispatch_semaphore_signal</code>对信号量的value++</li>
</ul>
<h3 id="调度组"><a href="#调度组" class="headerlink" title="调度组"></a>调度组</h3><p>####调度组的使用</p>
<p>有时候我们可能需要等待多个接口都返回数据才能进行下一步的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group &#x3D; dispatch_group_create();</span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">      &#x2F;&#x2F;下载任务1</span><br><span class="line">      sleep(2);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">      &#x2F;&#x2F;下载任务2</span><br><span class="line">      sleep(2);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line"> 			&#x2F;&#x2F;组里任务都执行之后，下一步的操作。	</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group &#x3D; dispatch_group_create();</span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">      &#x2F;&#x2F;下载任务1</span><br><span class="line">      sleep(2);</span><br><span class="line">      dispatch_group_leave(group);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">      &#x2F;&#x2F;下载任务2</span><br><span class="line">      sleep(2);</span><br><span class="line">      dispatch_group_leave(group);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line"> 			&#x2F;&#x2F;组里任务都执行之后，下一步的操作。	</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="调度组底层原理"><a href="#调度组底层原理" class="headerlink" title="调度组底层原理"></a>调度组底层原理</h4><p>我们从三个方面分析，组是如何控制同步的、<code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>的搭配、<code>dispatch_group_async</code>的原理。</p>
<h5 id="dispatch-group-create函数"><a href="#dispatch-group-create函数" class="headerlink" title="dispatch_group_create函数"></a>dispatch_group_create函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t</span><br><span class="line">dispatch_group_create(void)</span><br><span class="line">&#123;</span><br><span class="line">	return _dispatch_group_create_with_count(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是创建了一个组的数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_group_t</span></span><br><span class="line">_dispatch_group_create_with_count(<span class="keyword">uint32_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">dispatch_group_t</span> dg = _dispatch_object_alloc(DISPATCH_VTABLE(group),</span><br><span class="line">			<span class="keyword">sizeof</span>(struct dispatch_group_s));</span><br><span class="line">	dg-&gt;do_next = DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">	dg-&gt;do_targetq = _dispatch_get_default_queue(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (n) &#123;</span><br><span class="line">		os_atomic_store2o(dg, dg_bits,</span><br><span class="line">				(<span class="keyword">uint32_t</span>)-n * DISPATCH_GROUP_VALUE_INTERVAL, relaxed);</span><br><span class="line">		os_atomic_store2o(dg, do_ref_cnt, <span class="number">1</span>, relaxed); <span class="comment">// &lt;rdar://22318411&gt;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="dispatch-group-enter函数"><a href="#dispatch-group-enter函数" class="headerlink" title="dispatch_group_enter函数"></a>dispatch_group_enter函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_enter(<span class="keyword">dispatch_group_t</span> dg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// The value is decremented on a 32bits wide atomic so that the carry</span></span><br><span class="line">	<span class="comment">// for the 0 -&gt; -1 transition is not propagated to the upper 32bits.</span></span><br><span class="line">  <span class="comment">/// --操作</span></span><br><span class="line">	<span class="keyword">uint32_t</span> old_bits = os_atomic_sub_orig2o(dg, dg_bits,</span><br><span class="line">			DISPATCH_GROUP_VALUE_INTERVAL, acquire);</span><br><span class="line">	<span class="keyword">uint32_t</span> old_value = old_bits &amp; DISPATCH_GROUP_VALUE_MASK;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(old_value == <span class="number">0</span>)) &#123;</span><br><span class="line">		_dispatch_retain(dg); <span class="comment">// &lt;rdar://problem/22318411&gt;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(old_value == DISPATCH_GROUP_VALUE_MAX)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(old_bits,</span><br><span class="line">				<span class="string">"Too many nested calls to dispatch_group_enter()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开始count == 0，进行–操作，变为-1， </p>
<h5 id="dispatch-group-leave函数"><a href="#dispatch-group-leave函数" class="headerlink" title="dispatch_group_leave函数"></a>dispatch_group_leave函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_leave(<span class="keyword">dispatch_group_t</span> dg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// The value is incremented on a 64bits wide atomic so that the carry for</span></span><br><span class="line">	<span class="comment">// the -1 -&gt; 0 transition increments the generation atomically.</span></span><br><span class="line">	<span class="keyword">uint64_t</span> new_state, old_state = os_atomic_add_orig2o(dg, dg_state,</span><br><span class="line">			DISPATCH_GROUP_VALUE_INTERVAL, <span class="built_in">release</span>);</span><br><span class="line">	<span class="keyword">uint32_t</span> old_value = (<span class="keyword">uint32_t</span>)(old_state &amp; DISPATCH_GROUP_VALUE_MASK);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(old_value == DISPATCH_GROUP_VALUE_1)) &#123;<span class="comment">//old_state == -1</span></span><br><span class="line">		old_state += DISPATCH_GROUP_VALUE_INTERVAL;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			new_state = old_state;</span><br><span class="line">			<span class="keyword">if</span> ((old_state &amp; DISPATCH_GROUP_VALUE_MASK) == <span class="number">0</span>) &#123;</span><br><span class="line">				new_state &amp;= ~DISPATCH_GROUP_HAS_WAITERS;</span><br><span class="line">				new_state &amp;= ~DISPATCH_GROUP_HAS_NOTIFS;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// If the group was entered again since the atomic_add above,</span></span><br><span class="line">				<span class="comment">// we can't clear the waiters bit anymore as we don't know for</span></span><br><span class="line">				<span class="comment">// which generation the waiters are for</span></span><br><span class="line">				new_state &amp;= ~DISPATCH_GROUP_HAS_NOTIFS;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (old_state == new_state) <span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">while</span> (unlikely(!os_atomic_cmpxchgv2o(dg, dg_state,</span><br><span class="line">				old_state, new_state, &amp;old_state, relaxed)));</span><br><span class="line">		<span class="keyword">return</span> _dispatch_group_wake(dg, old_state, <span class="literal">true</span>);<span class="comment">///唤醒 notify</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(old_value == <span class="number">0</span>)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH((<span class="keyword">uintptr_t</span>)old_value,</span><br><span class="line">				<span class="string">"Unbalanced call to dispatch_group_leave()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>count由-1变为0，可以看出<code>old_state != new_state</code>时会一直<code>while</code>循环，当相等是执行<code>_dispatch_group_wake</code>唤醒阻塞的函数。</p>
<p>#####dispatch_group_notify</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_group_notify(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq,</span><br><span class="line">		<span class="keyword">dispatch_continuation_t</span> dsn)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> old_state, new_state;</span><br><span class="line">	<span class="keyword">dispatch_continuation_t</span> prev;</span><br><span class="line"></span><br><span class="line">	dsn-&gt;dc_data = dq;</span><br><span class="line">	_dispatch_retain(dq);</span><br><span class="line"></span><br><span class="line">	prev = os_mpsc_push_update_tail(os_mpsc(dg, dg_notify), dsn, do_next);</span><br><span class="line">	<span class="keyword">if</span> (os_mpsc_push_was_empty(prev)) _dispatch_retain(dg);</span><br><span class="line">	os_mpsc_push_update_prev(os_mpsc(dg, dg_notify), prev, dsn, do_next);</span><br><span class="line">	<span class="keyword">if</span> (os_mpsc_push_was_empty(prev)) &#123;</span><br><span class="line">		os_atomic_rmw_loop2o(dg, dg_state, old_state, new_state, <span class="built_in">release</span>, &#123;</span><br><span class="line">			new_state = old_state | DISPATCH_GROUP_HAS_NOTIFS;</span><br><span class="line">			<span class="keyword">if</span> ((<span class="keyword">uint32_t</span>)old_state == <span class="number">0</span>) &#123;</span><br><span class="line">				os_atomic_rmw_loop_give_up(&#123;<span class="comment">/// block callout函数</span></span><br><span class="line">					<span class="keyword">return</span> _dispatch_group_wake(dg, new_state, <span class="literal">false</span>);</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 可以看到<code>old_state == 0</code>的时候才会执行block，也就是<code>dispatch_group_leave</code>执行完成。</p>
<h5 id="dispatch-group-async"><a href="#dispatch-group-async" class="headerlink" title="dispatch_group_async"></a>dispatch_group_async</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_async(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq,</span><br><span class="line">		<span class="keyword">dispatch_block_t</span> db)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//任务封装</span></span><br><span class="line">	<span class="keyword">dispatch_continuation_t</span> dc = _dispatch_continuation_alloc();</span><br><span class="line">	<span class="keyword">uintptr_t</span> dc_flags = DC_FLAG_CONSUME | DC_FLAG_GROUP_ASYNC;</span><br><span class="line">	<span class="keyword">dispatch_qos_t</span> qos;</span><br><span class="line">	qos = _dispatch_continuation_init(dc, dq, db, <span class="number">0</span>, dc_flags);</span><br><span class="line">	_dispatch_continuation_group_async(dg, dq, dc, qos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_continuation_group_async(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq,</span><br><span class="line">		<span class="keyword">dispatch_continuation_t</span> dc, <span class="keyword">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_group_enter(dg);<span class="comment">//执行了enter</span></span><br><span class="line">	dc-&gt;dc_data = dg;</span><br><span class="line">	_dispatch_continuation_async(dq, dc, qos, dc-&gt;dc_flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_continuation_async(<span class="keyword">dispatch_queue_class_t</span> dqu,</span><br><span class="line">		<span class="keyword">dispatch_continuation_t</span> dc, <span class="keyword">dispatch_qos_t</span> qos, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_INTROSPECTION</span></span><br><span class="line">	<span class="keyword">if</span> (!(dc_flags &amp; DC_FLAG_NO_INTROSPECTION)) &#123;</span><br><span class="line">		_dispatch_trace_item_push(dqu, dc);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	(<span class="keyword">void</span>)dc_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> dx_push(dqu._dq, dc, qos);<span class="comment">//调用的函数 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里在<code>_dispatch_continuation_group_async</code>函数调用了<code>dispatch_group_enter</code>函数，然后再<code>dx_push</code>之后也就是callout函数之后执行了<code>dispatch_group_leave</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_continuation_with_group_invoke(<span class="keyword">dispatch_continuation_t</span> dc)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">dou</span> = <span class="title">dc</span>-&gt;<span class="title">dc_data</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> type = dx_type(dou);</span><br><span class="line">	<span class="keyword">if</span> (type == DISPATCH_GROUP_TYPE) &#123;</span><br><span class="line">		_dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);</span><br><span class="line">		_dispatch_trace_item_complete(dc);</span><br><span class="line">    <span class="comment">///执行了leave方法</span></span><br><span class="line">		dispatch_group_leave((<span class="keyword">dispatch_group_t</span>)dou);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		DISPATCH_INTERNAL_CRASH(dx_type(dou), <span class="string">"Unexpected object type"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul>
<li><code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>成对出现</li>
<li><code>dispatch_group_enter</code>底层对group的value做–操作（0-&gt;1）</li>
<li><code>dispatch_group_leave</code>底层对group的value做++操作（-1-&gt;0）</li>
<li><code>dispatch_group_notify</code>底层判断group的state是否为0，为0就通知执行block。</li>
<li>任务唤醒有两种方式：1、<code>dispatch_group_leave</code>2、<code>dispatch_group_notify</code></li>
<li><code>dispatch_group_async</code>等同于 <code>enter+leave</code>，底层实现包含一对enter+leave。</li>
</ul>
<p>###dispatch_source</p>
<p>dispatch_source我们平时会使用到的场景是一个计时器(倒计时)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (void)timeDone&#123;</span><br><span class="line">    &#x2F;&#x2F;倒计时时间</span><br><span class="line">    __block int timeout &#x3D; 3;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;创建队列</span><br><span class="line">    dispatch_queue_t globalQueue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;创建timer</span><br><span class="line">    dispatch_source_t timer &#x3D; dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, globalQueue);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;设置1s触发一次，0s的误差</span><br><span class="line">    &#x2F;*</span><br><span class="line">     - source 分派源</span><br><span class="line">     - start 数控制计时器第一次触发的时刻。参数类型是 dispatch_time_t，这是一个opaque类型，我们不能直接操作它。我们得需要 dispatch_time 和 dispatch_walltime 函数来创建它们。另外，常量 DISPATCH_TIME_NOW 和 DISPATCH_TIME_FOREVER 通常很有用。</span><br><span class="line">     - interval 间隔时间</span><br><span class="line">     - leeway 计时器触发的精准程度</span><br><span class="line">     *&#x2F;</span><br><span class="line">    dispatch_source_set_timer(timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0);</span><br><span class="line">    </span><br><span class="line">     &#x2F;&#x2F;触发的事件</span><br><span class="line">    dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">        &#x2F;&#x2F;倒计时结束，关闭</span><br><span class="line">        if (timeout &lt;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F;取消dispatch源</span><br><span class="line">            dispatch_source_cancel(timer);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            timeout--;</span><br><span class="line">            </span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                &#x2F;&#x2F;更新主界面的操作</span><br><span class="line">                NSLog(@&quot;倒计时 - %d&quot;, timeout);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F;开始执行dispatch源</span><br><span class="line">    dispatch_resume(timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/08/14/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-GCD-%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/14/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-GCD-%E4%BA%8C/" class="post-title-link" itemprop="url">iOS多线程-GCD(二)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-14 19:29:50" itemprop="dateCreated datePublished" datetime="2021-08-14T19:29:50+08:00">2021-08-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-23 23:16:42" itemprop="dateModified" datetime="2021-08-23T23:16:42+08:00">2021-08-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一篇我们主要探索了GCD的主队列及<code>串行队列</code>与<code>并发队列</code>在源码上的区分，以及同步函数的调用时机。本节我们主要探索同步函数与异步函数的区别：</p>
<ul>
<li>同步函数死锁分析</li>
<li>任务回调是否具有同步性、异步性</li>
<li><code>dispatch_once</code>底层的分析</li>
</ul>
<p>我们先从同步函数开始探索。</p>
<h3 id="同步函数死锁分析"><a href="#同步函数死锁分析" class="headerlink" title="同步函数死锁分析"></a>同步函数死锁分析</h3><p><code>libdispatch</code>源码中全局搜索<code>dispatch_sync</code>,找到方法的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_sync(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_block_t</span> work)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uintptr_t</span> dc_flags = DC_FLAG_BLOCK;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(_dispatch_block_has_private_data(work))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_block_with_privdata(dq, work, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_sync_f(dq, work, _dispatch_Block_invoke(work), dc_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟进方法<code>_dispatch_sync_f</code>实际调用<code>_dispatch_sync_f_inline</code>方法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_f_inline(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (likely(dq-&gt;dq_width == <span class="number">1</span>)) &#123;<span class="comment">//串行队列</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_barrier_sync_f(dq, ctxt, func, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(dx_metatype(dq) != _DISPATCH_LANE_TYPE)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(<span class="number">0</span>, <span class="string">"Queue type doesn't support dispatch_sync"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">dispatch_lane_t</span> dl = upcast(dq)._dl;</span><br><span class="line">	<span class="comment">// Global concurrent queues and queues bound to non-dispatch threads</span></span><br><span class="line">	<span class="comment">// always fall into the slow case, see DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!_dispatch_queue_try_reserve_sync_width(dl))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_f_slow(dl, ctxt, func, <span class="number">0</span>, dl, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_recurse(dl, ctxt, func, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_introspection_sync_begin(dl);</span><br><span class="line">	_dispatch_sync_invoke_and_complete(dl, ctxt, func DISPATCH_TRACE_ARG(</span><br><span class="line">			_dispatch_trace_item_sync_push_pop(dq, ctxt, func, dc_flags)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>串行队列调用了<code>_dispatch_barrier_sync_f</code>方法，最终调用到<code>_dispatch_barrier_sync_f_inline</code>方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_barrier_sync_f_inline(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_tid tid = _dispatch_tid_self();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(dx_metatype(dq) != _DISPATCH_LANE_TYPE)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(<span class="number">0</span>, <span class="string">"Queue type doesn't support dispatch_sync"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">dispatch_lane_t</span> dl = upcast(dq)._dl;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!_dispatch_queue_try_acquire_barrier_sync(dl, tid))) &#123;</span><br><span class="line">    <span class="comment">//死锁的是否会有_dispatch_sync_f_slow异常</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_f_slow(dl, ctxt, func, DC_FLAG_BARRIER, dl,</span><br><span class="line">				DC_FLAG_BARRIER | dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(dl-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_recurse(dl, ctxt, func,</span><br><span class="line">				DC_FLAG_BARRIER | dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_introspection_sync_begin(dl);</span><br><span class="line">	_dispatch_lane_barrier_sync_invoke_and_complete(dl, ctxt, func</span><br><span class="line">			DISPATCH_TRACE_ARG(_dispatch_trace_item_sync_push_pop(</span><br><span class="line">					dq, ctxt, func, dc_flags | DC_FLAG_BARRIER)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有多个调用的方法，我们自定义一种死锁的情况看调用堆栈的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;jason&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">  NSLog(@&quot;1&quot;);</span><br><span class="line">  dispatch_async(queue, ^&#123;</span><br><span class="line">      NSLog(@&quot;2&quot;);</span><br><span class="line">      dispatch_sync(queue, ^&#123;</span><br><span class="line">          NSLog(@&quot;3&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">      NSLog(@&quot;4&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;5&quot;);</span><br></pre></td></tr></table></figure>

<p>执行代码查看调用栈：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2597a32d39214293867da9b9fdf34478~tplv-k3u1fbpfcp-watermark.image" alt="死锁"></p>
<p>可以看到调用了<code>_dispatch_sync_f_slow</code>方法，然后调用了<code>__DISPATCH_WAIT_FOR_QUEUE__</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">__DISPATCH_WAIT_FOR_QUEUE__(<span class="keyword">dispatch_sync_context_t</span> dsc, <span class="keyword">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> dq_state = _dispatch_wait_prepare(dq);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(_dq_state_drain_locked_by(dq_state, dsc-&gt;dsc_waiter))) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH((<span class="keyword">uintptr_t</span>)dq_state,</span><br><span class="line">				<span class="string">"dispatch_sync called on queue "</span></span><br><span class="line">				<span class="string">"already owned by current thread"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">///省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里的crash信息和我们写的例子中最终的错误是一致的</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc3fa6cbe00e413dad18c53505a064e2~tplv-k3u1fbpfcp-watermark.image" alt="死锁2"></p>
<p>说明<code>_dq_state_drain_locked_by</code>判断的条件是产生死锁的原因，这个函数调用了<code>_dispatch_lock_is_locked_by</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">_dispatch_lock_is_locked_by(dispatch_lock lock_value, dispatch_tid tid)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// equivalent to _dispatch_lock_owner(lock_value) == tid</span></span><br><span class="line">	<span class="keyword">return</span> ((lock_value ^ tid) &amp; DLOCK_OWNER_MASK) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLOCK_OWNER_MASK			((dispatch_lock)0xfffffffc)</span></span><br></pre></td></tr></table></figure>

<p><code>DLOCK_OWNER_MASK</code>是一个很大的值，说明<code>lock_value ^ tid</code>为0，也就是<code>tid=lock_value</code>，看上面的注释也是这个意思，即当前的等待的线程与现在执行的线程是同一个。</p>
<h3 id="同步函数的回调"><a href="#同步函数的回调" class="headerlink" title="同步函数的回调"></a>同步函数的回调</h3><p>我们建立一个全局并发队列探索</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t concurrentQueue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">dispatch_sync(concurrentQueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;函数调用了....&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们回到<code>_dispatch_sync_f_inline</code>函数，然后打符号断点看执行了哪个方法</p>
<ul>
<li>_dispatch_sync_f_slow</li>
<li>_dispatch_sync_recurse</li>
<li>_dispatch_introspection_sync_begin</li>
<li>_dispatch_sync_invoke_and_complete</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf76ebde132c467e97f7c64de9a78302~tplv-k3u1fbpfcp-watermark.image" alt="同步函数并发队列探索"></p>
<p>断点调用到了<code>_dispatch_sync_f_slow</code>函数，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_f_slow(<span class="keyword">dispatch_queue_class_t</span> top_dqu, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func, <span class="keyword">uintptr_t</span> top_dc_flags,</span><br><span class="line">		<span class="keyword">dispatch_queue_class_t</span> dqu, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> top_dq = top_dqu._dq;</span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> dq = dqu._dq;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!dq-&gt;do_targetq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_function_invoke(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pthread_priority_t</span> pp = _dispatch_get_priority();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_sync_context_s</span> <span class="title">dsc</span> = &#123;</span></span><br><span class="line">		.dc_flags    = DC_FLAG_SYNC_WAITER | dc_flags,</span><br><span class="line">		.dc_func     = _dispatch_async_and_wait_invoke,</span><br><span class="line">		.dc_ctxt     = &amp;dsc,</span><br><span class="line">		.dc_other    = top_dq,</span><br><span class="line">		.dc_priority = pp | _PTHREAD_PRIORITY_ENFORCE_FLAG,</span><br><span class="line">		.dc_voucher  = _voucher_get(),</span><br><span class="line">		.dsc_func    = func,</span><br><span class="line">		.dsc_ctxt    = ctxt,</span><br><span class="line">		.dsc_waiter  = _dispatch_tid_self(),</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	_dispatch_trace_item_push(top_dq, &amp;dsc);</span><br><span class="line">	__DISPATCH_WAIT_FOR_QUEUE__(&amp;dsc, dq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dsc.dsc_func == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">// dsc_func being cleared means that the block ran on another thread ie.</span></span><br><span class="line">		<span class="comment">// case (2) as listed in _dispatch_async_and_wait_f_slow.</span></span><br><span class="line">		<span class="keyword">dispatch_queue_t</span> stop_dq = dsc.dc_other;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_complete_recurse(top_dq, stop_dq, top_dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_introspection_sync_begin(top_dq);</span><br><span class="line">	_dispatch_trace_item_pop(top_dq, &amp;dsc);</span><br><span class="line">	_dispatch_sync_invoke_and_complete_recurse(top_dq, ctxt, func,top_dc_flags</span><br><span class="line">			DISPATCH_TRACE_ARG(&amp;dsc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们继续加符号断点跟踪<code>_dispatch_trace_item_push</code>、<code>_dispatch_sync_complete_recurse</code>、<code>_dispatch_trace_item_pop</code>、<code>_dispatch_sync_invoke_and_complete_recurse</code>、<code>_dispatch_sync_function_invoke</code></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2ab368e89ac49a18c4d3c5f42865c88~tplv-k3u1fbpfcp-watermark.image" alt="同步函数并发队列"></p>
<p>说明执行了<code>_dispatch_sync_function_invoke</code>函数，注意<code>dq-&gt;do_targetq</code>系统队列为空，因为我们使用的是全局并发队列，所以执行到了这里。</p>
<p>继续看<code>_dispatch_sync_function_invoke</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_function_invoke(<span class="keyword">dispatch_queue_class_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">	_dispatch_sync_function_invoke_inline(dq, ctxt, func);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_function_invoke_inline(<span class="keyword">dispatch_queue_class_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_thread_frame_s dtf;</span><br><span class="line">	_dispatch_thread_frame_push(&amp;dtf, dq);</span><br><span class="line">	_dispatch_client_callout(ctxt, func);</span><br><span class="line">	_dispatch_perfmon_workitem_inc();</span><br><span class="line">	_dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里执行了<code>_dispatch_client_callout</code>函数，也就调用了<code>回调函数</code>。</p>
<h3 id="异步函数回调"><a href="#异步函数回调" class="headerlink" title="异步函数回调"></a>异步函数回调</h3><p>同样，我们也用符号断点的方式探究：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t concurrentQueue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;函数调用了....&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>全局搜索<code>dispatch_async</code>其调用了<code>_dispatch_continuation_async</code>函数，然后调用<code>dx_push</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_push(x, y, z) dx_vtable(x)-&gt;dq_push(x, y, z)</span></span><br></pre></td></tr></table></figure>

<p>最后调用了<code>dq_push</code>,<code>dq_push</code>根据队列类型的不同而调用，我们看并发队列的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_concurrent, lane,</span><br><span class="line">	.do_type        = DISPATCH_QUEUE_CONCURRENT_TYPE,</span><br><span class="line">	.do_dispose     = _dispatch_lane_dispose,</span><br><span class="line">	.do_debug       = _dispatch_queue_debug,</span><br><span class="line">	.do_invoke      = _dispatch_lane_invoke,</span><br><span class="line"></span><br><span class="line">	.dq_activate    = _dispatch_lane_activate,</span><br><span class="line">	.dq_wakeup      = _dispatch_lane_wakeup,</span><br><span class="line">	.dq_push        = _dispatch_lane_concurrent_push,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>搜索<code>_dispatch_lane_concurrent_push</code>的实现实际调用了<code>_dispatch_lane_push</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_lane_push(<span class="keyword">dispatch_lane_t</span> dq, <span class="keyword">dispatch_object_t</span> dou,</span><br><span class="line">		<span class="keyword">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">dispatch_wakeup_flags_t</span> flags = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(_dispatch_object_is_waiter(dou))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_lane_push_waiter(dq, dou._dsc, qos);</span><br><span class="line">	&#125;</span><br><span class="line">	dispatch_assert(!_dispatch_object_is_global(dq));</span><br><span class="line">	qos = _dispatch_queue_push_qos(dq, qos);</span><br><span class="line"></span><br><span class="line">	prev = os_mpsc_push_update_tail(os_mpsc(dq, dq_items), dou._do, do_next);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(os_mpsc_push_was_empty(prev))) &#123;</span><br><span class="line">		_dispatch_retain_2_unsafe(dq);</span><br><span class="line">		flags = DISPATCH_WAKEUP_CONSUME_2 | DISPATCH_WAKEUP_MAKE_DIRTY;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(_dispatch_queue_need_override(dq, qos))) &#123;</span><br><span class="line">		_dispatch_retain_2_unsafe(dq);</span><br><span class="line">		flags = DISPATCH_WAKEUP_CONSUME_2;</span><br><span class="line">	&#125;</span><br><span class="line">	os_mpsc_push_update_prev(os_mpsc(dq, dq_items), prev, dou._do, do_next);</span><br><span class="line">	<span class="keyword">if</span> (flags) &#123;</span><br><span class="line">		<span class="keyword">return</span> dx_wakeup(dq, qos, flags);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们添加符号断点<code>_dispatch_lane_push_waiter</code>、<code>_dispatch_queue_push_qos</code>、<code>os_mpsc_push_update_prev</code>、<code>dx_wakeup</code>。调用的是<code>dx_wakeup</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_wakeup(x, y, z) dx_vtable(x)-&gt;dq_wakeup(x, y, z)</span></span><br></pre></td></tr></table></figure>

<p>实际是对<code>dq_wakeup</code>的封装，依然我们找并发队列：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_concurrent, lane,</span><br><span class="line">	.do_type        = DISPATCH_QUEUE_CONCURRENT_TYPE,</span><br><span class="line">	.do_dispose     = _dispatch_lane_dispose,</span><br><span class="line">	.do_debug       = _dispatch_queue_debug,</span><br><span class="line">	.do_invoke      = _dispatch_lane_invoke,</span><br><span class="line"></span><br><span class="line">	.dq_activate    = _dispatch_lane_activate,</span><br><span class="line">	.dq_wakeup      = _dispatch_lane_wakeup,</span><br><span class="line">	.dq_push        = _dispatch_lane_concurrent_push,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><code>_dispatch_lane_wakeup</code>调用的<code>_dispatch_queue_wakeup</code>,同样也是把<code>_dispatch_queue_wakeup</code>调用的<code>return</code>的方法添加符号断点，会调用<code>_dispatch_queue_wakeup</code>-&gt;<code>_dispatch_lane_push</code>,执行到<code>_dispatch_root_queue_drain</code></p>
<h3 id="dispatch-once函数底层实现"><a href="#dispatch-once函数底层实现" class="headerlink" title="dispatch_once函数底层实现"></a>dispatch_once函数底层实现</h3><p>我们平时定义一个单例对象的时候一般都会使用<code>dispatch_once</code>函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    NSLog(@&quot;once&quot;)  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们在<code>libdispatch</code>中搜索<code>dispatch_once</code>看其底层实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_once(<span class="keyword">dispatch_once_t</span> *val, <span class="keyword">dispatch_block_t</span> block)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_once_f(val, block, _dispatch_Block_invoke(block));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>val</code>是<code>dispatch_once_t</code>类型。继续跟进<code>dispatch_once_f</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_once_f(<span class="keyword">dispatch_once_t</span> *val, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//gate</span></span><br><span class="line">	<span class="keyword">dispatch_once_gate_t</span> l = (<span class="keyword">dispatch_once_gate_t</span>)val;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !DISPATCH_ONCE_INLINE_FASTPATH || DISPATCH_ONCE_USE_QUIESCENT_COUNTER</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> v = os_atomic_load(&amp;l-&gt;dgo_once, acquire);</span><br><span class="line">	<span class="keyword">if</span> (likely(v == DLOCK_ONCE_DONE)) &#123;<span class="comment">//第一次会标示为done return</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_ONCE_USE_QUIESCENT_COUNTER</span></span><br><span class="line">	<span class="keyword">if</span> (likely(DISPATCH_ONCE_IS_GEN(v))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_once_mark_done_if_quiesced(l, v);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="comment">///第一次调用</span></span><br><span class="line">	<span class="keyword">if</span> (_dispatch_once_gate_tryenter(l)) &#123;<span class="comment">//锁 说明单例是线程安全的</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_once_callout(l, ctxt, func);<span class="comment">//执行任务</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_once_wait(l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">_dispatch_once_gate_tryenter(<span class="keyword">dispatch_once_gate_t</span> l)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> os_atomic_cmpxchg(&amp;l-&gt;dgo_once, DLOCK_ONCE_UNLOCKED,</span><br><span class="line">			(<span class="keyword">uintptr_t</span>)_dispatch_lock_value_for_self(), relaxed);</span><br><span class="line">&#125;</span><br><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_once_callout(<span class="keyword">dispatch_once_gate_t</span> l, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">///执行任务</span></span><br><span class="line">	_dispatch_client_callout(ctxt, func);</span><br><span class="line">  <span class="comment">///广播关门处理</span></span><br><span class="line">	_dispatch_once_gate_broadcast(l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_once_gate_broadcast(<span class="keyword">dispatch_once_gate_t</span> l)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_lock value_self = _dispatch_lock_value_for_self();</span><br><span class="line">	<span class="keyword">uintptr_t</span> v;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_ONCE_USE_QUIESCENT_COUNTER</span></span><br><span class="line">	v = _dispatch_once_mark_quiescing(l);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	v = _dispatch_once_mark_done(l);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (likely((dispatch_lock)v == value_self)) <span class="keyword">return</span>;</span><br><span class="line">	_dispatch_gate_broadcast_slow(&amp;l-&gt;dgo_gate, (dispatch_lock)v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li><p>只执行一次原理：<code>onceToken</code>是静态变量，具有唯一性，在底层被封装成了<code>dispatch_once_gate_t</code>类型的<code>变量l</code>，<code>l</code>主要是用来获取底层原子封装性的关联，即<code>变量v</code>，通过v来查询任务的状态，如果此时v等于<code>DLOCK_ONCE_DONE</code>，说明任务已经处理过一次了，直接`return</p>
</li>
<li><p>block调用的时机：如果此时任务没有执行过，将<code>任务进行加锁</code>，即任务状态置为<code>DLOCK_ONCE_UNLOCK</code>，目的是为了<code>保证当前任务执行的唯一性</code>，防止在其他地方有多次定义。加锁之后<code>进行block回调函数的执行</code>，执行完成后，将<code>当前任务解锁</code>，将当前的<code>任务状态置为DLOCK_ONCE_DONE</code>，在下次进来时，就不会在执行，会直接返回</p>
</li>
<li><p>如果在当前任务执行期间，有其他任务进来，会进入无限次等待，原因是当前任务已经获取了锁，进行了加锁，其他任务是无法获取锁的</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/08/05/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-GCD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/05/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-GCD/" class="post-title-link" itemprop="url">iOS多线程-GCD上</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-05 20:15:37" itemprop="dateCreated datePublished" datetime="2021-08-05T20:15:37+08:00">2021-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-10 20:47:31" itemprop="dateModified" datetime="2021-08-10T20:47:31+08:00">2021-08-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一篇我们介绍了多线程的一些概念，本篇我们主要探究iOS开发中经常会使用到的多线程技术<code>GCD</code>。</p>
<h3 id="GCD的概念"><a href="#GCD的概念" class="headerlink" title="GCD的概念"></a>GCD的概念</h3><p><code>GCD</code>的全称是 Grand Central Dispatch。它是由纯 C 语言实现，提供了非常多强大的函数。它有如下优势：</p>
<ul>
<li>GCD 是苹果公司为多核的并行运算提出的解决方案</li>
<li>GCD 会自动利用更多的CPU内核(比如双核、四核)</li>
<li>GCD 会自动管理线程的生命周期(创建线程、调度任务、销毁线程)</li>
<li>程序员只需要告诉 GCD 想要执行什么任务，不需要编写任何线程管理代码。</li>
</ul>
<p>总结来说GCD就是将任务添加到队列，并指定任务执行的函数。</p>
<h3 id="GCD的基本使用"><a href="#GCD的基本使用" class="headerlink" title="GCD的基本使用"></a>GCD的基本使用</h3><p>一般情况下我们会这样使用GCD</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建任务block</span><br><span class="line">dispatch_block_t block &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;这是任务&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;创建串行队列</span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;com.lg.cn&quot;, NULL);</span><br><span class="line">&#x2F;&#x2F;执行任务</span><br><span class="line">dispatch_async(queue, block);</span><br></pre></td></tr></table></figure>

<p>总结来看就是三部：</p>
<ul>
<li>创建任务块<code>dispatch_block_t</code></li>
<li>创建队列<code>dispatch_queue_t</code></li>
<li>将任务添加到队列并执行任务函数<code>dispatch_async</code>或<code>dispatch_sync</code></li>
</ul>
<p>还有两个概念其实我们也很熟悉了就是<code>函数</code>和<code>队列</code>。</p>
<ul>
<li>函数包括<code>同步函数（dispatch_sync）</code>和<code>异步函数（dispatch_async）</code>。</li>
<li>队列包括<code>串行队列（DISPATCH_QUEUE_SERIAL）</code>和<code>并行队列（DISPATCH_QUEUE_CONCURRENT）</code></li>
</ul>
<h3 id="主队列"><a href="#主队列" class="headerlink" title="主队列"></a>主队列</h3><p>主队列（<code>dispatch_queue_main_t</code>）是我们运行程序就会启动的一个队列，它是主线程所在的队列，会贯穿我们应用运行的始终。通过我们<code>dispatch_get_main_queue</code>函数的注释我们看到主队列是一个串行队列，这也不难理解，因为串行队列里的任务会逐个顺序执行，而我们主线程上的任务也符合这一特性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面这行注释说明它是一个串行队列，但不完全是一个标准的串行队列。  </span></span><br><span class="line">* Because the main <span class="built_in">queue</span> doesn<span class="number">'</span>t behave entirely like a regular serial <span class="built_in">queue</span>,</span><br><span class="line"> * it may have unwanted side-effects when used in processes that are <span class="keyword">not</span> UI apps</span><br><span class="line"> * (daemons). For such processes, the main <span class="built_in">queue</span> should be avoided.</span><br><span class="line"> *</span><br><span class="line"> * @see <span class="keyword">dispatch_queue_main_t</span></span><br><span class="line"> *</span><br><span class="line"> * @result</span><br><span class="line"> * Returns the main <span class="built_in">queue</span>. This <span class="built_in">queue</span> is created automatically on behalf of</span><br><span class="line"> * the main thread before main() is called.</span><br><span class="line"> */</span><br><span class="line">DISPATCH_INLINE DISPATCH_ALWAYS_INLINE DISPATCH_CONST DISPATCH_NOTHROW</span><br><span class="line"><span class="keyword">dispatch_queue_main_t</span></span><br><span class="line">dispatch_get_main_queue(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> DISPATCH_GLOBAL_OBJECT(<span class="keyword">dispatch_queue_main_t</span>, _dispatch_main_q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们下载<code>libdispatch</code>的源码，看一下<code>dispatch_get_main_queue</code>的源码，调用的是<code>DISPATCH_GLOBAL_OBJECT(dispatch_queue_main_t, _dispatch_main_q)</code>,它是一个<code>宏</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_GLOBAL_OBJECT(type, object) (static_cast<span class="meta-string">&lt;type&gt;(&amp;(object)))</span></span></span><br></pre></td></tr></table></figure>

<p>可以看到第一个参数<code>type</code>是类型，第二个参数<code>object</code>参数真正的参数也就是<code>_dispatch_main_q</code>,我们全局搜索<code>_dispatch_main_q =</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_static_s</span> _<span class="title">dispatch_main_q</span> = &#123;</span></span><br><span class="line">	DISPATCH_GLOBAL_OBJECT_HEADER(queue_main),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !DISPATCH_USE_RESOLVERS</span></span><br><span class="line">	.do_targetq = _dispatch_get_default_queue(<span class="literal">true</span>),</span><br><span class="line">#endif</span><br><span class="line">	.dq_state = DISPATCH_QUEUE_STATE_INIT_VALUE(<span class="number">1</span>) |</span><br><span class="line">			DISPATCH_QUEUE_ROLE_BASE_ANON,</span><br><span class="line">	.dq_label = <span class="string">"com.apple.main-thread"</span>,</span><br><span class="line">	.dq_atomic_flags = DQF_THREAD_BOUND | DQF_WIDTH(<span class="number">1</span>),</span><br><span class="line">	.dq_serialnum = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>发现<code>_dispatch_main_q</code>是一个结构体。可以看到<code>dispatch_queue_main_t</code>是一个结构体<code>dispatch_queue_static_s</code>。</p>
<h3 id="串行队列和并发队列源码上的区分"><a href="#串行队列和并发队列源码上的区分" class="headerlink" title="串行队列和并发队列源码上的区分"></a>串行队列和并发队列源码上的区分</h3><p>上面我们已经知道，gcd的队列的本质是<code>dispatch_queue_static_s</code>结构体，结构体中那个成员标示的是串行还是并行队列呢？我们源码中找答案。我们的队列是通过<code>dispatch_queue_create</code>函数创建的，它的第二个参数传入的是队列的类型，我们源码中找<code>dispatch_queue_create</code>函数的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span></span><br><span class="line">dispatch_queue_create(<span class="keyword">const</span> <span class="keyword">char</span> *label, <span class="keyword">dispatch_queue_attr_t</span> attr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_lane_create_with_target(label, attr,</span><br><span class="line">			DISPATCH_TARGET_QUEUE_DEFAULT, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟着调用继续查找<code>_dispatch_lane_create_with_target</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">dispatch_queue_t</span></span><br><span class="line">_dispatch_lane_create_with_target(<span class="keyword">const</span> <span class="keyword">char</span> *label, <span class="keyword">dispatch_queue_attr_t</span> dqa,</span><br><span class="line">		<span class="keyword">dispatch_queue_t</span> tq, <span class="keyword">bool</span> legacy)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">dispatch_queue_attr_info_t</span> dqai = _dispatch_queue_attr_to_info(dqa);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Step 1: Normalize arguments (qos, overcommit, tq)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">dispatch_qos_t</span> qos = dqai.dqai_qos;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !HAVE_PTHREAD_WORKQUEUE_QOS</span></span><br><span class="line">	<span class="keyword">if</span> (qos == DISPATCH_QOS_USER_INTERACTIVE) &#123;</span><br><span class="line">		dqai.dqai_qos = qos = DISPATCH_QOS_USER_INITIATED;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (qos == DISPATCH_QOS_MAINTENANCE) &#123;</span><br><span class="line">		dqai.dqai_qos = qos = DISPATCH_QOS_BACKGROUND;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !HAVE_PTHREAD_WORKQUEUE_QOS</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">_dispatch_queue_attr_overcommit_t</span> overcommit = dqai.dqai_overcommit;</span><br><span class="line">	<span class="keyword">if</span> (overcommit != _dispatch_queue_attr_overcommit_unspecified &amp;&amp; tq) &#123;</span><br><span class="line">		<span class="keyword">if</span> (tq-&gt;do_targetq) &#123;</span><br><span class="line">			DISPATCH_CLIENT_CRASH(tq, <span class="string">"Cannot specify both overcommit and "</span></span><br><span class="line">					<span class="string">"a non-global target queue"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tq &amp;&amp; dx_type(tq) == DISPATCH_QUEUE_GLOBAL_ROOT_TYPE) &#123;</span><br><span class="line">		<span class="comment">// Handle discrepancies between attr and target queue, attributes win</span></span><br><span class="line">		<span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_unspecified) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tq-&gt;dq_priority &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT) &#123;</span><br><span class="line">				overcommit = _dispatch_queue_attr_overcommit_enabled;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				overcommit = _dispatch_queue_attr_overcommit_disabled;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (qos == DISPATCH_QOS_UNSPECIFIED) &#123;</span><br><span class="line">			qos = _dispatch_priority_qos(tq-&gt;dq_priority);</span><br><span class="line">		&#125;</span><br><span class="line">		tq = <span class="literal">NULL</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tq &amp;&amp; !tq-&gt;do_targetq) &#123;</span><br><span class="line">		<span class="comment">// target is a pthread or runloop root queue, setting QoS or overcommit</span></span><br><span class="line">		<span class="comment">// is disallowed</span></span><br><span class="line">		<span class="keyword">if</span> (overcommit != _dispatch_queue_attr_overcommit_unspecified) &#123;</span><br><span class="line">			DISPATCH_CLIENT_CRASH(tq, <span class="string">"Cannot specify an overcommit attribute "</span></span><br><span class="line">					<span class="string">"and use this kind of target queue"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_unspecified) &#123;</span><br><span class="line">			<span class="comment">// Serial queues default to overcommit!</span></span><br><span class="line">			overcommit = dqai.dqai_concurrent ?</span><br><span class="line">					_dispatch_queue_attr_overcommit_disabled :</span><br><span class="line">					_dispatch_queue_attr_overcommit_enabled;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!tq) &#123;</span><br><span class="line">		tq = _dispatch_get_root_queue(</span><br><span class="line">				qos == DISPATCH_QOS_UNSPECIFIED ? DISPATCH_QOS_DEFAULT : qos,</span><br><span class="line">				overcommit == _dispatch_queue_attr_overcommit_enabled)-&gt;_as_dq;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!tq)) &#123;</span><br><span class="line">			DISPATCH_CLIENT_CRASH(qos, <span class="string">"Invalid queue attribute"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Step 2: Initialize the queue</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (legacy) &#123;</span><br><span class="line">		<span class="comment">// if any of these attributes is specified, use non legacy classes</span></span><br><span class="line">		<span class="keyword">if</span> (dqai.dqai_inactive || dqai.dqai_autorelease_frequency) &#123;</span><br><span class="line">			legacy = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">void</span> *vtable;</span><br><span class="line">	<span class="keyword">dispatch_queue_flags_t</span> dqf = legacy ? DQF_MUTABLE : <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (dqai.dqai_concurrent) &#123;</span><br><span class="line">		vtable = DISPATCH_VTABLE(queue_concurrent);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		vtable = DISPATCH_VTABLE(queue_serial);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> (dqai.dqai_autorelease_frequency) &#123;</span><br><span class="line">	<span class="keyword">case</span> DISPATCH_AUTORELEASE_FREQUENCY_NEVER:</span><br><span class="line">		dqf |= DQF_AUTORELEASE_NEVER;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM:</span><br><span class="line">		dqf |= DQF_AUTORELEASE_ALWAYS;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (label) &#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span> *tmp = _dispatch_strdup_if_mutable(label);</span><br><span class="line">		<span class="keyword">if</span> (tmp != label) &#123;</span><br><span class="line">			dqf |= DQF_LABEL_NEEDS_FREE;</span><br><span class="line">			label = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">dispatch_lane_t</span> dq = _dispatch_object_alloc(vtable,</span><br><span class="line">			<span class="keyword">sizeof</span>(struct dispatch_lane_s));</span><br><span class="line">	_dispatch_queue_init(dq, dqf, dqai.dqai_concurrent ?</span><br><span class="line">			DISPATCH_QUEUE_WIDTH_MAX : <span class="number">1</span>, DISPATCH_QUEUE_ROLE_INNER |</span><br><span class="line">			(dqai.dqai_inactive ? DISPATCH_QUEUE_INACTIVE : <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	dq-&gt;dq_label = label;</span><br><span class="line">	dq-&gt;dq_priority = _dispatch_priority_make((<span class="keyword">dispatch_qos_t</span>)dqai.dqai_qos,</span><br><span class="line">			dqai.dqai_relpri);</span><br><span class="line">	<span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_enabled) &#123;</span><br><span class="line">		dq-&gt;dq_priority |= DISPATCH_PRIORITY_FLAG_OVERCOMMIT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!dqai.dqai_inactive) &#123;</span><br><span class="line">		_dispatch_queue_priority_inherit_from_target(dq, tq);</span><br><span class="line">		_dispatch_lane_inherit_wlh_from_target(dq, tq);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_retain(tq);</span><br><span class="line">	dq-&gt;do_targetq = tq;</span><br><span class="line">	_dispatch_object_debug(dq, <span class="string">"%s"</span>, __func__);</span><br><span class="line">	<span class="keyword">return</span> _dispatch_trace_queue_create(dq)._dq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数比较长，按照管理我们还是先看返回值<code>_dispatch_trace_queue_create(dq)._dq</code>。重点看<code>dq</code>怎么创建的。所以我们主要<code>dq</code>的创建及成员赋值的过程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_lane_t</span> dq = _dispatch_object_alloc(vtable,</span><br><span class="line">			<span class="keyword">sizeof</span>(struct dispatch_lane_s));</span><br><span class="line">	_dispatch_queue_init(dq, dqf, dqai.dqai_concurrent ?</span><br><span class="line">			DISPATCH_QUEUE_WIDTH_MAX : <span class="number">1</span>, DISPATCH_QUEUE_ROLE_INNER |</span><br><span class="line">			(dqai.dqai_inactive ? DISPATCH_QUEUE_INACTIVE : <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>发现<code>_dispatch_queue_init</code>的实参有<code>dqai.dqai_concurrent</code>还是并行队列的判断。我们定位到<code>_dispatch_queue_init</code>的第三个参数，看看其赋值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_queue_class_t</span></span><br><span class="line">_dispatch_queue_init(<span class="keyword">dispatch_queue_class_t</span> dqu, <span class="keyword">dispatch_queue_flags_t</span> dqf,</span><br><span class="line">		<span class="keyword">uint16_t</span> <span class="built_in">width</span>, <span class="keyword">uint64_t</span> initial_state_bits)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> dq_state = DISPATCH_QUEUE_STATE_INIT_VALUE(<span class="built_in">width</span>);</span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> dq = dqu._dq;</span><br><span class="line"></span><br><span class="line">	dispatch_assert((initial_state_bits &amp; ~(DISPATCH_QUEUE_ROLE_MASK |</span><br><span class="line">			DISPATCH_QUEUE_INACTIVE)) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (initial_state_bits &amp; DISPATCH_QUEUE_INACTIVE) &#123;</span><br><span class="line">		dq-&gt;do_ref_cnt += <span class="number">2</span>; <span class="comment">// rdar://8181908 see _dispatch_lane_resume</span></span><br><span class="line">		<span class="keyword">if</span> (dx_metatype(dq) == _DISPATCH_SOURCE_TYPE) &#123;</span><br><span class="line">			dq-&gt;do_ref_cnt++; <span class="comment">// released when DSF_DELETED is set</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dq_state |= initial_state_bits;</span><br><span class="line">	dq-&gt;do_next = DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">	dqf |= DQF_WIDTH(<span class="built_in">width</span>);</span><br><span class="line">	os_atomic_store2o(dq, dq_atomic_flags, dqf, relaxed);</span><br><span class="line">	dq-&gt;dq_state = dq_state;</span><br><span class="line">	dq-&gt;dq_serialnum =</span><br><span class="line">			os_atomic_inc_orig(&amp;_dispatch_queue_serial_numbers, relaxed);</span><br><span class="line">	<span class="keyword">return</span> dqu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到第三个参数<code>width</code>复制的地方是<code>dqf |= DQF_WIDTH(width);</code>即：</p>
<ul>
<li><p>width = 1表示串行队列</p>
</li>
<li><p>width =  DISPATCH_QUEUE_WIDTH_MAX表示并行队列，其中<code>DISPATCH_QUEUE_WIDTH_MAX</code>的定义如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_QUEUE_WIDTH_FULL			0x1000ull</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_QUEUE_WIDTH_MAX  (DISPATCH_QUEUE_WIDTH_FULL - 2)</span></span><br></pre></td></tr></table></figure>

<h3 id="dispatch-queue-t的继承链"><a href="#dispatch-queue-t的继承链" class="headerlink" title="dispatch_queue_t的继承链"></a>dispatch_queue_t的继承链</h3></li>
</ul>
<p><code>dispatch_queue_t</code>的继承链是什么样子呢，我们在代码中按<code>cmd</code>+<code>dispatch_queue_t</code>会跳转到<code>DISPATCH_DECL(dispatch_queue);</code>代码，它是<code>dispatch_queue_t</code>的定义。我们在libdispatch源码中搜索<code>DISPATCH_DECL(</code>找定义的地方，根据上下文<code>if</code>判断下面这行是<code>oc</code>情况下的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_DECL(name) \</span></span><br><span class="line">		<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">name</span>##_<span class="title">s</span> :</span> <span class="keyword">public</span> dispatch_object_s &#123;&#125; *name##<span class="keyword">_t</span></span><br><span class="line"><span class="comment">///dispatch_queue_t -&gt; dispatch_queue_s -&gt; dispatch_object_s</span></span><br></pre></td></tr></table></figure>

<p>可以看到继承链为<code>dispatch_queue_t -&gt; dispatch_queue_s -&gt; dispatch_object_s</code></p>
<p>我们观察一下的机构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> &#123;</span></span><br><span class="line">	DISPATCH_QUEUE_CLASS_HEADER(<span class="built_in">queue</span>, <span class="keyword">void</span> *__dq_opaque1);</span><br><span class="line">	<span class="comment">/* 32bit hole on LP64 */</span></span><br><span class="line">&#125; DISPATCH_ATOMIC64_ALIGN;</span><br></pre></td></tr></table></figure>

<p>继续看<code>DISPATCH_QUEUE_CLASS_HEADER</code>结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DISPATCH_QUEUE_CLASS_HEADER(x, __pointer_sized_field__) \</span></span><br><span class="line">	DISPATCH_OBJECT_HEADER(x); \</span><br><span class="line">	__pointer_sized_field__; \</span><br><span class="line">	DISPATCH_UNION_LE(<span class="keyword">uint64_t</span> <span class="keyword">volatile</span> dq_state, \</span><br><span class="line">			dispatch_lock dq_state_lock, \</span><br><span class="line">			<span class="keyword">uint32_t</span> dq_state_bits \</span><br><span class="line">	)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>继承于<code>DISPATCH_OBJECT_HEADER</code>继续搜索：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DISPATCH_OBJECT_HEADER(x) \</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">os_object_s</span> _<span class="title">as_os_obj</span>[0];</span> \</span><br><span class="line">	OS_OBJECT_STRUCT_HEADER(dispatch_##x); \</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_</span>##<span class="title">x</span>##_<span class="title">s</span> *<span class="title">volatile</span> <span class="title">do_next</span>;</span> \</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *<span class="title">do_targetq</span>;</span> \</span><br><span class="line">	<span class="keyword">void</span> *do_ctxt; \</span><br><span class="line">	<span class="keyword">union</span> &#123; \</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> DISPATCH_FUNCTION_POINTER do_finalizer; \</span><br><span class="line">		<span class="keyword">void</span> *do_introspection_ctxt; \</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>最后继承的是<code>_os_object_s</code>,所以完整继承链就是</p>
<p>dispatch_queue_t -&gt; dispatch_queue_s -&gt; dispatch_object_s -&gt; _os_object_s</p>
<h3 id="函数的调用时机"><a href="#函数的调用时机" class="headerlink" title="函数的调用时机"></a>函数的调用时机</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_sync(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">    NSLog(@&quot;函数调用了&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们本小节探究函数的<code>block</code>参数是什么时候调用的，我们以同步函数为例，全局搜索<code>dispatch_sync</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_sync(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_block_t</span> work)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uintptr_t</span> dc_flags = DC_FLAG_BLOCK;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(_dispatch_block_has_private_data(work))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_block_with_privdata(dq, work, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_sync_f(dq, work, _dispatch_Block_invoke(work), dc_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>work</code>为我们传入的<code>block</code>，所以我们看和<code>work</code>参数相关的代码</p>
<p><code>_dispatch_Block_invoke</code>函数的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _dispatch_Block_invoke(bb) \</span></span><br><span class="line">		((<span class="keyword">dispatch_function_t</span>)((struct Block_layout *)bb)-&gt;invoke)</span><br></pre></td></tr></table></figure>

<p>可以看到_dispatch_Block_invoke函数主要是调用了<code>work</code>的<code>invoke</code>方法。</p>
<p>我们再看<code>_dispatch_sync_f</code>的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_f(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func,</span><br><span class="line">		<span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	_dispatch_sync_f_inline(dq, ctxt, func, dc_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟踪<code>_dispatch_sync_f_inline</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_f_inline(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (likely(dq-&gt;dq_width == <span class="number">1</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_barrier_sync_f(dq, ctxt, func, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(dx_metatype(dq) != _DISPATCH_LANE_TYPE)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(<span class="number">0</span>, <span class="string">"Queue type doesn't support dispatch_sync"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">dispatch_lane_t</span> dl = upcast(dq)._dl;</span><br><span class="line">	<span class="comment">// Global concurrent queues and queues bound to non-dispatch threads</span></span><br><span class="line">	<span class="comment">// always fall into the slow case, see DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!_dispatch_queue_try_reserve_sync_width(dl))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_f_slow(dl, ctxt, func, <span class="number">0</span>, dl, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_recurse(dl, ctxt, func, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_introspection_sync_begin(dl);</span><br><span class="line">	_dispatch_sync_invoke_and_complete(dl, ctxt, func DISPATCH_TRACE_ARG(</span><br><span class="line">			_dispatch_trace_item_sync_push_pop(dq, ctxt, func, dc_flags)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_dispatch_sync_f_inline</code>函数的<code>ctxt</code>和<code>func</code>参数是和block相关的参数，调用的地方比较多，我们在demo工程打一个符号断点看一下，到底执行了哪个方法：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5efc9820ecdd40359b417a0786b63a45~tplv-k3u1fbpfcp-watermark.image" alt="1628264358531"></p>
<p>我们发现实际调用的是<code>_dispatch_sync_f_slow</code>函数</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/036607d53d484d3a964806f0557747d9~tplv-k3u1fbpfcp-watermark.image" alt="1628264502620"></p>
<p>所以我们继续看<code>_dispatch_sync_f_slow</code>的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_f_slow(<span class="keyword">dispatch_queue_class_t</span> top_dqu, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func, <span class="keyword">uintptr_t</span> top_dc_flags,</span><br><span class="line">		<span class="keyword">dispatch_queue_class_t</span> dqu, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> top_dq = top_dqu._dq;</span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> dq = dqu._dq;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!dq-&gt;do_targetq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_function_invoke(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pthread_priority_t</span> pp = _dispatch_get_priority();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_sync_context_s</span> <span class="title">dsc</span> = &#123;</span></span><br><span class="line">		.dc_flags    = DC_FLAG_SYNC_WAITER | dc_flags,</span><br><span class="line">		.dc_func     = _dispatch_async_and_wait_invoke,</span><br><span class="line">		.dc_ctxt     = &amp;dsc,</span><br><span class="line">		.dc_other    = top_dq,</span><br><span class="line">		.dc_priority = pp | _PTHREAD_PRIORITY_ENFORCE_FLAG,</span><br><span class="line">		.dc_voucher  = _voucher_get(),</span><br><span class="line">		.dsc_func    = func,</span><br><span class="line">		.dsc_ctxt    = ctxt,</span><br><span class="line">		.dsc_waiter  = _dispatch_tid_self(),</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	_dispatch_trace_item_push(top_dq, &amp;dsc);</span><br><span class="line">	__DISPATCH_WAIT_FOR_QUEUE__(&amp;dsc, dq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dsc.dsc_func == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">// dsc_func being cleared means that the block ran on another thread ie.</span></span><br><span class="line">		<span class="comment">// case (2) as listed in _dispatch_async_and_wait_f_slow.</span></span><br><span class="line">		<span class="keyword">dispatch_queue_t</span> stop_dq = dsc.dc_other;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_complete_recurse(top_dq, stop_dq, top_dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_dispatch_introspection_sync_begin(top_dq);</span><br><span class="line">	_dispatch_trace_item_pop(top_dq, &amp;dsc);</span><br><span class="line">	_dispatch_sync_invoke_and_complete_recurse(top_dq, ctxt, func,top_dc_flags</span><br><span class="line">			DISPATCH_TRACE_ARG(&amp;dsc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关注的参数依然是<code>ctxt</code>和<code>func</code>，和上一步骤类似，我们继续打符号断点<code>_dispatch_sync_invoke_and_complete_recurse</code>和<code>_dispatch_sync_function_invoke</code>来看具体执行的代码。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/553b2e78bcb545a7811d664a66dd90cf~tplv-k3u1fbpfcp-watermark.image" alt="1628264995211"></p>
<p>实际调用了<code>_dispatch_sync_function_invoke</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_function_invoke(<span class="keyword">dispatch_queue_class_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">	_dispatch_sync_function_invoke_inline(dq, ctxt, func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟进<code>_dispatch_sync_function_invoke_inline</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_function_invoke_inline(<span class="keyword">dispatch_queue_class_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_thread_frame_s dtf;</span><br><span class="line">	_dispatch_thread_frame_push(&amp;dtf, dq);</span><br><span class="line">	_dispatch_client_callout(ctxt, func);</span><br><span class="line">	_dispatch_perfmon_workitem_inc();</span><br><span class="line">	_dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ctxt</code>和<code>func</code>的调用在<code>_dispatch_client_callout</code>函数，有多个实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_client_callout(<span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> f)</span><br><span class="line">&#123;</span><br><span class="line">	_dispatch_get_tsd_base();</span><br><span class="line">	<span class="keyword">void</span> *u = _dispatch_get_unwind_tsd();</span><br><span class="line">	<span class="keyword">if</span> (likely(!u)) <span class="keyword">return</span> f(ctxt);</span><br><span class="line">	_dispatch_set_unwind_tsd(<span class="literal">NULL</span>);</span><br><span class="line">	f(ctxt);</span><br><span class="line">	_dispatch_free_unwind_tsd();</span><br><span class="line">	_dispatch_set_unwind_tsd(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> _dispatch_client_callout</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_client_callout(<span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> f)</span><br><span class="line">&#123;</span><br><span class="line">	@<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> f(ctxt);</span><br><span class="line">	&#125;</span><br><span class="line">	@<span class="keyword">catch</span> (...) &#123;</span><br><span class="line">		objc_terminate();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然多处实现，但是调用<code>block</code>的代码都是<code>f(ctxt)</code>。</p>
<p>所以<code>block</code>的调用链是：<code>dispatch_sync</code>-&gt;<code>_dispatch_sync_f</code>-&gt;<code>_dispatch_sync_f_inline</code>-&gt;<code>_dispatch_sync_f_slow</code>-&gt;<code>_dispatch_sync_function_invoke</code>-&gt;<code>_dispatch_client_callout</code>-&gt;<code>f(ctxt)</code>。</p>
<p>同理异步函数<code>dispatch_async</code>用相同的方法也能探究出一个调用链，最后调用的也是<code>f(ctxt)</code>,感兴趣的童鞋可以探究一下。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/08/01/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/01/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">iOS多线程-多线程原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-01 17:05:50 / 修改时间：21:23:57" itemprop="dateCreated datePublished" datetime="2021-08-01T17:05:50+08:00">2021-08-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本节我们主要了解一些多线程的理论知识。</p>
<h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><ul>
<li>进程是指在系统中正在运行的一个应用程序。</li>
<li>每个进程之间是独立的，每个进程均运行在其专用的且受保护的内存空间内。</li>
<li>通过“活动监视器”可以查看 Mac 系统中所开启的进程。</li>
</ul>
<h5 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h5><ul>
<li>线程是进程的基本执行单元，一个进程的所有任务都在线程中执行。</li>
<li>进程要想执行任务，必须得有线程，进程至少要有一条线程。</li>
<li>程序启动会默认开启一条线程，这条线程被称为主线程或 UI 线程。</li>
</ul>
<h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><ul>
<li>地址空间:同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。</li>
<li>资源拥有:同一进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的 资源是独立的。</li>
</ul>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><ol>
<li>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</li>
<li>进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进 程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程 </li>
<li>执行过程:每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口。但是 线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li>
<li>线程是处理器调度的基本单位，但是进程不是。</li>
<li>线程没有地址空间,线程包含在进程地址空间中。</li>
</ol>
<h3 id="多线程原理"><a href="#多线程原理" class="headerlink" title="多线程原理"></a>多线程原理</h3><ul>
<li>对于<code>单核CPU</code>，<code>同一时间，CPU只能处理一条线程</code>，即只有一条线程在工作，</li>
<li>iOS中的<code>多线程同时执行</code>的本质是CPU在多个任务直接进行快速的切换，由于CPU调度线程的时间足够快，就造成了多线程的“同时”执行的效果。其中切换的时间间隔就是<code>时间片</code>。</li>
</ul>
<h4 id="多线程的优点"><a href="#多线程的优点" class="headerlink" title="多线程的优点"></a>多线程的优点</h4><ul>
<li>能适当提高程序的执行效率</li>
<li>能适当提高资源的利用率(CPU，内存)</li>
<li>线程上的任务执行完成后，线程会自动销毁</li>
</ul>
<h4 id="多线程的缺点"><a href="#多线程的缺点" class="headerlink" title="多线程的缺点"></a>多线程的缺点</h4><ul>
<li>开启线程需要占用一定的内存空间(默认情况下，每一个线程都占 512 KB，90ms的时间)。</li>
<li>如果开启大量的线程，会占用大量的内存空间，降低程序的性能。</li>
<li>线程越多，CPU 在调用线程上的开销就越大。</li>
<li>程序设计更加复杂，比如线程间的通信，多线程的数据共享。</li>
</ul>
<h3 id="多线程生命周期"><a href="#多线程生命周期" class="headerlink" title="多线程生命周期"></a>多线程生命周期</h3><p>多线程的生命周期主要分为5部分：新建 - 就绪 - 运行 - 阻塞 - 死亡，如下图所示</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5c1d80cb9754ab98612a71b7f3ea3ec~tplv-k3u1fbpfcp-watermark.image" alt="多线程生命周期"></p>
<ul>
<li><code>新建</code>：主要是实例化线程对象</li>
<li><code>就绪</code>：线程对象调用start方法，将线程对象加入可调度线程池，等待CPU的调用，即调用start方法，并不会立即执行，进入<code>就绪状态</code>，需要等待一段时间，经CPU时间片调度后再执行，也就是从就绪状态进入<code>运行状态</code>。</li>
<li><code>阻塞</code>：当满足某个预定条件时，可以<code>使用休眠，即sleep，或者同步锁</code>，阻塞线程执行。当进入sleep时，会重新将<code>线程加入就绪</code>中。</li>
<li><code>死亡</code>：分为两种情况，<ol>
<li><code>正常死亡</code>，即线程执行完毕</li>
<li><code>非正常死亡</code>，即当满足某个条件后，在线程内部（或者主线程中）终止执行（调用exit方法等退出）</li>
</ol>
</li>
<li><code>运行</code>：就是线程执行，处于<code>运行中的线程</code>拥有一段可以执行的时间(<code>时间片</code>)。<ol>
<li>如果<code>时间片用尽</code>，线程就会进入<code>就绪状态队列</code></li>
<li>如果<code>时间片没有用尽</code>，且需要开始<code>等待某事件</code>，就会进入<code>阻塞状态队列</code></li>
<li>等待事件发生后，线程又会重新进入<code>就绪状态队列</code></li>
<li>每当一个<code>线程离开运行</code>，即执行完毕或者强制退出后，会重新从就绪状态队列中选择一个线程继续执行</li>
</ol>
</li>
</ul>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池流程图如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86ba007efda84d878b9551594a95d4b4~tplv-k3u1fbpfcp-watermark.image" alt="线程池"></p>
<ol>
<li>判断核心线程池是否都正在执行任务<ul>
<li>返回NO，创建新的工作线程去执行</li>
<li>返回YES，进入2</li>
</ul>
</li>
<li>判断线程池工作队列是否已经饱满<ul>
<li>返回NO，将任务存储到工作队列，等待CPU调度</li>
<li>返回YES，进入3</li>
</ul>
</li>
<li>判断线程池中的线程是否都处于执行状态<ul>
<li>返回NO，安排可调度线程池中空闲的线程去执行任务</li>
<li>返回YES，进入4</li>
</ul>
</li>
<li>交给饱和策略去执行。饱和策略有一下四种：<ul>
<li><code>AbortPolicy</code>：直接抛出RejectedExecutionExeception异常来阻止系统正常运行</li>
<li><code>CallerRunsPolicy</code>：将任务回退到调用者</li>
<li><code>DisOldestPolicy</code>：丢掉等待最久的任务</li>
<li><code>DisCardPolicy</code>：直接丢弃任务</li>
<li>这四种拒绝策略均实现的RejectedExecutionHandler接口</li>
</ul>
</li>
</ol>
<h3 id="互斥锁与自旋锁"><a href="#互斥锁与自旋锁" class="headerlink" title="互斥锁与自旋锁"></a>互斥锁与自旋锁</h3><p>锁是用户保护临界区，确保同一时间，只有一条线程能够访问临界区。</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><ul>
<li>自旋锁在获取到资源之前一直处于忙等。</li>
<li>自旋锁的使用场景：锁持有时间短，且线程不希望在重新调用上花太多成本。<code>OC</code>属性的关键字<code>atomic</code>就是使用了自旋锁。</li>
<li>使用自旋锁，当心线程访问代码时，如果发现其他线程转给你在锁定代码，新线程会用死循环的方法，一直等待锁定的代码执行完成，比较消耗性能。</li>
</ul>
<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><ul>
<li><p>互斥锁在获取到资源之前是休眠状态，释放资源后会被唤醒。</p>
</li>
<li><p>如果代码中<code>只有一个地方需要加锁，大多都使用 self</code>，这样可以避免单独再创建一个锁对象</p>
</li>
<li><p>互斥锁的<code>锁定范围，应该尽量小</code>，锁定范围越大，效率越差</p>
</li>
<li><p>能够<code>加锁的任意 NSObject 对象</code></p>
</li>
<li><p>锁对象一定要保证所有的线程都能够访问</p>
<h3 id="几个多线程题目"><a href="#几个多线程题目" class="headerlink" title="几个多线程题目"></a>几个多线程题目</h3></li>
</ul>
<h4 id="任务执行的影响因素"><a href="#任务执行的影响因素" class="headerlink" title="任务执行的影响因素"></a>任务执行的影响因素</h4><ul>
<li>cpu的调度</li>
<li>执行任务的复杂度</li>
<li>任务的优先级</li>
<li>线程的状态</li>
</ul>
<h4 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h4><p>两种线程：IO密集型、CPU密集型</p>
<ul>
<li>IO密集型，频繁等待的线程。更容易得到优先级提升。</li>
<li>CPU密集型，很少等待的线程。</li>
<li>IO密集型线程容易饿死。</li>
<li>cpu调度来提升等待线程的优先级</li>
</ul>
<h4 id="优先级的影响因素"><a href="#优先级的影响因素" class="headerlink" title="优先级的影响因素"></a>优先级的影响因素</h4><ul>
<li>用户指定。</li>
<li>等待的频繁度。</li>
<li>长时间不执行。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/07/27/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-KVO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/27/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-KVO/" class="post-title-link" itemprop="url">iOS底层探索-KVO</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-27 20:30:04" itemprop="dateCreated datePublished" datetime="2021-07-27T20:30:04+08:00">2021-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-31 15:58:49" itemprop="dateModified" datetime="2021-07-31T15:58:49+08:00">2021-07-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>KVO</code>是一种机制，它允许对象在其他对象的指定属性发生更改时收到通知。它最常用的一个场景就是<code>viewconroller</code>中监听<code>model</code>属性的变化从而刷新页面展示。</p>
<h3 id="KVO使用过程的细节"><a href="#KVO使用过程的细节" class="headerlink" title="KVO使用过程的细节"></a><code>KVO</code>使用过程的细节</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p><code>KVO</code>的基本使用就是三部曲：</p>
<ul>
<li><p>注册观察者 <code>addObserver:forKeyPath:options:context</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.person addObserver:self forKeyPath:@&quot;nickname&quot; options:NSKeyValueObservingOptionNew context:NULL];</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现<code>KVO</code>的回调<code>observeValueForKeyPath:ofObject:change:context</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    if ([keyPath isEqualToString:@&quot;nickname&quot;]) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,change);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>移除观察者<code>removeObserver:forKeyPath:context</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.person removeObserver:self forKeyPath:@&quot;nickname&quot; context:NULL];</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="context参数的使用"><a href="#context参数的使用" class="headerlink" title="context参数的使用"></a>context参数的使用</h4><p>基本使用的过程中我们经常会给<code>context</code>传<code>NULL</code>作为实参，<code>context</code>参数的作用很容易被我们忽略。苹果官方文档对<code>context</code>有详细的说明</p>
<blockquote>
<p>The context pointer in the <code>addObserver:forKeyPath:options:context:</code> message contains arbitrary data that will be passed back to the observer in the corresponding change notifications. You may specify <code>NULL</code> and rely entirely on the key path string to determine the origin of a change notification, but this approach may cause problems for an object whose superclass is also observing the same key path for different reasons.</p>
<p>A safer and more extensible approach is to use the context to ensure notifications you receive are destined for your observer and not a superclass.</p>
</blockquote>
<p>大体意思就是：<code>addObserver：forKeyPath：options：context：</code>方法中的<code>context</code>指针包含任意数据，这些数据将在相应的更改通知中传递回观察者。可以通过<code>指定context为NULL</code>，从而<code>依靠keyPath</code>即<code>键路径字符串</code>传来确定更改通知的来源，但是这种方法可能会导致对象的父类由于不同的原因也观察到相同的键路径而导致问题。所以可以为每个观察到的keyPath创建一个不同的context，从而<code>完全不需要进行字符串比较</code>，从而可以更有效地进行通知解析。</p>
<p><code>context</code>主要是用于区分不同对象的同名属性，从而在KVO回调方法中可以直接使用<code>context</code>进行区分，可以大大提升性能，以及代码的可读性。</p>
<ul>
<li><p>不使用context时，我们通过字符串判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[self.person addObserver:self forKeyPath:@&quot;nickname&quot; options:NSKeyValueObservingOptionNew context:NULL];</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    if ([keyPath isEqualToString:@&quot;nickname&quot;]) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,change);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用context时，我们通过<code>context</code>判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;context定义</span><br><span class="line">static void *PersonNickNameContext &#x3D; &amp;PersonNickNameContext;</span><br><span class="line">static void *PersonNameContext &#x3D; &amp;PersonNameContext;</span><br><span class="line">&#x2F;&#x2F;注册观察者</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;nick&quot; options:NSKeyValueObservingOptionNew context:PersonNickNameContext];</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:PersonNameContext];</span><br><span class="line">&#x2F;&#x2F;KVO的回调</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    if (context &#x3D;&#x3D; PersonNickNameContext) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,change);</span><br><span class="line">    &#125;else if (context &#x3D;&#x3D; PersonNameContext)&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,change);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="是否有必要移除KVOobserver"><a href="#是否有必要移除KVOobserver" class="headerlink" title="是否有必要移除KVOobserver"></a>是否有必要移除<code>KVO</code>observer</h4><p>官方文档对<code>removeObserver</code>也有说明：</p>
<blockquote>
<p>When removing an observer, keep several points in mind:</p>
<ul>
<li>Asking to be removed as an observer if not already registered as one results in an <code>NSRangeException</code>. You either call <code>removeObserver:forKeyPath:context:</code> exactly once for the corresponding call to <code>addObserver:forKeyPath:options:context:</code>, or if that is not feasible in your app, place the <code>removeObserver:forKeyPath:context:</code> call inside a try/catch block to process the potential exception.</li>
<li>An observer does not automatically remove itself when deallocated. The observed object continues to send notifications, oblivious to the state of the observer. However, a change notification, like any other message, sent to a released object, triggers a memory access exception. You therefore ensure that observers remove themselves before disappearing from memory.</li>
<li>The protocol offers no way to ask an object if it is an observer or being observed. Construct your code to avoid release related errors. A typical pattern is to register as an observer during the observer’s initialization (for example in <code>init</code> or <code>viewDidLoad</code>) and unregister during deallocation (usually in <code>dealloc</code>), ensuring properly paired and ordered add and remove messages, and that the observer is unregistered before it is freed from memory.</li>
</ul>
</blockquote>
<p>翻译过来就是，移除观察者时，注意以下几点：</p>
<ul>
<li>如果未注册为观察者，在移除观察者的时候会导致<code>NSRangeException</code>异常。<code>removeObserver</code>必须和<code>addObserver</code>对应，且只能调用一次。如果项目中不能保证，就需要在使用的时候使用<code>try/catch</code>来处理异常。</li>
<li>观察者在对象销毁的时候不会自动移除观察者。被观察者会继续发送通知，对观察者来说这个状态是感知不到的。但是，向一个已经释放的对象发送通知会引起内存访问异常。所以，我们要保证观察者在内存释放之前移除观察。</li>
<li>这个协议没有方法可以判断他是一个观察者还是被观察者，写代码是要避免释放内存相关的错误。一个典型的规范就是在观察者初始画的时候注册观察，在<code>dealloc</code>的时候移除观察，以确保成对和有序地添加和删除消息，并确保观察者在注册之前被取消注册，从内存中释放出来。</li>
</ul>
<p>所以，总的来说，<code>KVO注册观察者 和移除观察者是需要成对出现的</code>，如果只注册，不移除，会出现<code>野指针的崩溃</code>。</p>
<h4 id="自动触发与手动触发"><a href="#自动触发与手动触发" class="headerlink" title="自动触发与手动触发"></a>自动触发与手动触发</h4><p>KVO观察的自动和手动两种方式</p>
<ul>
<li><p>自动开关，<code>automaticallyNotifiesObserversForKey</code>返回<code>YES</code>的时候标示自动监听，如果是<code>NO</code>表示我们需要手动监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 自动开关</span><br><span class="line">+ (BOOL) automaticallyNotifiesObserversForKey:(NSString *)key&#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果是手动，我们需要通过<code>手动开关</code>监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)setNickName:(NSString *)nickName&#123;</span><br><span class="line">    &#x2F;&#x2F;手动开关</span><br><span class="line">    [self willChangeValueForKey:@&quot;nickName&quot;];</span><br><span class="line">    _nickName &#x3D; namenickName</span><br><span class="line">    [self didChangeValueForKey:@&quot;nickName&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="观察多个属性变化"><a href="#观察多个属性变化" class="headerlink" title="观察多个属性变化"></a>观察多个属性变化</h4><p>我们以观察两个属性为例，例如我们需要根据速度<code>speed</code>和时间<code>time</code>，取得当前的路程<code>distance</code>。我们用两种方式。</p>
<ul>
<li><p>第一种就是分别观察速度<code>speed</code>和时间<code>time</code>两个属性，当其中一个发生变化计算 当前路程<code>distance</code>。</p>
</li>
<li><p>第二种方式就是，通过<code>keyPathsForValuesAffectingValueForKey</code>方法，将两个观察合为一个观察，即观察当前路程<code>distance</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1、合二为一的观察方法</span><br><span class="line">+ (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key&#123;</span><br><span class="line">    NSSet *keyPaths &#x3D; [super keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line">    if ([key isEqualToString:@&quot;distance&quot;]) &#123;</span><br><span class="line">        NSArray *affectingKeys &#x3D; @[@&quot;speed&quot;, @&quot;time&quot;];</span><br><span class="line">        keyPaths &#x3D; [keyPaths setByAddingObjectsFromArray:affectingKeys];</span><br><span class="line">    &#125;</span><br><span class="line">    return keyPaths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2、注册KVO观察</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;distance&quot; options:(NSKeyValueObservingOptionNew) context:NULL];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3、触发属性值变化</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    self.person.speed +&#x3D; 10;</span><br><span class="line">    self.person.time  +&#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;4、移除观察者</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">    [self.person removeObserver:self forKeyPath:@&quot;distance&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="可变数组的观察"><a href="#可变数组的观察" class="headerlink" title="可变数组的观察"></a>可变数组的观察</h4><p>KVO是基于KVC基础之上的，所以可变数组如果直接添加数据，是不会调用setter方法的，所有对<code>可变数组</code>的KVO观察下面这种方式<code>不生效</code>的,即直接通过<code>[self.person.dateArray addObject:@&quot;1&quot;];</code>向数组添加元素，是不会触发kvo通知回调的，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1、注册可变数组KVO观察者</span><br><span class="line">self.person.dateArray &#x3D; [NSMutableArray arrayWithCapacity:1];</span><br><span class="line">    [self.person addObserver:self forKeyPath:@&quot;dateArray&quot; options:(NSKeyValueObservingOptionNew) context:NULL];</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;2、KVO回调</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,change);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3、移除观察者</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line"> [self.person removeObserver:self forKeyPath:@&quot;dateArray&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;4、触发数组添加数据</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    [self.person.dateArray addObject:@&quot;1&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在KVC官方文档中，针对<code>可变数组的集合</code>类型，有如下说明，即访问集合对象需要需要通过<code>mutableArrayValueForKey</code>方法，这样才能<code>将元素添加到可变数组</code>中</p>
<blockquote>
<p>The protocol defines three different proxy methods for collection object access, each with a key and a key path variant:</p>
<ul>
<li><p><code>mutableArrayValueForKey:</code> and <code>mutableArrayValueForKeyPath:</code></p>
<p>These return a proxy object that behaves like an <code>NSMutableArray</code> object.</p>
</li>
<li><p><code>mutableSetValueForKey:</code> and <code>mutableSetValueForKeyPath:</code></p>
<p>These return a proxy object that behaves like an <code>NSMutableSet</code> object.</p>
</li>
<li><p><code>mutableOrderedSetValueForKey:</code> and <code>mutableOrderedSetValueForKeyPath:</code></p>
<p>These return a proxy object that behaves like an <code>NSMutableOrderedSet</code> object.</p>
</li>
</ul>
</blockquote>
<p>我们代码这样修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    &#x2F;&#x2F; KVC 集合 array</span><br><span class="line">    [[self.person mutableArrayValueForKey:@&quot;dateArray&quot;] addObject:@&quot;1&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在可变数组就可以监听到了。</p>
<h3 id="KVO底层探索"><a href="#KVO底层探索" class="headerlink" title="KVO底层探索"></a>KVO底层探索</h3><p>苹果官方文档在<code>Key-Value Observing Implementation Details</code>里有提到<code>KVO</code>的实现：</p>
<blockquote>
<p>Automatic key-value observing is implemented using a technique called <em>isa-swizzling</em>.</p>
<p>The <code>isa</code> pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.</p>
<p>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</p>
<p>You should never rely on the <code>isa</code> pointer to determine class membership. Instead, you should use the <code>class</code> method to determine the class of an object instance.</p>
</blockquote>
<p>大概意思就是<code>KVO</code>的实现使用了<code>isa</code>的交换。当我们添加一个<code>observer</code>的时候<code>isa</code>的指向会发生改变，是一个<code>中间类</code>而不是<code>真正的类</code>。我们不能根据<code>isa</code>指针确定类的成员身份，而是用哪个<code>class</code>方法确定。</p>
<h4 id="中间类是什么"><a href="#中间类是什么" class="headerlink" title="中间类是什么"></a><code>中间类</code>是什么</h4><p>看苹果官网文档我们了解了，<code>KVO</code>的实现时通过修改<code>isa</code>指针指向了一个<code>中间类</code>实现的，我们使用<code>lldb</code>探究一下<code>中间类</code>是什么。</p>
<ul>
<li><p>添加观察者之前，我们打印实例对象<code>person</code>的方法是<code>JSPerson</code>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) <span class="function">po <span class="title">object_getClassName</span><span class="params">(self.person)</span></span></span><br><span class="line">"JSPerson"</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加观察者之后，我们打印实例对象<code>person</code>的方法是<code>NSKVONotifying_JSPerson</code>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) <span class="function">po <span class="title">object_getClassName</span><span class="params">(self.person)</span></span></span><br><span class="line">"NSKVONotifying_JSPerson"</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>通过上面的调试，我们看到添加观察者值<code>isa</code>指向了一个名为<code>&quot;NSKVONotifying_JSPerson</code>的中间类。关于这个<code>中间类</code>我们有几个点需要研究一下。</p>
<ol>
<li><p><code>中间类</code>和之前的类是父子类关系吗</p>
<p>我们通过一个方法来判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 遍历类以及子类</span><br><span class="line">- (void)printClasses:(Class)cls&#123;</span><br><span class="line">    &#x2F;&#x2F; 注册类的总数</span><br><span class="line">    int count &#x3D; objc_getClassList(NULL, 0);</span><br><span class="line">    &#x2F;&#x2F; 创建一个数组， 其中包含给定对象</span><br><span class="line">    NSMutableArray *mArray &#x3D; [NSMutableArray arrayWithObject:cls];</span><br><span class="line">    &#x2F;&#x2F; 获取所有已注册的类</span><br><span class="line">    Class* classes &#x3D; (Class*)malloc(sizeof(Class)*count);</span><br><span class="line">    objc_getClassList(classes, count);</span><br><span class="line">    for (int i &#x3D; 0; i&lt;count; i++) &#123;</span><br><span class="line">        if (cls &#x3D;&#x3D; class_getSuperclass(classes[i])) &#123;</span><br><span class="line">            [mArray addObject:classes[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(classes);</span><br><span class="line">    NSLog(@&quot;classes &#x3D; %@&quot;, mArray);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;********以下为调用********</span><br><span class="line">[self printClasses:[JSPerson class]];</span><br></pre></td></tr></table></figure>

<p>打印结果为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">classes = (</span><br><span class="line">    JSPerson,</span><br><span class="line">    <span class="string">"NSKVONotifying_JSPerson"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>通过打印结果我们可以判断中间类<code>NSKVONotifying_JSPerson</code>是<code>JSPerson</code>的子类。</p>
</li>
<li><p>中间类里有什么方法。</p>
<p>同样，我们定义一个方法获取<code>NSKVONotifying_JSPerson</code>的所有方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 遍历方法-ivar-property</span><br><span class="line">- (void)printClassAllMethod:(Class)cls&#123;</span><br><span class="line">    unsigned int count &#x3D; 0;</span><br><span class="line">    Method *methodList &#x3D; class_copyMethodList(cls, &amp;count);</span><br><span class="line">    for (int i &#x3D; 0; i&lt;count; i++) &#123;</span><br><span class="line">        Method method &#x3D; methodList[i];</span><br><span class="line">        SEL sel &#x3D; method_getName(method);</span><br><span class="line">        IMP imp &#x3D; class_getMethodImplementation(cls, sel);</span><br><span class="line">        NSLog(@&quot;%@-%p&quot;,NSStringFromSelector(sel),imp);</span><br><span class="line">    &#125;</span><br><span class="line">    free(methodList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;********以下为调用********</span><br><span class="line">[self printClassAllMethod:objc_getClass(&quot;NSKVONotifying_JSPerson&quot;)];</span><br></pre></td></tr></table></figure>

<p>打印结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setNickName:<span class="number">-0x7fff207bbb57</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>-0<span class="title">x7fff207ba662</span></span></span><br><span class="line"><span class="class"><span class="title">dealloc</span>-0<span class="title">x7fff207ba40b</span></span></span><br><span class="line"><span class="class">_<span class="title">isKVOA</span>-0<span class="title">x7fff207ba403</span></span></span><br></pre></td></tr></table></figure>

<p>我们看到一共有四个方法</p>
<ul>
<li>重写了父类的<code>setNickName</code>方法</li>
<li>重写了根类的<code>class</code>、<code>dealloc</code>方法</li>
<li><code>_isKVO</code>方法，用来判断是否是<code>kvo</code>类</li>
</ul>
</li>
<li><p>dealloc中移除观察者后，isa会指回来吗</p>
<ul>
<li><p>移除观察者之前，我们用<code>lldb</code>打印</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) <span class="function">po <span class="title">object_getClassName</span><span class="params">(self.person)</span></span></span><br><span class="line">"NSKVONotifying_JSPerson"</span><br></pre></td></tr></table></figure>
</li>
<li><p>移除观察者之后，我们重新打印</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) <span class="function">po <span class="title">object_getClassName</span><span class="params">(self.person)</span></span></span><br><span class="line">"JSPerson"</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>说明的确是在移除观察的时候将<code>isa</code>指回来的。</p>
</li>
<li><p>移除观察后中间类会销毁吗</p>
<p>我们返回前一个页面，此时添加观察者的VC已经销毁，我们打印<code>JSPerson</code>的子类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self printClasses:[JSPerson class]];</span><br></pre></td></tr></table></figure>

<p>打印结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">classes = (</span><br><span class="line">    JSPerson,</span><br><span class="line">    <span class="string">"NSKVONotifying_JSPerson"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>发现子类并不会被销毁。</p>
</li>
</ol>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>实例对象<code>isa</code>的指向<code>在添加KVO观察者之后</code>，由<code>原有类</code>更改为<code>指向中间类</code></li>
<li><code>中间类</code>重写了观察<code>属性的setter方法</code>、<code>class</code>、<code>dealloc</code>、<code>_isKVOA</code>方法</li>
<li><code>dealloc</code>方法中，移除KVO观察者之后，实例对象<code>isa</code>指向由<code>中间类</code>更改为<code>原有类</code></li>
<li><code>中间类</code>从创建后，就一直<code>存在内存中，不会被销毁</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/07/26/Flutter-IneritedWidget/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/26/Flutter-IneritedWidget/" class="post-title-link" itemprop="url">Flutter-InheritedWidget</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-26 10:41:49" itemprop="dateCreated datePublished" datetime="2021-07-26T10:41:49+08:00">2021-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-30 15:06:34" itemprop="dateModified" datetime="2021-07-30T15:06:34+08:00">2021-07-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/07/25/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-KVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/25/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-KVC/" class="post-title-link" itemprop="url">iOS底层探索-KVC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-25 11:04:54 / 修改时间：16:26:44" itemprop="dateCreated datePublished" datetime="2021-07-25T11:04:54+08:00">2021-07-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>KVC</code>的全拼是<code>Key-Value Coding</code>,中文是<code>键值编码</code>。是由<code>NSKeyValueCoding</code>非正式协议的一种机制。对象可以间接地访问它们的属性。这种间接访问机制是实例变量及其相关访问器方法提供的直接访问的补充。</p>
<h3 id="使用KVC"><a href="#使用KVC" class="headerlink" title="使用KVC"></a>使用<code>KVC</code></h3><h4 id="通过key取值和设置值"><a href="#通过key取值和设置值" class="headerlink" title="通过key取值和设置值"></a>通过<code>key</code>取值和设置值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;直接通过Key来取值</span><br><span class="line">- (nullable id)valueForKey:(NSString *)key;</span><br><span class="line">&#x2F;&#x2F;通过Key来设值</span><br><span class="line">- (void)setValue:(nullable id)value forKey:(NSString *)key;</span><br></pre></td></tr></table></figure>

<h4 id="通过keyPath（路由）取值和设置值"><a href="#通过keyPath（路由）取值和设置值" class="headerlink" title="通过keyPath（路由）取值和设置值"></a>通过<code>keyPath</code>（路由）取值和设置值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通过KeyPath来取值</span><br><span class="line">- (nullable id)valueForKeyPath:(NSString *)keyPath; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过KeyPath来设值                 </span><br><span class="line">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure>

<p>我们平时项目中主要是通过使用的是<code>valueForKey</code>和<code>valueForKeyPath</code>的方式取值和设值，当然还有<code>集合类型</code>的一些操作可以参见<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107-SW1" target="_blank" rel="noopener">苹果KVC的文档</a>查看使用。</p>
<h3 id="KVC的设值过程"><a href="#KVC的设值过程" class="headerlink" title="KVC的设值过程"></a><code>KVC</code>的设值过程</h3><p><code>setValue:forKey:</code>这个方法有一个调用顺序(基本数据类型)：</p>
<ul>
<li>按顺序查找名为 set<Key>: 或 _set<Key> 的第一个访问器。如果找到，则使用输入值（或根据需要展开的值）调用它并完成。</li>
<li>如果未找到简单访问器，并且类方法 accessInstanceVariablesDirectly 返回 YES，则按顺序查找名称类似于 _<key>、_is<Key>、<key> 或 is<Key> 的实例变量。如果找到，直接使用输入值（或解包值）设置变量并完成。</li>
<li>在未找到访问器或实例变量时，调用 setValue:forUndefinedKey:。默认情况下，这会引发异常，但 NSObject 的子类可能会提供特定于键的行为。</li>
</ul>
<p>整个流程图如下(以<code>person</code>对象设置<code>name</code>属性为例)：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fafa22458d84357afcda544590fc1e1~tplv-k3u1fbpfcp-watermark.image" alt="kvc取值流程"></p>
<h3 id="KVC取值过程"><a href="#KVC取值过程" class="headerlink" title="KVC取值过程"></a><code>KVC</code>取值过程</h3><p>和设值过程一样，取值过程<code>valueForKey:</code>也有一个调用顺序(包含集合类型)：</p>
<ul>
<li>在实例中搜索找到的第一个访问器方法，其名称类似于 get<Key>、<key>、is<Key> 或 _<key>，按该顺序。如果找到，则调用它并使用结果继续执行步骤 5。否则继续下一个步骤</li>
<li>如果没有找到简单的访问器方法，则在实例中搜索名称与模式 countOf<Key> 和 objectIn<Key>AtIndex:（对应于 NSArray 类定义的原始方法）和 <key>AtIndexes:（对应于模式）的方法NSArray 方法 objectsAtIndexes:)。如果找到其中的第一个和至少其他两个中的一个，则创建一个集合代理对象，该对象响应所有 NSArray 方法并返回该对象。否则，继续执行步骤 3。代理对象随后将它接收到的任何 NSArray 消息转换为 countOf<Key>、objectIn<Key>AtIndex: 和 <key>AtIndexes: 消息的某种组合，并将其转换为创建它的键值编码兼容对象。如果原始对象还实现了一个可选方法，其名称类似于 get<Key>:range:，则代理对象也会在适当的时候使用它。实际上，代理对象与键值编码兼容对象一起工作允许底层属性表现得好像它是一个 NSArray，即使它不是。</li>
<li>如果没有找到简单的访问器方法或数组访问方法组，则查找名为 countOf<Key>、enumeratorOf<Key> 和 memberOf<Key> 的三元组方法：（对应于 NSSet 类定义的原始方法）。如果找到所有三个方法，则创建一个集合代理对象，该对象响应所有 NSSet 方法并返回该对象。否则，继续执行步骤 4。这个代理对象随后将它接收到的任何 NSSet 消息转换为 countOf<Key>、enumeratorOf<Key> 和 memberOf<Key> 的某种组合：消息到创建它的对象。实际上，与键值编码兼容的对象一起工作的代理对象允许底层属性表现得好像它是一个 NSSet，即使它不是。</li>
<li>如果没有找到简单的访问器方法或集合访问方法组，并且如果接收者的类方法accessInstanceVariables直接返回YES，则搜索名为_<key>、_is<Key>、<key>或is<Key>的实例变量，以该顺序。如果找到，直接获取实例变量的值并进行步骤5，否则进行步骤6。</li>
<li>如果检索到的属性值是一个对象指针，只需返回结果即可。 如果该值是 NSNumber 支持的标量类型，则将其存储在 NSNumber 实例中并返回。 如果结果是 NSNumber 不支持的标量类型，则转换为 NSValue 对象并返回。</li>
<li>如果所有其他方法都失败，请调用 valueForUndefinedKey:。默认情况下，这会引发异常，但 NSObject 的子类可能会提供特定于键的行为。</li>
</ul>
<p>其流程图如下：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21604d5aa0e64c64a2f038d4436db4f8~tplv-k3u1fbpfcp-watermark.image" alt="KVC取值过程"></p>
<h3 id="自定义实现KVC"><a href="#自定义实现KVC" class="headerlink" title="自定义实现KVC"></a>自定义实现KVC</h3><p>如果自己实现一个<code>KVC</code>可以参考上面的顺序，实现<code>valueForKey</code>和<code>setValueForKey</code>。</p>
<h4 id="设值过程"><a href="#设值过程" class="headerlink" title="设值过程"></a>设值过程</h4><ul>
<li>判断<code>key</code>是否为空，为空直接返回。</li>
<li>查找是否有 setter方法 <code>set&lt;Key&gt;:</code> ， <code>_set&lt;Key&gt;</code>, <code>setIs&lt;Key&gt;</code>，如果有则实现并返回。</li>
<li>如果没找到则判断accessInstanceVariablesDirectly的返回值是否为YES，可以则往下走，否则抛出异常。</li>
<li>查找自己的ivar列表中是否包含实例变量 <code>_&lt;key&gt;</code>, <code>_is&lt;Key&gt;</code>,<code>&lt;key&gt;</code>,<code>is&lt;Key&gt;</code>,找到就赋值。</li>
<li>如果都搜索不到，就抛出异常。</li>
</ul>
<p>实现代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">- (void)js_setValue:(nullable id)value forKey:(NSString *)key&#123;</span><br><span class="line">    &#x2F;&#x2F; 空判断</span><br><span class="line">    if (key &#x3D;&#x3D; nil || key.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 2: setter set&lt;Key&gt;: or _set&lt;Key&gt;,</span><br><span class="line">    &#x2F;&#x2F; key 要大写</span><br><span class="line">    NSString *Key &#x3D; key.capitalizedString;</span><br><span class="line">    &#x2F;&#x2F; 拼接方法</span><br><span class="line">    NSString *setKey &#x3D; [NSString stringWithFormat:@&quot;set%@:&quot;,Key];</span><br><span class="line">    NSString *_setKey &#x3D; [NSString stringWithFormat:@&quot;_set%@:&quot;,Key];</span><br><span class="line">    NSString *setIsKey &#x3D; [NSString stringWithFormat:@&quot;setIs%@:&quot;,Key];</span><br><span class="line">    </span><br><span class="line">    if ([self js_performSelectorWithMethodName:setKey value:value]) &#123;</span><br><span class="line">        NSLog(@&quot;*********%@**********&quot;,setKey);</span><br><span class="line">        return;</span><br><span class="line">    &#125;else if ([self js_performSelectorWithMethodName:_setKey value:value]) &#123;</span><br><span class="line">        NSLog(@&quot;*********%@**********&quot;,_setKey);</span><br><span class="line">        return;</span><br><span class="line">    &#125;else if ([self js_performSelectorWithMethodName:setIsKey value:value]) &#123;</span><br><span class="line">        NSLog(@&quot;*********%@**********&quot;,setIsKey);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 3: 判断是否响应 accessInstanceVariablesDirectly 返回YES NO 奔溃</span><br><span class="line">    &#x2F;&#x2F; 3:判断是否能够直接赋值实例变量</span><br><span class="line">    if (![self.class accessInstanceVariablesDirectly] ) &#123;</span><br><span class="line">        @throw [NSException exceptionWithName:@&quot;JSUnknownKeyException&quot; reason:[NSString stringWithFormat:@&quot;****[%@ valueForUndefinedKey:]: this class is not key value coding-compliant for the key name.****&quot;,self] userInfo:nil];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 4: 间接变量</span><br><span class="line">    &#x2F;&#x2F; 获取 ivar -&gt; 遍历 containsObjct -</span><br><span class="line">    &#x2F;&#x2F; 4.1 定义一个收集实例变量的可变数组</span><br><span class="line">    NSMutableArray *mArray &#x3D; [self getIvarListName];</span><br><span class="line">    &#x2F;&#x2F; _&lt;key&gt; _is&lt;Key&gt; &lt;key&gt; is&lt;Key&gt;</span><br><span class="line">    NSString *_key &#x3D; [NSString stringWithFormat:@&quot;_%@&quot;,key];</span><br><span class="line">    NSString *_isKey &#x3D; [NSString stringWithFormat:@&quot;_is%@&quot;,Key];</span><br><span class="line">    NSString *isKey &#x3D; [NSString stringWithFormat:@&quot;is%@&quot;,Key];</span><br><span class="line">    if ([mArray containsObject:_key]) &#123;</span><br><span class="line">        &#x2F;&#x2F; 4.2 获取相应的 ivar</span><br><span class="line">       Ivar ivar &#x3D; class_getInstanceVariable([self class], _key.UTF8String);</span><br><span class="line">        &#x2F;&#x2F; 4.3 对相应的 ivar 设置值</span><br><span class="line">       object_setIvar(self , ivar, value);</span><br><span class="line">       return;</span><br><span class="line">    &#125;else if ([mArray containsObject:_isKey]) &#123;</span><br><span class="line">       Ivar ivar &#x3D; class_getInstanceVariable([self class], _isKey.UTF8String);</span><br><span class="line">       object_setIvar(self , ivar, value);</span><br><span class="line">       return;</span><br><span class="line">    &#125;else if ([mArray containsObject:key]) &#123;</span><br><span class="line">       Ivar ivar &#x3D; class_getInstanceVariable([self class], key.UTF8String);</span><br><span class="line">       object_setIvar(self , ivar, value);</span><br><span class="line">       return;</span><br><span class="line">    &#125;else if ([mArray containsObject:isKey]) &#123;</span><br><span class="line">       Ivar ivar &#x3D; class_getInstanceVariable([self class], isKey.UTF8String);</span><br><span class="line">       object_setIvar(self , ivar, value);</span><br><span class="line">       return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 5:如果找不到相关实例</span><br><span class="line">    @throw [NSException exceptionWithName:@&quot;JSUnknownKeyException&quot; reason:[NSString stringWithFormat:@&quot;****[%@ %@]: this class is not key value coding-compliant for the key name.****&quot;,self,NSStringFromSelector(_cmd)] userInfo:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="取值过程"><a href="#取值过程" class="headerlink" title="取值过程"></a>取值过程</h4><ul>
<li>同样是判断key非空</li>
<li>按顺序查找方法：<code>get&lt;Key&gt;</code>、 <code>&lt;key&gt;</code>、<code>countOf&lt;Key&gt;</code>、 <code>objectIn&lt;Key&gt;AtIndex</code></li>
<li>判断accessInstanceVariablesDirectly的返回值是否为YES，可以则往下走，否则抛出异常。</li>
<li>查找自己的ivar列表中是否包含实例变量 <code>_&lt;key&gt;</code>, <code>_is&lt;Key&gt;</code>,<code>&lt;key&gt;</code>,<code>is&lt;Key&gt;</code>,找到就取值。</li>
<li>未找到抛出异常。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)js_valueForKey:(NSString *)key&#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 1:判断非空</span><br><span class="line">    if (key &#x3D;&#x3D; nil  || key.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 2:找到相关方法 get&lt;Key&gt; &lt;key&gt; countOf&lt;Key&gt;  objectIn&lt;Key&gt;AtIndex</span><br><span class="line">    &#x2F;&#x2F; key 要大写</span><br><span class="line">    NSString *Key &#x3D; key.capitalizedString;</span><br><span class="line">    &#x2F;&#x2F; 拼接方法</span><br><span class="line">    NSString *getKey &#x3D; [NSString stringWithFormat:@&quot;get%@&quot;,Key];</span><br><span class="line">    NSString *countOfKey &#x3D; [NSString stringWithFormat:@&quot;countOf%@&quot;,Key];</span><br><span class="line">    NSString *objectInKeyAtIndex &#x3D; [NSString stringWithFormat:@&quot;objectIn%@AtIndex:&quot;,Key];</span><br><span class="line">        </span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">    if ([self respondsToSelector:NSSelectorFromString(getKey)]) &#123;</span><br><span class="line">        return [self performSelector:NSSelectorFromString(getKey)];</span><br><span class="line">    &#125;else if ([self respondsToSelector:NSSelectorFromString(key)])&#123;</span><br><span class="line">        return [self performSelector:NSSelectorFromString(key)];</span><br><span class="line">    &#125;else if ([self respondsToSelector:NSSelectorFromString(countOfKey)])&#123;</span><br><span class="line">        if ([self respondsToSelector:NSSelectorFromString(objectInKeyAtIndex)]) &#123;</span><br><span class="line">            int num &#x3D; (int)[self performSelector:NSSelectorFromString(countOfKey)];</span><br><span class="line">            NSMutableArray *mArray &#x3D; [NSMutableArray arrayWithCapacity:1];</span><br><span class="line">            for (int i &#x3D; 0; i&lt;num-1; i++) &#123;</span><br><span class="line">                num &#x3D; (int)[self performSelector:NSSelectorFromString(countOfKey)];</span><br><span class="line">            &#125;</span><br><span class="line">            for (int j &#x3D; 0; j&lt;num; j++) &#123;</span><br><span class="line">                id objc &#x3D; [self performSelector:NSSelectorFromString(objectInKeyAtIndex) withObject:@(num)];</span><br><span class="line">                [mArray addObject:objc];</span><br><span class="line">            &#125;</span><br><span class="line">            return mArray;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 3:判断是否能够直接赋值实例变量</span><br><span class="line">    if (![self.class accessInstanceVariablesDirectly] ) &#123;</span><br><span class="line">        @throw [NSException exceptionWithName:@&quot;JSUnknownKeyException&quot; reason:[NSString stringWithFormat:@&quot;****[%@ valueForUndefinedKey:]: this class is not key value coding-compliant for the key name.****&quot;,self] userInfo:nil];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 4.找相关实例变量进行赋值</span><br><span class="line">    &#x2F;&#x2F; 4.1 定义一个收集实例变量的可变数组</span><br><span class="line">    NSMutableArray *mArray &#x3D; [self getIvarListName];</span><br><span class="line">    &#x2F;&#x2F; _&lt;key&gt; _is&lt;Key&gt; &lt;key&gt; is&lt;Key&gt;</span><br><span class="line">    &#x2F;&#x2F; _name -&gt; _isName -&gt; name -&gt; isName</span><br><span class="line">    NSString *_key &#x3D; [NSString stringWithFormat:@&quot;_%@&quot;,key];</span><br><span class="line">    NSString *_isKey &#x3D; [NSString stringWithFormat:@&quot;_is%@&quot;,Key];</span><br><span class="line">    NSString *isKey &#x3D; [NSString stringWithFormat:@&quot;is%@&quot;,Key];</span><br><span class="line">    if ([mArray containsObject:_key]) &#123;</span><br><span class="line">        Ivar ivar &#x3D; class_getInstanceVariable([self class], _key.UTF8String);</span><br><span class="line">        return object_getIvar(self, ivar);;</span><br><span class="line">    &#125;else if ([mArray containsObject:_isKey]) &#123;</span><br><span class="line">        Ivar ivar &#x3D; class_getInstanceVariable([self class], _isKey.UTF8String);</span><br><span class="line">        return object_getIvar(self, ivar);;</span><br><span class="line">    &#125;else if ([mArray containsObject:key]) &#123;</span><br><span class="line">        Ivar ivar &#x3D; class_getInstanceVariable([self class], key.UTF8String);</span><br><span class="line">        return object_getIvar(self, ivar);;</span><br><span class="line">    &#125;else if ([mArray containsObject:isKey]) &#123;</span><br><span class="line">        Ivar ivar &#x3D; class_getInstanceVariable([self class], isKey.UTF8String);</span><br><span class="line">        return object_getIvar(self, ivar);;</span><br><span class="line">    &#125;</span><br><span class="line">    return @&quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇我们主要探索了KVC的<code>取值</code>和<code>设值</code>的流程。设值过程<code>集合</code>类型的情况没有写，感兴趣的童鞋可以查看苹果<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107-SW1" target="_blank" rel="noopener">官方文档</a>进行探索。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/07/22/Objective-c%E5%BA%95%E5%B1%82%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/22/Objective-c%E5%BA%95%E5%B1%82%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">Objective-C底层面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-22 20:15:48" itemprop="dateCreated datePublished" datetime="2021-07-22T20:15:48+08:00">2021-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-25 11:04:14" itemprop="dateModified" datetime="2021-07-25T11:04:14+08:00">2021-07-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>oc</code>底层探索了很多了，今天主要总结一下一些相关的面试题。</p>
<h3 id="load方法什么时候调用。"><a href="#load方法什么时候调用。" class="headerlink" title="load方法什么时候调用。"></a><code>load</code>方法什么时候调用。</h3><p>这个问题很多同学应该都知道，就是<code>main</code>函数之前，但是<code>main</code>之前的哪一步执行的，可能有些同学就疑惑了，，同时还有一个方法的调用时机也会被经常问到就是<code>initialize</code>,我们分别讨论。</p>
<h4 id="load方法"><a href="#load方法" class="headerlink" title="load方法"></a><code>load</code>方法</h4><ul>
<li><code>load</code>方法是在应用程序加载过程中调用的，确实是在<code>main</code>函数之前调用。</li>
<li>具体是<code>_dyld_objc_notify_register</code>方法的第二个参数<code>load_images</code>回调的。</li>
<li>通过<code>prepare_load_methods</code>递归查找<code>load</code>方法添加到一个<code>load</code>方法的加载表<code>loadable_classes</code>里，注意父类会比子类先加入到表中，查找完类的<code>load</code>方法之后，查找分类的<code>load</code>也会添加到一个<code>loadable_categories</code>表中。</li>
<li>最后是<code>call_load_methods</code>调用<code>load</code>方法，先从<code>loadable_classes</code>表里循环调用类的<code>load</code>方法，然后从<code>loadable_categories</code>表里循环调用分类的<code>load</code>方法。</li>
<li>因为是顺序遍历表调用<code>load</code>方法的。所以<code>load</code>方法的调用次序是<code>父类</code>&gt;<code>本类</code>&gt;<code>分类</code>。</li>
<li>如果有多个分类都有<code>load</code>方法，其调用顺序会根据编译的顺序调用。编译顺序可以在<code>Compiles Sources</code>里调整。</li>
<li><code>load</code>方法过多会影响到应用的启动速度。</li>
</ul>
<h4 id="initialize方法。"><a href="#initialize方法。" class="headerlink" title="initialize方法。"></a><code>initialize</code>方法。</h4><ul>
<li><code>initialize</code>方法是在第一次<code>objc_msgSend</code>的时候调用的，它的调用时机晚于<code>load</code>。</li>
<li>分类的方法是在类<code>realize</code>之后<code>attachCategorys</code>进去的，会在类的方法前面。如果分类实现了<code>initialize</code>方法，会优先调用分类的方法。</li>
</ul>
<h3 id="Runtime是什么"><a href="#Runtime是什么" class="headerlink" title="Runtime是什么"></a><code>Runtime</code>是什么</h3><ul>
<li><code>runtime</code>是由<code>c</code>、<code>c++</code>、<code>汇编</code>实现的一套<code>API</code>,为<code>oc</code>语言加入面向对象运行时功能。</li>
<li><code>运行时</code>是指讲数据类型的确定有<code>编译时</code>推迟到了<code>运行时</code>。</li>
<li>我们写的<code>oc</code>代码，在程序运行过程中，最终都会转换成<code>runtime</code>的<code>c</code>语言代码。</li>
</ul>
<h3 id="⽅法的本质，sel是什么？IMP是什么？两者之间的关系是什么"><a href="#⽅法的本质，sel是什么？IMP是什么？两者之间的关系是什么" class="headerlink" title="⽅法的本质，sel是什么？IMP是什么？两者之间的关系是什么"></a>⽅法的本质，<code>sel</code>是什么？<code>IMP</code>是什么？两者之间的关系是什么</h3><h4 id="⽅法的本质"><a href="#⽅法的本质" class="headerlink" title="⽅法的本质"></a>⽅法的本质</h4><p>⽅法的本质是消息发送，即<code>objc_msgSend</code>,它的流程是：</p>
<ul>
<li>快速查找 （<code>objc_msgSend</code>）~ <code>cache_t</code> 缓存消息</li>
<li>慢速查找~ 递归⾃⼰或⽗类 ~ <code>lookUpImpOrForward</code></li>
<li>查找不到消息: 动态⽅法解析 ~ <code>resolveInstanceMethod</code></li>
<li>消息快速转发 ~ <code>forwardingTargetForSelector</code></li>
<li>消息慢速转发 ~ <code>methodSignatureForSelector</code> 和 <code>forwardInvocation</code></li>
</ul>
<h4 id="sel是什么"><a href="#sel是什么" class="headerlink" title="sel是什么"></a><code>sel</code>是什么</h4><p><code>sel</code>是⽅法编号，在<code>read_images</code>期间就加载进⼊了内存。它实际是<code>objc_selector</code>结构体。</p>
<h4 id="IMP是什么"><a href="#IMP是什么" class="headerlink" title="IMP是什么"></a><code>IMP</code>是什么</h4><p><code>imp</code>就是我们函数实现指针，找<code>imp</code>就是找函数实现的过程。</p>
<h4 id="sel与IMP的关系"><a href="#sel与IMP的关系" class="headerlink" title="sel与IMP的关系"></a><code>sel</code>与<code>IMP</code>的关系</h4><ul>
<li><code>sel</code>就相当于书本的⽬录<code>title</code></li>
<li><code>imp</code>就是书本的⻚码</li>
<li>方法调用的时候首先根据<code>sel</code>找到<code>imp</code>最后到具体函数的实现，完成调用。</li>
</ul>
<h3 id="能否向编译后的类中增加实例变量？能否向运⾏时创建的类中添加实例变量？"><a href="#能否向编译后的类中增加实例变量？能否向运⾏时创建的类中添加实例变量？" class="headerlink" title="能否向编译后的类中增加实例变量？能否向运⾏时创建的类中添加实例变量？"></a>能否向编译后的类中增加实例变量？能否向运⾏时创建的类中添加实例变量？</h3><ul>
<li><p>不能向编译后的得到的类中增加实例变量：</p>
<ul>
<li>我们编译好的实例变量存储的位置在<code>ro</code>（read only），⼀旦编译完成，内存结构就完全确定。</li>
<li>我们可以通过<code>分类</code>向类中添加<code>方法</code>和<code>属性</code>(通过关联对象)。</li>
</ul>
</li>
<li><p>可以向运行时创建的类中添加实例变量，只要类没有注册到内存还是可以添加。</p>
<p>这里<code>运行时创建的类</code>指的是通过<code>objc_allocateClassPair</code>方法，创建的<code>类</code>,在调用<code>objc_registerClassPair</code>方法之前是可以添加<code>实例变量</code>的。</p>
</li>
</ul>
<h3 id="self-class-和-super-class-区别"><a href="#self-class-和-super-class-区别" class="headerlink" title="[self class]和[super class]区别"></a>[self class]和[super class]区别</h3><p>先定义两个类<code>JSPerson</code>和<code>JSStudent</code>,其中<code>JSStudent</code>继承于<code>JSPerson</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@interface JSPerson : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">#import &quot;JSPerson.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation JSPerson</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface JSStudent : JSPerson</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation JSStudent</span><br><span class="line"></span><br><span class="line">- (instancetype)init&#123;</span><br><span class="line">    self &#x3D; [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        NSLog(@&quot;%@ - %@&quot;,[self class],[super class]);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>在<code>main</code>函数里实例化一个<code>JSStudent</code>对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        JSStudent *student &#x3D; [[JSStudent alloc] init];;</span><br><span class="line">        NSLog(@&quot;%@&quot;,student);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现打印结果为<code>JSStudent - JSStudent</code>。这是为什么呢，我们下面分析一下。</p>
<p>首先，<code>JSPerson</code>和<code>JSStudent</code>类都没有实现<code>class</code>方法，根据消息发送查找流程，会调用<code>NSObject</code>类的<code>class</code>方法，它的实现为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (Class)<span class="class"><span class="keyword">class</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> object_getClass(self);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据isa找到类</span></span><br><span class="line"><span class="function">Class <span class="title">object_getClass</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) <span class="keyword">return</span> obj-&gt;getIsa();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>class</code>方法的作用是返回当前的类，<code>self</code>是调用的对象也就是<code>student</code>实例。</p>
<ul>
<li><p><code>[self class]</code>打印的是<code>JSStudent</code>很好理解，因为消息接受者就是<code>JSStudent</code>的实例对象，通过<code>isa</code>找到的就是<code>JSStudent</code>类。</p>
</li>
<li><p><code>[super class]</code>打印的也是<code>JSStudent</code>就让人困惑了，我们打开<code>汇编调试</code>看一下<code>[super class]</code>的底层调用了什么</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32b236096024497cb3c8e4345f302f03~tplv-k3u1fbpfcp-watermark.image" alt="WechatIMG1246"></p>
<p><code>[super class]</code>实际调用的是<code>objc_msgSendSuper2</code>方法，我们在源码看一下这个方法的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc_msgSendSuper2() takes the current search class, not its superclass.</span></span><br><span class="line">OBJC_EXPORT id _Nullable</span><br><span class="line">objc_msgSendSuper2(struct objc_super * _Nonnull super, SEL _Nonnull op, ...)</span><br><span class="line">    OBJC_AVAILABLE(<span class="number">10.6</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br></pre></td></tr></table></figure>

<p>其实看<code>objc_msgSendSuper2</code>的注释就可以看出来，方法查找的是<code>本类</code>而不是它的<code>父类</code>。</p>
<p>继续看，<code>super</code>是方法的第一个参数，也就是<code>objc_super *</code>它的结构是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_super</span> &#123;</span></span><br><span class="line">    <span class="comment">/// Specifies an instance of a class.</span></span><br><span class="line">    __unsafe_unretained _Nonnull id receiver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Specifies the particular superclass of the instance to message. </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span></span><br><span class="line">    <span class="comment">/* For compatibility with old objc-runtime.h header */</span></span><br><span class="line">  	<span class="comment">///old结构，我们可以忽略 !__OBJC2__使用</span></span><br><span class="line">    __unsafe_unretained _Nonnull Class <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    __unsafe_unretained _Nonnull Class super_class;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* super_class is the first class to search */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>objc_super</code>的成员变量有<code>receiver</code>它是当前的调用的实例也就是<code>student</code>,<code>super_class</code>是当前实例对象的类的<code>父类</code>。所以说<code>[super class]</code>的消息接受者<code>self</code>还是<code>student</code>,所以打印的是<code>JSStudent</code>，<code>super</code>是一个关键字。</p>
<h3 id="内存平移问题"><a href="#内存平移问题" class="headerlink" title="内存平移问题"></a>内存平移问题</h3><p>案例说明:<code>JSPerson</code>类中有一个<code>saySomething</code>方法，在<code>ViewController</code>类的<code>viewDidLoad</code>通过两种方式调用，详细看代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@implementation JSPerson</span><br><span class="line">- (void)saySomething&#123;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    &#x2F;&#x2F; Do any additional setup after loading the view.</span><br><span class="line">    JSPerson *person &#x3D; [JSPerson alloc];</span><br><span class="line">    [person saySomething];</span><br><span class="line">    </span><br><span class="line">    Class cls &#x3D; [JSPerson class];</span><br><span class="line">    void  *js &#x3D; &amp;cls;</span><br><span class="line">    [(__bridge id)js saySomething];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>问题是这两个调用<code>saySomething</code>的语句是否有问题。</p>
<ul>
<li><p><code>[person saySomething]</code>：这种方式没什么疑问，正常的方法调用。它的流程是通过<code>person</code>对象的<code>isa</code>指针找到类<code>JSPerson</code>,首先通过内存平移找到<code>cache</code>里查找，如果找不到，继续平移找到<code>bits</code>查找方法列表查找，最后找到<code>imp</code>调用。</p>
</li>
<li><p><code>[(__bridge id)js saySomething]</code>:运行代码，我们这一行代码也正常执行了，原因是什么呢</p>
<p><code>void  *js = &amp;cls;</code>说明<code>js</code>是一个指向<code>JSPerson</code>类首地址的指针，它和对象的<code>isa</code>指向的是同一个地址，通过内存平移也可以找到对应的方法。</p>
</li>
</ul>
<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>在<code>saySomething</code>方法里增加属性<code>self.js_name</code> 的打印,其他不变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@interface JSPerson : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSString *js_name;</span><br><span class="line"></span><br><span class="line">- (void)saySomething;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation JSPerson</span><br><span class="line">- (void)saySomething&#123;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;%s - %@&quot;,__func__,self.js_name);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>再次运行程序发现打印结果为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-[JSPerson saySomething] - (null)</span><br><span class="line">-[JSPerson saySomething] - &lt;JSPerson: <span class="number">0x600003a00380</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>[person saySomething]</code>：因为我们没有对<code>js_name</code>赋值，<code>[person saySomething]</code>打印<code>(null)</code>正常。</p>
</li>
<li><p><code>[(__bridge id)js saySomething]</code>：这里打印了<code>&lt;JSPerson: 0x600003a00380&gt;</code>很困惑。</p>
<p>我们首先要清楚<code>self.js_name</code>是怎么找到<code>js_name</code>并打印的，它是从<code>person</code>内存地址中平移8位(<code>isa</code>是8位)找到第一个属性<code>js_name</code>。</p>
<p>类比<code>js</code>也需要平移8位找<code>js_name</code>,由于<code>js</code>是一个指针，存在<code>栈</code>上的，栈是一个<code>先进后出</code>的数据结构，每次参数传入就会压栈。</p>
<ul>
<li><p>其中<code>隐藏参数会压入栈</code>，且每个函数都会有两个隐藏参数<code>(id self，sel _cmd)</code>，这个我们前面探索过，可以通过<code>clang</code>将<code>oc</code>代码转成<code>c++</code>代码查看。</p>
</li>
<li><p><code>隐藏参数压栈</code>的过程，其地址是<code>递减</code>的，而<code>栈是从高地址-&gt;低地址 分配</code>的，即<code>在栈中，参数会从前往后一直压</code></p>
</li>
<li><p>前面还有一行<code>[super viewDidLoad];</code>,<code>super</code>调用的压栈我们也需要研究一下，其实上一题我们研究过它实际调用的是<code>objc_msgSendSuper2</code>,有两个参数<code>_objc_super</code>和<code>sel</code>。结构体的属性的压栈我们通过自定义一个结构体探索</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct js_struct&#123;</span><br><span class="line">    NSNumber *num1;</span><br><span class="line">    NSNumber *num2;</span><br><span class="line">&#125; js_struct;</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    &#x2F;&#x2F; Do any additional setup after loading the view.</span><br><span class="line">    JSPerson *person1 &#x3D; [JSPerson alloc];</span><br><span class="line">    struct js_struct jst &#x3D; &#123;@(1),@(3)&#125;;</span><br><span class="line">    JSPerson *person &#x3D; [JSPerson alloc];</span><br><span class="line">    [person saySomething];</span><br><span class="line">    </span><br><span class="line">    Class cls &#x3D; [JSPerson class];</span><br><span class="line">    void  *js &#x3D; &amp;cls;</span><br><span class="line">    [(__bridge id)js saySomething];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在图示位置添加断点调试</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/900abebd0f814bdb9251b1f21cefaf32~tplv-k3u1fbpfcp-watermark.image" alt="1627138804130"></p>
<p>使用<code>lldb</code>调试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p &amp;person1</span><br><span class="line">(JSPerson **) $<span class="number">0</span> = <span class="number">0x00007ffeed1d8118</span></span><br><span class="line">(lldb) p &amp;jst</span><br><span class="line">(js_struct *) $<span class="number">1</span> = <span class="number">0x00007ffeed1d8108</span></span><br><span class="line">(lldb) p &amp;person</span><br><span class="line">(JSPerson **) $<span class="number">2</span> = <span class="number">0x00007ffeed1d8100</span></span><br><span class="line">(lldb) p jst.num1</span><br><span class="line">(__NSCFNumber *) $<span class="number">3</span> = <span class="number">0xbab63c269bab4904</span> (<span class="keyword">int</span>)<span class="number">1</span></span><br><span class="line">(lldb) p &amp;$<span class="number">3</span></span><br><span class="line">(NSNumber **) $<span class="number">4</span> = <span class="number">0x00007ffeed1d8108</span></span><br><span class="line">(lldb) p jst.num2</span><br><span class="line">(__NSCFNumber *) $<span class="number">5</span> = <span class="number">0xbab63c269bab4924</span> (<span class="keyword">int</span>)<span class="number">3</span></span><br><span class="line">(lldb) p &amp;$<span class="number">5</span></span><br><span class="line">(NSNumber **) $<span class="number">6</span> = <span class="number">0x00007ffeed1d8110</span></span><br></pre></td></tr></table></figure>

<p>发现<code>num1</code>的地址&lt;<code>num2</code>的地址，说明<code>num2</code>先入栈。也就是<code>结构体是从后向前入栈的</code>。</p>
</li>
<li><p>总结来说题中压栈的顺序是<code>self</code>-&gt;<code>_cmd</code>-&gt;<code>superClass</code>-&gt;<code>self</code>-&gt;<code>person</code>-&gt;<code>cls</code>-&gt;<code>js</code>。地址空间是由高到低。所以这个地方<code>js</code>向高地址平移8字节找到的是<code>person</code>也就是打印是<code>&lt;JSPerson: 0x600003a00380&gt;</code>的原因。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/07/22/Flutter-runApp-%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/22/Flutter-runApp-%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">Flutter-runApp()方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-22 14:46:42" itemprop="dateCreated datePublished" datetime="2021-07-22T14:46:42+08:00">2021-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-23 17:05:06" itemprop="dateModified" datetime="2021-07-23T17:05:06+08:00">2021-07-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>Flutter</code>程序的入口<code>main()</code>方法会调用<code>runApp()</code>方法，我们本篇探索<code>runApp</code>都做了啥。</p>
<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> runApp(Widget app) &#123;</span><br><span class="line">  WidgetsFlutterBinding.ensureInitialized()</span><br><span class="line">    ..scheduleAttachRootWidget(app)</span><br><span class="line">    ..scheduleWarmUpFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法一看很简洁，一共调用了<code>WidgetsFlutterBinding</code>的三个方法，在看三个方法的实现之前，我们看一下<code>WidgetsFlutterBinding</code>是什么。</p>
<h3 id="WidgetsFlutterBinding"><a href="#WidgetsFlutterBinding" class="headerlink" title="WidgetsFlutterBinding"></a>WidgetsFlutterBinding</h3><p>我们看一下官方的解释：</p>
<p><code>A concrete binding for applications based on the Widgets framework.This is the glue that binds the framework to the Flutter engine.</code></p>
<p>翻译过来就是，一个基于<code>Widgets framework</code>的应用程序的具体绑定，它是绑定<code>framework</code>和<code>Flutter engine</code>的胶水层。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetsFlutterBinding</span> <span class="keyword">extends</span> <span class="title">BindingBase</span> <span class="title">with</span> <span class="title">GestureBinding</span>, <span class="title">SchedulerBinding</span>, <span class="title">ServicesBinding</span>, <span class="title">PaintingBinding</span>, <span class="title">SemanticsBinding</span>, <span class="title">RendererBinding</span>, <span class="title">WidgetsBinding</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> WidgetsBinding ensureInitialized() &#123;</span><br><span class="line">    <span class="keyword">if</span> (WidgetsBinding.instance == <span class="keyword">null</span>)</span><br><span class="line">      WidgetsFlutterBinding();</span><br><span class="line">    <span class="keyword">return</span> WidgetsBinding.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的父类<code>BindingBase</code>是一个抽象类，<code>with</code>实现了很多<code>mixin</code>,这些<code>mixin</code>只能用于继承自<code>BindingBase</code>的类。<code>mixin</code>的作用是扩展功能，<code>mixin</code>可以类比于<code>iOS</code>的<code>protocol</code>(个人见解，如果不对欢迎指正)。</p>
<h4 id="BindingBase"><a href="#BindingBase" class="headerlink" title="BindingBase"></a>BindingBase</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingBase</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">省略代码</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">However, multiple window support is not yet implemented, so currently this</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">provides access to the one and only window.</span></span></span><br><span class="line">  <span class="comment">// TODO(gspencergoog): remove the preceding note once multi-window support is</span></span><br><span class="line">  <span class="comment">// active.</span></span><br><span class="line">  <span class="comment">// 唯一的window</span></span><br><span class="line">  ui.SingletonFlutterWindow <span class="keyword">get</span> <span class="built_in">window</span> =&gt; ui.<span class="built_in">window</span>;</span><br><span class="line">  <span class="comment">/// <span class="markdown">每一个BindingBase类定义行为 都有一个 platformDispatcher 作为回调(handlers)</span></span></span><br><span class="line">  ui.PlatformDispatcher <span class="keyword">get</span> platformDispatcher =&gt; ui.PlatformDispatcher.instance;</span><br><span class="line">  <span class="comment">/// <span class="markdown">初始化实例</span></span></span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">assert</span>(!_debugInitialized);</span><br><span class="line">    <span class="keyword">assert</span>(() &#123;</span><br><span class="line">      _debugInitialized = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// <span class="markdown">The current [WidgetsBinding], if one has been created.</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">ensureInitialized方法返回的实例</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">If you need the binding to be constructed before calling [runApp],</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">you can ensure a Widget binding has been constructed by calling the</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown"><span class="code">`WidgetsFlutterBinding.ensureInitialized()`</span> function.</span></span></span><br><span class="line">  <span class="keyword">static</span> WidgetsBinding? <span class="keyword">get</span> instance =&gt; _instance;</span><br><span class="line">  <span class="keyword">static</span> WidgetsBinding? _instance;</span><br><span class="line">  <span class="comment">/// <span class="markdown">注册 service extensions 初始化之后调用</span></span></span><br><span class="line">  <span class="keyword">void</span> initServiceExtensions() &#123;</span><br><span class="line">    <span class="comment">///<span class="markdown">省略代码</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ui.window</code>：是<code>Flutter App</code>显示的窗口，它继承自<code>FlutterView</code>,位于<code>Flutter engine</code>层。</li>
<li><code>ui.PlatformDispatcher.instance</code>：platformDispatcher是Flutter 的一个事件分发器，负责Flutter分发engine的事件，和传递事件给engine层。</li>
<li><code>initInstances</code>：初始化实例的方法。</li>
<li><code>initServiceExtensions()</code>：注册 <code>service extensions</code>,比如<code>platformOverride</code>、<code>activeDevToolsServerAddress</code>等。</li>
</ul>
<h3 id="ensureInitialized（）方法"><a href="#ensureInitialized（）方法" class="headerlink" title="ensureInitialized（）方法"></a>ensureInitialized（）方法</h3><p>该方法的作用是返回一个<code>WidgetsBinding</code>类型实例，如果未创建就新创建一个。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> WidgetsBinding ensureInitialized() &#123;</span><br><span class="line">  <span class="keyword">if</span> (WidgetsBinding.instance == <span class="keyword">null</span>)</span><br><span class="line">    WidgetsFlutterBinding();</span><br><span class="line">  <span class="keyword">return</span> WidgetsBinding.instance!;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是返回一个<code>WidgetsBinding.instance</code>实例，因为<code>WidgetsFlutterBinding</code>实现了<code>GestureBinding, SchedulerBinding, ServicesBinding, PaintingBinding, SemanticsBinding, RendererBinding, WidgetsBinding</code>mixin，mixin的<code>initInstances</code>和<code>initServiceExtensions</code>方法也会调用，每个mixin的功能：</p>
<ul>
<li><code>GestureBinding</code>：处理手势。</li>
<li><code>SchedulerBinding</code>: 处理系统调度。</li>
<li><code>ServicesBinding</code>：处理与原生的交互。</li>
<li><code>PaintingBinding</code>：处理绘制。</li>
<li><code>SemanticsBinding</code>：处理语义化。</li>
<li><code>RendererBinding</code>：处理渲染。</li>
<li><code>WidgetsBinding</code>：<code>Widgets</code>相关。</li>
</ul>
<p>我们下面主要看<code>WidgetsBinding</code>和<code>RendererBinding</code>。</p>
<h4 id="WidgetsBinding"><a href="#WidgetsBinding" class="headerlink" title="WidgetsBinding"></a>WidgetsBinding</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> WidgetsBinding <span class="keyword">on</span> BindingBase, ServicesBinding, SchedulerBinding, GestureBinding, RendererBinding, SemanticsBinding &#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initInstances();</span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">assert</span>(() &#123;</span><br><span class="line">      _debugAddStackFilters();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;());</span><br><span class="line">    <span class="comment">// Initialization of [_buildOwner] has to be done after</span></span><br><span class="line">    <span class="comment">// [super.initInstances] is called, as it requires [ServicesBinding] to</span></span><br><span class="line">    <span class="comment">// properly setup the [defaultBinaryMessenger] instance.</span></span><br><span class="line">    _buildOwner = BuildOwner();</span><br><span class="line">    buildOwner!.onBuildScheduled = _handleBuildScheduled;</span><br><span class="line">    <span class="built_in">window</span>.onLocaleChanged = handleLocaleChanged;</span><br><span class="line">    <span class="built_in">window</span>.onAccessibilityFeaturesChanged = handleAccessibilityFeaturesChanged;</span><br><span class="line">    SystemChannels.navigation.setMethodCallHandler(_handleNavigationInvocation);</span><br><span class="line">    FlutterErrorDetails.propertiesTransformers.add(transformDebugCreator);</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="comment">///<span class="markdown">省略代码</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WidgetsBinding</code>初始化会创建一个<code>BuildOwner</code>对象，它的作用是管理<code>Widget</code>树和<code>Element</code>树。</p>
<h4 id="RendererBinding"><a href="#RendererBinding" class="headerlink" title="RendererBinding"></a>RendererBinding</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixin</span> RendererBinding <span class="keyword">on</span> BindingBase, ServicesBinding, SchedulerBinding, GestureBinding, SemanticsBinding, HitTestable &#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initInstances();</span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line">    _pipelineOwner = PipelineOwner(</span><br><span class="line">      onNeedVisualUpdate: ensureVisualUpdate,</span><br><span class="line">      onSemanticsOwnerCreated: _handleSemanticsOwnerCreated,</span><br><span class="line">      onSemanticsOwnerDisposed: _handleSemanticsOwnerDisposed,</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">window</span></span><br><span class="line">      ..onMetricsChanged = handleMetricsChanged</span><br><span class="line">      ..onTextScaleFactorChanged = handleTextScaleFactorChanged</span><br><span class="line">      ..onPlatformBrightnessChanged = handlePlatformBrightnessChanged</span><br><span class="line">      ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged</span><br><span class="line">      ..onSemanticsAction = _handleSemanticsAction;</span><br><span class="line">    initRenderView();</span><br><span class="line">    _handleSemanticsEnabledChanged();</span><br><span class="line">    <span class="keyword">assert</span>(renderView != <span class="keyword">null</span>);</span><br><span class="line">    addPersistentFrameCallback(_handlePersistentFrameCallback);</span><br><span class="line">    initMouseTracker();</span><br><span class="line">    <span class="keyword">if</span> (kIsWeb) &#123;</span><br><span class="line">      addPostFrameCallback(_handleWebFirstFrame);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">The current [RendererBinding], if one has been created.</span></span></span><br><span class="line">  <span class="keyword">static</span> RendererBinding? <span class="keyword">get</span> instance =&gt; _instance;</span><br><span class="line">  <span class="keyword">static</span> RendererBinding? _instance;</span><br><span class="line">  <span class="comment">///<span class="markdown">省略代码</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RendererBinding</code>初始化会创建一个<code>PipelineOwner</code>对象，用于管理<code>RenderObject</code>树。<code>PipelineOwner</code>和<code>BuildOwner</code>都位于<code>framework</code>层，它们通过<code>Bingding</code>(胶水层)与<code>engine</code>交互。</p>
<ul>
<li>初始化了一个PipelineOwner用于管理RenderObject.</li>
<li>将<code>_handlePersistentFrameCallback</code>这个callback传入<code>SchedulerBinding</code>中的<code>_postFrameCallbacks</code>中，这样在硬件每次发出<code>VSync</code>信号的时候都会调用<code>RenderBinding</code>中的<code>_handlePersistentFrameCallback</code>方法.<code>_handlePersistentFrameCallback</code>方法中直接调用了<code>drawFrame</code>方法。</li>
</ul>
<h3 id="scheduleAttachRootWidget"><a href="#scheduleAttachRootWidget" class="headerlink" title="scheduleAttachRootWidget"></a>scheduleAttachRootWidget</h3><p>实例化之后会调用<code>scheduleAttachRootWidget</code>方法。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@protected</span></span><br><span class="line"><span class="keyword">void</span> scheduleAttachRootWidget(Widget rootWidget) &#123;</span><br><span class="line">  Timer.run(() &#123;</span><br><span class="line">    attachRootWidget(rootWidget);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了<code>attachRootWidget</code>方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> attachRootWidget(Widget rootWidget) &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> isBootstrapFrame = renderViewElement == <span class="keyword">null</span>;</span><br><span class="line">  _readyToProduceFrames = <span class="keyword">true</span>;</span><br><span class="line">  _renderViewElement = RenderObjectToWidgetAdapter&lt;RenderBox&gt;(</span><br><span class="line">    container: renderView,</span><br><span class="line">    debugShortDescription: <span class="string">'[root]'</span>,</span><br><span class="line">    child: rootWidget,</span><br><span class="line">  ).attachToRenderTree(buildOwner!, renderViewElement <span class="keyword">as</span> RenderObjectToWidgetElement&lt;RenderBox&gt;?);</span><br><span class="line">  <span class="keyword">if</span> (isBootstrapFrame) &#123;</span><br><span class="line">    SchedulerBinding.instance!.ensureVisualUpdate();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>attachRootWidget方法用于是为根Widget生成一个根Element。生成Element调用了attachToRenderTree方法并传入了BuildOwner和Element。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RenderObjectToWidgetElement&lt;T&gt; attachToRenderTree(BuildOwner owner, [ RenderObjectToWidgetElement&lt;T&gt;? element ]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (element == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">///<span class="markdown">新创建一个 element</span></span></span><br><span class="line">      owner.lockState(() &#123;</span><br><span class="line">        element = createElement();</span><br><span class="line">        <span class="keyword">assert</span>(element != <span class="keyword">null</span>);</span><br><span class="line">        element!.assignOwner(owner);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 建立能更新widget 树的能力，可以回调 callback，构建所有标记为dirty的elment</span></span><br><span class="line">      owner.buildScope(element!, () &#123;</span><br><span class="line">        element!.mount(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element._newWidget = <span class="keyword">this</span>;</span><br><span class="line">      element.markNeedsBuild();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> element!;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要是<code>element</code>为空的时候新建一个<code>element</code>，新建后会调用<code>BuildOwner</code>的<code>buildScope</code>主要作用是建立能更新<code>widget</code> 树的能力，可以回调 <code>callback</code>，构建所有标记为<code>dirty</code>的<code>element</code>。</p>
<p><code>attachRootWidget</code>方法，最后会执行<code>SchedulerBinding.instance!.ensureVisualUpdate()</code>，</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ensureVisualUpdate() &#123;</span><br><span class="line">  <span class="keyword">switch</span> (schedulerPhase) &#123;</span><br><span class="line">    <span class="keyword">case</span> SchedulerPhase.idle:</span><br><span class="line">    <span class="keyword">case</span> SchedulerPhase.postFrameCallbacks:</span><br><span class="line">      scheduleFrame();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> SchedulerPhase.transientCallbacks:</span><br><span class="line">    <span class="keyword">case</span> SchedulerPhase.midFrameMicrotasks:</span><br><span class="line">    <span class="keyword">case</span> SchedulerPhase.persistentCallbacks:</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它主要是调用新的帧的调度管理。它会调用<code>scheduleFrame</code>方法</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> scheduleFrame() &#123;</span><br><span class="line">  <span class="keyword">if</span> (_hasScheduledFrame || !framesEnabled)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">assert</span>(() &#123;</span><br><span class="line">    <span class="keyword">if</span> (debugPrintScheduleFrameStacks)</span><br><span class="line">      debugPrintStack(label: <span class="string">'scheduleFrame() called. Current phase is <span class="subst">$schedulerPhase</span>.'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;());</span><br><span class="line">  <span class="comment">///<span class="markdown">给window设置回调</span></span></span><br><span class="line">  ensureFrameCallbacksRegistered();</span><br><span class="line">  <span class="comment">///<span class="markdown">调度更新</span></span></span><br><span class="line">  <span class="built_in">window</span>.scheduleFrame();</span><br><span class="line">  _hasScheduledFrame = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会给<code>window</code>设置<code>onBeginFrame</code>和<code>onDrawFrame</code>的回调，<code>window</code>会把回调传给<code>platformDispatcher</code>。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">set</span> onBeginFrame(ui.FrameCallback? callback) &#123;</span><br><span class="line">  platformDispatcher.onBeginFrame = callback;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">ui.VoidCallback? <span class="keyword">get</span> onDrawFrame =&gt; platformDispatcher.onDrawFrame;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">set</span> onDrawFrame(ui.VoidCallback? callback) &#123;</span><br><span class="line">  platformDispatcher.onDrawFrame = callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说<code>scheduleAttachRootWidget</code>经过一系列调用之后，会把<code>SchedulerBinding</code>的<code>_handleBeginFrame</code>和<code>_handleDrawFrame</code>传给<code>platformDispatcher</code>。<code>platformDispatcher</code>分发来自enginee的事件。而在这里<code>SingletonFlutterWindow</code>把<code>platformDispatcher</code>的<code>onBeginFrame</code>和<code>onDrawFrame</code>这两个事件交给<code>SchedulerBinding</code>处理。</p>
<p>当硬件发出<code>VSync</code>信号时，会调用<code>platformDispatcher的onDrawFrame</code>。实际上会调用<code>SchedulerBinding</code>中的<code>_handleDrawFrame</code>方法。<code>_handleDrawFrame</code>会调用<code>handleDrawFrame</code>方法:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> handleDrawFrame() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(_schedulerPhase == SchedulerPhase.midFrameMicrotasks);</span><br><span class="line">  Timeline.finishSync(); <span class="comment">// end the "Animate" phase</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// PERSISTENT FRAME CALLBACKS</span></span><br><span class="line">    _schedulerPhase = SchedulerPhase.persistentCallbacks;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> FrameCallback callback <span class="keyword">in</span> _persistentCallbacks)</span><br><span class="line">      _invokeFrameCallback(callback, _currentFrameTimeStamp!);</span><br><span class="line">    <span class="comment">// POST-FRAME CALLBACKS</span></span><br><span class="line">    _schedulerPhase = SchedulerPhase.postFrameCallbacks;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">List</span>&lt;FrameCallback&gt; localPostFrameCallbacks =</span><br><span class="line">        <span class="built_in">List</span>&lt;FrameCallback&gt;.from(_postFrameCallbacks);</span><br><span class="line">    _postFrameCallbacks.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> FrameCallback callback <span class="keyword">in</span> localPostFrameCallbacks)</span><br><span class="line">      _invokeFrameCallback(callback, _currentFrameTimeStamp!);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">///<span class="markdown">省略代码</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_postFrameCallbacks</code>里面存储的是<code>callback</code>，作用是硬件每次发出<code>VSync</code>信号的时候都会调用。这里的<code>_postFrameCallbacks</code>是在<code>RenderBinding</code>这个<code>mixin</code>的<code>initInstances</code>方法中传入的</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addPersistentFrameCallback(_handlePersistentFrameCallback);</span><br></pre></td></tr></table></figure>

<h3 id="scheduleWarmUpFrame"><a href="#scheduleWarmUpFrame" class="headerlink" title="scheduleWarmUpFrame"></a>scheduleWarmUpFrame</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> scheduleWarmUpFrame() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_warmUpFrame || schedulerPhase != SchedulerPhase.idle)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    _warmUpFrame = <span class="keyword">true</span>;</span><br><span class="line">    Timeline.startSync(<span class="string">'Warm-up frame'</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">bool</span> hadScheduledFrame = _hasScheduledFrame;</span><br><span class="line">    <span class="comment">// We use timers here to ensure that microtasks flush in between.</span></span><br><span class="line">    Timer.run(() &#123;</span><br><span class="line">      <span class="keyword">assert</span>(_warmUpFrame);</span><br><span class="line">      handleBeginFrame(<span class="keyword">null</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    Timer.run(() &#123;</span><br><span class="line">      <span class="keyword">assert</span>(_warmUpFrame);</span><br><span class="line">      handleDrawFrame();</span><br><span class="line">      <span class="comment">// We call resetEpoch after this frame so that, in the hot reload case,</span></span><br><span class="line">      <span class="comment">// the very next frame pretends to have occurred immediately after this</span></span><br><span class="line">      <span class="comment">// warm-up frame. The warm-up frame's timestamp will typically be far in</span></span><br><span class="line">      <span class="comment">// the past (the time of the last real frame), so if we didn't reset the</span></span><br><span class="line">      <span class="comment">// epoch we would see a sudden jump from the old time in the warm-up frame</span></span><br><span class="line">      <span class="comment">// to the new time in the "real" frame. The biggest problem with this is</span></span><br><span class="line">      <span class="comment">// that implicit animations end up being triggered at the old time and</span></span><br><span class="line">      <span class="comment">// then skipping every frame and finishing in the new time.</span></span><br><span class="line">      resetEpoch();</span><br><span class="line">      _warmUpFrame = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (hadScheduledFrame)</span><br><span class="line">        scheduleFrame();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// Lock events so touch events etc don't insert themselves until the</span></span><br><span class="line">    <span class="comment">// scheduled frame has finished.</span></span><br><span class="line">    lockEvents(() <span class="keyword">async</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> endOfFrame;</span><br><span class="line">      Timeline.finishSync();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要调用是<code>scheduleFrame</code>，跟进代码实际是调用的<code>window.scheduleFrame()</code>,</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> scheduleFrame() &#123;</span><br><span class="line">  platformDispatcher.scheduleFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>window.scheduleFrame()</code>调用了<code>platformDispatcher.scheduleFrame()</code>,通知<code>engine</code>层需要绘制。engine会根据情况尽快地调用platformDispatcher的onDrawFrame方法。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>runApp方法主要做了以下事情：</p>
<ul>
<li>创建<code>WidgetsFlutterBinding</code>它是连接<code>framework</code>和<code>engine</code>的胶水层。注册<code>Vsync</code>回调，后面每一帧的调用会出发<code>WidgetsFlutterBinding</code>的回调，最后传递到<code>framework</code>层处理逻辑。</li>
<li><code>attachRootWidget</code>：遍历挂载整个视图树，建立<code>widget</code>、<code>element</code>、<code>renderObjcect</code>的连接关系。</li>
<li><code>scheduleWarmUpFrame</code>：调度帧预热(warmUp)。执行帧绘制<code>handleBeginFrame</code>和<code>handleDrawFrame</code>方法。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/07/20/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E7%B1%BB%E7%9A%84%E6%89%A9%E5%B1%95%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/20/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E7%B1%BB%E7%9A%84%E6%89%A9%E5%B1%95%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">iOS底层探索-类的扩展和关联对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-20 09:24:28" itemprop="dateCreated datePublished" datetime="2021-07-20T09:24:28+08:00">2021-07-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-21 11:34:53" itemprop="dateModified" datetime="2021-07-21T11:34:53+08:00">2021-07-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前面几篇我们探索了<code>类</code>的加载过程，本篇我们研究类相关的两个点：<code>类的扩展</code>和<code>关联对象</code>。</p>
<h3 id="类扩展"><a href="#类扩展" class="headerlink" title="类扩展"></a>类扩展</h3><h4 id="clang编译"><a href="#clang编译" class="headerlink" title="clang编译"></a>clang编译</h4><p>我们首先在<code>main.m</code>文件中新建一个类<code>JSAnimal</code>,并给类定义扩展，注意<code>扩展</code>要在<code>声明之后</code>和<code>实现之后</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@interface JSAnimal : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic,copy)NSString *name;</span><br><span class="line"></span><br><span class="line">- (void)sayWow;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface JSAnimal ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic,copy)NSString *type;</span><br><span class="line"></span><br><span class="line">- (void)ex_sayWow;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation JSAnimal</span><br><span class="line"></span><br><span class="line">+ (void)classMethod&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sayWow&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)ex_sayWow&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        JSAnimal *animal &#x3D; [[JSAnimal alloc] init];</span><br><span class="line">        [animal ex_sayWow];</span><br><span class="line">        NSLog(@&quot;done&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用<code>clang</code>命令，将<code>main.m</code>转成<code>main.cpp</code>文件，看一下分类的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m -o main.cpp</span><br></pre></td></tr></table></figure>

<p><code>main.cpp</code>文件搜索<code>JSAnimal</code></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfcccacbc80a4621b82cd607c8089ade~tplv-k3u1fbpfcp-watermark.image" alt="1626779765218"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f79df3e864584213815b25cd6c2a5cbc~tplv-k3u1fbpfcp-watermark.image" alt="1626779854673"></p>
<p>发现<code>扩展</code>里声明的<code>属性</code>和<code>方法</code>编译后和<code>类</code>中的在一起，作为<code>类</code>的一部分，也就是说<code>扩展中的属性和方法</code>在<code>编译期</code>就添加到<code>本类</code>中了。</p>
<h4 id="通过源码探索运行时"><a href="#通过源码探索运行时" class="headerlink" title="通过源码探索运行时"></a>通过源码探索运行时</h4><p>定义一个<code>JSPerson</code>类和扩展，本类中实现扩展中声明的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface JSPerson : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line"></span><br><span class="line">- (void)saySomething;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;JSPerson.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation JSPerson</span><br><span class="line"></span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)saySomething&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)ext_instanceMethod&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)ext_classMethod&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface JSPerson ()</span><br><span class="line"></span><br><span class="line">- (void)ext_instanceMethod;</span><br><span class="line"></span><br><span class="line">+ (void)ext_classMethod;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>注意<code>JSPerson</code>类实现了<code>load</code>方法，目的是让其<code>非懒加载</code>。根据我们的经验，我们在<code>realizeClassWithoutSwift</code>添加断点调试</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af878f11eefc4b4b89daf2d446cba41d~tplv-k3u1fbpfcp-watermark.image" alt="1626781568401"></p>
<p>通过<code>lldb</code>打印<code>ro</code>中的方法列表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p ro</span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *) $<span class="number">0</span> = <span class="number">0x0000000100004790</span></span><br><span class="line">(lldb) p *$<span class="number">0</span></span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">class_ro_t</span>) $<span class="number">1</span> = &#123;</span><br><span class="line">  flags = <span class="number">0</span></span><br><span class="line">  instanceStart = <span class="number">8</span></span><br><span class="line">  instanceSize = <span class="number">16</span></span><br><span class="line">  reserved = <span class="number">0</span></span><br><span class="line">   = &#123;</span><br><span class="line">    ivarLayout = <span class="number">0x0000000000000000</span></span><br><span class="line">    nonMetaclass = nil</span><br><span class="line">  &#125;</span><br><span class="line">  name = &#123;</span><br><span class="line">    <span class="built_in">std</span>::__1::atomic&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; = <span class="string">"JSPerson"</span> &#123;</span><br><span class="line">      Value = <span class="number">0x0000000100003b58</span> <span class="string">"JSPerson"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  baseMethodList = <span class="number">0x00000001000047d8</span></span><br><span class="line">  baseProtocols = nil</span><br><span class="line">  ivars = <span class="number">0x0000000100004840</span></span><br><span class="line">  weakIvarLayout = <span class="number">0x0000000000000000</span></span><br><span class="line">  baseProperties = <span class="number">0x0000000100004868</span></span><br><span class="line">  _swiftMetadataInitializer_NEVER_USE = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">1.b</span>aseMethods()</span><br><span class="line">(<span class="keyword">method_list_t</span> *) $<span class="number">2</span> = <span class="number">0x00000001000047d8</span></span><br><span class="line">(lldb) p *$<span class="number">2</span></span><br><span class="line">(<span class="keyword">method_list_t</span>) $<span class="number">3</span> = &#123;</span><br><span class="line">  entsize_list_tt&lt;<span class="keyword">method_t</span>, <span class="keyword">method_list_t</span>, <span class="number">4294901763</span>, <span class="keyword">method_t</span>::pointer_modifier&gt; = (entsizeAndFlags = <span class="number">24</span>, count = <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">3.</span><span class="built_in">get</span>(<span class="number">0</span>).big()</span><br><span class="line">(<span class="keyword">method_t</span>::big) $<span class="number">4</span> = &#123;</span><br><span class="line">  name = <span class="string">"saySomething"</span></span><br><span class="line">  types = <span class="number">0x0000000100003d84</span> <span class="string">"v16@0:8"</span></span><br><span class="line">  imp = <span class="number">0x0000000100003600</span> (KCObjcBuild`-[JSPerson saySomething])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">3.</span><span class="built_in">get</span>(<span class="number">1</span>).big()</span><br><span class="line">(<span class="keyword">method_t</span>::big) $<span class="number">5</span> = &#123;</span><br><span class="line">  name = <span class="string">"ext_instanceMethod"</span></span><br><span class="line">  types = <span class="number">0x0000000100003d84</span> <span class="string">"v16@0:8"</span></span><br><span class="line">  imp = <span class="number">0x0000000100003630</span> (KCObjcBuild`-[JSPerson ext_instanceMethod])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">3.</span><span class="built_in">get</span>(<span class="number">2</span>).big()</span><br><span class="line">(<span class="keyword">method_t</span>::big) $<span class="number">6</span> = &#123;</span><br><span class="line">  name = <span class="string">"name"</span></span><br><span class="line">  types = <span class="number">0x0000000100003d98</span> <span class="string">"@16@0:8"</span></span><br><span class="line">  imp = <span class="number">0x0000000100003660</span> (KCObjcBuild`-[JSPerson name])</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">3.</span><span class="built_in">get</span>(<span class="number">3</span>).big()</span><br><span class="line">(<span class="keyword">method_t</span>::big) $<span class="number">7</span> = &#123;</span><br><span class="line">  name = <span class="string">"setName:"</span></span><br><span class="line">  types = <span class="number">0x0000000100003da0</span> <span class="string">"v24@0:8@16"</span></span><br><span class="line">  imp = <span class="number">0x0000000100003690</span> (KCObjcBuild`-[JSPerson setName:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>扩展</code>中的方向现在已经加载了已知<code>ro</code>中的方法是<code>编译期</code>就确定的，所以也验证了<code>扩展</code>的方法是在<code>编译期</code>添加到<code>本类</code>的。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>类的扩展 在<code>编译期</code> 会作为类的一部分，和类一起编译进来</li>
<li>类的扩展只是<code>声明</code>，依赖于<code>本类</code>的实现。</li>
</ul>
<h3 id="分类的关联对象"><a href="#分类的关联对象" class="headerlink" title="分类的关联对象"></a>分类的关联对象</h3><p>我们知道<code>分类</code>正常是不能添加<code>属性</code>的，但是通过<code>关联对象</code>可以，其实现通过两个方法</p>
<ul>
<li>通过<code>objc_setAssociatedObject</code>方法设置值。</li>
<li>通过<code>objc_getAssociatedObject</code>方法取值。</li>
</ul>
<p>下面我们分别探索。</p>
<h4 id="objc-setAssociatedObject流程"><a href="#objc-setAssociatedObject流程" class="headerlink" title="objc_setAssociatedObject流程"></a>objc_setAssociatedObject流程</h4><p><code>objc_setAssociatedObject</code>有四个参数：</p>
<ul>
<li>参数1：要关联的对象</li>
<li>参数2：表示符，方便查找识别</li>
<li>参数3：value值</li>
<li>参数4：属性的<code>策略</code>,我们定义属性经常用到的如<code>nonatomic</code>、<code>strong</code>、<code>weak</code>。</li>
</ul>
<p>首先定义<code>JSPerson</code>的<code>分类</code>，定义一个属性<code>cateegory_name</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@interface JSPerson (JSCategory)</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *cateegory_name;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation JSPerson (JSCategory)</span><br><span class="line"></span><br><span class="line">- (void)setCateegory_name:(NSString *)category_name&#123;</span><br><span class="line">    objc_setAssociatedObject(self, &quot;category_name&quot;, category_name, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)category_name&#123;</span><br><span class="line">    return  objc_getAssociatedObject(self, &quot;category_name&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>在<code>main</code>函数赋值属性的地方添加断点，根据调用情况</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/565a6873ad724e6db775d38ea637c95a~tplv-k3u1fbpfcp-watermark.image" alt="1626783154111"></p>
<p>定位到<code>objc_setAssociatedObject</code>方法</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10b7f73974e746a6bedd5b3ab397f809~tplv-k3u1fbpfcp-watermark.image" alt="1626783226697"></p>
<p>调用的是<code>_object_set_associative_reference</code>方法，我们继续跟进查看源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_object_set_associative_reference(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key, id value, <span class="keyword">uintptr_t</span> policy)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This code used to work when nil was passed for object and key. Some code</span></span><br><span class="line">    <span class="comment">// probably relies on that to not crash. Check and handle it explicitly.</span></span><br><span class="line">    <span class="comment">// rdar://problem/44094390</span></span><br><span class="line">    <span class="keyword">if</span> (!object &amp;&amp; !value) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (object-&gt;getIsa()-&gt;forbidsAssociatedObjects())</span><br><span class="line">        _objc_fatal(<span class="string">"objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects"</span>, object, object_getClassName(object));</span><br><span class="line">		<span class="comment">///将object封装一下 类型为DisguisedPtr</span></span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; disguised&#123;(objc_object *)object&#125;;</span><br><span class="line">    <span class="comment">///包装policy  value</span></span><br><span class="line">    ObjcAssociation association&#123;policy, value&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// retain the new value (if any) outside the lock.</span></span><br><span class="line">    <span class="comment">//根据策略类型(strong、weak等)进行处理</span></span><br><span class="line">    association.acquireValue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isFirstAssociation = <span class="literal">false</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化manager变量，相当于自动调用AssociationsManager的构造函数进行初始化</span></span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">      	<span class="comment">///一个HashMap</span></span><br><span class="line">        <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.<span class="built_in">get</span>())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">          	<span class="comment">//返回的结果是一个类对</span></span><br><span class="line">            <span class="keyword">auto</span> refs_result = associations.try_emplace(disguised, ObjectAssociationMap&#123;&#125;);</span><br><span class="line">            <span class="keyword">if</span> (refs_result.second) &#123;</span><br><span class="line">                <span class="comment">/* it's the first association we make */</span></span><br><span class="line">                isFirstAssociation = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* establish or replace the association 建立或者替换关联*/</span></span><br><span class="line">            <span class="keyword">auto</span> &amp;refs = refs_result.first-&gt;second;<span class="comment">///得到一个空的桶，找到引用对象类型,即第一个元素的second值</span></span><br><span class="line">            <span class="keyword">auto</span> result = refs.try_emplace(key, <span class="built_in">std</span>::<span class="built_in">move</span>(association));<span class="comment">//查找当前的key是否有association关联对象</span></span><br><span class="line">            <span class="keyword">if</span> (!result.second) &#123;<span class="comment">///如果结果不存在</span></span><br><span class="line">                association.swap(result.first-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果传的是空值，则移除关联，相当于移除</span></span><br><span class="line">            <span class="keyword">auto</span> refs_it = associations.<span class="built_in">find</span>(disguised);</span><br><span class="line">            <span class="keyword">if</span> (refs_it != associations.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> &amp;refs = refs_it-&gt;second;</span><br><span class="line">                <span class="keyword">auto</span> it = refs.<span class="built_in">find</span>(key);</span><br><span class="line">                <span class="keyword">if</span> (it != refs.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    association.swap(it-&gt;second);</span><br><span class="line">                    refs.erase(it);</span><br><span class="line">                    <span class="keyword">if</span> (refs.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                        associations.erase(refs_it);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Call setHasAssociatedObjects outside the lock, since this</span></span><br><span class="line">    <span class="comment">// will call the object's _noteAssociatedObjects method if it</span></span><br><span class="line">    <span class="comment">// has one, and this may trigger +initialize which might do</span></span><br><span class="line">    <span class="comment">// arbitrary stuff, including setting more associated objects.</span></span><br><span class="line">    <span class="keyword">if</span> (isFirstAssociation)</span><br><span class="line">        object-&gt;setHasAssociatedObjects();</span><br><span class="line">    <span class="comment">// release the old value (outside of the lock).释放老的关联值</span></span><br><span class="line">    association.releaseHeldValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过源码我们看到大体的流程为：</p>
<ul>
<li>创建一个<code>AssociationsManager</code>管理类</li>
<li>获取<code>静态哈希表</code>:<code>associations</code></li>
<li>判断<code>关联值value</code>是否为空<ul>
<li>如果为空就走：<code>插入空值</code>流程。</li>
<li>如果不为空继续下一步</li>
</ul>
</li>
<li>通过<code>try_emplace</code>方法，创建一个空的 <code>ObjectAssociationMap</code> 去取查询的键值对</li>
<li>如果发现<code>没有</code> <code>key</code> 就<code>插入一个 空的 BucketT</code>进去并返回true</li>
<li>通过<code>setHasAssociatedObjects</code>方法<code>标记对象存在关联对象</code></li>
<li>用当前 <code>policy 和 value</code> 组成了一个 <code>ObjcAssociation</code> 替换原来 <code>BucketT</code>中的值</li>
<li>标记一下 <code>ObjectAssociationMap</code> 的<code>第一次</code>为 <code>false</code></li>
</ul>
<h4 id="源码调试"><a href="#源码调试" class="headerlink" title="源码调试"></a>源码调试</h4><p>对流程有了大概的认识，我们开始断点调试</p>
<h5 id="if-value-之前变量的值"><a href="#if-value-之前变量的值" class="headerlink" title="if (value) 之前变量的值"></a><strong>if</strong> (value) 之前变量的值</h5><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d0c1f116d8b4d999e54a29b275453cc~tplv-k3u1fbpfcp-watermark.image" alt="1626785173962"></p>
<p>通过<code>lldb</code>我们打印出了<code>disguised</code>、<code>association</code>、<code>manager</code>、<code>associations</code>、<code>value</code>的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p disguised</span><br><span class="line">(DisguisedPtr&lt;objc_object&gt;) $<span class="number">0</span> = (value = <span class="number">18446744069393517536</span>)</span><br><span class="line">(lldb) p association</span><br><span class="line">(objc::ObjcAssociation) $<span class="number">1</span> = &#123;</span><br><span class="line">  _policy = <span class="number">3</span></span><br><span class="line">  _value = <span class="number">0x0000000100004080</span> <span class="string">"哈哈哈"</span></span><br><span class="line">&#125;</span><br><span class="line">(lldb) p manager</span><br><span class="line">(objc::AssociationsManager) $<span class="number">2</span> = &#123;&#125;</span><br><span class="line">(lldb) p associations</span><br><span class="line">(objc::AssociationsHashMap) $<span class="number">3</span> = &#123;</span><br><span class="line">  Buckets = nil</span><br><span class="line">  NumEntries = <span class="number">0</span></span><br><span class="line">  NumTombstones = <span class="number">0</span></span><br><span class="line">  NumBuckets = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">(lldb) p value</span><br><span class="line">(__NSCFConstantString *) $<span class="number">4</span> = <span class="number">0x0000000100004080</span> <span class="string">"哈哈哈"</span></span><br></pre></td></tr></table></figure>

<h5 id="value不为空流程"><a href="#value不为空流程" class="headerlink" title="value不为空流程"></a><code>value</code>不为空流程</h5><p>上面我们看到<code>value</code>值不为空，我们进入<code>if</code>语句继续调试。</p>
<ul>
<li><code>p refs_result</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p refs_result</span><br><span class="line">(<span class="built_in">std</span>::pair&lt;objc::DenseMapIterator&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt;, objc::DenseMapValueInfo&lt;objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt;, objc::DenseMapInfo&lt;DisguisedPtr&lt;objc_object&gt; &gt;, objc::detail::DenseMapPair&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt;, <span class="literal">false</span>&gt;, <span class="keyword">bool</span>&gt;) $<span class="number">5</span> = &#123;</span><br><span class="line">  first = &#123;</span><br><span class="line">    Ptr = <span class="number">0x00000001012102a0</span></span><br><span class="line">    End = <span class="number">0x0000000101210300</span></span><br><span class="line">  &#125;</span><br><span class="line">  second = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到<code>refs_result</code>的数据结构看起来比较复杂，但是值比较简单，有两个属性<code>first</code>、<code>second</code>。其中<code>first</code>的值为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p $<span class="number">5.f</span>irst.Ptr</span><br><span class="line">(objc::DenseMapIterator&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt;, objc::DenseMapValueInfo&lt;objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt;, objc::DenseMapInfo&lt;DisguisedPtr&lt;objc_object&gt; &gt;, objc::detail::DenseMapPair&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt;, <span class="literal">false</span>&gt;::pointer) $<span class="number">6</span> = <span class="number">0x00000001012102a0</span></span><br><span class="line"> (lldb) p $<span class="number">5.f</span>irst.End</span><br><span class="line">(objc::DenseMapIterator&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt;, objc::DenseMapValueInfo&lt;objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt;, objc::DenseMapInfo&lt;DisguisedPtr&lt;objc_object&gt; &gt;, objc::detail::DenseMapPair&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt;, <span class="literal">false</span>&gt;::pointer) $<span class="number">7</span> = <span class="number">0x0000000101210300</span></span><br></pre></td></tr></table></figure>

<p><code>second</code>值为<code>true</code>，所以会执行<code>isFirstAssociation = true</code>。</p>
<ul>
<li><p><code>try_emplace</code>方法，<code>associations</code>调用了<code>try_emplace</code>方法，我们看一下他的源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line">std::pair&lt;iterator, bool&gt; try_emplace(const KeyT &amp;Key, Ts &amp;&amp;... Args) &#123;</span><br><span class="line">  BucketT *TheBucket;</span><br><span class="line">  <span class="comment">///根据key找桶</span></span><br><span class="line">  <span class="keyword">if</span> (LookupBucketFor(Key, TheBucket))</span><br><span class="line">    <span class="comment">///如果桶存在 则返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(</span><br><span class="line">             makeIterator(TheBucket, getBucketsEnd(), <span class="literal">true</span>),</span><br><span class="line">             <span class="literal">false</span>); <span class="comment">// Already in map.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Otherwise, insert the new element.</span></span><br><span class="line">  <span class="comment">///如果不存在则插入桶 并返回</span></span><br><span class="line">  TheBucket = InsertIntoBucket(TheBucket, Key, <span class="built_in">std</span>::forward&lt;Ts&gt;(Args)...);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(</span><br><span class="line">           makeIterator(TheBucket, getBucketsEnd(), <span class="literal">true</span>),</span><br><span class="line">           <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两个返回，都是通过<code>std::make_pair</code>生成相应的键值对。</p>
<ol>
<li>通过<code>LookupBucketFor</code>方法<code>查找桶</code>，如果map中已经<code>存在</code>，则<code>直接返回</code>，其中<code>make_pair</code>的第二个参数<code>bool值为false</code></li>
<li>如果没<code>有找到</code>，则通过<code>InsertIntoBucket</code>插入map，其中<code>make_pair</code>的第二个参数<code>bool值为true</code></li>
</ol>
<p>我们断点进来使用<code>lldb</code>调试</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b57bcdf62c24de9932bddcc72f87cc9~tplv-k3u1fbpfcp-watermark.image" alt="1626787367239"></p>
<p><code>p TheBucket</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p TheBucket</span><br><span class="line">(objc::detail::DenseMapPair&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt; *) $<span class="number">1</span> = <span class="number">0x0000000101c04200</span></span><br><span class="line">(lldb) p *$<span class="number">1</span></span><br><span class="line">(objc::detail::DenseMapPair&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt;) $<span class="number">2</span> = &#123;</span><br><span class="line">  <span class="built_in">std</span>::__1::pair&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt; = &#123;</span><br><span class="line">    first = (value = <span class="number">18446744069384153152</span>)</span><br><span class="line">    second = &#123;</span><br><span class="line">      Buckets = nil</span><br><span class="line">      NumEntries = <span class="number">0</span></span><br><span class="line">      NumTombstones = <span class="number">0</span></span><br><span class="line">      NumBuckets = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到<code>TheBucket</code>的类型与 <code>refs_result</code>中属性的类型是一致的。</p>
</li>
<li><p><code>LookupBucketFor</code>方法</p>
<p>我们进入<code>LookupBucketFor</code>源码发现有两个实现，它们的区别是<code>FoundBucket</code>的参数类型第一个实现多<code>const</code>修饰。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63c705dadb7446558d8876e8bb63a56e~tplv-k3u1fbpfcp-watermark.image" alt="1626786329854"></p>
<p>我们通过断点调试，发现调用的是第2个实现，第2个方法内部调用了第1个实现。我们先看第1个实现源码，注释中有流程说明。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> LookupKeyT&gt;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">LookupBucketFor</span><span class="params">(<span class="keyword">const</span> LookupKeyT &amp;Val,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> BucketT *&amp;FoundBucket)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> BucketT *BucketsPtr = getBuckets();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> NumBuckets = getNumBuckets();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (NumBuckets == <span class="number">0</span>) &#123;</span><br><span class="line">      FoundBucket = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// FoundTombstone - Keep track of whether we find a tombstone while probing.</span></span><br><span class="line">    <span class="keyword">const</span> BucketT *FoundTombstone = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">const</span> KeyT EmptyKey = getEmptyKey();</span><br><span class="line">    <span class="keyword">const</span> KeyT TombstoneKey = getTombstoneKey();</span><br><span class="line">    assert(!KeyInfoT::isEqual(Val, EmptyKey) &amp;&amp;</span><br><span class="line">           !KeyInfoT::isEqual(Val, TombstoneKey) &amp;&amp;</span><br><span class="line">           <span class="string">"Empty/Tombstone value shouldn't be inserted into map!"</span>);</span><br><span class="line">  	<span class="comment">///通过哈希函数得到BucketNo</span></span><br><span class="line">    <span class="keyword">unsigned</span> BucketNo = getHashValue(Val) &amp; (NumBuckets<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> ProbeAmt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;<span class="comment">//与catche_t查找imp类似，通过哈希查找</span></span><br><span class="line">      <span class="keyword">const</span> BucketT *ThisBucket = BucketsPtr + BucketNo;</span><br><span class="line">      <span class="comment">// Found Val's bucket?  If so, return it. 如果找到直接返回 true</span></span><br><span class="line">      <span class="keyword">if</span> (LLVM_LIKELY(KeyInfoT::isEqual(Val, ThisBucket-&gt;getFirst()))) &#123;</span><br><span class="line">        FoundBucket = ThisBucket;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">			</span><br><span class="line">      <span class="comment">// If we found an empty bucket, the key doesn't exist in the set.</span></span><br><span class="line">      <span class="comment">// Insert it and return the default value.</span></span><br><span class="line">      <span class="comment">//如果是一个空桶 说明key不在集合中，将key插入 返回false</span></span><br><span class="line">      <span class="keyword">if</span> (LLVM_LIKELY(KeyInfoT::isEqual(ThisBucket-&gt;getFirst(), EmptyKey))) &#123;</span><br><span class="line">        <span class="comment">// If we've already seen a tombstone while probing, fill it in instead</span></span><br><span class="line">        <span class="comment">// of the empty bucket we eventually probed to.</span></span><br><span class="line">        FoundBucket = FoundTombstone ? FoundTombstone : ThisBucket;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If this is a tombstone, remember it.  If Val ends up not in the map, we</span></span><br><span class="line">      <span class="comment">// prefer to return it than something that would require more probing.</span></span><br><span class="line">      <span class="comment">// Ditto for zero values.</span></span><br><span class="line">      <span class="comment">// 以上条件都不满足 BucketNo调整进行平移、再哈希继续查找</span></span><br><span class="line">      <span class="keyword">if</span> (KeyInfoT::isEqual(ThisBucket-&gt;getFirst(), TombstoneKey) &amp;&amp;</span><br><span class="line">          !FoundTombstone)</span><br><span class="line">        FoundTombstone = ThisBucket;  <span class="comment">// Remember the first tombstone found.</span></span><br><span class="line">      <span class="keyword">if</span> (ValueInfoT::isPurgeable(ThisBucket-&gt;getSecond())  &amp;&amp;  !FoundTombstone)</span><br><span class="line">        FoundTombstone = ThisBucket;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Otherwise, it's a hash collision or a tombstone, continue quadratic</span></span><br><span class="line">      <span class="comment">// probing.</span></span><br><span class="line">      <span class="keyword">if</span> (ProbeAmt &gt; NumBuckets) &#123;</span><br><span class="line">        FatalCorruptHashTables(BucketsPtr, NumBuckets);</span><br><span class="line">      &#125;</span><br><span class="line">      BucketNo += ProbeAmt++;</span><br><span class="line">      BucketNo &amp;= (NumBuckets<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>第2个<code>LookupBucketFor</code>的实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LookupBucketFor</span><span class="params">(<span class="keyword">const</span> LookupKeyT &amp;Val, BucketT *&amp;FoundBucket)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> BucketT *ConstFoundBucket;<span class="comment">//空的桶</span></span><br><span class="line">  <span class="keyword">bool</span> Result = <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> DenseMapBase *&gt;(<span class="keyword">this</span>)</span><br><span class="line">    -&gt;LookupBucketFor(Val, ConstFoundBucket);<span class="comment">//调用第一个LookupBucketFor方法查找</span></span><br><span class="line">  FoundBucket = <span class="keyword">const_cast</span>&lt;BucketT *&gt;(ConstFoundBucket);<span class="comment">//如果找到复制给第二个参数，因为第二个参数是引用类型会直接让调用的地方获取到值。也就是try_emplace方法的TheBucket</span></span><br><span class="line">  <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>继续走<code>value</code>为<code>true</code>的流程</p>
<p>后面还会执行<code>try_emplace</code>方法，我们在执行之前查看一下<code>refs</code>的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p refs</span><br><span class="line">(objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt;) $<span class="number">3</span> = &#123;</span><br><span class="line">  Buckets = nil</span><br><span class="line">  NumEntries = <span class="number">0</span></span><br><span class="line">  NumTombstones = <span class="number">0</span></span><br><span class="line">  NumBuckets = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>try_emplace</code>方法之后<code>refs</code>的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p refs</span><br><span class="line">(objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt;) $<span class="number">4</span> = &#123;</span><br><span class="line">  Buckets = <span class="number">0x0000000100711390</span></span><br><span class="line">  NumEntries = <span class="number">1</span></span><br><span class="line">  NumTombstones = <span class="number">0</span></span><br><span class="line">  NumBuckets = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次执行<code>try_emplace</code>插入的是一个空桶，还没有值，第二次执行第一次执行<code>try_emplace</code>才插入值，即往空桶中插入<code>ObjectAssociationMap（value，policy）</code>，返回true。</p>
<p>此时<code>result.second</code>为<code>true</code>，此时属性的<code>value</code>就关联上了。</p>
</li>
</ul>
<h5 id="关联对象结构"><a href="#关联对象结构" class="headerlink" title="关联对象结构"></a>关联对象结构</h5><p>关联对象的设置图如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/518c45cdebd6464199f8f249c2f0a134~tplv-k3u1fbpfcp-watermark.image" alt="关联对象"></p>
<p>属性设计的哈希表结构如下：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0aee709a499d45c8a1aa14d9be1f626b~tplv-k3u1fbpfcp-watermark.image" alt="关联对象哈希表"></p>
<p>map中有很多的关联对象map，类型是<code>ObjectAssociationMap</code>，其中key为<code>DisguisedPtr&lt;objc_object&gt;</code>，例如<code>JSPerson</code>会对应一个<code>ObjectAssociationMap</code>，<code>JSTeacher</code>也会对应一个<code>ObjectAssociationMap</code>。</p>
<p><code>ObjectAssociationMap</code>哈希表中有很多<code>key-value</code>键值对，其中<code>key</code>的类型为<code>const void *</code>，其实这个<code>key</code>从底层这个方法<code>_object_set_associative_reference(id object, const void *key, id value, uintptr_t policy)</code>的参数就可以看出，<code>key</code>是我们关联属性时<code>设置的字符串</code>，<code>value</code>的类型为<code>ObjcAssociation</code></p>
<h5 id="value为空流程"><a href="#value为空流程" class="headerlink" title="value为空流程"></a><code>value</code>为空流程</h5><p>这个过程其实就是<code>else</code>流程，也就是我们对<code>value</code>设置为<code>nil</code>的流程，主要就是移除关联。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">auto</span> refs_it = associations.<span class="built_in">find</span>(disguised);</span><br><span class="line">     <span class="keyword">if</span> (refs_it != associations.<span class="built_in">end</span>()) &#123;</span><br><span class="line">         <span class="keyword">auto</span> &amp;refs = refs_it-&gt;second;</span><br><span class="line">         <span class="keyword">auto</span> it = refs.<span class="built_in">find</span>(key);</span><br><span class="line">         <span class="keyword">if</span> (it != refs.<span class="built_in">end</span>()) &#123;</span><br><span class="line">             association.swap(it-&gt;second);</span><br><span class="line">             refs.erase(it);</span><br><span class="line">             <span class="keyword">if</span> (refs.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                 associations.erase(refs_it);</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>根据 DisguisedPtr 找到 AssociationsHashMap 中的 iterator 迭代查询器</li>
<li>清理迭代器</li>
<li>实际上如果插入空置 相当于清除</li>
</ul>
<h4 id="objc-getAssociatedObject流程"><a href="#objc-getAssociatedObject流程" class="headerlink" title="objc_getAssociatedObject流程"></a>objc_getAssociatedObject流程</h4><h5 id="在main方法中添加一个取值的语句"><a href="#在main方法中添加一个取值的语句" class="headerlink" title="在main方法中添加一个取值的语句"></a>在<code>main</code>方法中添加一个取值的语句</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        JSPerson *person &#x3D; [[JSPerson alloc] init];</span><br><span class="line">        person.category_name &#x3D; @&quot;哈哈哈&quot;;</span><br><span class="line">        NSString *name &#x3D; person.category_name;</span><br><span class="line">        NSLog(@&quot;done&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="objc-getAssociatedObject源码实现"><a href="#objc-getAssociatedObject源码实现" class="headerlink" title="objc_getAssociatedObject源码实现"></a><code>objc_getAssociatedObject</code>源码实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">objc_getAssociatedObject(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _object_get_associative_reference(object, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>_object_get_associative_reference</code>函数。</p>
<h5 id="object-get-associative-reference源码"><a href="#object-get-associative-reference源码" class="headerlink" title="_object_get_associative_reference源码"></a><code>_object_get_associative_reference</code>源码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">_object_get_associative_reference(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    ObjcAssociation association&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      	<span class="comment">///创建AssociationsManager管理类</span></span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">      	<span class="comment">///获取静态哈希表</span></span><br><span class="line">        <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.<span class="built_in">get</span>())</span></span>;</span><br><span class="line">      	<span class="comment">/////找到迭代器，即获取buckets</span></span><br><span class="line">        AssociationsHashMap::iterator i = associations.<span class="built_in">find</span>((objc_object *)object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.<span class="built_in">end</span>()) &#123;<span class="comment">//如果这个迭代查询器不是最后一个 继续获取</span></span><br><span class="line">            <span class="comment">//找到ObjectAssociationMap的迭代查询器获取一个经过属性修饰符修饰的value</span></span><br><span class="line">            ObjectAssociationMap &amp;refs = i-&gt;second;</span><br><span class="line">          	<span class="comment">//根据key查找ObjectAssociationMap，即获取bucket</span></span><br><span class="line">            ObjectAssociationMap::iterator j = refs.<span class="built_in">find</span>(key);</span><br><span class="line">            <span class="keyword">if</span> (j != refs.<span class="built_in">end</span>()) &#123;</span><br><span class="line">              	<span class="comment">//获取ObjcAssociation</span></span><br><span class="line">                association = j-&gt;second;</span><br><span class="line">                association.retainReturnedValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">///返回值</span></span><br><span class="line">    <span class="keyword">return</span> association.autoreleaseReturnedValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看源码分析主要分为以下几步</p>
<ul>
<li>创建一个 <code>AssociationsManager</code> 管理类</li>
<li>获取静态哈希表：<code>AssociationsHashMap</code></li>
<li>通过<code>find</code>方法根据 <code>DisguisedPtr</code> 找到 <code>AssociationsHashMap</code> 中的 <code>iterator</code> 迭代查询器</li>
<li>如果这个迭代查询器不是最后一个 继续获取 : <code>ObjectAssociationMap (policy和value)</code></li>
<li>通过<code>find</code>方法找到<code>ObjectAssociationMap</code>的迭代查询器获取一个经过属性修饰符修饰的<code>value</code></li>
<li>返回 <code>value</code></li>
</ul>
<h5 id="查找方法find"><a href="#查找方法find" class="headerlink" title="查找方法find"></a>查找方法<code>find</code></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(<span class="keyword">const_arg_type_t</span>&lt;KeyT&gt; Val)</span> </span>&#123;</span><br><span class="line">  BucketT *TheBucket;</span><br><span class="line">  <span class="keyword">if</span> (LookupBucketFor(Val, TheBucket))</span><br><span class="line">    <span class="keyword">return</span> makeIterator(TheBucket, getBucketsEnd(), <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据关联对象迭代查找<code>AssociationsHashMap</code>，也就是<code>buckets</code></p>
<h5 id="通过源码看取值流程"><a href="#通过源码看取值流程" class="headerlink" title="通过源码看取值流程"></a>通过源码看取值流程</h5><p>我们直接断点到<code>_object_get_associative_reference</code>函数</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd50af8bbb204b1b92447fa2a245d626~tplv-k3u1fbpfcp-watermark.image" alt="1626789232319"></p>
<p>执行<code>p i</code>和<code>p i-&gt;second</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p i</span><br><span class="line">(objc::DenseMapBase&lt;objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt;, objc::DenseMapValueInfo&lt;objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt;, objc::DenseMapInfo&lt;DisguisedPtr&lt;objc_object&gt; &gt;, objc::detail::DenseMapPair&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt; &gt;, DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt;, objc::DenseMapValueInfo&lt;objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt;, objc::DenseMapInfo&lt;DisguisedPtr&lt;objc_object&gt; &gt;, objc::detail::DenseMapPair&lt;DisguisedPtr&lt;objc_object&gt;, objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt; &gt; &gt;::iterator) $<span class="number">0</span> = &#123;</span><br><span class="line">  Ptr = <span class="number">0x0000000100631d60</span></span><br><span class="line">  End = <span class="number">0x0000000100631d80</span></span><br><span class="line">&#125;</span><br><span class="line">(lldb) p i-&gt;second</span><br><span class="line">(objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt;) $<span class="number">1</span> = &#123;</span><br><span class="line">  Buckets = <span class="number">0x0000000100631d80</span></span><br><span class="line">  NumEntries = <span class="number">1</span></span><br><span class="line">  NumTombstones = <span class="number">0</span></span><br><span class="line">  NumBuckets = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次执行<code>find</code>方法，在调用<code>find</code>方法之前，我们先打印<code>j</code>,此时<code>value</code>为<code>nil</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p j</span><br><span class="line">(objc::DenseMapBase&lt;objc::DenseMap&lt;const void *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;const void *&gt;, objc::detail::DenseMapPair&lt;const void *, objc::ObjcAssociation&gt; &gt;, const void *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;const void *&gt;, objc::detail::DenseMapPair&lt;const void *, objc::ObjcAssociation&gt; &gt;::iterator) $2 &#x3D; &#123;</span><br><span class="line">  Ptr &#x3D; 0x00007ffeefbff400</span><br><span class="line">  End &#x3D; 0x00000001002e70db</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p j-&gt;second</span><br><span class="line">(objc::ObjcAssociation) $3 &#x3D; &#123;</span><br><span class="line">  _policy &#x3D; 4294980472</span><br><span class="line">  _value &#x3D; nil</span><br><span class="line">&#125;</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>执行<code>find</code>方法之后再次打印,发现<code>value</code>已经有值，也就是取到了关联对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p j</span><br><span class="line">(objc::DenseMapBase&lt;objc::DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt;, <span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation, objc::DenseMapValueInfo&lt;objc::ObjcAssociation&gt;, objc::DenseMapInfo&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;, objc::detail::DenseMapPair&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, objc::ObjcAssociation&gt; &gt;::iterator) $<span class="number">4</span> = &#123;</span><br><span class="line">  Ptr = <span class="number">0x0000000100631d80</span></span><br><span class="line">  End = <span class="number">0x0000000100631de0</span></span><br><span class="line">&#125;</span><br><span class="line">(lldb) p j-&gt;second</span><br><span class="line">(objc::ObjcAssociation) $<span class="number">5</span> = &#123;</span><br><span class="line">  _policy = <span class="number">3</span></span><br><span class="line">  _value = <span class="number">0x0000000100004080</span> <span class="string">"哈哈哈"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇主要探索了<code>扩展</code>和<code>关联对象</code>，其中<code>类的扩展</code> 在<code>编译期</code> 会作为类的一部分，和类一起编译进来。</p>
<p>关联对象设置流程为：</p>
<ul>
<li>创建一个<code>AssociationsManager</code>管理类</li>
<li>获取<code>静态哈希表</code>:<code>associations</code></li>
<li>判断<code>关联值value</code>是否为空<ul>
<li>如果为空就走：<code>插入空值</code>流程。</li>
<li>如果不为空继续下一步</li>
</ul>
</li>
<li>通过<code>try_emplace</code>方法，创建一个空的 <code>ObjectAssociationMap</code> 去取查询的键值对</li>
<li>如果发现<code>没有</code> <code>key</code> 就<code>插入一个 空的 BucketT</code>进去并返回true</li>
<li>通过<code>setHasAssociatedObjects</code>方法<code>标记对象存在关联对象</code></li>
<li>用当前 <code>policy 和 value</code> 组成了一个 <code>ObjcAssociation</code> 替换原来 <code>BucketT</code>中的值</li>
<li>标记一下 <code>ObjectAssociationMap</code> 的<code>第一次</code>为 <code>false</code></li>
</ul>
<p>关联对象取值的流程为：</p>
<ul>
<li>创建一个 <code>AssociationsManager</code> 管理类</li>
<li>获取静态哈希表：<code>AssociationsHashMap</code></li>
<li>通过<code>find</code>方法根据 <code>DisguisedPtr</code> 找到 <code>AssociationsHashMap</code> 中的 <code>iterator</code> 迭代查询器</li>
<li>如果这个迭代查询器不是最后一个 继续获取 : <code>ObjectAssociationMap (policy和value)</code></li>
<li>通过<code>find</code>方法找到<code>ObjectAssociationMap</code>的迭代查询器获取一个经过属性修饰符修饰的<code>value</code></li>
<li>返回 <code>value</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jason</p>
  <div class="site-description" itemprop="description">个人技术博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">50</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
