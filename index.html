<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yujiusheng.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="个人技术博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Jason的博客">
<meta property="og:url" content="http://yujiusheng.com/index.html">
<meta property="og:site_name" content="Jason的博客">
<meta property="og:description" content="个人技术博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yujiusheng.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Jason的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jason的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/08/24/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-Block/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/24/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-Block/" class="post-title-link" itemprop="url">iOS底层探索 - Block</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-24 19:42:22" itemprop="dateCreated datePublished" datetime="2021-08-24T19:42:22+08:00">2021-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-27 22:41:00" itemprop="dateModified" datetime="2021-08-27T22:41:00+08:00">2021-08-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>block是我们开发经常遇到的一个结构，本篇我们就来探索一下它的结构。</p>
<h3 id="block的分类"><a href="#block的分类" class="headerlink" title="block的分类"></a>block的分类</h3><p>block的分类相信大家已经很清楚了，分为全局block、堆block和栈block。我们来个例子看看它们的区别</p>
<ul>
<li><p>全局block</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void (^block)(void) &#x3D; ^&#123;</span><br><span class="line">&#125;;</span><br><span class="line">NSLog(@&quot;%@&quot;,block);</span><br><span class="line">&#x2F;&#x2F;&#x2F;打印结果</span><br><span class="line">&lt;__NSGlobalBlock__: 0x1072d4100&gt;</span><br></pre></td></tr></table></figure>

<p>全局block是指不捕获任何外部变量的block，只会使用静态变量和全局变量，存储于内存的<code>全局区</code>。</p>
</li>
<li><p>堆block</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 10;</span><br><span class="line">void (^block)(void) &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;Cooci - %d&quot;,a);</span><br><span class="line">&#125;;</span><br><span class="line">NSLog(@&quot;%@&quot;,block);</span><br><span class="line">&#x2F;&#x2F;&#x2F;打印结果</span><br><span class="line">&lt;__NSMallocBlock__: 0x60000130c4b0&gt;</span><br></pre></td></tr></table></figure>

<p>堆block会捕获外部变量，存储于内存的<code>堆区</code>。</p>
</li>
<li><p>栈block</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 10;</span><br><span class="line">void (^__weak block)(void) &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;Cooci - %d&quot;,a);</span><br><span class="line">&#125;;</span><br><span class="line">NSLog(@&quot;%@&quot;,block);</span><br><span class="line">&#x2F;&#x2F;&#x2F;打印结果</span><br><span class="line">&lt;__NSStackBlock__: 0x7ffee06ac4d8&gt;</span><br></pre></td></tr></table></figure>

<p>栈block也会捕获外部变量，和堆block的区别是需要加<code>__weak</code>修饰，它存储于内存的<code>栈区</code></p>
</li>
</ul>
<h3 id="block的循环引用"><a href="#block的循环引用" class="headerlink" title="block的循环引用"></a>block的循环引用</h3><h4 id="block引起循环引用的原因"><a href="#block引起循环引用的原因" class="headerlink" title="block引起循环引用的原因"></a>block引起循环引用的原因</h4><p>A、B相互持有，所以导致A无法调用dealloc方法给B发送release信号，而B也无法接收到release信号。所以A、B此时都无法释放。如图所示</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ff0b44dcab44114828396a67d202ca5~tplv-k3u1fbpfcp-watermark.image" alt="循环引用"></p>
<h4 id="解决循环引用"><a href="#解决循环引用" class="headerlink" title="解决循环引用"></a>解决循环引用</h4><p>我们看一段循环引用的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSString *name &#x3D; @&quot;JS&quot;;</span><br><span class="line">self.block &#x3D; ^(void)&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,self.name);</span><br><span class="line">&#125;;</span><br><span class="line">self.block();</span><br></pre></td></tr></table></figure>

<p>这段代码出现了循环引用，因为在<code>block</code>内部使用了<code>外部变量name</code>，导致<code>block持有了self</code>，而<code>self原本是持有block</code>的，所以导致了<code>self和block的相互持有</code>。</p>
<p>解决方法：</p>
<ul>
<li><p>__weak和__strong组合使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^JSBlock)(void);</span><br><span class="line"></span><br><span class="line">@property(nonatomic, copy) JSBlock jslBlock;</span><br><span class="line"></span><br><span class="line">__weak typeof(self) weakSelf &#x3D; self;</span><br><span class="line">self.jslBlock &#x3D; ^(void)&#123;</span><br><span class="line">			__strong typeof(weakSelf) strongSelf &#x3D; weakSelf;</span><br><span class="line">     NSLog(@&quot;%@&quot;,weakSelf.name);</span><br><span class="line">&#125;</span><br><span class="line">self.jslBlock();</span><br></pre></td></tr></table></figure>

<p>这是我们最容易想到的方式，使用__weak打破强引用，__strong的作用的方式self提前释放，而block执行的时候因为self已经释放而拿不到值。</p>
</li>
<li><p>__block定义一个临时变量指向self。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__block ViewController *vc &#x3D; self;</span><br><span class="line">self.jslBlock &#x3D; ^(void)&#123;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,vc.name);</span><br><span class="line">        vc &#x3D; nil;&#x2F;&#x2F;需手动释放</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">self.jslBlock();</span><br></pre></td></tr></table></figure>

<p>这种方式是在方法外部定义一个指向self的变量，block内部捕获临时变量，使用结束后将临时变量置为nil，加__block的原因是需要在block内存对其进行置空操作。</p>
</li>
<li><p>block加一个参数，使用参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^JSBlock)(ViewController *);</span><br><span class="line">@property(nonatomic, copy) JSBlock jslBlock;</span><br><span class="line">self.jslBlock &#x3D; ^(ViewController *vc)&#123;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,vc.name);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">self.jslBlock(self);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Block的底层分析"><a href="#Block的底层分析" class="headerlink" title="Block的底层分析"></a>Block的底层分析</h3><p>我们主要通过clang和断点调试的方式分析。</p>
<h4 id="xcrun编译分析"><a href="#xcrun编译分析" class="headerlink" title="xcrun编译分析"></a>xcrun编译分析</h4><p>我们首先自定义一个<code>block.c</code>文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">void</span>(^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"js - %d"</span>,a);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>xcrun</code>命令讲<code>block.c</code>编译成<code>block.cpp</code>。<code>xcrun -sdk iphonesimulator clang -arch x86_64 -rewrite-objc block.c</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> a = __cself-&gt;a; <span class="comment">// bound by copy</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"js - %d"</span>,a);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">void</span>(*block)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a));</span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们把类型强转的代码去掉：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">void</span>(*block)(<span class="keyword">void</span>) = __main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, a));</span><br><span class="line">    block-&gt;FuncPtr(block);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简化之后我们看到<code>block</code>代码块是一个<code>__main_block_impl_0</code>，<code>__main_block_impl_0</code>的结构是一个结构体,它的<code>impl</code>也是一个结构体</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> _a, <span class="keyword">int</span> flags=<span class="number">0</span>) : a(_a) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意：在结构体内部捕获到了外部变量<code>a</code>，且在结构体内部生成了一个成员变量<code>a</code>与其对应。</p>
<p>我们对代码做一下修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    __block int a &#x3D; 18;</span><br><span class="line">    void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">        a++;</span><br><span class="line">        printf(&quot;js - %d&quot;,a);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新<code>xcrun</code>一下看看结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __Block_byref_a_0 *a; <span class="comment">// by ref</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, <span class="keyword">int</span> flags=<span class="number">0</span>) : a(_a-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>可以看到，现在的<code>a</code>和之前的<code>a</code>不同的是加了<code>__Block_byref_a_0 *</code>修饰，这样就可以对捕获到的变量进行修改，传给block是a的地址，所以block内部可以修改。</p>
</li>
<li><p><code>impl.isa = &amp;_NSConcreteStackBlock</code>说明现在<code>栈类型</code>根据我们前面的分析这里应该是<code>堆block</code>，为什么不同呢。</p>
</li>
<li><p>fp是一个函数式保存，如果不调用不会执行。</p>
</li>
</ul>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>我们首先用汇编，查看源码在哪个库中，我们打断点</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43a7f94029c64667a1de4d787d11d80f~tplv-k3u1fbpfcp-watermark.image" alt="断点"></p>
<p>然后看汇编代码，<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf9c4a24e15d42babeb4c0cb6b706af8~tplv-k3u1fbpfcp-watermark.image" alt="源码定位"></p>
<p>我们添加符号断点<code>objc_retainBlock</code>:</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24c28d4e308c4869a1c3aea6e4627459~tplv-k3u1fbpfcp-watermark.image" alt="1629984483869"></p>
<p>所以我们去<code>libobjc</code>去搜索<code>objc_retainBlock</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id <span class="title">objc_retainBlock</span><span class="params">(id x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (id)_Block_copy(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际调用了<code>_Block_copy</code>,在<code>libobjc</code>库中并没有找到方法的实现，我们继续打符号断点：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/973b28fba97a4952bb24470da47023fb~tplv-k3u1fbpfcp-watermark.image" alt="1629984996709"></p>
<p><code>_Block_copy</code>函数的实现在<code>libsystem</code>库中，这个库没有开源，我们找一个替换的库<code>libclosure</code>的源码分析。我们在<code>libclosure</code>源码中搜索<code>_Block_copy</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy, or bump refcount, of a block.  If really copying, call the copy helper if present.</span></span><br><span class="line"><span class="keyword">void</span> *_Block_copy(<span class="keyword">const</span> <span class="keyword">void</span> *arg) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_layout</span> *<span class="title">aBlock</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!arg) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// The following would be better done as a switch statement</span></span><br><span class="line">    aBlock = (struct Block_layout *)arg;</span><br><span class="line">    <span class="keyword">if</span> (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) &#123;</span><br><span class="line">        <span class="comment">// latches on high</span></span><br><span class="line">        latching_incr_int(&amp;aBlock-&gt;flags);</span><br><span class="line">        <span class="keyword">return</span> aBlock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) &#123;</span><br><span class="line">        <span class="keyword">return</span> aBlock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 栈 - 堆 运行时拷贝到堆上</span></span><br><span class="line">        <span class="comment">// Its a stack block.  Make a copy.</span></span><br><span class="line">        <span class="keyword">size_t</span> <span class="built_in">size</span> = Block_size(aBlock);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Block_layout</span> *<span class="title">result</span> = (<span class="title">struct</span> <span class="title">Block_layout</span> *)<span class="title">malloc</span>(<span class="title">size</span>);</span></span><br><span class="line">        <span class="keyword">if</span> (!result) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        memmove(result, aBlock, <span class="built_in">size</span>); <span class="comment">// bitcopy first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(ptrauth_calls)</span></span><br><span class="line">        <span class="comment">// Resign the invoke pointer as it uses address authentication.</span></span><br><span class="line">        result-&gt;invoke = aBlock-&gt;invoke;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(ptrauth_signed_block_descriptors)</span></span><br><span class="line">        <span class="keyword">if</span> (aBlock-&gt;flags &amp; BLOCK_SMALL_DESCRIPTOR) &#123;</span><br><span class="line">            <span class="keyword">uintptr_t</span> oldDesc = ptrauth_blend_discriminator(</span><br><span class="line">                    &amp;aBlock-&gt;descriptor,</span><br><span class="line">                    _Block_descriptor_ptrauth_discriminator);</span><br><span class="line">            <span class="keyword">uintptr_t</span> newDesc = ptrauth_blend_discriminator(</span><br><span class="line">                    &amp;result-&gt;descriptor,</span><br><span class="line">                    _Block_descriptor_ptrauth_discriminator);</span><br><span class="line"></span><br><span class="line">            result-&gt;descriptor =</span><br><span class="line">                    ptrauth_auth_and_resign(aBlock-&gt;descriptor,</span><br><span class="line">                                            ptrauth_key_asda, oldDesc,</span><br><span class="line">                                            ptrauth_key_asda, newDesc);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">// reset refcount</span></span><br><span class="line">        result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK|BLOCK_DEALLOCATING);    <span class="comment">// XXX not needed</span></span><br><span class="line">        result-&gt;flags |= BLOCK_NEEDS_FREE | <span class="number">2</span>;  <span class="comment">// logical refcount 1</span></span><br><span class="line">        _Block_call_copy_helper(result, aBlock);</span><br><span class="line">        <span class="comment">// Set isa last so memory analysis tools see a fully-initialized object.</span></span><br><span class="line">        result-&gt;isa = _NSConcreteMallocBlock;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>Block_layout</code>结构体的结构是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block_layout</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> * __ptrauth_objc_isa_pointer isa;<span class="comment">//isa 标识是栈、堆block类型</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span> flags; <span class="comment">// contains ref count 引用计数</span></span><br><span class="line">    <span class="keyword">int32_t</span> reserved;<span class="comment">//流程数据</span></span><br><span class="line">    BlockInvokeFunction invoke;<span class="comment">//调用函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_descriptor_1</span> *<span class="title">descriptor</span>;</span><span class="comment">//相关描述</span></span><br><span class="line">    <span class="comment">// imported variables</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对结构有个简单了解之后，我们打符号断点，看运行中<code>block</code>的结构。</p>
<ul>
<li><p><code>objc_retainBlock</code></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fca99172b35b4a35a130f9bb0ea423dd~tplv-k3u1fbpfcp-watermark.image" alt="1629986289286"></p>
<p>发现此时的block类型还是<code>StackBlock</code>。</p>
</li>
<li><p>在<code>_Block_copy</code>最后打一个断点：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cb0fd0a0551400ab250a8d6ad9142f6~tplv-k3u1fbpfcp-watermark.image" alt="1629986567227"></p>
<p>此时<code>block</code>的类型就是<code>__NSMallocBlock__</code>类型了。</p>
</li>
</ul>
<h5 id="blockLayout结构"><a href="#blockLayout结构" class="headerlink" title="blockLayout结构"></a>blockLayout结构</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block_layout</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> * __ptrauth_objc_isa_pointer isa;<span class="comment">//isa 标识是栈、堆block类型</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span> flags; <span class="comment">// contains ref count 引用计数</span></span><br><span class="line">    <span class="keyword">int32_t</span> reserved;<span class="comment">//流程数据</span></span><br><span class="line">    BlockInvokeFunction invoke;<span class="comment">//调用函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_descriptor_1</span> *<span class="title">descriptor</span>;</span><span class="comment">//相关描述</span></span><br><span class="line">    <span class="comment">// imported variables</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们看<code>Block_descriptor_1</code>的结构，发现并没有上面调试打印的<code>signature</code>信息。</p>
<p>我们看源码发现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCK_DESCRIPTOR_2 1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block_descriptor_2</span> &#123;</span></span><br><span class="line">    <span class="comment">// requires BLOCK_HAS_COPY_DISPOSE</span></span><br><span class="line">    BlockCopyFunction copy;<span class="comment">//拷贝函数指针</span></span><br><span class="line">    BlockDisposeFunction dispose;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCK_DESCRIPTOR_3 1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block_descriptor_3</span> &#123;</span></span><br><span class="line">    <span class="comment">// requires BLOCK_HAS_SIGNATURE</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *signature;<span class="comment">//签名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *layout;     <span class="comment">// contents depend on BLOCK_HAS_EXTENDED_LAYOUT 布局</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Block_descriptor_2</code>和<code>Block_descriptor_3</code>是可选的，它们是通过<code>Block_descriptor_1</code>内存平移得到的。</p>
<h5 id="捕获变量的copy"><a href="#捕获变量的copy" class="headerlink" title="捕获变量的copy"></a>捕获变量的copy</h5><h6 id="Block-copy"><a href="#Block-copy" class="headerlink" title="_Block_copy"></a>_Block_copy</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy, or bump refcount, of a block.  If really copying, call the copy helper if present.</span></span><br><span class="line"><span class="comment">//  栈Block -&gt; 堆Block</span></span><br><span class="line"><span class="keyword">void</span> *_Block_copy(<span class="keyword">const</span> <span class="keyword">void</span> *arg) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_layout</span> *<span class="title">aBlock</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!arg) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The following would be better done as a switch statement</span></span><br><span class="line">    aBlock = (struct Block_layout *)arg;<span class="comment">//强转为Block_layout类型对象，防止对外界造成影响</span></span><br><span class="line">    <span class="keyword">if</span> (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) &#123;<span class="comment">//是否需要释放</span></span><br><span class="line">        <span class="comment">// latches on high</span></span><br><span class="line">        latching_incr_int(&amp;aBlock-&gt;flags);</span><br><span class="line">        <span class="keyword">return</span> aBlock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) &#123;<span class="comment">//如果是全局block，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> aBlock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//为栈block 或者 堆block，由于堆区需要申请内存，所以只可能是栈区</span></span><br><span class="line">        <span class="comment">// Its a stack block.  Make a copy. 它是一个堆栈块block，拷贝。</span></span><br><span class="line">        struct Block_layout *result =</span><br><span class="line">            (struct Block_layout *)<span class="built_in">malloc</span>(aBlock-&gt;descriptor-&gt;<span class="built_in">size</span>);<span class="comment">//申请空间并接收</span></span><br><span class="line">        <span class="keyword">if</span> (!result) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//通过memmove内存拷贝，将 aBlock 拷贝至result</span></span><br><span class="line">        memmove(result, aBlock, aBlock-&gt;descriptor-&gt;<span class="built_in">size</span>); <span class="comment">// bitcopy first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(ptrauth_calls)</span></span><br><span class="line">        <span class="comment">// Resign the invoke pointer as it uses address authentication.</span></span><br><span class="line">        result-&gt;invoke = aBlock-&gt;invoke;<span class="comment">//可以直接调起invoke</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">// reset refcount</span></span><br><span class="line">        result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK|BLOCK_DEALLOCATING);    <span class="comment">// XXX not needed 告知可释放</span></span><br><span class="line">        result-&gt;flags |= BLOCK_NEEDS_FREE | <span class="number">2</span>;  <span class="comment">// logical refcount 1</span></span><br><span class="line">        _Block_call_copy_helper(result, aBlock);</span><br><span class="line">        <span class="comment">// Set isa last so memory analysis tools see a fully-initialized object.</span></span><br><span class="line">        result-&gt;isa = _NSConcreteMallocBlock;<span class="comment">//设置block对象类型为堆区block</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_Block_copy</code>主要是将block从栈区拷贝到堆区</p>
<ul>
<li>如果需要释放，则直接释放</li>
<li>如果是<code>globalBlock</code>不需要copy，返回</li>
<li>剩下两种情况：堆区block和栈区block。由于堆区block需要申请内存，这里到这里只能是栈block。<ul>
<li>通过<code>malloc</code>申请内存空间用于接收block</li>
<li>通过remove将block拷贝至新申请的内存中</li>
<li>设置block对象的类型为堆区block。将<code>isa</code>指向<code>__NSConcreteMallocBlock</code></li>
</ul>
</li>
</ul>
<h6 id="Block-object-assign"><a href="#Block-object-assign" class="headerlink" title="_Block_object_assign"></a>_Block_object_assign</h6><p>先看一个枚举的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Block 捕获的外界变量的种类</span></span><br><span class="line"><span class="comment">// Runtime support functions used by compiler when generating copy/dispose helpers</span></span><br><span class="line"><span class="comment">// Values for _Block_object_assign() and _Block_object_dispose() parameters</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    <span class="comment">// see function implementation for a more complete description of these fields and combinations</span></span><br><span class="line">    <span class="comment">//普通对象，即没有其他的引用类型</span></span><br><span class="line">    BLOCK_FIELD_IS_OBJECT   =  <span class="number">3</span>,  <span class="comment">// id, NSObject, __attribute__((NSObject)), block, ...</span></span><br><span class="line">    <span class="comment">//block类型作为变量</span></span><br><span class="line">    BLOCK_FIELD_IS_BLOCK    =  <span class="number">7</span>,  <span class="comment">// a block variable</span></span><br><span class="line">    <span class="comment">//经过__block修饰的变量</span></span><br><span class="line">    BLOCK_FIELD_IS_BYREF    =  <span class="number">8</span>,  <span class="comment">// the on stack structure holding the __block variable</span></span><br><span class="line">    <span class="comment">//weak 弱引用变量</span></span><br><span class="line">    BLOCK_FIELD_IS_WEAK     = <span class="number">16</span>,  <span class="comment">// declared __weak, only used in byref copy helpers</span></span><br><span class="line">    <span class="comment">//返回的调用对象 - 处理block_byref内部对象内存会加的一个额外标记，配合flags一起使用</span></span><br><span class="line">    BLOCK_BYREF_CALLER      = <span class="number">128</span>, <span class="comment">// called from __block (byref) copy/dispose support routines.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中用的最多的是<code>BLOCK_FIELD_IS_OBJECT</code>和<code>BLOCK_FIELD_IS_BYREF</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref</span> *_<span class="title">Block_byref_copy</span>(<span class="title">const</span> <span class="title">void</span> *<span class="title">arg</span>) &#123;</span></span><br><span class="line">    <span class="comment">//强转为Block_byref结构体类型，保存一份</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref</span> *<span class="title">src</span> = (<span class="title">struct</span> <span class="title">Block_byref</span> *)<span class="title">arg</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((src-&gt;forwarding-&gt;flags &amp; BLOCK_REFCOUNT_MASK) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// src points to stack 申请内存</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref</span> *<span class="title">copy</span> = (<span class="title">struct</span> <span class="title">Block_byref</span> *)<span class="title">malloc</span>(<span class="title">src</span>-&gt;<span class="title">size</span>);</span></span><br><span class="line">        copy-&gt;isa = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// byref value 4 is logical refcount of 2: one for caller, one for stack</span></span><br><span class="line">        copy-&gt;flags = src-&gt;flags | BLOCK_BYREF_NEEDS_FREE | <span class="number">4</span>;</span><br><span class="line">        <span class="comment">//block内部持有的Block_byref 和 外界的Block_byref 所持有的对象是同一个，这也是为什么__block修饰的变量具有修改能力</span></span><br><span class="line">        <span class="comment">//copy 和 scr 的地址指针达到了完美的同一份拷贝，目前只有持有能力</span></span><br><span class="line">        copy-&gt;forwarding = copy; <span class="comment">// patch heap copy to point to itself</span></span><br><span class="line">        src-&gt;forwarding = copy;  <span class="comment">// patch stack to point to heap copy</span></span><br><span class="line">        copy-&gt;<span class="built_in">size</span> = src-&gt;<span class="built_in">size</span>;</span><br><span class="line">        <span class="comment">//如果有copy能力</span></span><br><span class="line">        <span class="keyword">if</span> (src-&gt;flags &amp; BLOCK_BYREF_HAS_COPY_DISPOSE) &#123;</span><br><span class="line">            <span class="comment">// Trust copy helper to copy everything of interest</span></span><br><span class="line">            <span class="comment">// If more than one field shows up in a byref block this is wrong XXX</span></span><br><span class="line">            <span class="comment">//Block_byref_2是结构体，__block修饰的可能是对象，对象通过byref_keep保存，在合适的时机进行调用</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref_2</span> *<span class="title">src2</span> = (<span class="title">struct</span> <span class="title">Block_byref_2</span> *)(<span class="title">src</span>+1);</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref_2</span> *<span class="title">copy2</span> = (<span class="title">struct</span> <span class="title">Block_byref_2</span> *)(<span class="title">copy</span>+1);</span></span><br><span class="line">            copy2-&gt;byref_keep = src2-&gt;byref_keep;</span><br><span class="line">            copy2-&gt;byref_destroy = src2-&gt;byref_destroy;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (src-&gt;flags &amp; BLOCK_BYREF_LAYOUT_EXTENDED) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref_3</span> *<span class="title">src3</span> = (<span class="title">struct</span> <span class="title">Block_byref_3</span> *)(<span class="title">src2</span>+1);</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref_3</span> *<span class="title">copy3</span> = (<span class="title">struct</span> <span class="title">Block_byref_3</span>*)(<span class="title">copy2</span>+1);</span></span><br><span class="line">                copy3-&gt;layout = src3-&gt;layout;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//等价于 __Block_byref_id_object_copy</span></span><br><span class="line">            (*src2-&gt;byref_keep)(copy, src);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Bitwise copy.</span></span><br><span class="line">            <span class="comment">// This copy includes Block_byref_3, if any.</span></span><br><span class="line">            memmove(copy+<span class="number">1</span>, src+<span class="number">1</span>, src-&gt;<span class="built_in">size</span> - <span class="keyword">sizeof</span>(*src));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// already copied to heap</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((src-&gt;forwarding-&gt;flags &amp; BLOCK_BYREF_NEEDS_FREE) == BLOCK_BYREF_NEEDS_FREE) &#123;</span><br><span class="line">        latching_incr_int(&amp;src-&gt;forwarding-&gt;flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> src-&gt;forwarding;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_Block_object_assign</code>是在底层编译代码中，外部变量拷贝时调用的方法就是它。</p>
<ul>
<li>如果是普通对象，交给系统arc处理，拷贝对象指针，引用技术+1，外界变量不能释放。</li>
<li>如果是block类型的变量，通过_Block_copy操作，将block从栈区拷贝到堆区。</li>
<li>如果是<code>__block</code>修饰的变量，调用<code>_Block_byref_copy</code>函数，进行内存拷贝以及常规处理。</li>
</ul>
<h6 id="Block-byref-copy"><a href="#Block-byref-copy" class="headerlink" title="_Block_byref_copy"></a>_Block_byref_copy</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref</span> *_<span class="title">Block_byref_copy</span>(<span class="title">const</span> <span class="title">void</span> *<span class="title">arg</span>) &#123;</span></span><br><span class="line">    <span class="comment">//强转为Block_byref结构体类型，保存一份</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref</span> *<span class="title">src</span> = (<span class="title">struct</span> <span class="title">Block_byref</span> *)<span class="title">arg</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((src-&gt;forwarding-&gt;flags &amp; BLOCK_REFCOUNT_MASK) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// src points to stack 申请内存</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref</span> *<span class="title">copy</span> = (<span class="title">struct</span> <span class="title">Block_byref</span> *)<span class="title">malloc</span>(<span class="title">src</span>-&gt;<span class="title">size</span>);</span></span><br><span class="line">        copy-&gt;isa = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// byref value 4 is logical refcount of 2: one for caller, one for stack</span></span><br><span class="line">        copy-&gt;flags = src-&gt;flags | BLOCK_BYREF_NEEDS_FREE | <span class="number">4</span>;</span><br><span class="line">        <span class="comment">//block内部持有的Block_byref 和 外界的Block_byref 所持有的对象是同一个，这也是为什么__block修饰的变量具有修改能力</span></span><br><span class="line">        <span class="comment">//copy 和 scr 的地址指针达到了完美的同一份拷贝，目前只有持有能力</span></span><br><span class="line">        copy-&gt;forwarding = copy; <span class="comment">// patch heap copy to point to itself</span></span><br><span class="line">        src-&gt;forwarding = copy;  <span class="comment">// patch stack to point to heap copy</span></span><br><span class="line">        copy-&gt;<span class="built_in">size</span> = src-&gt;<span class="built_in">size</span>;</span><br><span class="line">        <span class="comment">//如果有copy能力</span></span><br><span class="line">        <span class="keyword">if</span> (src-&gt;flags &amp; BLOCK_BYREF_HAS_COPY_DISPOSE) &#123;</span><br><span class="line">            <span class="comment">// Trust copy helper to copy everything of interest</span></span><br><span class="line">            <span class="comment">// If more than one field shows up in a byref block this is wrong XXX</span></span><br><span class="line">            <span class="comment">//Block_byref_2是结构体，__block修饰的可能是对象，对象通过byref_keep保存，在合适的时机进行调用</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref_2</span> *<span class="title">src2</span> = (<span class="title">struct</span> <span class="title">Block_byref_2</span> *)(<span class="title">src</span>+1);</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref_2</span> *<span class="title">copy2</span> = (<span class="title">struct</span> <span class="title">Block_byref_2</span> *)(<span class="title">copy</span>+1);</span></span><br><span class="line">            copy2-&gt;byref_keep = src2-&gt;byref_keep;</span><br><span class="line">            copy2-&gt;byref_destroy = src2-&gt;byref_destroy;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (src-&gt;flags &amp; BLOCK_BYREF_LAYOUT_EXTENDED) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref_3</span> *<span class="title">src3</span> = (<span class="title">struct</span> <span class="title">Block_byref_3</span> *)(<span class="title">src2</span>+1);</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref_3</span> *<span class="title">copy3</span> = (<span class="title">struct</span> <span class="title">Block_byref_3</span>*)(<span class="title">copy2</span>+1);</span></span><br><span class="line">                copy3-&gt;layout = src3-&gt;layout;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//等价于 __Block_byref_id_object_copy</span></span><br><span class="line">            (*src2-&gt;byref_keep)(copy, src);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Bitwise copy.</span></span><br><span class="line">            <span class="comment">// This copy includes Block_byref_3, if any.</span></span><br><span class="line">            memmove(copy+<span class="number">1</span>, src+<span class="number">1</span>, src-&gt;<span class="built_in">size</span> - <span class="keyword">sizeof</span>(*src));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// already copied to heap</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((src-&gt;forwarding-&gt;flags &amp; BLOCK_BYREF_NEEDS_FREE) == BLOCK_BYREF_NEEDS_FREE) &#123;</span><br><span class="line">        latching_incr_int(&amp;src-&gt;forwarding-&gt;flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> src-&gt;forwarding;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将传入的对象，强转为<code>Block_byref</code>结构体类型对象。保存</li>
<li>如果没有将变量拷贝到堆上，就申请内存进行拷贝</li>
<li>如果已经拷贝，则进行处理并返回</li>
<li>其中copy和src的forwarding指针都是指向同一片内存。这就是为什么<code>__block</code>修饰的对象具有修改的能力。</li>
</ul>
<h4 id="三层copy小结"><a href="#三层copy小结" class="headerlink" title="三层copy小结"></a>三层copy小结</h4><ul>
<li>第一层：通过<code>_Block_copy</code>实现对象的<code>自身拷贝</code>,从栈区拷贝至堆区</li>
<li>第二层：通过<code>_Block_byref_copy</code>方法，将对象拷贝为<code>Block_byref</code>结构体类型</li>
<li>第三次：调用<code>_Block_object_assign</code>方法，对<code>__block</code>修饰的<code>当前变量的拷贝</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/08/23/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/23/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81/" class="post-title-link" itemprop="url">iOS多线程-锁</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-23 23:29:44" itemprop="dateCreated datePublished" datetime="2021-08-23T23:29:44+08:00">2021-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-27 22:05:07" itemprop="dateModified" datetime="2021-08-27T22:05:07+08:00">2021-08-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前面几篇我们探索了<code>iOS</code>使用频率很高的多线程技术<code>GCD</code>，本篇我们探索多线程中一个重要的概念<code>锁</code>。</p>
<h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><p>锁主要分为两大类<code>自旋锁</code>和<code>互斥锁</code>。</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>在自旋锁中，<code>线程会反复检查变量是否可用</code>。由于线程这个过程中一致保持执行，所以是一种<code>忙等待</code>。 一旦获取了自旋锁，线程就<code>会一直保持该锁</code>，直到显式释放自旋锁。自旋锁避免了进程上下文的调度开销，因此对于<code>线程只会阻塞很短时间的场合</code>是<code>有效</code>的。对于iOS属性的修饰符<code>atomic</code>，自带一把自旋锁</p>
<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p><code>互斥锁</code>是一种用于<code>多线程编程</code>中，<code>防止两条线程同时对同一公共资源（例如全局变量）进行读写的机制</code>，该目的是通过<code>将代码切成一个个临界区</code>而达成。</p>
<h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>读写锁实际是一种特殊的互斥锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源 进行读访问，写者则需要对共享资源进行写操作。这种锁相对于自旋锁而言，能提高并发性，因为在多处理器系统中，它允许同时有多个读者来访问共享资源，最大可能的读者数为实际的逻辑CPU 数。写者是排他性的，一个读写锁同时只能有一个写者或多个读者(与CPU数相关)，但不能同时既有读者又有写者。在读写锁保持期间也是抢占失效的。</p>
<p>如果读写锁当前没有读者，也没有写者，那么写者可以立刻获得读写锁，否则它必须自旋在那里， 直到没有任何写者或读者。如果读写锁没有写者，那么读者可以立即获得该读写锁，否则读者必须自旋在那里，直到写者释放该读写锁。</p>
<p>当读写锁是写加锁状态时, 在这个锁被解锁之前, 所有试图对这个锁加锁的线程都会被阻塞.当读写锁在读加锁状态时, 所有试图以读模式对它进行加锁的线程都可以得到访问权, 但是如果线程希望以写模式对此锁进行加锁, 它必须直到所有的线程释放锁.通常, 当读写锁处于读模式锁住状态时, 如果有另外线程试图以写模式加锁, 读写锁通常会阻塞随后的读模式锁请求, 这样可以避免读模式锁⻓期占用, 而等待的写模式锁请求⻓期阻塞.读写锁适合于对数据结构的读次数比写次数多得多的情况. 因为, 读模式锁定时可以共享, 以写模式锁住时意味着独占, 所以读写锁又叫共享-独占锁.</p>
<h3 id="几种锁的性能对比"><a href="#几种锁的性能对比" class="headerlink" title="几种锁的性能对比"></a>几种锁的性能对比</h3><p>我们通过代码打印的方式比较各种锁性能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">int js_runTimes &#x3D; 100000;</span><br><span class="line">&#x2F;** OSSpinLock 性能 *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">    OSSpinLock js_spinlock &#x3D; OS_SPINLOCK_INIT;</span><br><span class="line">    double_t js_beginTime &#x3D; CFAbsoluteTimeGetCurrent();</span><br><span class="line">    for (int i&#x3D;0 ; i &lt; js_runTimes; i++) &#123;</span><br><span class="line">        OSSpinLockLock(&amp;js_spinlock);          &#x2F;&#x2F;解锁</span><br><span class="line">        OSSpinLockUnlock(&amp;js_spinlock);</span><br><span class="line">    &#125;</span><br><span class="line">    double_t js_endTime &#x3D; CFAbsoluteTimeGetCurrent() ;</span><br><span class="line">    JSLog(@&quot;OSSpinLock: %f ms&quot;,(js_endTime - js_beginTime)*1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** dispatch_semaphore_t 性能 *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_semaphore_t js_sem &#x3D; dispatch_semaphore_create(1);</span><br><span class="line">    double_t js_beginTime &#x3D; CFAbsoluteTimeGetCurrent();</span><br><span class="line">    for (int i&#x3D;0 ; i &lt; js_runTimes; i++) &#123;</span><br><span class="line">        dispatch_semaphore_wait(js_sem, DISPATCH_TIME_FOREVER);</span><br><span class="line">        dispatch_semaphore_signal(js_sem);</span><br><span class="line">    &#125;</span><br><span class="line">    double_t js_endTime &#x3D; CFAbsoluteTimeGetCurrent() ;</span><br><span class="line">    JSLog(@&quot;dispatch_semaphore_t: %f ms&quot;,(js_endTime - js_beginTime)*1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** os_unfair_lock_lock 性能 *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">    os_unfair_lock js_unfairlock &#x3D; OS_UNFAIR_LOCK_INIT;</span><br><span class="line">    double_t js_beginTime &#x3D; CFAbsoluteTimeGetCurrent();</span><br><span class="line">    for (int i&#x3D;0 ; i &lt; js_runTimes; i++) &#123;</span><br><span class="line">        os_unfair_lock_lock(&amp;js_unfairlock);</span><br><span class="line">        os_unfair_lock_unlock(&amp;js_unfairlock);</span><br><span class="line">    &#125;</span><br><span class="line">    double_t js_endTime &#x3D; CFAbsoluteTimeGetCurrent() ;</span><br><span class="line">    JSLog(@&quot;os_unfair_lock_lock: %f ms&quot;,(js_endTime - js_beginTime)*1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;** pthread_mutex_t 性能 *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_t js_metext &#x3D; PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">  </span><br><span class="line">    double_t js_beginTime &#x3D; CFAbsoluteTimeGetCurrent();</span><br><span class="line">    for (int i&#x3D;0 ; i &lt; js_runTimes; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;js_metext);</span><br><span class="line">        pthread_mutex_unlock(&amp;js_metext);</span><br><span class="line">    &#125;</span><br><span class="line">    double_t js_endTime &#x3D; CFAbsoluteTimeGetCurrent() ;</span><br><span class="line">    JSLog(@&quot;pthread_mutex_t: %f ms&quot;,(js_endTime - js_beginTime)*1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;** NSlock 性能 *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">    NSLock *js_lock &#x3D; [NSLock new];</span><br><span class="line">    double_t js_beginTime &#x3D; CFAbsoluteTimeGetCurrent();</span><br><span class="line">    for (int i&#x3D;0 ; i &lt; js_runTimes; i++) &#123;</span><br><span class="line">        [js_lock lock];</span><br><span class="line">        [js_lock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">    double_t js_endTime &#x3D; CFAbsoluteTimeGetCurrent() ;</span><br><span class="line">    JSLog(@&quot;NSlock: %f ms&quot;,(js_endTime - js_beginTime)*1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** NSCondition 性能 *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">    NSCondition *js_condition &#x3D; [NSCondition new];</span><br><span class="line">    double_t js_beginTime &#x3D; CFAbsoluteTimeGetCurrent();</span><br><span class="line">    for (int i&#x3D;0 ; i &lt; js_runTimes; i++) &#123;</span><br><span class="line">        [js_condition lock];</span><br><span class="line">        [js_condition unlock];</span><br><span class="line">    &#125;</span><br><span class="line">    double_t js_endTime &#x3D; CFAbsoluteTimeGetCurrent() ;</span><br><span class="line">    JSLog(@&quot;NSCondition: %f ms&quot;,(js_endTime - js_beginTime)*1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** PTHREAD_MUTEX_RECURSIVE 性能 *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_t js_metext_recurive;</span><br><span class="line">    pthread_mutexattr_t attr;</span><br><span class="line">    pthread_mutexattr_init (&amp;attr);</span><br><span class="line">    pthread_mutexattr_settype (&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">    pthread_mutex_init (&amp;js_metext_recurive, &amp;attr);</span><br><span class="line">    </span><br><span class="line">    double_t js_beginTime &#x3D; CFAbsoluteTimeGetCurrent();</span><br><span class="line">    for (int i&#x3D;0 ; i &lt; js_runTimes; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;js_metext_recurive);</span><br><span class="line">        pthread_mutex_unlock(&amp;js_metext_recurive);</span><br><span class="line">    &#125;</span><br><span class="line">    double_t js_endTime &#x3D; CFAbsoluteTimeGetCurrent() ;</span><br><span class="line">    JSLog(@&quot;PTHREAD_MUTEX_RECURSIVE: %f ms&quot;,(js_endTime - js_beginTime)*1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** NSRecursiveLock 性能 *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">    NSRecursiveLock *js_recursiveLock &#x3D; [NSRecursiveLock new];</span><br><span class="line">    double_t js_beginTime &#x3D; CFAbsoluteTimeGetCurrent();</span><br><span class="line">    for (int i&#x3D;0 ; i &lt; js_runTimes; i++) &#123;</span><br><span class="line">        [js_recursiveLock lock];</span><br><span class="line">        [js_recursiveLock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">    double_t js_endTime &#x3D; CFAbsoluteTimeGetCurrent() ;</span><br><span class="line">    JSLog(@&quot;NSRecursiveLock: %f ms&quot;,(js_endTime - js_beginTime)*1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;** NSConditionLock 性能 *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">    NSConditionLock *js_conditionLock &#x3D; [NSConditionLock new];</span><br><span class="line">    double_t js_beginTime &#x3D; CFAbsoluteTimeGetCurrent();</span><br><span class="line">    for (int i&#x3D;0 ; i &lt; js_runTimes; i++) &#123;</span><br><span class="line">        [js_conditionLock lock];</span><br><span class="line">        [js_conditionLock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">    double_t js_endTime &#x3D; CFAbsoluteTimeGetCurrent() ;</span><br><span class="line">    JSLog(@&quot;NSConditionLock: %f ms&quot;,(js_endTime - js_beginTime)*1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** @synchronized 性能 *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">    double_t js_beginTime &#x3D; CFAbsoluteTimeGetCurrent();</span><br><span class="line">    for (int i&#x3D;0 ; i &lt; js_runTimes; i++) &#123;</span><br><span class="line">        @synchronized(self) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    double_t js_endTime &#x3D; CFAbsoluteTimeGetCurrent() ;</span><br><span class="line">    JSLog(@&quot;@synchronized: %f ms&quot;,(js_endTime - js_beginTime)*1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在iPhone 12pro模拟器打印的结果为：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e27af26dedf46ff9c3bc053105c7f1d~tplv-k3u1fbpfcp-watermark.image" alt="模拟器锁性能"></p>
<p>在iPhone12 mini真机的结果如下：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c6345a8d4df4656a9edb72697e8c6e9~tplv-k3u1fbpfcp-watermark.image" alt="12mini锁的性能"></p>
<p>可以看到模拟器上<strong>@synchronized</strong>锁性能是比较差的，但12系列(xr经过测试并没提高)手机的性能有很大提升，我们项目中会比较常见，我们就从<strong>@synchronized</strong>开始探索。</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a><strong>@synchronized</strong></h3><h4 id="xcrun分析"><a href="#xcrun分析" class="headerlink" title="xcrun分析"></a>xcrun分析</h4><p>我们在<code>main.m</code>文件里写一个锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    NSString * appDelegateClassName;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        &#x2F;&#x2F; Setup code that might create autoreleased objects goes here.</span><br><span class="line">        appDelegateClassName &#x3D; NSStringFromClass([AppDelegate class]);</span><br><span class="line">        @synchronized (appDelegateClassName) &#123;</span><br><span class="line">       </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return UIApplicationMain(argc, argv, nil, appDelegateClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>xcrun</code>命令将其编译成<code>.cpp</code>文件</p>
<p><code>xcrun -sdk iphoneos clang -arch arm64e -rewrite-objc main.m</code></p>
<p>在<code>main.cpp</code>文件最下方找到<code>main</code>函数的实习，定位到<code>@synchronized</code>代码块</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db699552afd14951b6c3695a353a7d51~tplv-k3u1fbpfcp-watermark.image" alt="xcrunsyn"></p>
<p>将代码排版之后：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  id _rethrow = <span class="number">0</span>; </span><br><span class="line">  id _sync_obj = (id)appDelegateClassName; </span><br><span class="line">  objc_sync_enter(_sync_obj);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">SYNC_EXIT</span> &#123;</span></span><br><span class="line">         _SYNC_EXIT(id arg) : sync_exit(arg) &#123;&#125;</span><br><span class="line">       ~_SYNC_EXIT() &#123;objc_sync_exit(sync_exit);&#125;</span><br><span class="line">        id sync_exit;</span><br><span class="line">    &#125; </span><br><span class="line">    _sync_exit(_sync_obj);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (id e) &#123;_rethrow = e;&#125;</span><br><span class="line">  &#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">FIN</span> &#123;</span> _FIN(id reth) : rethrow(reth) &#123;&#125;</span><br><span class="line">  ~_FIN() &#123; <span class="keyword">if</span> (rethrow) objc_exception_throw(rethrow); &#125;</span><br><span class="line">  id rethrow;</span><br><span class="line">&#125; _fin_force_rethow(_rethrow);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加锁成功的情况我们只需要关注<code>try</code>代码块及以上的代码。经过我们的简化后的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id _sync_obj = (id)appDelegateClassName; </span><br><span class="line">objc_sync_enter(_sync_obj);</span><br><span class="line">objc_sync_exit(sync_exit);</span><br></pre></td></tr></table></figure>

<p>可以看到主要就是执行了两个函数<code>objc_sync_enter</code>和<code>objc_sync_exit</code>。</p>
<h4 id="libobjc源码分析"><a href="#libobjc源码分析" class="headerlink" title="libobjc源码分析"></a>libobjc源码分析</h4><p>通过打符号断点<code>objc_sync_enter</code>,我们可以知道<code>objc_sync_enter</code>在<code>libobjc</code>源码中。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/852b8ac50ca64cb6aa06a11eb15f9546~tplv-k3u1fbpfcp-watermark.image" alt="libobjc_enter"></p>
<p>接下来我们在<code>libobjc</code>源码中全局搜索<code>objc_sync_enter</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">objc_sync_enter</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;<span class="comment">///重要代码</span></span><br><span class="line">        SyncData* data = id2data(obj, ACQUIRE);</span><br><span class="line">        ASSERT(data);</span><br><span class="line">        data-&gt;mutex.lock();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">        <span class="keyword">if</span> (DebugNilSync) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        objc_sync_nil();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果传入<code>obj</code>为<code>nil</code>,会什么也不做。主要看<code>if</code>代码块的代码，可以看到加锁是通过<code>data-&gt;mutex.lock()</code>,也就是<code>SyncData</code>的实例，所以我们先探究一下<code>SyncData</code>类型的结构：</p>
<h5 id="SyncData"><a href="#SyncData" class="headerlink" title="SyncData"></a>SyncData</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> struct <span class="title">alignas</span><span class="params">(CacheLineSize)</span> SyncData </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SyncData</span>* <span class="title">nextData</span>;</span></span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; object;</span><br><span class="line">    <span class="keyword">int32_t</span> threadCount;  <span class="comment">// number of THREADS using this block</span></span><br><span class="line">    <span class="keyword">recursive_mutex_t</span> mutex;</span><br><span class="line">&#125; SyncData;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>nextData</code>：链表结构下一个节点</li>
<li><code>object</code>：参照关联对象的结构，哈希表</li>
<li><code>threadCount</code>：使用block的线程数量</li>
<li><code>mutex</code>：递归锁（单用多线程会出现问题）</li>
</ul>
<p>在初始化<code>SyncData</code>实例的时候使用的是<code>id2data</code>函数，我们接下来探索这个函数。</p>
<h5 id="id2data函数"><a href="#id2data函数" class="headerlink" title="id2data函数"></a>id2data函数</h5><p><code>id2data</code>函数有150+行，我们先隐藏代码块，总览一下结构：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02d33a39e653474f9471c6e0e1ef2994~tplv-k3u1fbpfcp-watermark.image" alt="id2data"></p>
<p>函数的最开始两行有两个宏，它们的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_FOR_OBJ(obj) sDataLists[obj].lock</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_FOR_OBJ(obj) sDataLists[obj].data</span></span><br><span class="line"><span class="keyword">static</span> StripedMap&lt;SyncList&gt; sDataLists;</span><br></pre></td></tr></table></figure>

<p><code>sDataLists</code>是一个静态哈希表结构，我们使用<code>lldb</code>查看它的数据结构：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/328a178a46ec4d4cb286a8360e332ddc~tplv-k3u1fbpfcp-watermark.image" alt="sData"></p>
<p>经过断点调试，第一次进来执行的代码是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">posix_memalign((<span class="keyword">void</span> **)&amp;result, <span class="keyword">alignof</span>(SyncData), <span class="keyword">sizeof</span>(SyncData));</span><br><span class="line">result-&gt;object = (objc_object *)object;</span><br><span class="line">result-&gt;threadCount = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">new</span> (&amp;result-&gt;mutex) <span class="keyword">recursive_mutex_t</span>(fork_unsafe_lock);</span><br><span class="line">result-&gt;nextData = *listp;<span class="comment">//头插法 添加近链表</span></span><br><span class="line">*listp = result;</span><br></pre></td></tr></table></figure>

<p>这里有个细节就是<code>listp</code>使用的<code>头插法</code>将新的元素添加到链表，它的可递归性的实现依赖了这种数据结构的使用。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>synchronized的数据结构是哈希表，采用的拉链法处理哈希冲突</li>
<li>sDataLists arrary key是和对象相关的，拉链链表里的元素是同一个对象的锁。</li>
<li>objc_sync_enter和objc_sync_exit是对称的，它是一把递归锁。</li>
<li>会有两种存储结构：tls和catch</li>
<li>第一次访问syncData采用的是头插法链表结构 标记threadCount = 1</li>
<li>后续访问，会判断是不是同一个对象，同一对象lockcount++,不是同一个对象threadCount++1。</li>
<li>synchronized是一种可重入、递归的多线程锁，原因<ul>
<li>tls保障 threadCount 可以有多个线程对这个锁对象加锁</li>
<li>lock++会记录总共锁了多少次。</li>
</ul>
</li>
</ul>
<h3 id="NSLock和NSRecursiveLock使用"><a href="#NSLock和NSRecursiveLock使用" class="headerlink" title="NSLock和NSRecursiveLock使用"></a>NSLock和NSRecursiveLock使用</h3><p>我们以一个实例分析这两种锁的区别：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">void</span> (^testMethod)(<span class="keyword">int</span>);</span><br><span class="line">        testMethod = ^(<span class="keyword">int</span> value)&#123;</span><br><span class="line">        <span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"current value = %d"</span>,value);</span><br><span class="line">            testMethod(value - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        testMethod(<span class="number">10</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个代码有多线程冲突的问题，打印的结果无序，不是我们想要的结果</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e83ec7588234014956e787a0991f1ba~tplv-k3u1fbpfcp-watermark.image" alt="没有锁无序"></p>
<h4 id="使用NSLock解决问题"><a href="#使用NSLock解决问题" class="headerlink" title="使用NSLock解决问题"></a>使用<code>NSLock</code>解决问题</h4><p>使用<code>NSLock</code>解决的方法其实很简单，就是在我们调用方法<code>testMethod</code>前后加锁。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a874305ec494450ab33acfb02f644768~tplv-k3u1fbpfcp-watermark.image" alt="nslock"></p>
<p>我们再看打印结果就正常了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/467c7996864941688b3ca24a63d15e0a~tplv-k3u1fbpfcp-watermark.image" alt="nslock打印结果"></p>
<p><code>NSLock</code>适用的是在最外层加锁，如果我们能写的代码只能在<code>testMethod</code>操作，这个时候加<code>NSLock</code>就不会正常工作了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a4425ac2c0541c3af2d506802ebf03c~tplv-k3u1fbpfcp-watermark.image" alt="nslock加在业务代码"></p>
<h4 id="使用NSRecursiveLock"><a href="#使用NSRecursiveLock" class="headerlink" title="使用NSRecursiveLock"></a>使用NSRecursiveLock</h4><p>上面我们知道<code>NSLock</code>在<code>testMethod</code>无法解决问题，我们尝试用<code>NSRecursiveLock</code>解决。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e05a791f9e0e4be78679301542fd64aa~tplv-k3u1fbpfcp-watermark.image" alt="nsrecrusiveLock"></p>
<p>发现<code>NSRecursiveLock</code>并不能解决问题，而且还会偶现崩溃。<code>NSRecursiveLock</code>是一把递归锁，但是它并不支持多线程递归。</p>
<h4 id="使用-synchronized"><a href="#使用-synchronized" class="headerlink" title="使用@synchronized"></a>使用@synchronized</h4><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5223b33727034d4eaf5490d7d8a08fdf~tplv-k3u1fbpfcp-watermark.image" alt="sychorsize解决问题"></p>
<p>使用@synchronized解决了业务代码里的问题，说明@synchronized是一把支持多线程的递归锁。</p>
<h3 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h3><p><strong>NSCondition</strong> 的对象实际上作为一个锁和一个线程检查器:锁主要 为了当检测条件时保护数据源，执行条件引发的任务;线程检查器 主要是根据条件决定是否继续运行线程，即线程是否被阻塞。它主要有四个方法</p>
<ul>
<li><strong>[condition lock]</strong>：一般用于多线程同时访问、修改同一个数据源，保证在同一 时间内数据源只被访问、修改一次，其他线程的命令需要在<strong>lock</strong> 外等待，只到 <strong>unlock</strong> ，才可访问</li>
<li><strong>[condition unlock];//</strong>与<strong>lock</strong> 同时使用</li>
<li><strong>[condition wait];//</strong>让当前线程处于等待状态</li>
<li><strong>[condition signal];//CPU</strong>发信号告诉线程不用在等待，可以继续执行</li>
</ul>
<p>它的一个应用场景之一就是<code>生产者-消费者</code>模型。也就是通过多线程进行生产和销售产品，当产品数量为0的时候就只能等待，具体代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)js_testConditon&#123;</span><br><span class="line">    _testCondition = [[<span class="built_in">NSCondition</span> alloc] init];</span><br><span class="line">    <span class="comment">//创建生产-消费者</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> js_producer];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> js_consumer];</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> js_consumer];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> js_producer];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)js_producer&#123;</span><br><span class="line">    [_testCondition lock]; <span class="comment">// 操作的多线程影响</span></span><br><span class="line">    <span class="keyword">self</span>.ticketCount = <span class="keyword">self</span>.ticketCount + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"生产一个 现有 count %zd"</span>,<span class="keyword">self</span>.ticketCount);</span><br><span class="line">    [_testCondition signal]; <span class="comment">// 信号</span></span><br><span class="line">    [_testCondition unlock];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)js_consumer&#123;</span><br><span class="line">     [_testCondition lock];  <span class="comment">// 操作的多线程影响</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.ticketCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"等待 count %zd"</span>,<span class="keyword">self</span>.ticketCount);</span><br><span class="line">        [_testCondition wait];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意消费行为，要在等待条件判断之后</span></span><br><span class="line">    <span class="keyword">self</span>.ticketCount -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"消费一个 还剩 count %zd "</span>,<span class="keyword">self</span>.ticketCount);</span><br><span class="line">     [_testCondition unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Foundation源码看锁的封装"><a href="#Foundation源码看锁的封装" class="headerlink" title="Foundation源码看锁的封装"></a>Foundation源码看锁的封装</h3><p>我们在<code>swift-corelibs-foundation</code>源码中探索。</p>
<p>通过源码我们看到，<code>NSLock</code>等锁都实现了一个协议就是<code>NSLocking</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">NSLocking</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它们都是对<code>pthread</code>的封装</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/582cb7845b854b7e97338ddb9618d7a0~tplv-k3u1fbpfcp-watermark.image" alt="锁的源码"></p>
<p>NSRecursiveLock，也类似，它和<code>NSLock</code>的区别是<code>pthread_mutexattr_settype(attrs, Int32(PTHREAD_MUTEX_RECURSIVE))</code></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30104e8b0ae74ff8a0c3d7123644dc6c~tplv-k3u1fbpfcp-watermark.image" alt="nsrecursivelock源码"></p>
<h3 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a>NSConditionLock</h3><ul>
<li><strong>NSConditionLock</strong> 是锁，一旦一个线程获得锁，其他线程一定等待</li>
<li>lock函数：表示 对象期待获得锁，如果没有其他线程获得锁(不需要判断内部的 <strong>condition)</strong> 那它能执行此行以下代码，如果已经有其他线程获得锁(可能是条件锁，或者无条件 锁)，则等待，直至其他线程解锁</li>
<li>[xx <strong>lockWhenCondition</strong>：<strong>:A</strong>条件]方法：表示如果没有其他线程获得该锁，但是该锁内部的 <strong>condition</strong>不等于<strong>A</strong>条件，它依然不能获得锁，仍然等待。如果内部的<strong>condition</strong>等于<strong>A</strong>条件，并且 没有其他线程获得该锁，则进入代码区，同时设置它获得该锁，其他任何线程都将等待它代码的 完成，直至它解锁。</li>
<li><strong>[xxx unlockWithCondition:A</strong>条件<strong>];</strong> 表示释放锁，同时把内部的<strong>condition</strong>设置为<strong>A</strong>条件</li>
<li><strong>return = [xxx lockWhenCondition:A</strong>条件 <strong>beforeDate:A</strong>时间<strong>];</strong> 表示如果被锁定(没获得 锁)，并超过该时间则不再阻塞线程。但是注意:返回的值是<strong>NO,</strong>它没有改变锁的状态，这个函 数的目的在于可以实现两种状态下的处理。</li>
</ul>
<h3 id="栅栏函数实现读写锁"><a href="#栅栏函数实现读写锁" class="headerlink" title="栅栏函数实现读写锁"></a>栅栏函数实现读写锁</h3><p>读写锁主要要实现以下功能：</p>
<ul>
<li>多读单写功能。</li>
<li>写入和写入互斥。</li>
<li>读和写入互斥。</li>
<li>写入不能阻塞主线程任务执行。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">dispatch_queue_t</span> js_currentQueue;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *mDict;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.js_currentQueue = dispatch_queue_create(<span class="string">"jscurrent"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    <span class="keyword">self</span>.mDict = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line">    [<span class="keyword">self</span> js_safeSetter:<span class="string">@"123"</span> time:<span class="number">10</span>];</span><br><span class="line">    [<span class="keyword">self</span> js_safeSetter:<span class="string">@"456"</span> time:<span class="number">5</span>];</span><br><span class="line">    [<span class="keyword">self</span> js_safeSetter:<span class="string">@"789"</span> time:<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"读取，name = %@ thread---%@"</span>,[<span class="keyword">self</span> js_safeGetter],[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)js_safeSetter:(<span class="built_in">NSString</span> *)name time:(<span class="keyword">int</span>)time&#123;</span><br><span class="line">    dispatch_barrier_async(<span class="keyword">self</span>.js_currentQueue, ^&#123;</span><br><span class="line">        sleep(time);</span><br><span class="line">        [<span class="keyword">self</span>.mDict setValue:name forKey:<span class="string">@"name"</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"写入，name = %@ thread---%@"</span>,name,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)js_safeGetter&#123;</span><br><span class="line">    __block <span class="built_in">NSString</span> *result;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.js_currentQueue, ^&#123;</span><br><span class="line">        result = <span class="keyword">self</span>.mDict[<span class="string">@"name"</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>程序运行我们就开始点击屏幕(读操作)，最后看打印结果：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2b276d04dd04fd88e2f06568a9d8546~tplv-k3u1fbpfcp-watermark.image" alt="读写锁"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/08/21/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-GCD-%E4%B8%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/21/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-GCD-%E4%B8%89/" class="post-title-link" itemprop="url">iOS多线程 - GCD(三)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-21 17:38:29" itemprop="dateCreated datePublished" datetime="2021-08-21T17:38:29+08:00">2021-08-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-23 23:19:34" itemprop="dateModified" datetime="2021-08-23T23:19:34+08:00">2021-08-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前两篇我们主要探索了<code>GCD</code>的函数和队列的调度及死锁和单例，本篇我们开始探索<code>GCD</code>的其他函数。</p>
<h3 id="栅栏函数"><a href="#栅栏函数" class="headerlink" title="栅栏函数"></a>栅栏函数</h3><p>栅栏函数最直接的作用是：控制任务执行顺序，同步</p>
<ul>
<li>dispatch_battier_async 前面的任务执行完毕才会来到这里。</li>
<li>dispatch_battier_sync 作用相同，但是会阻塞线程，影响后面的任务执行。 </li>
<li>栅栏函数只能控制同一并发队列。</li>
</ul>
<h4 id="栅栏函数的使用"><a href="#栅栏函数的使用" class="headerlink" title="栅栏函数的使用"></a>栅栏函数的使用</h4><p>我们一般会如下使用栅栏函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t concurrentQueue &#x3D; dispatch_queue_create(&quot;jason&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;123&quot;);</span><br><span class="line">&#125;); </span><br><span class="line">dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">    sleep(1);</span><br><span class="line">    NSLog(@&quot;456&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_barrier_async(concurrentQueue1, ^&#123;</span><br><span class="line">    NSLog(@&quot;----%@-----&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;789&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;10 11 12&quot;);</span><br></pre></td></tr></table></figure>

<p>我们打印结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">10</span> <span class="number">11</span> <span class="number">12</span></span><br><span class="line"><span class="number">456</span></span><br><span class="line">----&lt;NSThread: <span class="number">0x6000012ca180</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125;-----</span><br><span class="line"><span class="number">789</span></span><br></pre></td></tr></table></figure>

<p>可以看到栅栏函数阻塞了自己的<code>block</code>和后续异步函数的执行，也就是必须前面的函数执行之后才会执行后续操作。</p>
<p>我们换成同步栅栏函数再执行一次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_barrier_sync(concurrentQueue1, ^&#123;</span><br><span class="line">    NSLog(@&quot;----%@-----&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">456</span><br><span class="line">----&lt;NSThread: 0x6000025a4140&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;-----</span><br><span class="line">10 11 12</span><br><span class="line">789</span><br></pre></td></tr></table></figure>

<p>可以看到<code>dispatch_battier_sync</code>阻塞了<code>NSLog(@&quot;10 11 12&quot;);</code>代码的执行。</p>
<p>注意：还有一个点需要注意就是<code>栅栏函数</code>不能阻塞<code>全局并发队列</code>。</p>
<p>接下来我们从源码层面看<code>栅栏函数</code>的实现以及为什么全局并发队列不能被<code>栅栏函数</code>阻塞。</p>
<h4 id="栅栏函数底层原理"><a href="#栅栏函数底层原理" class="headerlink" title="栅栏函数底层原理"></a>栅栏函数底层原理</h4><p>我们还是以同步函数<code>dispatch_barrier_sync</code>为例探索</p>
<p>调试代码如图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fccfb4fa9b1f495aacd0d7731e726902~tplv-k3u1fbpfcp-watermark.image" alt="1629551309944"></p>
<p>调试代码有个点就是<code>sleep(30)</code>方便调试等待前面方法执行完成之前的调用。</p>
<p>我们从<code>libdispatch</code>源码中搜索<code>dispatch_barrier_sync</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_barrier_sync(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_block_t</span> work)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uintptr_t</span> dc_flags = DC_FLAG_BARRIER | DC_FLAG_BLOCK;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(_dispatch_block_has_private_data(work))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_block_with_privdata(dq, work, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_barrier_sync_f(dq, work, _dispatch_Block_invoke(work), dc_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了<code>_dispatch_barrier_sync_f</code>函数，继续跟进去：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_barrier_sync_f(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	_dispatch_barrier_sync_f_inline(dq, ctxt, func, dc_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>_dispatch_barrier_sync_f_inline</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_barrier_sync_f_inline(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_tid tid = _dispatch_tid_self();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(dx_metatype(dq) != _DISPATCH_LANE_TYPE)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(<span class="number">0</span>, <span class="string">"Queue type doesn't support dispatch_sync"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">dispatch_lane_t</span> dl = upcast(dq)._dl;</span><br><span class="line">	<span class="comment">// The more correct thing to do would be to merge the qos of the thread</span></span><br><span class="line">	<span class="comment">// that just acquired the barrier lock into the queue state.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// However this is too expensive for the fast path, so skip doing it.</span></span><br><span class="line">	<span class="comment">// The chosen tradeoff is that if an enqueue on a lower priority thread</span></span><br><span class="line">	<span class="comment">// contends with this fast path, this thread may receive a useless override.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Global concurrent queues and queues bound to non-dispatch threads</span></span><br><span class="line">	<span class="comment">// always fall into the slow case, see DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!_dispatch_queue_try_acquire_barrier_sync(dl, tid))) &#123;</span><br><span class="line">    <span class="comment">//经过断点调试执行了这里</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_f_slow(dl, ctxt, func, DC_FLAG_BARRIER, dl,</span><br><span class="line">				DC_FLAG_BARRIER | dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(dl-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_recurse(dl, ctxt, func,</span><br><span class="line">				DC_FLAG_BARRIER | dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_introspection_sync_begin(dl);</span><br><span class="line">	_dispatch_lane_barrier_sync_invoke_and_complete(dl, ctxt, func</span><br><span class="line">			DISPATCH_TRACE_ARG(_dispatch_trace_item_sync_push_pop(</span><br><span class="line">					dq, ctxt, func, dc_flags | DC_FLAG_BARRIER)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们加两个符号断点调试一下看看执行的是<code>_dispatch_sync_f_slow</code>还是<code>_dispatch_sync_recurse</code>,经过添加符号断点实际调用了<code>_dispatch_sync_f_slow</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_f_slow(<span class="keyword">dispatch_queue_class_t</span> top_dqu, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func, <span class="keyword">uintptr_t</span> top_dc_flags,</span><br><span class="line">		<span class="keyword">dispatch_queue_class_t</span> dqu, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> top_dq = top_dqu._dq;</span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> dq = dqu._dq;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!dq-&gt;do_targetq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_function_invoke(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pthread_priority_t</span> pp = _dispatch_get_priority();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_sync_context_s</span> <span class="title">dsc</span> = &#123;</span></span><br><span class="line">		.dc_flags    = DC_FLAG_SYNC_WAITER | dc_flags,</span><br><span class="line">		.dc_func     = _dispatch_async_and_wait_invoke,</span><br><span class="line">		.dc_ctxt     = &amp;dsc,</span><br><span class="line">		.dc_other    = top_dq,</span><br><span class="line">		.dc_priority = pp | _PTHREAD_PRIORITY_ENFORCE_FLAG,</span><br><span class="line">		.dc_voucher  = _voucher_get(),</span><br><span class="line">		.dsc_func    = func,</span><br><span class="line">		.dsc_ctxt    = ctxt,</span><br><span class="line">		.dsc_waiter  = _dispatch_tid_self(),</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	_dispatch_trace_item_push(top_dq, &amp;dsc);</span><br><span class="line">	__DISPATCH_WAIT_FOR_QUEUE__(&amp;dsc, dq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dsc.dsc_func == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">// dsc_func being cleared means that the block ran on another thread ie.</span></span><br><span class="line">		<span class="comment">// case (2) as listed in _dispatch_async_and_wait_f_slow.</span></span><br><span class="line">		<span class="keyword">dispatch_queue_t</span> stop_dq = dsc.dc_other;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_complete_recurse(top_dq, stop_dq, top_dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_introspection_sync_begin(top_dq);</span><br><span class="line">	_dispatch_trace_item_pop(top_dq, &amp;dsc);</span><br><span class="line">	_dispatch_sync_invoke_and_complete_recurse(top_dq, ctxt, func,top_dc_flags</span><br><span class="line">			DISPATCH_TRACE_ARG(&amp;dsc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_dispatch_sync_f_slow</code>函数我们比较熟悉了，在上一篇探索过，我们继续添加符号断点，</p>
<p><strong>这里有个细节</strong>，就是会先调用<code>__DISPATCH_WAIT_FOR_QUEUE__</code>等待<code>sleep(300);</code>的调用结束说明等待的过程是<code>__DISPATCH_WAIT_FOR_QUEUE__</code>处理，接着会调用到<code>dq_push</code>及<code>_dispatch_lane_concurrent_push</code>函数-&gt;<code>_dispatch_lane_push</code>-&gt;<code>_dispatch_lane_push_waiter</code>也就是阻塞了当前队列。</p>
<ul>
<li>自定义并发队列会执行<code>_dispatch_lane_wakeup</code>会有等待<code>barrier</code>的判断。</li>
<li>全局并发队列会执行<code>_dispatch_root_queue_wakeup</code>方法，所以不会有等待的方法,所以不会阻塞</li>
</ul>
<p>等待执行的队列完成之后会调用<code>_dispatch_lane_class_barrier_complete</code>函数-&gt;<code>dx_wakeup</code>-&gt;<code>_dispatch_lane_wakeup</code>-&gt;<code>_dispatch_queue_wakeup</code>。</p>
<p>这里会调用<code>_dispatch_client_callout</code>函数，然后同步函数就接着被执行了。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><h4 id="信号量的使用"><a href="#信号量的使用" class="headerlink" title="信号量的使用"></a>信号量的使用</h4><p>先看使用代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">dispatch_semaphore_t sem &#x3D; dispatch_semaphore_create(0);</span><br><span class="line"> &#x2F;&#x2F;任务1</span><br><span class="line"> dispatch_async(queue, ^&#123;</span><br><span class="line">     dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER); &#x2F;&#x2F; sem开始为0 需要等待等待</span><br><span class="line">     NSLog(@&quot;执行任务1&quot;);</span><br><span class="line">     NSLog(@&quot;任务1完成&quot;);</span><br><span class="line"> &#125;);</span><br><span class="line"> &#x2F;&#x2F;任务2</span><br><span class="line"> dispatch_async(queue, ^&#123;</span><br><span class="line">     sleep(2);</span><br><span class="line">     NSLog(@&quot;执行任务2&quot;);</span><br><span class="line">     NSLog(@&quot;任务2完成&quot;);</span><br><span class="line">     dispatch_semaphore_signal(sem); &#x2F;&#x2F; 发信号 sem+1</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<p>信号量主要有三个函数：</p>
<ul>
<li>dispatch_semaphore_create：创建信号量</li>
<li>dispatch_semaphore_wait：等待信号量</li>
<li>dispatch_semaphore_signal：信号量释放</li>
</ul>
<p>它可以控制<code>GCD</code>的最大并发数。</p>
<h4 id="信号量的底层原理"><a href="#信号量的底层原理" class="headerlink" title="信号量的底层原理"></a>信号量的底层原理</h4><p>底层原理其实就是三个方法的探索，我们依次探索</p>
<h5 id="dispatch-semaphore-wait"><a href="#dispatch-semaphore-wait" class="headerlink" title="dispatch_semaphore_wait"></a>dispatch_semaphore_wait</h5><p>全局搜索<code>dispatch_semaphore_wait</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">intptr_t</span></span><br><span class="line">dispatch_semaphore_wait(<span class="keyword">dispatch_semaphore_t</span> dsema, <span class="keyword">dispatch_time_t</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//--1</span></span><br><span class="line">	<span class="keyword">long</span> value = os_atomic_dec2o(dsema, dsema_value, acquire);</span><br><span class="line">	<span class="keyword">if</span> (likely(value &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_semaphore_wait_slow(dsema, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面的例子我们创建的信号量为0，经过–操作&lt;0，会执行<code>_dispatch_semaphore_wait_slow</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">intptr_t</span></span><br><span class="line">_dispatch_semaphore_wait_slow(<span class="keyword">dispatch_semaphore_t</span> dsema,</span><br><span class="line">		<span class="keyword">dispatch_time_t</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">long</span> orig;</span><br><span class="line"></span><br><span class="line">	_dispatch_sema4_create(&amp;dsema-&gt;dsema_sema, _DSEMA4_POLICY_FIFO);</span><br><span class="line">	<span class="keyword">switch</span> (timeout) &#123;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">if</span> (!_dispatch_sema4_timedwait(&amp;dsema-&gt;dsema_sema, timeout)) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Fall through and try to undo what the fast path did to</span></span><br><span class="line">		<span class="comment">// dsema-&gt;dsema_value</span></span><br><span class="line">	<span class="keyword">case</span> DISPATCH_TIME_NOW:</span><br><span class="line">    <span class="comment">//超时操作</span></span><br><span class="line">		orig = dsema-&gt;dsema_value;</span><br><span class="line">		<span class="keyword">while</span> (orig &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (os_atomic_cmpxchgv2o(dsema, dsema_value, orig, orig + <span class="number">1</span>,</span><br><span class="line">					&amp;orig, relaxed)) &#123;</span><br><span class="line">				<span class="keyword">return</span> _DSEMA4_TIMEOUT();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Another thread called semaphore_signal().</span></span><br><span class="line">		<span class="comment">// Fall through and drain the wakeup.</span></span><br><span class="line">	<span class="keyword">case</span> DISPATCH_TIME_FOREVER:</span><br><span class="line">     <span class="comment">//一直等待</span></span><br><span class="line">		_dispatch_sema4_wait(&amp;dsema-&gt;dsema_sema);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见等待的函数是<code>_dispatch_sema4_wait</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_sema4_wait(<span class="keyword">_dispatch_sema4_t</span> *sema)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		ret = sem_wait(sema);</span><br><span class="line">	&#125; <span class="keyword">while</span> (ret == <span class="number">-1</span> &amp;&amp; errno == EINTR);</span><br><span class="line">	DISPATCH_SEMAPHORE_VERIFY_RET(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sem_wait</code>是c语言的方法，这里是一个do-while循环事宜等待信号量的值满足条件。</p>
<p>#####dispatch_semaphore_signal</p>
<p>全局搜索<code>dispatch_semaphore_signal</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">intptr_t</span></span><br><span class="line">dispatch_semaphore_signal(<span class="keyword">dispatch_semaphore_t</span> dsema)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//++1</span></span><br><span class="line">	<span class="keyword">long</span> value = os_atomic_inc2o(dsema, dsema_value, <span class="built_in">release</span>);</span><br><span class="line">	<span class="keyword">if</span> (likely(value &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(value == LONG_MIN)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(value,</span><br><span class="line">				<span class="string">"Unbalanced call to dispatch_semaphore_signal()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_semaphore_signal_slow(dsema);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里信号量++一次，如果信号量&gt;0就可以正常执行了，如果信号量还是&lt;=0,会进入函数<code>_dispatch_semaphore_signal_slow</code>,它是异常的处理一直++信号量的值，直到返回的值为正值。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li><code>dispatch_semaphore_create</code>:初始化信号量。</li>
<li><code>dispatch_semaphore_wait</code>：对信号量的value–</li>
<li><code>dispatch_semaphore_signal</code>对信号量的value++</li>
</ul>
<h3 id="调度组"><a href="#调度组" class="headerlink" title="调度组"></a>调度组</h3><p>####调度组的使用</p>
<p>有时候我们可能需要等待多个接口都返回数据才能进行下一步的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group &#x3D; dispatch_group_create();</span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">      &#x2F;&#x2F;下载任务1</span><br><span class="line">      sleep(2);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">      &#x2F;&#x2F;下载任务2</span><br><span class="line">      sleep(2);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line"> 			&#x2F;&#x2F;组里任务都执行之后，下一步的操作。	</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group &#x3D; dispatch_group_create();</span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">      &#x2F;&#x2F;下载任务1</span><br><span class="line">      sleep(2);</span><br><span class="line">      dispatch_group_leave(group);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">      &#x2F;&#x2F;下载任务2</span><br><span class="line">      sleep(2);</span><br><span class="line">      dispatch_group_leave(group);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line"> 			&#x2F;&#x2F;组里任务都执行之后，下一步的操作。	</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="调度组底层原理"><a href="#调度组底层原理" class="headerlink" title="调度组底层原理"></a>调度组底层原理</h4><p>我们从三个方面分析，组是如何控制同步的、<code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>的搭配、<code>dispatch_group_async</code>的原理。</p>
<h5 id="dispatch-group-create函数"><a href="#dispatch-group-create函数" class="headerlink" title="dispatch_group_create函数"></a>dispatch_group_create函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t</span><br><span class="line">dispatch_group_create(void)</span><br><span class="line">&#123;</span><br><span class="line">	return _dispatch_group_create_with_count(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是创建了一个组的数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_group_t</span></span><br><span class="line">_dispatch_group_create_with_count(<span class="keyword">uint32_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">dispatch_group_t</span> dg = _dispatch_object_alloc(DISPATCH_VTABLE(group),</span><br><span class="line">			<span class="keyword">sizeof</span>(struct dispatch_group_s));</span><br><span class="line">	dg-&gt;do_next = DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">	dg-&gt;do_targetq = _dispatch_get_default_queue(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (n) &#123;</span><br><span class="line">		os_atomic_store2o(dg, dg_bits,</span><br><span class="line">				(<span class="keyword">uint32_t</span>)-n * DISPATCH_GROUP_VALUE_INTERVAL, relaxed);</span><br><span class="line">		os_atomic_store2o(dg, do_ref_cnt, <span class="number">1</span>, relaxed); <span class="comment">// &lt;rdar://22318411&gt;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="dispatch-group-enter函数"><a href="#dispatch-group-enter函数" class="headerlink" title="dispatch_group_enter函数"></a>dispatch_group_enter函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_enter(<span class="keyword">dispatch_group_t</span> dg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// The value is decremented on a 32bits wide atomic so that the carry</span></span><br><span class="line">	<span class="comment">// for the 0 -&gt; -1 transition is not propagated to the upper 32bits.</span></span><br><span class="line">  <span class="comment">/// --操作</span></span><br><span class="line">	<span class="keyword">uint32_t</span> old_bits = os_atomic_sub_orig2o(dg, dg_bits,</span><br><span class="line">			DISPATCH_GROUP_VALUE_INTERVAL, acquire);</span><br><span class="line">	<span class="keyword">uint32_t</span> old_value = old_bits &amp; DISPATCH_GROUP_VALUE_MASK;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(old_value == <span class="number">0</span>)) &#123;</span><br><span class="line">		_dispatch_retain(dg); <span class="comment">// &lt;rdar://problem/22318411&gt;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(old_value == DISPATCH_GROUP_VALUE_MAX)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(old_bits,</span><br><span class="line">				<span class="string">"Too many nested calls to dispatch_group_enter()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开始count == 0，进行–操作，变为-1， </p>
<h5 id="dispatch-group-leave函数"><a href="#dispatch-group-leave函数" class="headerlink" title="dispatch_group_leave函数"></a>dispatch_group_leave函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_leave(<span class="keyword">dispatch_group_t</span> dg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// The value is incremented on a 64bits wide atomic so that the carry for</span></span><br><span class="line">	<span class="comment">// the -1 -&gt; 0 transition increments the generation atomically.</span></span><br><span class="line">	<span class="keyword">uint64_t</span> new_state, old_state = os_atomic_add_orig2o(dg, dg_state,</span><br><span class="line">			DISPATCH_GROUP_VALUE_INTERVAL, <span class="built_in">release</span>);</span><br><span class="line">	<span class="keyword">uint32_t</span> old_value = (<span class="keyword">uint32_t</span>)(old_state &amp; DISPATCH_GROUP_VALUE_MASK);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(old_value == DISPATCH_GROUP_VALUE_1)) &#123;<span class="comment">//old_state == -1</span></span><br><span class="line">		old_state += DISPATCH_GROUP_VALUE_INTERVAL;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			new_state = old_state;</span><br><span class="line">			<span class="keyword">if</span> ((old_state &amp; DISPATCH_GROUP_VALUE_MASK) == <span class="number">0</span>) &#123;</span><br><span class="line">				new_state &amp;= ~DISPATCH_GROUP_HAS_WAITERS;</span><br><span class="line">				new_state &amp;= ~DISPATCH_GROUP_HAS_NOTIFS;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// If the group was entered again since the atomic_add above,</span></span><br><span class="line">				<span class="comment">// we can't clear the waiters bit anymore as we don't know for</span></span><br><span class="line">				<span class="comment">// which generation the waiters are for</span></span><br><span class="line">				new_state &amp;= ~DISPATCH_GROUP_HAS_NOTIFS;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (old_state == new_state) <span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">while</span> (unlikely(!os_atomic_cmpxchgv2o(dg, dg_state,</span><br><span class="line">				old_state, new_state, &amp;old_state, relaxed)));</span><br><span class="line">		<span class="keyword">return</span> _dispatch_group_wake(dg, old_state, <span class="literal">true</span>);<span class="comment">///唤醒 notify</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(old_value == <span class="number">0</span>)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH((<span class="keyword">uintptr_t</span>)old_value,</span><br><span class="line">				<span class="string">"Unbalanced call to dispatch_group_leave()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>count由-1变为0，可以看出<code>old_state != new_state</code>时会一直<code>while</code>循环，当相等是执行<code>_dispatch_group_wake</code>唤醒阻塞的函数。</p>
<p>#####dispatch_group_notify</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_group_notify(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq,</span><br><span class="line">		<span class="keyword">dispatch_continuation_t</span> dsn)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> old_state, new_state;</span><br><span class="line">	<span class="keyword">dispatch_continuation_t</span> prev;</span><br><span class="line"></span><br><span class="line">	dsn-&gt;dc_data = dq;</span><br><span class="line">	_dispatch_retain(dq);</span><br><span class="line"></span><br><span class="line">	prev = os_mpsc_push_update_tail(os_mpsc(dg, dg_notify), dsn, do_next);</span><br><span class="line">	<span class="keyword">if</span> (os_mpsc_push_was_empty(prev)) _dispatch_retain(dg);</span><br><span class="line">	os_mpsc_push_update_prev(os_mpsc(dg, dg_notify), prev, dsn, do_next);</span><br><span class="line">	<span class="keyword">if</span> (os_mpsc_push_was_empty(prev)) &#123;</span><br><span class="line">		os_atomic_rmw_loop2o(dg, dg_state, old_state, new_state, <span class="built_in">release</span>, &#123;</span><br><span class="line">			new_state = old_state | DISPATCH_GROUP_HAS_NOTIFS;</span><br><span class="line">			<span class="keyword">if</span> ((<span class="keyword">uint32_t</span>)old_state == <span class="number">0</span>) &#123;</span><br><span class="line">				os_atomic_rmw_loop_give_up(&#123;<span class="comment">/// block callout函数</span></span><br><span class="line">					<span class="keyword">return</span> _dispatch_group_wake(dg, new_state, <span class="literal">false</span>);</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 可以看到<code>old_state == 0</code>的时候才会执行block，也就是<code>dispatch_group_leave</code>执行完成。</p>
<h5 id="dispatch-group-async"><a href="#dispatch-group-async" class="headerlink" title="dispatch_group_async"></a>dispatch_group_async</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_async(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq,</span><br><span class="line">		<span class="keyword">dispatch_block_t</span> db)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//任务封装</span></span><br><span class="line">	<span class="keyword">dispatch_continuation_t</span> dc = _dispatch_continuation_alloc();</span><br><span class="line">	<span class="keyword">uintptr_t</span> dc_flags = DC_FLAG_CONSUME | DC_FLAG_GROUP_ASYNC;</span><br><span class="line">	<span class="keyword">dispatch_qos_t</span> qos;</span><br><span class="line">	qos = _dispatch_continuation_init(dc, dq, db, <span class="number">0</span>, dc_flags);</span><br><span class="line">	_dispatch_continuation_group_async(dg, dq, dc, qos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_continuation_group_async(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq,</span><br><span class="line">		<span class="keyword">dispatch_continuation_t</span> dc, <span class="keyword">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_group_enter(dg);<span class="comment">//执行了enter</span></span><br><span class="line">	dc-&gt;dc_data = dg;</span><br><span class="line">	_dispatch_continuation_async(dq, dc, qos, dc-&gt;dc_flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_continuation_async(<span class="keyword">dispatch_queue_class_t</span> dqu,</span><br><span class="line">		<span class="keyword">dispatch_continuation_t</span> dc, <span class="keyword">dispatch_qos_t</span> qos, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_INTROSPECTION</span></span><br><span class="line">	<span class="keyword">if</span> (!(dc_flags &amp; DC_FLAG_NO_INTROSPECTION)) &#123;</span><br><span class="line">		_dispatch_trace_item_push(dqu, dc);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	(<span class="keyword">void</span>)dc_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> dx_push(dqu._dq, dc, qos);<span class="comment">//调用的函数 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里在<code>_dispatch_continuation_group_async</code>函数调用了<code>dispatch_group_enter</code>函数，然后再<code>dx_push</code>之后也就是callout函数之后执行了<code>dispatch_group_leave</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_continuation_with_group_invoke(<span class="keyword">dispatch_continuation_t</span> dc)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">dou</span> = <span class="title">dc</span>-&gt;<span class="title">dc_data</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> type = dx_type(dou);</span><br><span class="line">	<span class="keyword">if</span> (type == DISPATCH_GROUP_TYPE) &#123;</span><br><span class="line">		_dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);</span><br><span class="line">		_dispatch_trace_item_complete(dc);</span><br><span class="line">    <span class="comment">///执行了leave方法</span></span><br><span class="line">		dispatch_group_leave((<span class="keyword">dispatch_group_t</span>)dou);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		DISPATCH_INTERNAL_CRASH(dx_type(dou), <span class="string">"Unexpected object type"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul>
<li><code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>成对出现</li>
<li><code>dispatch_group_enter</code>底层对group的value做–操作（0-&gt;1）</li>
<li><code>dispatch_group_leave</code>底层对group的value做++操作（-1-&gt;0）</li>
<li><code>dispatch_group_notify</code>底层判断group的state是否为0，为0就通知执行block。</li>
<li>任务唤醒有两种方式：1、<code>dispatch_group_leave</code>2、<code>dispatch_group_notify</code></li>
<li><code>dispatch_group_async</code>等同于 <code>enter+leave</code>，底层实现包含一对enter+leave。</li>
</ul>
<p>###dispatch_source</p>
<p>dispatch_source我们平时会使用到的场景是一个计时器(倒计时)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (void)timeDone&#123;</span><br><span class="line">    &#x2F;&#x2F;倒计时时间</span><br><span class="line">    __block int timeout &#x3D; 3;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;创建队列</span><br><span class="line">    dispatch_queue_t globalQueue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;创建timer</span><br><span class="line">    dispatch_source_t timer &#x3D; dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, globalQueue);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;设置1s触发一次，0s的误差</span><br><span class="line">    &#x2F;*</span><br><span class="line">     - source 分派源</span><br><span class="line">     - start 数控制计时器第一次触发的时刻。参数类型是 dispatch_time_t，这是一个opaque类型，我们不能直接操作它。我们得需要 dispatch_time 和 dispatch_walltime 函数来创建它们。另外，常量 DISPATCH_TIME_NOW 和 DISPATCH_TIME_FOREVER 通常很有用。</span><br><span class="line">     - interval 间隔时间</span><br><span class="line">     - leeway 计时器触发的精准程度</span><br><span class="line">     *&#x2F;</span><br><span class="line">    dispatch_source_set_timer(timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0);</span><br><span class="line">    </span><br><span class="line">     &#x2F;&#x2F;触发的事件</span><br><span class="line">    dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">        &#x2F;&#x2F;倒计时结束，关闭</span><br><span class="line">        if (timeout &lt;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F;取消dispatch源</span><br><span class="line">            dispatch_source_cancel(timer);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            timeout--;</span><br><span class="line">            </span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                &#x2F;&#x2F;更新主界面的操作</span><br><span class="line">                NSLog(@&quot;倒计时 - %d&quot;, timeout);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F;开始执行dispatch源</span><br><span class="line">    dispatch_resume(timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/08/14/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-GCD-%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/14/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-GCD-%E4%BA%8C/" class="post-title-link" itemprop="url">iOS多线程-GCD(二)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-14 19:29:50" itemprop="dateCreated datePublished" datetime="2021-08-14T19:29:50+08:00">2021-08-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-23 23:16:42" itemprop="dateModified" datetime="2021-08-23T23:16:42+08:00">2021-08-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一篇我们主要探索了GCD的主队列及<code>串行队列</code>与<code>并发队列</code>在源码上的区分，以及同步函数的调用时机。本节我们主要探索同步函数与异步函数的区别：</p>
<ul>
<li>同步函数死锁分析</li>
<li>任务回调是否具有同步性、异步性</li>
<li><code>dispatch_once</code>底层的分析</li>
</ul>
<p>我们先从同步函数开始探索。</p>
<h3 id="同步函数死锁分析"><a href="#同步函数死锁分析" class="headerlink" title="同步函数死锁分析"></a>同步函数死锁分析</h3><p><code>libdispatch</code>源码中全局搜索<code>dispatch_sync</code>,找到方法的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_sync(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_block_t</span> work)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uintptr_t</span> dc_flags = DC_FLAG_BLOCK;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(_dispatch_block_has_private_data(work))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_block_with_privdata(dq, work, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_sync_f(dq, work, _dispatch_Block_invoke(work), dc_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟进方法<code>_dispatch_sync_f</code>实际调用<code>_dispatch_sync_f_inline</code>方法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_f_inline(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (likely(dq-&gt;dq_width == <span class="number">1</span>)) &#123;<span class="comment">//串行队列</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_barrier_sync_f(dq, ctxt, func, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(dx_metatype(dq) != _DISPATCH_LANE_TYPE)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(<span class="number">0</span>, <span class="string">"Queue type doesn't support dispatch_sync"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">dispatch_lane_t</span> dl = upcast(dq)._dl;</span><br><span class="line">	<span class="comment">// Global concurrent queues and queues bound to non-dispatch threads</span></span><br><span class="line">	<span class="comment">// always fall into the slow case, see DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!_dispatch_queue_try_reserve_sync_width(dl))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_f_slow(dl, ctxt, func, <span class="number">0</span>, dl, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_recurse(dl, ctxt, func, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_introspection_sync_begin(dl);</span><br><span class="line">	_dispatch_sync_invoke_and_complete(dl, ctxt, func DISPATCH_TRACE_ARG(</span><br><span class="line">			_dispatch_trace_item_sync_push_pop(dq, ctxt, func, dc_flags)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>串行队列调用了<code>_dispatch_barrier_sync_f</code>方法，最终调用到<code>_dispatch_barrier_sync_f_inline</code>方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_barrier_sync_f_inline(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_tid tid = _dispatch_tid_self();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(dx_metatype(dq) != _DISPATCH_LANE_TYPE)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(<span class="number">0</span>, <span class="string">"Queue type doesn't support dispatch_sync"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">dispatch_lane_t</span> dl = upcast(dq)._dl;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!_dispatch_queue_try_acquire_barrier_sync(dl, tid))) &#123;</span><br><span class="line">    <span class="comment">//死锁的是否会有_dispatch_sync_f_slow异常</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_f_slow(dl, ctxt, func, DC_FLAG_BARRIER, dl,</span><br><span class="line">				DC_FLAG_BARRIER | dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(dl-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_recurse(dl, ctxt, func,</span><br><span class="line">				DC_FLAG_BARRIER | dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_introspection_sync_begin(dl);</span><br><span class="line">	_dispatch_lane_barrier_sync_invoke_and_complete(dl, ctxt, func</span><br><span class="line">			DISPATCH_TRACE_ARG(_dispatch_trace_item_sync_push_pop(</span><br><span class="line">					dq, ctxt, func, dc_flags | DC_FLAG_BARRIER)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有多个调用的方法，我们自定义一种死锁的情况看调用堆栈的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;jason&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">  NSLog(@&quot;1&quot;);</span><br><span class="line">  dispatch_async(queue, ^&#123;</span><br><span class="line">      NSLog(@&quot;2&quot;);</span><br><span class="line">      dispatch_sync(queue, ^&#123;</span><br><span class="line">          NSLog(@&quot;3&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">      NSLog(@&quot;4&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;5&quot;);</span><br></pre></td></tr></table></figure>

<p>执行代码查看调用栈：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2597a32d39214293867da9b9fdf34478~tplv-k3u1fbpfcp-watermark.image" alt="死锁"></p>
<p>可以看到调用了<code>_dispatch_sync_f_slow</code>方法，然后调用了<code>__DISPATCH_WAIT_FOR_QUEUE__</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">__DISPATCH_WAIT_FOR_QUEUE__(<span class="keyword">dispatch_sync_context_t</span> dsc, <span class="keyword">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> dq_state = _dispatch_wait_prepare(dq);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(_dq_state_drain_locked_by(dq_state, dsc-&gt;dsc_waiter))) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH((<span class="keyword">uintptr_t</span>)dq_state,</span><br><span class="line">				<span class="string">"dispatch_sync called on queue "</span></span><br><span class="line">				<span class="string">"already owned by current thread"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">///省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里的crash信息和我们写的例子中最终的错误是一致的</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc3fa6cbe00e413dad18c53505a064e2~tplv-k3u1fbpfcp-watermark.image" alt="死锁2"></p>
<p>说明<code>_dq_state_drain_locked_by</code>判断的条件是产生死锁的原因，这个函数调用了<code>_dispatch_lock_is_locked_by</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">_dispatch_lock_is_locked_by(dispatch_lock lock_value, dispatch_tid tid)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// equivalent to _dispatch_lock_owner(lock_value) == tid</span></span><br><span class="line">	<span class="keyword">return</span> ((lock_value ^ tid) &amp; DLOCK_OWNER_MASK) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLOCK_OWNER_MASK			((dispatch_lock)0xfffffffc)</span></span><br></pre></td></tr></table></figure>

<p><code>DLOCK_OWNER_MASK</code>是一个很大的值，说明<code>lock_value ^ tid</code>为0，也就是<code>tid=lock_value</code>，看上面的注释也是这个意思，即当前的等待的线程与现在执行的线程是同一个。</p>
<h3 id="同步函数的回调"><a href="#同步函数的回调" class="headerlink" title="同步函数的回调"></a>同步函数的回调</h3><p>我们建立一个全局并发队列探索</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t concurrentQueue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">dispatch_sync(concurrentQueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;函数调用了....&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们回到<code>_dispatch_sync_f_inline</code>函数，然后打符号断点看执行了哪个方法</p>
<ul>
<li>_dispatch_sync_f_slow</li>
<li>_dispatch_sync_recurse</li>
<li>_dispatch_introspection_sync_begin</li>
<li>_dispatch_sync_invoke_and_complete</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf76ebde132c467e97f7c64de9a78302~tplv-k3u1fbpfcp-watermark.image" alt="同步函数并发队列探索"></p>
<p>断点调用到了<code>_dispatch_sync_f_slow</code>函数，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_f_slow(<span class="keyword">dispatch_queue_class_t</span> top_dqu, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func, <span class="keyword">uintptr_t</span> top_dc_flags,</span><br><span class="line">		<span class="keyword">dispatch_queue_class_t</span> dqu, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> top_dq = top_dqu._dq;</span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> dq = dqu._dq;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!dq-&gt;do_targetq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_function_invoke(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pthread_priority_t</span> pp = _dispatch_get_priority();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_sync_context_s</span> <span class="title">dsc</span> = &#123;</span></span><br><span class="line">		.dc_flags    = DC_FLAG_SYNC_WAITER | dc_flags,</span><br><span class="line">		.dc_func     = _dispatch_async_and_wait_invoke,</span><br><span class="line">		.dc_ctxt     = &amp;dsc,</span><br><span class="line">		.dc_other    = top_dq,</span><br><span class="line">		.dc_priority = pp | _PTHREAD_PRIORITY_ENFORCE_FLAG,</span><br><span class="line">		.dc_voucher  = _voucher_get(),</span><br><span class="line">		.dsc_func    = func,</span><br><span class="line">		.dsc_ctxt    = ctxt,</span><br><span class="line">		.dsc_waiter  = _dispatch_tid_self(),</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	_dispatch_trace_item_push(top_dq, &amp;dsc);</span><br><span class="line">	__DISPATCH_WAIT_FOR_QUEUE__(&amp;dsc, dq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dsc.dsc_func == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">// dsc_func being cleared means that the block ran on another thread ie.</span></span><br><span class="line">		<span class="comment">// case (2) as listed in _dispatch_async_and_wait_f_slow.</span></span><br><span class="line">		<span class="keyword">dispatch_queue_t</span> stop_dq = dsc.dc_other;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_complete_recurse(top_dq, stop_dq, top_dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_introspection_sync_begin(top_dq);</span><br><span class="line">	_dispatch_trace_item_pop(top_dq, &amp;dsc);</span><br><span class="line">	_dispatch_sync_invoke_and_complete_recurse(top_dq, ctxt, func,top_dc_flags</span><br><span class="line">			DISPATCH_TRACE_ARG(&amp;dsc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们继续加符号断点跟踪<code>_dispatch_trace_item_push</code>、<code>_dispatch_sync_complete_recurse</code>、<code>_dispatch_trace_item_pop</code>、<code>_dispatch_sync_invoke_and_complete_recurse</code>、<code>_dispatch_sync_function_invoke</code></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2ab368e89ac49a18c4d3c5f42865c88~tplv-k3u1fbpfcp-watermark.image" alt="同步函数并发队列"></p>
<p>说明执行了<code>_dispatch_sync_function_invoke</code>函数，注意<code>dq-&gt;do_targetq</code>系统队列为空，因为我们使用的是全局并发队列，所以执行到了这里。</p>
<p>继续看<code>_dispatch_sync_function_invoke</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_function_invoke(<span class="keyword">dispatch_queue_class_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">	_dispatch_sync_function_invoke_inline(dq, ctxt, func);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_function_invoke_inline(<span class="keyword">dispatch_queue_class_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_thread_frame_s dtf;</span><br><span class="line">	_dispatch_thread_frame_push(&amp;dtf, dq);</span><br><span class="line">	_dispatch_client_callout(ctxt, func);</span><br><span class="line">	_dispatch_perfmon_workitem_inc();</span><br><span class="line">	_dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里执行了<code>_dispatch_client_callout</code>函数，也就调用了<code>回调函数</code>。</p>
<h3 id="异步函数回调"><a href="#异步函数回调" class="headerlink" title="异步函数回调"></a>异步函数回调</h3><p>同样，我们也用符号断点的方式探究：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t concurrentQueue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;函数调用了....&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>全局搜索<code>dispatch_async</code>其调用了<code>_dispatch_continuation_async</code>函数，然后调用<code>dx_push</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_push(x, y, z) dx_vtable(x)-&gt;dq_push(x, y, z)</span></span><br></pre></td></tr></table></figure>

<p>最后调用了<code>dq_push</code>,<code>dq_push</code>根据队列类型的不同而调用，我们看并发队列的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_concurrent, lane,</span><br><span class="line">	.do_type        = DISPATCH_QUEUE_CONCURRENT_TYPE,</span><br><span class="line">	.do_dispose     = _dispatch_lane_dispose,</span><br><span class="line">	.do_debug       = _dispatch_queue_debug,</span><br><span class="line">	.do_invoke      = _dispatch_lane_invoke,</span><br><span class="line"></span><br><span class="line">	.dq_activate    = _dispatch_lane_activate,</span><br><span class="line">	.dq_wakeup      = _dispatch_lane_wakeup,</span><br><span class="line">	.dq_push        = _dispatch_lane_concurrent_push,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>搜索<code>_dispatch_lane_concurrent_push</code>的实现实际调用了<code>_dispatch_lane_push</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_lane_push(<span class="keyword">dispatch_lane_t</span> dq, <span class="keyword">dispatch_object_t</span> dou,</span><br><span class="line">		<span class="keyword">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">dispatch_wakeup_flags_t</span> flags = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(_dispatch_object_is_waiter(dou))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_lane_push_waiter(dq, dou._dsc, qos);</span><br><span class="line">	&#125;</span><br><span class="line">	dispatch_assert(!_dispatch_object_is_global(dq));</span><br><span class="line">	qos = _dispatch_queue_push_qos(dq, qos);</span><br><span class="line"></span><br><span class="line">	prev = os_mpsc_push_update_tail(os_mpsc(dq, dq_items), dou._do, do_next);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(os_mpsc_push_was_empty(prev))) &#123;</span><br><span class="line">		_dispatch_retain_2_unsafe(dq);</span><br><span class="line">		flags = DISPATCH_WAKEUP_CONSUME_2 | DISPATCH_WAKEUP_MAKE_DIRTY;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(_dispatch_queue_need_override(dq, qos))) &#123;</span><br><span class="line">		_dispatch_retain_2_unsafe(dq);</span><br><span class="line">		flags = DISPATCH_WAKEUP_CONSUME_2;</span><br><span class="line">	&#125;</span><br><span class="line">	os_mpsc_push_update_prev(os_mpsc(dq, dq_items), prev, dou._do, do_next);</span><br><span class="line">	<span class="keyword">if</span> (flags) &#123;</span><br><span class="line">		<span class="keyword">return</span> dx_wakeup(dq, qos, flags);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们添加符号断点<code>_dispatch_lane_push_waiter</code>、<code>_dispatch_queue_push_qos</code>、<code>os_mpsc_push_update_prev</code>、<code>dx_wakeup</code>。调用的是<code>dx_wakeup</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_wakeup(x, y, z) dx_vtable(x)-&gt;dq_wakeup(x, y, z)</span></span><br></pre></td></tr></table></figure>

<p>实际是对<code>dq_wakeup</code>的封装，依然我们找并发队列：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_concurrent, lane,</span><br><span class="line">	.do_type        = DISPATCH_QUEUE_CONCURRENT_TYPE,</span><br><span class="line">	.do_dispose     = _dispatch_lane_dispose,</span><br><span class="line">	.do_debug       = _dispatch_queue_debug,</span><br><span class="line">	.do_invoke      = _dispatch_lane_invoke,</span><br><span class="line"></span><br><span class="line">	.dq_activate    = _dispatch_lane_activate,</span><br><span class="line">	.dq_wakeup      = _dispatch_lane_wakeup,</span><br><span class="line">	.dq_push        = _dispatch_lane_concurrent_push,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><code>_dispatch_lane_wakeup</code>调用的<code>_dispatch_queue_wakeup</code>,同样也是把<code>_dispatch_queue_wakeup</code>调用的<code>return</code>的方法添加符号断点，会调用<code>_dispatch_queue_wakeup</code>-&gt;<code>_dispatch_lane_push</code>,执行到<code>_dispatch_root_queue_drain</code></p>
<h3 id="dispatch-once函数底层实现"><a href="#dispatch-once函数底层实现" class="headerlink" title="dispatch_once函数底层实现"></a>dispatch_once函数底层实现</h3><p>我们平时定义一个单例对象的时候一般都会使用<code>dispatch_once</code>函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    NSLog(@&quot;once&quot;)  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们在<code>libdispatch</code>中搜索<code>dispatch_once</code>看其底层实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_once(<span class="keyword">dispatch_once_t</span> *val, <span class="keyword">dispatch_block_t</span> block)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_once_f(val, block, _dispatch_Block_invoke(block));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>val</code>是<code>dispatch_once_t</code>类型。继续跟进<code>dispatch_once_f</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_once_f(<span class="keyword">dispatch_once_t</span> *val, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//gate</span></span><br><span class="line">	<span class="keyword">dispatch_once_gate_t</span> l = (<span class="keyword">dispatch_once_gate_t</span>)val;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !DISPATCH_ONCE_INLINE_FASTPATH || DISPATCH_ONCE_USE_QUIESCENT_COUNTER</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> v = os_atomic_load(&amp;l-&gt;dgo_once, acquire);</span><br><span class="line">	<span class="keyword">if</span> (likely(v == DLOCK_ONCE_DONE)) &#123;<span class="comment">//第一次会标示为done return</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_ONCE_USE_QUIESCENT_COUNTER</span></span><br><span class="line">	<span class="keyword">if</span> (likely(DISPATCH_ONCE_IS_GEN(v))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_once_mark_done_if_quiesced(l, v);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="comment">///第一次调用</span></span><br><span class="line">	<span class="keyword">if</span> (_dispatch_once_gate_tryenter(l)) &#123;<span class="comment">//锁 说明单例是线程安全的</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_once_callout(l, ctxt, func);<span class="comment">//执行任务</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_once_wait(l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">_dispatch_once_gate_tryenter(<span class="keyword">dispatch_once_gate_t</span> l)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> os_atomic_cmpxchg(&amp;l-&gt;dgo_once, DLOCK_ONCE_UNLOCKED,</span><br><span class="line">			(<span class="keyword">uintptr_t</span>)_dispatch_lock_value_for_self(), relaxed);</span><br><span class="line">&#125;</span><br><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_once_callout(<span class="keyword">dispatch_once_gate_t</span> l, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">///执行任务</span></span><br><span class="line">	_dispatch_client_callout(ctxt, func);</span><br><span class="line">  <span class="comment">///广播关门处理</span></span><br><span class="line">	_dispatch_once_gate_broadcast(l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_once_gate_broadcast(<span class="keyword">dispatch_once_gate_t</span> l)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_lock value_self = _dispatch_lock_value_for_self();</span><br><span class="line">	<span class="keyword">uintptr_t</span> v;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_ONCE_USE_QUIESCENT_COUNTER</span></span><br><span class="line">	v = _dispatch_once_mark_quiescing(l);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	v = _dispatch_once_mark_done(l);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (likely((dispatch_lock)v == value_self)) <span class="keyword">return</span>;</span><br><span class="line">	_dispatch_gate_broadcast_slow(&amp;l-&gt;dgo_gate, (dispatch_lock)v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li><p>只执行一次原理：<code>onceToken</code>是静态变量，具有唯一性，在底层被封装成了<code>dispatch_once_gate_t</code>类型的<code>变量l</code>，<code>l</code>主要是用来获取底层原子封装性的关联，即<code>变量v</code>，通过v来查询任务的状态，如果此时v等于<code>DLOCK_ONCE_DONE</code>，说明任务已经处理过一次了，直接`return</p>
</li>
<li><p>block调用的时机：如果此时任务没有执行过，将<code>任务进行加锁</code>，即任务状态置为<code>DLOCK_ONCE_UNLOCK</code>，目的是为了<code>保证当前任务执行的唯一性</code>，防止在其他地方有多次定义。加锁之后<code>进行block回调函数的执行</code>，执行完成后，将<code>当前任务解锁</code>，将当前的<code>任务状态置为DLOCK_ONCE_DONE</code>，在下次进来时，就不会在执行，会直接返回</p>
</li>
<li><p>如果在当前任务执行期间，有其他任务进来，会进入无限次等待，原因是当前任务已经获取了锁，进行了加锁，其他任务是无法获取锁的</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/08/05/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-GCD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/05/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-GCD/" class="post-title-link" itemprop="url">iOS多线程-GCD上</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-05 20:15:37" itemprop="dateCreated datePublished" datetime="2021-08-05T20:15:37+08:00">2021-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-10 20:47:31" itemprop="dateModified" datetime="2021-08-10T20:47:31+08:00">2021-08-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一篇我们介绍了多线程的一些概念，本篇我们主要探究iOS开发中经常会使用到的多线程技术<code>GCD</code>。</p>
<h3 id="GCD的概念"><a href="#GCD的概念" class="headerlink" title="GCD的概念"></a>GCD的概念</h3><p><code>GCD</code>的全称是 Grand Central Dispatch。它是由纯 C 语言实现，提供了非常多强大的函数。它有如下优势：</p>
<ul>
<li>GCD 是苹果公司为多核的并行运算提出的解决方案</li>
<li>GCD 会自动利用更多的CPU内核(比如双核、四核)</li>
<li>GCD 会自动管理线程的生命周期(创建线程、调度任务、销毁线程)</li>
<li>程序员只需要告诉 GCD 想要执行什么任务，不需要编写任何线程管理代码。</li>
</ul>
<p>总结来说GCD就是将任务添加到队列，并指定任务执行的函数。</p>
<h3 id="GCD的基本使用"><a href="#GCD的基本使用" class="headerlink" title="GCD的基本使用"></a>GCD的基本使用</h3><p>一般情况下我们会这样使用GCD</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建任务block</span><br><span class="line">dispatch_block_t block &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;这是任务&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;创建串行队列</span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;com.lg.cn&quot;, NULL);</span><br><span class="line">&#x2F;&#x2F;执行任务</span><br><span class="line">dispatch_async(queue, block);</span><br></pre></td></tr></table></figure>

<p>总结来看就是三部：</p>
<ul>
<li>创建任务块<code>dispatch_block_t</code></li>
<li>创建队列<code>dispatch_queue_t</code></li>
<li>将任务添加到队列并执行任务函数<code>dispatch_async</code>或<code>dispatch_sync</code></li>
</ul>
<p>还有两个概念其实我们也很熟悉了就是<code>函数</code>和<code>队列</code>。</p>
<ul>
<li>函数包括<code>同步函数（dispatch_sync）</code>和<code>异步函数（dispatch_async）</code>。</li>
<li>队列包括<code>串行队列（DISPATCH_QUEUE_SERIAL）</code>和<code>并行队列（DISPATCH_QUEUE_CONCURRENT）</code></li>
</ul>
<h3 id="主队列"><a href="#主队列" class="headerlink" title="主队列"></a>主队列</h3><p>主队列（<code>dispatch_queue_main_t</code>）是我们运行程序就会启动的一个队列，它是主线程所在的队列，会贯穿我们应用运行的始终。通过我们<code>dispatch_get_main_queue</code>函数的注释我们看到主队列是一个串行队列，这也不难理解，因为串行队列里的任务会逐个顺序执行，而我们主线程上的任务也符合这一特性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面这行注释说明它是一个串行队列，但不完全是一个标准的串行队列。  </span></span><br><span class="line">* Because the main <span class="built_in">queue</span> doesn<span class="number">'</span>t behave entirely like a regular serial <span class="built_in">queue</span>,</span><br><span class="line"> * it may have unwanted side-effects when used in processes that are <span class="keyword">not</span> UI apps</span><br><span class="line"> * (daemons). For such processes, the main <span class="built_in">queue</span> should be avoided.</span><br><span class="line"> *</span><br><span class="line"> * @see <span class="keyword">dispatch_queue_main_t</span></span><br><span class="line"> *</span><br><span class="line"> * @result</span><br><span class="line"> * Returns the main <span class="built_in">queue</span>. This <span class="built_in">queue</span> is created automatically on behalf of</span><br><span class="line"> * the main thread before main() is called.</span><br><span class="line"> */</span><br><span class="line">DISPATCH_INLINE DISPATCH_ALWAYS_INLINE DISPATCH_CONST DISPATCH_NOTHROW</span><br><span class="line"><span class="keyword">dispatch_queue_main_t</span></span><br><span class="line">dispatch_get_main_queue(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> DISPATCH_GLOBAL_OBJECT(<span class="keyword">dispatch_queue_main_t</span>, _dispatch_main_q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们下载<code>libdispatch</code>的源码，看一下<code>dispatch_get_main_queue</code>的源码，调用的是<code>DISPATCH_GLOBAL_OBJECT(dispatch_queue_main_t, _dispatch_main_q)</code>,它是一个<code>宏</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_GLOBAL_OBJECT(type, object) (static_cast<span class="meta-string">&lt;type&gt;(&amp;(object)))</span></span></span><br></pre></td></tr></table></figure>

<p>可以看到第一个参数<code>type</code>是类型，第二个参数<code>object</code>参数真正的参数也就是<code>_dispatch_main_q</code>,我们全局搜索<code>_dispatch_main_q =</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_static_s</span> _<span class="title">dispatch_main_q</span> = &#123;</span></span><br><span class="line">	DISPATCH_GLOBAL_OBJECT_HEADER(queue_main),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !DISPATCH_USE_RESOLVERS</span></span><br><span class="line">	.do_targetq = _dispatch_get_default_queue(<span class="literal">true</span>),</span><br><span class="line">#endif</span><br><span class="line">	.dq_state = DISPATCH_QUEUE_STATE_INIT_VALUE(<span class="number">1</span>) |</span><br><span class="line">			DISPATCH_QUEUE_ROLE_BASE_ANON,</span><br><span class="line">	.dq_label = <span class="string">"com.apple.main-thread"</span>,</span><br><span class="line">	.dq_atomic_flags = DQF_THREAD_BOUND | DQF_WIDTH(<span class="number">1</span>),</span><br><span class="line">	.dq_serialnum = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>发现<code>_dispatch_main_q</code>是一个结构体。可以看到<code>dispatch_queue_main_t</code>是一个结构体<code>dispatch_queue_static_s</code>。</p>
<h3 id="串行队列和并发队列源码上的区分"><a href="#串行队列和并发队列源码上的区分" class="headerlink" title="串行队列和并发队列源码上的区分"></a>串行队列和并发队列源码上的区分</h3><p>上面我们已经知道，gcd的队列的本质是<code>dispatch_queue_static_s</code>结构体，结构体中那个成员标示的是串行还是并行队列呢？我们源码中找答案。我们的队列是通过<code>dispatch_queue_create</code>函数创建的，它的第二个参数传入的是队列的类型，我们源码中找<code>dispatch_queue_create</code>函数的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span></span><br><span class="line">dispatch_queue_create(<span class="keyword">const</span> <span class="keyword">char</span> *label, <span class="keyword">dispatch_queue_attr_t</span> attr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_lane_create_with_target(label, attr,</span><br><span class="line">			DISPATCH_TARGET_QUEUE_DEFAULT, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟着调用继续查找<code>_dispatch_lane_create_with_target</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">dispatch_queue_t</span></span><br><span class="line">_dispatch_lane_create_with_target(<span class="keyword">const</span> <span class="keyword">char</span> *label, <span class="keyword">dispatch_queue_attr_t</span> dqa,</span><br><span class="line">		<span class="keyword">dispatch_queue_t</span> tq, <span class="keyword">bool</span> legacy)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">dispatch_queue_attr_info_t</span> dqai = _dispatch_queue_attr_to_info(dqa);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Step 1: Normalize arguments (qos, overcommit, tq)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">dispatch_qos_t</span> qos = dqai.dqai_qos;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !HAVE_PTHREAD_WORKQUEUE_QOS</span></span><br><span class="line">	<span class="keyword">if</span> (qos == DISPATCH_QOS_USER_INTERACTIVE) &#123;</span><br><span class="line">		dqai.dqai_qos = qos = DISPATCH_QOS_USER_INITIATED;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (qos == DISPATCH_QOS_MAINTENANCE) &#123;</span><br><span class="line">		dqai.dqai_qos = qos = DISPATCH_QOS_BACKGROUND;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !HAVE_PTHREAD_WORKQUEUE_QOS</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">_dispatch_queue_attr_overcommit_t</span> overcommit = dqai.dqai_overcommit;</span><br><span class="line">	<span class="keyword">if</span> (overcommit != _dispatch_queue_attr_overcommit_unspecified &amp;&amp; tq) &#123;</span><br><span class="line">		<span class="keyword">if</span> (tq-&gt;do_targetq) &#123;</span><br><span class="line">			DISPATCH_CLIENT_CRASH(tq, <span class="string">"Cannot specify both overcommit and "</span></span><br><span class="line">					<span class="string">"a non-global target queue"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tq &amp;&amp; dx_type(tq) == DISPATCH_QUEUE_GLOBAL_ROOT_TYPE) &#123;</span><br><span class="line">		<span class="comment">// Handle discrepancies between attr and target queue, attributes win</span></span><br><span class="line">		<span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_unspecified) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tq-&gt;dq_priority &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT) &#123;</span><br><span class="line">				overcommit = _dispatch_queue_attr_overcommit_enabled;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				overcommit = _dispatch_queue_attr_overcommit_disabled;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (qos == DISPATCH_QOS_UNSPECIFIED) &#123;</span><br><span class="line">			qos = _dispatch_priority_qos(tq-&gt;dq_priority);</span><br><span class="line">		&#125;</span><br><span class="line">		tq = <span class="literal">NULL</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tq &amp;&amp; !tq-&gt;do_targetq) &#123;</span><br><span class="line">		<span class="comment">// target is a pthread or runloop root queue, setting QoS or overcommit</span></span><br><span class="line">		<span class="comment">// is disallowed</span></span><br><span class="line">		<span class="keyword">if</span> (overcommit != _dispatch_queue_attr_overcommit_unspecified) &#123;</span><br><span class="line">			DISPATCH_CLIENT_CRASH(tq, <span class="string">"Cannot specify an overcommit attribute "</span></span><br><span class="line">					<span class="string">"and use this kind of target queue"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_unspecified) &#123;</span><br><span class="line">			<span class="comment">// Serial queues default to overcommit!</span></span><br><span class="line">			overcommit = dqai.dqai_concurrent ?</span><br><span class="line">					_dispatch_queue_attr_overcommit_disabled :</span><br><span class="line">					_dispatch_queue_attr_overcommit_enabled;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!tq) &#123;</span><br><span class="line">		tq = _dispatch_get_root_queue(</span><br><span class="line">				qos == DISPATCH_QOS_UNSPECIFIED ? DISPATCH_QOS_DEFAULT : qos,</span><br><span class="line">				overcommit == _dispatch_queue_attr_overcommit_enabled)-&gt;_as_dq;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!tq)) &#123;</span><br><span class="line">			DISPATCH_CLIENT_CRASH(qos, <span class="string">"Invalid queue attribute"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Step 2: Initialize the queue</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (legacy) &#123;</span><br><span class="line">		<span class="comment">// if any of these attributes is specified, use non legacy classes</span></span><br><span class="line">		<span class="keyword">if</span> (dqai.dqai_inactive || dqai.dqai_autorelease_frequency) &#123;</span><br><span class="line">			legacy = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">void</span> *vtable;</span><br><span class="line">	<span class="keyword">dispatch_queue_flags_t</span> dqf = legacy ? DQF_MUTABLE : <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (dqai.dqai_concurrent) &#123;</span><br><span class="line">		vtable = DISPATCH_VTABLE(queue_concurrent);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		vtable = DISPATCH_VTABLE(queue_serial);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> (dqai.dqai_autorelease_frequency) &#123;</span><br><span class="line">	<span class="keyword">case</span> DISPATCH_AUTORELEASE_FREQUENCY_NEVER:</span><br><span class="line">		dqf |= DQF_AUTORELEASE_NEVER;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM:</span><br><span class="line">		dqf |= DQF_AUTORELEASE_ALWAYS;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (label) &#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span> *tmp = _dispatch_strdup_if_mutable(label);</span><br><span class="line">		<span class="keyword">if</span> (tmp != label) &#123;</span><br><span class="line">			dqf |= DQF_LABEL_NEEDS_FREE;</span><br><span class="line">			label = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">dispatch_lane_t</span> dq = _dispatch_object_alloc(vtable,</span><br><span class="line">			<span class="keyword">sizeof</span>(struct dispatch_lane_s));</span><br><span class="line">	_dispatch_queue_init(dq, dqf, dqai.dqai_concurrent ?</span><br><span class="line">			DISPATCH_QUEUE_WIDTH_MAX : <span class="number">1</span>, DISPATCH_QUEUE_ROLE_INNER |</span><br><span class="line">			(dqai.dqai_inactive ? DISPATCH_QUEUE_INACTIVE : <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	dq-&gt;dq_label = label;</span><br><span class="line">	dq-&gt;dq_priority = _dispatch_priority_make((<span class="keyword">dispatch_qos_t</span>)dqai.dqai_qos,</span><br><span class="line">			dqai.dqai_relpri);</span><br><span class="line">	<span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_enabled) &#123;</span><br><span class="line">		dq-&gt;dq_priority |= DISPATCH_PRIORITY_FLAG_OVERCOMMIT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!dqai.dqai_inactive) &#123;</span><br><span class="line">		_dispatch_queue_priority_inherit_from_target(dq, tq);</span><br><span class="line">		_dispatch_lane_inherit_wlh_from_target(dq, tq);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_retain(tq);</span><br><span class="line">	dq-&gt;do_targetq = tq;</span><br><span class="line">	_dispatch_object_debug(dq, <span class="string">"%s"</span>, __func__);</span><br><span class="line">	<span class="keyword">return</span> _dispatch_trace_queue_create(dq)._dq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数比较长，按照管理我们还是先看返回值<code>_dispatch_trace_queue_create(dq)._dq</code>。重点看<code>dq</code>怎么创建的。所以我们主要<code>dq</code>的创建及成员赋值的过程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_lane_t</span> dq = _dispatch_object_alloc(vtable,</span><br><span class="line">			<span class="keyword">sizeof</span>(struct dispatch_lane_s));</span><br><span class="line">	_dispatch_queue_init(dq, dqf, dqai.dqai_concurrent ?</span><br><span class="line">			DISPATCH_QUEUE_WIDTH_MAX : <span class="number">1</span>, DISPATCH_QUEUE_ROLE_INNER |</span><br><span class="line">			(dqai.dqai_inactive ? DISPATCH_QUEUE_INACTIVE : <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>发现<code>_dispatch_queue_init</code>的实参有<code>dqai.dqai_concurrent</code>还是并行队列的判断。我们定位到<code>_dispatch_queue_init</code>的第三个参数，看看其赋值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_queue_class_t</span></span><br><span class="line">_dispatch_queue_init(<span class="keyword">dispatch_queue_class_t</span> dqu, <span class="keyword">dispatch_queue_flags_t</span> dqf,</span><br><span class="line">		<span class="keyword">uint16_t</span> <span class="built_in">width</span>, <span class="keyword">uint64_t</span> initial_state_bits)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> dq_state = DISPATCH_QUEUE_STATE_INIT_VALUE(<span class="built_in">width</span>);</span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> dq = dqu._dq;</span><br><span class="line"></span><br><span class="line">	dispatch_assert((initial_state_bits &amp; ~(DISPATCH_QUEUE_ROLE_MASK |</span><br><span class="line">			DISPATCH_QUEUE_INACTIVE)) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (initial_state_bits &amp; DISPATCH_QUEUE_INACTIVE) &#123;</span><br><span class="line">		dq-&gt;do_ref_cnt += <span class="number">2</span>; <span class="comment">// rdar://8181908 see _dispatch_lane_resume</span></span><br><span class="line">		<span class="keyword">if</span> (dx_metatype(dq) == _DISPATCH_SOURCE_TYPE) &#123;</span><br><span class="line">			dq-&gt;do_ref_cnt++; <span class="comment">// released when DSF_DELETED is set</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dq_state |= initial_state_bits;</span><br><span class="line">	dq-&gt;do_next = DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">	dqf |= DQF_WIDTH(<span class="built_in">width</span>);</span><br><span class="line">	os_atomic_store2o(dq, dq_atomic_flags, dqf, relaxed);</span><br><span class="line">	dq-&gt;dq_state = dq_state;</span><br><span class="line">	dq-&gt;dq_serialnum =</span><br><span class="line">			os_atomic_inc_orig(&amp;_dispatch_queue_serial_numbers, relaxed);</span><br><span class="line">	<span class="keyword">return</span> dqu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到第三个参数<code>width</code>复制的地方是<code>dqf |= DQF_WIDTH(width);</code>即：</p>
<ul>
<li><p>width = 1表示串行队列</p>
</li>
<li><p>width =  DISPATCH_QUEUE_WIDTH_MAX表示并行队列，其中<code>DISPATCH_QUEUE_WIDTH_MAX</code>的定义如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_QUEUE_WIDTH_FULL			0x1000ull</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_QUEUE_WIDTH_MAX  (DISPATCH_QUEUE_WIDTH_FULL - 2)</span></span><br></pre></td></tr></table></figure>

<h3 id="dispatch-queue-t的继承链"><a href="#dispatch-queue-t的继承链" class="headerlink" title="dispatch_queue_t的继承链"></a>dispatch_queue_t的继承链</h3></li>
</ul>
<p><code>dispatch_queue_t</code>的继承链是什么样子呢，我们在代码中按<code>cmd</code>+<code>dispatch_queue_t</code>会跳转到<code>DISPATCH_DECL(dispatch_queue);</code>代码，它是<code>dispatch_queue_t</code>的定义。我们在libdispatch源码中搜索<code>DISPATCH_DECL(</code>找定义的地方，根据上下文<code>if</code>判断下面这行是<code>oc</code>情况下的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_DECL(name) \</span></span><br><span class="line">		<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">name</span>##_<span class="title">s</span> :</span> <span class="keyword">public</span> dispatch_object_s &#123;&#125; *name##<span class="keyword">_t</span></span><br><span class="line"><span class="comment">///dispatch_queue_t -&gt; dispatch_queue_s -&gt; dispatch_object_s</span></span><br></pre></td></tr></table></figure>

<p>可以看到继承链为<code>dispatch_queue_t -&gt; dispatch_queue_s -&gt; dispatch_object_s</code></p>
<p>我们观察一下的机构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> &#123;</span></span><br><span class="line">	DISPATCH_QUEUE_CLASS_HEADER(<span class="built_in">queue</span>, <span class="keyword">void</span> *__dq_opaque1);</span><br><span class="line">	<span class="comment">/* 32bit hole on LP64 */</span></span><br><span class="line">&#125; DISPATCH_ATOMIC64_ALIGN;</span><br></pre></td></tr></table></figure>

<p>继续看<code>DISPATCH_QUEUE_CLASS_HEADER</code>结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DISPATCH_QUEUE_CLASS_HEADER(x, __pointer_sized_field__) \</span></span><br><span class="line">	DISPATCH_OBJECT_HEADER(x); \</span><br><span class="line">	__pointer_sized_field__; \</span><br><span class="line">	DISPATCH_UNION_LE(<span class="keyword">uint64_t</span> <span class="keyword">volatile</span> dq_state, \</span><br><span class="line">			dispatch_lock dq_state_lock, \</span><br><span class="line">			<span class="keyword">uint32_t</span> dq_state_bits \</span><br><span class="line">	)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>继承于<code>DISPATCH_OBJECT_HEADER</code>继续搜索：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DISPATCH_OBJECT_HEADER(x) \</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">os_object_s</span> _<span class="title">as_os_obj</span>[0];</span> \</span><br><span class="line">	OS_OBJECT_STRUCT_HEADER(dispatch_##x); \</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_</span>##<span class="title">x</span>##_<span class="title">s</span> *<span class="title">volatile</span> <span class="title">do_next</span>;</span> \</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *<span class="title">do_targetq</span>;</span> \</span><br><span class="line">	<span class="keyword">void</span> *do_ctxt; \</span><br><span class="line">	<span class="keyword">union</span> &#123; \</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> DISPATCH_FUNCTION_POINTER do_finalizer; \</span><br><span class="line">		<span class="keyword">void</span> *do_introspection_ctxt; \</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>最后继承的是<code>_os_object_s</code>,所以完整继承链就是</p>
<p>dispatch_queue_t -&gt; dispatch_queue_s -&gt; dispatch_object_s -&gt; _os_object_s</p>
<h3 id="函数的调用时机"><a href="#函数的调用时机" class="headerlink" title="函数的调用时机"></a>函数的调用时机</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_sync(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">    NSLog(@&quot;函数调用了&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们本小节探究函数的<code>block</code>参数是什么时候调用的，我们以同步函数为例，全局搜索<code>dispatch_sync</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_sync(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_block_t</span> work)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uintptr_t</span> dc_flags = DC_FLAG_BLOCK;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(_dispatch_block_has_private_data(work))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_block_with_privdata(dq, work, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_sync_f(dq, work, _dispatch_Block_invoke(work), dc_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>work</code>为我们传入的<code>block</code>，所以我们看和<code>work</code>参数相关的代码</p>
<p><code>_dispatch_Block_invoke</code>函数的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _dispatch_Block_invoke(bb) \</span></span><br><span class="line">		((<span class="keyword">dispatch_function_t</span>)((struct Block_layout *)bb)-&gt;invoke)</span><br></pre></td></tr></table></figure>

<p>可以看到_dispatch_Block_invoke函数主要是调用了<code>work</code>的<code>invoke</code>方法。</p>
<p>我们再看<code>_dispatch_sync_f</code>的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_f(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func,</span><br><span class="line">		<span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	_dispatch_sync_f_inline(dq, ctxt, func, dc_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟踪<code>_dispatch_sync_f_inline</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_f_inline(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (likely(dq-&gt;dq_width == <span class="number">1</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_barrier_sync_f(dq, ctxt, func, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(dx_metatype(dq) != _DISPATCH_LANE_TYPE)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(<span class="number">0</span>, <span class="string">"Queue type doesn't support dispatch_sync"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">dispatch_lane_t</span> dl = upcast(dq)._dl;</span><br><span class="line">	<span class="comment">// Global concurrent queues and queues bound to non-dispatch threads</span></span><br><span class="line">	<span class="comment">// always fall into the slow case, see DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!_dispatch_queue_try_reserve_sync_width(dl))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_f_slow(dl, ctxt, func, <span class="number">0</span>, dl, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_recurse(dl, ctxt, func, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_introspection_sync_begin(dl);</span><br><span class="line">	_dispatch_sync_invoke_and_complete(dl, ctxt, func DISPATCH_TRACE_ARG(</span><br><span class="line">			_dispatch_trace_item_sync_push_pop(dq, ctxt, func, dc_flags)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_dispatch_sync_f_inline</code>函数的<code>ctxt</code>和<code>func</code>参数是和block相关的参数，调用的地方比较多，我们在demo工程打一个符号断点看一下，到底执行了哪个方法：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5efc9820ecdd40359b417a0786b63a45~tplv-k3u1fbpfcp-watermark.image" alt="1628264358531"></p>
<p>我们发现实际调用的是<code>_dispatch_sync_f_slow</code>函数</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/036607d53d484d3a964806f0557747d9~tplv-k3u1fbpfcp-watermark.image" alt="1628264502620"></p>
<p>所以我们继续看<code>_dispatch_sync_f_slow</code>的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_f_slow(<span class="keyword">dispatch_queue_class_t</span> top_dqu, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func, <span class="keyword">uintptr_t</span> top_dc_flags,</span><br><span class="line">		<span class="keyword">dispatch_queue_class_t</span> dqu, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> top_dq = top_dqu._dq;</span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> dq = dqu._dq;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!dq-&gt;do_targetq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_function_invoke(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pthread_priority_t</span> pp = _dispatch_get_priority();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_sync_context_s</span> <span class="title">dsc</span> = &#123;</span></span><br><span class="line">		.dc_flags    = DC_FLAG_SYNC_WAITER | dc_flags,</span><br><span class="line">		.dc_func     = _dispatch_async_and_wait_invoke,</span><br><span class="line">		.dc_ctxt     = &amp;dsc,</span><br><span class="line">		.dc_other    = top_dq,</span><br><span class="line">		.dc_priority = pp | _PTHREAD_PRIORITY_ENFORCE_FLAG,</span><br><span class="line">		.dc_voucher  = _voucher_get(),</span><br><span class="line">		.dsc_func    = func,</span><br><span class="line">		.dsc_ctxt    = ctxt,</span><br><span class="line">		.dsc_waiter  = _dispatch_tid_self(),</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	_dispatch_trace_item_push(top_dq, &amp;dsc);</span><br><span class="line">	__DISPATCH_WAIT_FOR_QUEUE__(&amp;dsc, dq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dsc.dsc_func == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">// dsc_func being cleared means that the block ran on another thread ie.</span></span><br><span class="line">		<span class="comment">// case (2) as listed in _dispatch_async_and_wait_f_slow.</span></span><br><span class="line">		<span class="keyword">dispatch_queue_t</span> stop_dq = dsc.dc_other;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_complete_recurse(top_dq, stop_dq, top_dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_dispatch_introspection_sync_begin(top_dq);</span><br><span class="line">	_dispatch_trace_item_pop(top_dq, &amp;dsc);</span><br><span class="line">	_dispatch_sync_invoke_and_complete_recurse(top_dq, ctxt, func,top_dc_flags</span><br><span class="line">			DISPATCH_TRACE_ARG(&amp;dsc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关注的参数依然是<code>ctxt</code>和<code>func</code>，和上一步骤类似，我们继续打符号断点<code>_dispatch_sync_invoke_and_complete_recurse</code>和<code>_dispatch_sync_function_invoke</code>来看具体执行的代码。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/553b2e78bcb545a7811d664a66dd90cf~tplv-k3u1fbpfcp-watermark.image" alt="1628264995211"></p>
<p>实际调用了<code>_dispatch_sync_function_invoke</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_function_invoke(<span class="keyword">dispatch_queue_class_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">	_dispatch_sync_function_invoke_inline(dq, ctxt, func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟进<code>_dispatch_sync_function_invoke_inline</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_function_invoke_inline(<span class="keyword">dispatch_queue_class_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_thread_frame_s dtf;</span><br><span class="line">	_dispatch_thread_frame_push(&amp;dtf, dq);</span><br><span class="line">	_dispatch_client_callout(ctxt, func);</span><br><span class="line">	_dispatch_perfmon_workitem_inc();</span><br><span class="line">	_dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ctxt</code>和<code>func</code>的调用在<code>_dispatch_client_callout</code>函数，有多个实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_client_callout(<span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> f)</span><br><span class="line">&#123;</span><br><span class="line">	_dispatch_get_tsd_base();</span><br><span class="line">	<span class="keyword">void</span> *u = _dispatch_get_unwind_tsd();</span><br><span class="line">	<span class="keyword">if</span> (likely(!u)) <span class="keyword">return</span> f(ctxt);</span><br><span class="line">	_dispatch_set_unwind_tsd(<span class="literal">NULL</span>);</span><br><span class="line">	f(ctxt);</span><br><span class="line">	_dispatch_free_unwind_tsd();</span><br><span class="line">	_dispatch_set_unwind_tsd(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> _dispatch_client_callout</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_client_callout(<span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> f)</span><br><span class="line">&#123;</span><br><span class="line">	@<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> f(ctxt);</span><br><span class="line">	&#125;</span><br><span class="line">	@<span class="keyword">catch</span> (...) &#123;</span><br><span class="line">		objc_terminate();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然多处实现，但是调用<code>block</code>的代码都是<code>f(ctxt)</code>。</p>
<p>所以<code>block</code>的调用链是：<code>dispatch_sync</code>-&gt;<code>_dispatch_sync_f</code>-&gt;<code>_dispatch_sync_f_inline</code>-&gt;<code>_dispatch_sync_f_slow</code>-&gt;<code>_dispatch_sync_function_invoke</code>-&gt;<code>_dispatch_client_callout</code>-&gt;<code>f(ctxt)</code>。</p>
<p>同理异步函数<code>dispatch_async</code>用相同的方法也能探究出一个调用链，最后调用的也是<code>f(ctxt)</code>,感兴趣的童鞋可以探究一下。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/08/01/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/01/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">iOS多线程-多线程原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-01 17:05:50 / 修改时间：21:23:57" itemprop="dateCreated datePublished" datetime="2021-08-01T17:05:50+08:00">2021-08-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本节我们主要了解一些多线程的理论知识。</p>
<h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><ul>
<li>进程是指在系统中正在运行的一个应用程序。</li>
<li>每个进程之间是独立的，每个进程均运行在其专用的且受保护的内存空间内。</li>
<li>通过“活动监视器”可以查看 Mac 系统中所开启的进程。</li>
</ul>
<h5 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h5><ul>
<li>线程是进程的基本执行单元，一个进程的所有任务都在线程中执行。</li>
<li>进程要想执行任务，必须得有线程，进程至少要有一条线程。</li>
<li>程序启动会默认开启一条线程，这条线程被称为主线程或 UI 线程。</li>
</ul>
<h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><ul>
<li>地址空间:同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。</li>
<li>资源拥有:同一进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的 资源是独立的。</li>
</ul>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><ol>
<li>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</li>
<li>进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进 程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程 </li>
<li>执行过程:每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口。但是 线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li>
<li>线程是处理器调度的基本单位，但是进程不是。</li>
<li>线程没有地址空间,线程包含在进程地址空间中。</li>
</ol>
<h3 id="多线程原理"><a href="#多线程原理" class="headerlink" title="多线程原理"></a>多线程原理</h3><ul>
<li>对于<code>单核CPU</code>，<code>同一时间，CPU只能处理一条线程</code>，即只有一条线程在工作，</li>
<li>iOS中的<code>多线程同时执行</code>的本质是CPU在多个任务直接进行快速的切换，由于CPU调度线程的时间足够快，就造成了多线程的“同时”执行的效果。其中切换的时间间隔就是<code>时间片</code>。</li>
</ul>
<h4 id="多线程的优点"><a href="#多线程的优点" class="headerlink" title="多线程的优点"></a>多线程的优点</h4><ul>
<li>能适当提高程序的执行效率</li>
<li>能适当提高资源的利用率(CPU，内存)</li>
<li>线程上的任务执行完成后，线程会自动销毁</li>
</ul>
<h4 id="多线程的缺点"><a href="#多线程的缺点" class="headerlink" title="多线程的缺点"></a>多线程的缺点</h4><ul>
<li>开启线程需要占用一定的内存空间(默认情况下，每一个线程都占 512 KB，90ms的时间)。</li>
<li>如果开启大量的线程，会占用大量的内存空间，降低程序的性能。</li>
<li>线程越多，CPU 在调用线程上的开销就越大。</li>
<li>程序设计更加复杂，比如线程间的通信，多线程的数据共享。</li>
</ul>
<h3 id="多线程生命周期"><a href="#多线程生命周期" class="headerlink" title="多线程生命周期"></a>多线程生命周期</h3><p>多线程的生命周期主要分为5部分：新建 - 就绪 - 运行 - 阻塞 - 死亡，如下图所示</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5c1d80cb9754ab98612a71b7f3ea3ec~tplv-k3u1fbpfcp-watermark.image" alt="多线程生命周期"></p>
<ul>
<li><code>新建</code>：主要是实例化线程对象</li>
<li><code>就绪</code>：线程对象调用start方法，将线程对象加入可调度线程池，等待CPU的调用，即调用start方法，并不会立即执行，进入<code>就绪状态</code>，需要等待一段时间，经CPU时间片调度后再执行，也就是从就绪状态进入<code>运行状态</code>。</li>
<li><code>阻塞</code>：当满足某个预定条件时，可以<code>使用休眠，即sleep，或者同步锁</code>，阻塞线程执行。当进入sleep时，会重新将<code>线程加入就绪</code>中。</li>
<li><code>死亡</code>：分为两种情况，<ol>
<li><code>正常死亡</code>，即线程执行完毕</li>
<li><code>非正常死亡</code>，即当满足某个条件后，在线程内部（或者主线程中）终止执行（调用exit方法等退出）</li>
</ol>
</li>
<li><code>运行</code>：就是线程执行，处于<code>运行中的线程</code>拥有一段可以执行的时间(<code>时间片</code>)。<ol>
<li>如果<code>时间片用尽</code>，线程就会进入<code>就绪状态队列</code></li>
<li>如果<code>时间片没有用尽</code>，且需要开始<code>等待某事件</code>，就会进入<code>阻塞状态队列</code></li>
<li>等待事件发生后，线程又会重新进入<code>就绪状态队列</code></li>
<li>每当一个<code>线程离开运行</code>，即执行完毕或者强制退出后，会重新从就绪状态队列中选择一个线程继续执行</li>
</ol>
</li>
</ul>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池流程图如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86ba007efda84d878b9551594a95d4b4~tplv-k3u1fbpfcp-watermark.image" alt="线程池"></p>
<ol>
<li>判断核心线程池是否都正在执行任务<ul>
<li>返回NO，创建新的工作线程去执行</li>
<li>返回YES，进入2</li>
</ul>
</li>
<li>判断线程池工作队列是否已经饱满<ul>
<li>返回NO，将任务存储到工作队列，等待CPU调度</li>
<li>返回YES，进入3</li>
</ul>
</li>
<li>判断线程池中的线程是否都处于执行状态<ul>
<li>返回NO，安排可调度线程池中空闲的线程去执行任务</li>
<li>返回YES，进入4</li>
</ul>
</li>
<li>交给饱和策略去执行。饱和策略有一下四种：<ul>
<li><code>AbortPolicy</code>：直接抛出RejectedExecutionExeception异常来阻止系统正常运行</li>
<li><code>CallerRunsPolicy</code>：将任务回退到调用者</li>
<li><code>DisOldestPolicy</code>：丢掉等待最久的任务</li>
<li><code>DisCardPolicy</code>：直接丢弃任务</li>
<li>这四种拒绝策略均实现的RejectedExecutionHandler接口</li>
</ul>
</li>
</ol>
<h3 id="互斥锁与自旋锁"><a href="#互斥锁与自旋锁" class="headerlink" title="互斥锁与自旋锁"></a>互斥锁与自旋锁</h3><p>锁是用户保护临界区，确保同一时间，只有一条线程能够访问临界区。</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><ul>
<li>自旋锁在获取到资源之前一直处于忙等。</li>
<li>自旋锁的使用场景：锁持有时间短，且线程不希望在重新调用上花太多成本。<code>OC</code>属性的关键字<code>atomic</code>就是使用了自旋锁。</li>
<li>使用自旋锁，当心线程访问代码时，如果发现其他线程转给你在锁定代码，新线程会用死循环的方法，一直等待锁定的代码执行完成，比较消耗性能。</li>
</ul>
<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><ul>
<li><p>互斥锁在获取到资源之前是休眠状态，释放资源后会被唤醒。</p>
</li>
<li><p>如果代码中<code>只有一个地方需要加锁，大多都使用 self</code>，这样可以避免单独再创建一个锁对象</p>
</li>
<li><p>互斥锁的<code>锁定范围，应该尽量小</code>，锁定范围越大，效率越差</p>
</li>
<li><p>能够<code>加锁的任意 NSObject 对象</code></p>
</li>
<li><p>锁对象一定要保证所有的线程都能够访问</p>
<h3 id="几个多线程题目"><a href="#几个多线程题目" class="headerlink" title="几个多线程题目"></a>几个多线程题目</h3></li>
</ul>
<h4 id="任务执行的影响因素"><a href="#任务执行的影响因素" class="headerlink" title="任务执行的影响因素"></a>任务执行的影响因素</h4><ul>
<li>cpu的调度</li>
<li>执行任务的复杂度</li>
<li>任务的优先级</li>
<li>线程的状态</li>
</ul>
<h4 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h4><p>两种线程：IO密集型、CPU密集型</p>
<ul>
<li>IO密集型，频繁等待的线程。更容易得到优先级提升。</li>
<li>CPU密集型，很少等待的线程。</li>
<li>IO密集型线程容易饿死。</li>
<li>cpu调度来提升等待线程的优先级</li>
</ul>
<h4 id="优先级的影响因素"><a href="#优先级的影响因素" class="headerlink" title="优先级的影响因素"></a>优先级的影响因素</h4><ul>
<li>用户指定。</li>
<li>等待的频繁度。</li>
<li>长时间不执行。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/07/27/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-KVO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/27/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-KVO/" class="post-title-link" itemprop="url">iOS底层探索-KVO</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-27 20:30:04" itemprop="dateCreated datePublished" datetime="2021-07-27T20:30:04+08:00">2021-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-31 15:58:49" itemprop="dateModified" datetime="2021-07-31T15:58:49+08:00">2021-07-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>KVO</code>是一种机制，它允许对象在其他对象的指定属性发生更改时收到通知。它最常用的一个场景就是<code>viewconroller</code>中监听<code>model</code>属性的变化从而刷新页面展示。</p>
<h3 id="KVO使用过程的细节"><a href="#KVO使用过程的细节" class="headerlink" title="KVO使用过程的细节"></a><code>KVO</code>使用过程的细节</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p><code>KVO</code>的基本使用就是三部曲：</p>
<ul>
<li><p>注册观察者 <code>addObserver:forKeyPath:options:context</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.person addObserver:self forKeyPath:@&quot;nickname&quot; options:NSKeyValueObservingOptionNew context:NULL];</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现<code>KVO</code>的回调<code>observeValueForKeyPath:ofObject:change:context</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    if ([keyPath isEqualToString:@&quot;nickname&quot;]) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,change);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>移除观察者<code>removeObserver:forKeyPath:context</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.person removeObserver:self forKeyPath:@&quot;nickname&quot; context:NULL];</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="context参数的使用"><a href="#context参数的使用" class="headerlink" title="context参数的使用"></a>context参数的使用</h4><p>基本使用的过程中我们经常会给<code>context</code>传<code>NULL</code>作为实参，<code>context</code>参数的作用很容易被我们忽略。苹果官方文档对<code>context</code>有详细的说明</p>
<blockquote>
<p>The context pointer in the <code>addObserver:forKeyPath:options:context:</code> message contains arbitrary data that will be passed back to the observer in the corresponding change notifications. You may specify <code>NULL</code> and rely entirely on the key path string to determine the origin of a change notification, but this approach may cause problems for an object whose superclass is also observing the same key path for different reasons.</p>
<p>A safer and more extensible approach is to use the context to ensure notifications you receive are destined for your observer and not a superclass.</p>
</blockquote>
<p>大体意思就是：<code>addObserver：forKeyPath：options：context：</code>方法中的<code>context</code>指针包含任意数据，这些数据将在相应的更改通知中传递回观察者。可以通过<code>指定context为NULL</code>，从而<code>依靠keyPath</code>即<code>键路径字符串</code>传来确定更改通知的来源，但是这种方法可能会导致对象的父类由于不同的原因也观察到相同的键路径而导致问题。所以可以为每个观察到的keyPath创建一个不同的context，从而<code>完全不需要进行字符串比较</code>，从而可以更有效地进行通知解析。</p>
<p><code>context</code>主要是用于区分不同对象的同名属性，从而在KVO回调方法中可以直接使用<code>context</code>进行区分，可以大大提升性能，以及代码的可读性。</p>
<ul>
<li><p>不使用context时，我们通过字符串判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[self.person addObserver:self forKeyPath:@&quot;nickname&quot; options:NSKeyValueObservingOptionNew context:NULL];</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    if ([keyPath isEqualToString:@&quot;nickname&quot;]) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,change);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用context时，我们通过<code>context</code>判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;context定义</span><br><span class="line">static void *PersonNickNameContext &#x3D; &amp;PersonNickNameContext;</span><br><span class="line">static void *PersonNameContext &#x3D; &amp;PersonNameContext;</span><br><span class="line">&#x2F;&#x2F;注册观察者</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;nick&quot; options:NSKeyValueObservingOptionNew context:PersonNickNameContext];</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:PersonNameContext];</span><br><span class="line">&#x2F;&#x2F;KVO的回调</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    if (context &#x3D;&#x3D; PersonNickNameContext) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,change);</span><br><span class="line">    &#125;else if (context &#x3D;&#x3D; PersonNameContext)&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,change);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="是否有必要移除KVOobserver"><a href="#是否有必要移除KVOobserver" class="headerlink" title="是否有必要移除KVOobserver"></a>是否有必要移除<code>KVO</code>observer</h4><p>官方文档对<code>removeObserver</code>也有说明：</p>
<blockquote>
<p>When removing an observer, keep several points in mind:</p>
<ul>
<li>Asking to be removed as an observer if not already registered as one results in an <code>NSRangeException</code>. You either call <code>removeObserver:forKeyPath:context:</code> exactly once for the corresponding call to <code>addObserver:forKeyPath:options:context:</code>, or if that is not feasible in your app, place the <code>removeObserver:forKeyPath:context:</code> call inside a try/catch block to process the potential exception.</li>
<li>An observer does not automatically remove itself when deallocated. The observed object continues to send notifications, oblivious to the state of the observer. However, a change notification, like any other message, sent to a released object, triggers a memory access exception. You therefore ensure that observers remove themselves before disappearing from memory.</li>
<li>The protocol offers no way to ask an object if it is an observer or being observed. Construct your code to avoid release related errors. A typical pattern is to register as an observer during the observer’s initialization (for example in <code>init</code> or <code>viewDidLoad</code>) and unregister during deallocation (usually in <code>dealloc</code>), ensuring properly paired and ordered add and remove messages, and that the observer is unregistered before it is freed from memory.</li>
</ul>
</blockquote>
<p>翻译过来就是，移除观察者时，注意以下几点：</p>
<ul>
<li>如果未注册为观察者，在移除观察者的时候会导致<code>NSRangeException</code>异常。<code>removeObserver</code>必须和<code>addObserver</code>对应，且只能调用一次。如果项目中不能保证，就需要在使用的时候使用<code>try/catch</code>来处理异常。</li>
<li>观察者在对象销毁的时候不会自动移除观察者。被观察者会继续发送通知，对观察者来说这个状态是感知不到的。但是，向一个已经释放的对象发送通知会引起内存访问异常。所以，我们要保证观察者在内存释放之前移除观察。</li>
<li>这个协议没有方法可以判断他是一个观察者还是被观察者，写代码是要避免释放内存相关的错误。一个典型的规范就是在观察者初始画的时候注册观察，在<code>dealloc</code>的时候移除观察，以确保成对和有序地添加和删除消息，并确保观察者在注册之前被取消注册，从内存中释放出来。</li>
</ul>
<p>所以，总的来说，<code>KVO注册观察者 和移除观察者是需要成对出现的</code>，如果只注册，不移除，会出现<code>野指针的崩溃</code>。</p>
<h4 id="自动触发与手动触发"><a href="#自动触发与手动触发" class="headerlink" title="自动触发与手动触发"></a>自动触发与手动触发</h4><p>KVO观察的自动和手动两种方式</p>
<ul>
<li><p>自动开关，<code>automaticallyNotifiesObserversForKey</code>返回<code>YES</code>的时候标示自动监听，如果是<code>NO</code>表示我们需要手动监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 自动开关</span><br><span class="line">+ (BOOL) automaticallyNotifiesObserversForKey:(NSString *)key&#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果是手动，我们需要通过<code>手动开关</code>监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)setNickName:(NSString *)nickName&#123;</span><br><span class="line">    &#x2F;&#x2F;手动开关</span><br><span class="line">    [self willChangeValueForKey:@&quot;nickName&quot;];</span><br><span class="line">    _nickName &#x3D; namenickName</span><br><span class="line">    [self didChangeValueForKey:@&quot;nickName&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="观察多个属性变化"><a href="#观察多个属性变化" class="headerlink" title="观察多个属性变化"></a>观察多个属性变化</h4><p>我们以观察两个属性为例，例如我们需要根据速度<code>speed</code>和时间<code>time</code>，取得当前的路程<code>distance</code>。我们用两种方式。</p>
<ul>
<li><p>第一种就是分别观察速度<code>speed</code>和时间<code>time</code>两个属性，当其中一个发生变化计算 当前路程<code>distance</code>。</p>
</li>
<li><p>第二种方式就是，通过<code>keyPathsForValuesAffectingValueForKey</code>方法，将两个观察合为一个观察，即观察当前路程<code>distance</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1、合二为一的观察方法</span><br><span class="line">+ (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key&#123;</span><br><span class="line">    NSSet *keyPaths &#x3D; [super keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line">    if ([key isEqualToString:@&quot;distance&quot;]) &#123;</span><br><span class="line">        NSArray *affectingKeys &#x3D; @[@&quot;speed&quot;, @&quot;time&quot;];</span><br><span class="line">        keyPaths &#x3D; [keyPaths setByAddingObjectsFromArray:affectingKeys];</span><br><span class="line">    &#125;</span><br><span class="line">    return keyPaths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2、注册KVO观察</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;distance&quot; options:(NSKeyValueObservingOptionNew) context:NULL];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3、触发属性值变化</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    self.person.speed +&#x3D; 10;</span><br><span class="line">    self.person.time  +&#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;4、移除观察者</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">    [self.person removeObserver:self forKeyPath:@&quot;distance&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="可变数组的观察"><a href="#可变数组的观察" class="headerlink" title="可变数组的观察"></a>可变数组的观察</h4><p>KVO是基于KVC基础之上的，所以可变数组如果直接添加数据，是不会调用setter方法的，所有对<code>可变数组</code>的KVO观察下面这种方式<code>不生效</code>的,即直接通过<code>[self.person.dateArray addObject:@&quot;1&quot;];</code>向数组添加元素，是不会触发kvo通知回调的，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1、注册可变数组KVO观察者</span><br><span class="line">self.person.dateArray &#x3D; [NSMutableArray arrayWithCapacity:1];</span><br><span class="line">    [self.person addObserver:self forKeyPath:@&quot;dateArray&quot; options:(NSKeyValueObservingOptionNew) context:NULL];</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;2、KVO回调</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,change);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3、移除观察者</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line"> [self.person removeObserver:self forKeyPath:@&quot;dateArray&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;4、触发数组添加数据</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    [self.person.dateArray addObject:@&quot;1&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在KVC官方文档中，针对<code>可变数组的集合</code>类型，有如下说明，即访问集合对象需要需要通过<code>mutableArrayValueForKey</code>方法，这样才能<code>将元素添加到可变数组</code>中</p>
<blockquote>
<p>The protocol defines three different proxy methods for collection object access, each with a key and a key path variant:</p>
<ul>
<li><p><code>mutableArrayValueForKey:</code> and <code>mutableArrayValueForKeyPath:</code></p>
<p>These return a proxy object that behaves like an <code>NSMutableArray</code> object.</p>
</li>
<li><p><code>mutableSetValueForKey:</code> and <code>mutableSetValueForKeyPath:</code></p>
<p>These return a proxy object that behaves like an <code>NSMutableSet</code> object.</p>
</li>
<li><p><code>mutableOrderedSetValueForKey:</code> and <code>mutableOrderedSetValueForKeyPath:</code></p>
<p>These return a proxy object that behaves like an <code>NSMutableOrderedSet</code> object.</p>
</li>
</ul>
</blockquote>
<p>我们代码这样修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    &#x2F;&#x2F; KVC 集合 array</span><br><span class="line">    [[self.person mutableArrayValueForKey:@&quot;dateArray&quot;] addObject:@&quot;1&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在可变数组就可以监听到了。</p>
<h3 id="KVO底层探索"><a href="#KVO底层探索" class="headerlink" title="KVO底层探索"></a>KVO底层探索</h3><p>苹果官方文档在<code>Key-Value Observing Implementation Details</code>里有提到<code>KVO</code>的实现：</p>
<blockquote>
<p>Automatic key-value observing is implemented using a technique called <em>isa-swizzling</em>.</p>
<p>The <code>isa</code> pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.</p>
<p>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</p>
<p>You should never rely on the <code>isa</code> pointer to determine class membership. Instead, you should use the <code>class</code> method to determine the class of an object instance.</p>
</blockquote>
<p>大概意思就是<code>KVO</code>的实现使用了<code>isa</code>的交换。当我们添加一个<code>observer</code>的时候<code>isa</code>的指向会发生改变，是一个<code>中间类</code>而不是<code>真正的类</code>。我们不能根据<code>isa</code>指针确定类的成员身份，而是用哪个<code>class</code>方法确定。</p>
<h4 id="中间类是什么"><a href="#中间类是什么" class="headerlink" title="中间类是什么"></a><code>中间类</code>是什么</h4><p>看苹果官网文档我们了解了，<code>KVO</code>的实现时通过修改<code>isa</code>指针指向了一个<code>中间类</code>实现的，我们使用<code>lldb</code>探究一下<code>中间类</code>是什么。</p>
<ul>
<li><p>添加观察者之前，我们打印实例对象<code>person</code>的方法是<code>JSPerson</code>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) <span class="function">po <span class="title">object_getClassName</span><span class="params">(self.person)</span></span></span><br><span class="line">"JSPerson"</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加观察者之后，我们打印实例对象<code>person</code>的方法是<code>NSKVONotifying_JSPerson</code>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) <span class="function">po <span class="title">object_getClassName</span><span class="params">(self.person)</span></span></span><br><span class="line">"NSKVONotifying_JSPerson"</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>通过上面的调试，我们看到添加观察者值<code>isa</code>指向了一个名为<code>&quot;NSKVONotifying_JSPerson</code>的中间类。关于这个<code>中间类</code>我们有几个点需要研究一下。</p>
<ol>
<li><p><code>中间类</code>和之前的类是父子类关系吗</p>
<p>我们通过一个方法来判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 遍历类以及子类</span><br><span class="line">- (void)printClasses:(Class)cls&#123;</span><br><span class="line">    &#x2F;&#x2F; 注册类的总数</span><br><span class="line">    int count &#x3D; objc_getClassList(NULL, 0);</span><br><span class="line">    &#x2F;&#x2F; 创建一个数组， 其中包含给定对象</span><br><span class="line">    NSMutableArray *mArray &#x3D; [NSMutableArray arrayWithObject:cls];</span><br><span class="line">    &#x2F;&#x2F; 获取所有已注册的类</span><br><span class="line">    Class* classes &#x3D; (Class*)malloc(sizeof(Class)*count);</span><br><span class="line">    objc_getClassList(classes, count);</span><br><span class="line">    for (int i &#x3D; 0; i&lt;count; i++) &#123;</span><br><span class="line">        if (cls &#x3D;&#x3D; class_getSuperclass(classes[i])) &#123;</span><br><span class="line">            [mArray addObject:classes[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(classes);</span><br><span class="line">    NSLog(@&quot;classes &#x3D; %@&quot;, mArray);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;********以下为调用********</span><br><span class="line">[self printClasses:[JSPerson class]];</span><br></pre></td></tr></table></figure>

<p>打印结果为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">classes = (</span><br><span class="line">    JSPerson,</span><br><span class="line">    <span class="string">"NSKVONotifying_JSPerson"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>通过打印结果我们可以判断中间类<code>NSKVONotifying_JSPerson</code>是<code>JSPerson</code>的子类。</p>
</li>
<li><p>中间类里有什么方法。</p>
<p>同样，我们定义一个方法获取<code>NSKVONotifying_JSPerson</code>的所有方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 遍历方法-ivar-property</span><br><span class="line">- (void)printClassAllMethod:(Class)cls&#123;</span><br><span class="line">    unsigned int count &#x3D; 0;</span><br><span class="line">    Method *methodList &#x3D; class_copyMethodList(cls, &amp;count);</span><br><span class="line">    for (int i &#x3D; 0; i&lt;count; i++) &#123;</span><br><span class="line">        Method method &#x3D; methodList[i];</span><br><span class="line">        SEL sel &#x3D; method_getName(method);</span><br><span class="line">        IMP imp &#x3D; class_getMethodImplementation(cls, sel);</span><br><span class="line">        NSLog(@&quot;%@-%p&quot;,NSStringFromSelector(sel),imp);</span><br><span class="line">    &#125;</span><br><span class="line">    free(methodList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;********以下为调用********</span><br><span class="line">[self printClassAllMethod:objc_getClass(&quot;NSKVONotifying_JSPerson&quot;)];</span><br></pre></td></tr></table></figure>

<p>打印结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setNickName:<span class="number">-0x7fff207bbb57</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>-0<span class="title">x7fff207ba662</span></span></span><br><span class="line"><span class="class"><span class="title">dealloc</span>-0<span class="title">x7fff207ba40b</span></span></span><br><span class="line"><span class="class">_<span class="title">isKVOA</span>-0<span class="title">x7fff207ba403</span></span></span><br></pre></td></tr></table></figure>

<p>我们看到一共有四个方法</p>
<ul>
<li>重写了父类的<code>setNickName</code>方法</li>
<li>重写了根类的<code>class</code>、<code>dealloc</code>方法</li>
<li><code>_isKVO</code>方法，用来判断是否是<code>kvo</code>类</li>
</ul>
</li>
<li><p>dealloc中移除观察者后，isa会指回来吗</p>
<ul>
<li><p>移除观察者之前，我们用<code>lldb</code>打印</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) <span class="function">po <span class="title">object_getClassName</span><span class="params">(self.person)</span></span></span><br><span class="line">"NSKVONotifying_JSPerson"</span><br></pre></td></tr></table></figure>
</li>
<li><p>移除观察者之后，我们重新打印</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) <span class="function">po <span class="title">object_getClassName</span><span class="params">(self.person)</span></span></span><br><span class="line">"JSPerson"</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>说明的确是在移除观察的时候将<code>isa</code>指回来的。</p>
</li>
<li><p>移除观察后中间类会销毁吗</p>
<p>我们返回前一个页面，此时添加观察者的VC已经销毁，我们打印<code>JSPerson</code>的子类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self printClasses:[JSPerson class]];</span><br></pre></td></tr></table></figure>

<p>打印结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">classes = (</span><br><span class="line">    JSPerson,</span><br><span class="line">    <span class="string">"NSKVONotifying_JSPerson"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>发现子类并不会被销毁。</p>
</li>
</ol>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>实例对象<code>isa</code>的指向<code>在添加KVO观察者之后</code>，由<code>原有类</code>更改为<code>指向中间类</code></li>
<li><code>中间类</code>重写了观察<code>属性的setter方法</code>、<code>class</code>、<code>dealloc</code>、<code>_isKVOA</code>方法</li>
<li><code>dealloc</code>方法中，移除KVO观察者之后，实例对象<code>isa</code>指向由<code>中间类</code>更改为<code>原有类</code></li>
<li><code>中间类</code>从创建后，就一直<code>存在内存中，不会被销毁</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/07/26/Flutter-IneritedWidget/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/26/Flutter-IneritedWidget/" class="post-title-link" itemprop="url">Flutter-InheritedWidget</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-26 10:41:49" itemprop="dateCreated datePublished" datetime="2021-07-26T10:41:49+08:00">2021-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-30 15:06:34" itemprop="dateModified" datetime="2021-07-30T15:06:34+08:00">2021-07-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/07/25/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-KVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/25/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-KVC/" class="post-title-link" itemprop="url">iOS底层探索-KVC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-25 11:04:54 / 修改时间：16:26:44" itemprop="dateCreated datePublished" datetime="2021-07-25T11:04:54+08:00">2021-07-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>KVC</code>的全拼是<code>Key-Value Coding</code>,中文是<code>键值编码</code>。是由<code>NSKeyValueCoding</code>非正式协议的一种机制。对象可以间接地访问它们的属性。这种间接访问机制是实例变量及其相关访问器方法提供的直接访问的补充。</p>
<h3 id="使用KVC"><a href="#使用KVC" class="headerlink" title="使用KVC"></a>使用<code>KVC</code></h3><h4 id="通过key取值和设置值"><a href="#通过key取值和设置值" class="headerlink" title="通过key取值和设置值"></a>通过<code>key</code>取值和设置值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;直接通过Key来取值</span><br><span class="line">- (nullable id)valueForKey:(NSString *)key;</span><br><span class="line">&#x2F;&#x2F;通过Key来设值</span><br><span class="line">- (void)setValue:(nullable id)value forKey:(NSString *)key;</span><br></pre></td></tr></table></figure>

<h4 id="通过keyPath（路由）取值和设置值"><a href="#通过keyPath（路由）取值和设置值" class="headerlink" title="通过keyPath（路由）取值和设置值"></a>通过<code>keyPath</code>（路由）取值和设置值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通过KeyPath来取值</span><br><span class="line">- (nullable id)valueForKeyPath:(NSString *)keyPath; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过KeyPath来设值                 </span><br><span class="line">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure>

<p>我们平时项目中主要是通过使用的是<code>valueForKey</code>和<code>valueForKeyPath</code>的方式取值和设值，当然还有<code>集合类型</code>的一些操作可以参见<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107-SW1" target="_blank" rel="noopener">苹果KVC的文档</a>查看使用。</p>
<h3 id="KVC的设值过程"><a href="#KVC的设值过程" class="headerlink" title="KVC的设值过程"></a><code>KVC</code>的设值过程</h3><p><code>setValue:forKey:</code>这个方法有一个调用顺序(基本数据类型)：</p>
<ul>
<li>按顺序查找名为 set<Key>: 或 _set<Key> 的第一个访问器。如果找到，则使用输入值（或根据需要展开的值）调用它并完成。</li>
<li>如果未找到简单访问器，并且类方法 accessInstanceVariablesDirectly 返回 YES，则按顺序查找名称类似于 _<key>、_is<Key>、<key> 或 is<Key> 的实例变量。如果找到，直接使用输入值（或解包值）设置变量并完成。</li>
<li>在未找到访问器或实例变量时，调用 setValue:forUndefinedKey:。默认情况下，这会引发异常，但 NSObject 的子类可能会提供特定于键的行为。</li>
</ul>
<p>整个流程图如下(以<code>person</code>对象设置<code>name</code>属性为例)：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fafa22458d84357afcda544590fc1e1~tplv-k3u1fbpfcp-watermark.image" alt="kvc取值流程"></p>
<h3 id="KVC取值过程"><a href="#KVC取值过程" class="headerlink" title="KVC取值过程"></a><code>KVC</code>取值过程</h3><p>和设值过程一样，取值过程<code>valueForKey:</code>也有一个调用顺序(包含集合类型)：</p>
<ul>
<li>在实例中搜索找到的第一个访问器方法，其名称类似于 get<Key>、<key>、is<Key> 或 _<key>，按该顺序。如果找到，则调用它并使用结果继续执行步骤 5。否则继续下一个步骤</li>
<li>如果没有找到简单的访问器方法，则在实例中搜索名称与模式 countOf<Key> 和 objectIn<Key>AtIndex:（对应于 NSArray 类定义的原始方法）和 <key>AtIndexes:（对应于模式）的方法NSArray 方法 objectsAtIndexes:)。如果找到其中的第一个和至少其他两个中的一个，则创建一个集合代理对象，该对象响应所有 NSArray 方法并返回该对象。否则，继续执行步骤 3。代理对象随后将它接收到的任何 NSArray 消息转换为 countOf<Key>、objectIn<Key>AtIndex: 和 <key>AtIndexes: 消息的某种组合，并将其转换为创建它的键值编码兼容对象。如果原始对象还实现了一个可选方法，其名称类似于 get<Key>:range:，则代理对象也会在适当的时候使用它。实际上，代理对象与键值编码兼容对象一起工作允许底层属性表现得好像它是一个 NSArray，即使它不是。</li>
<li>如果没有找到简单的访问器方法或数组访问方法组，则查找名为 countOf<Key>、enumeratorOf<Key> 和 memberOf<Key> 的三元组方法：（对应于 NSSet 类定义的原始方法）。如果找到所有三个方法，则创建一个集合代理对象，该对象响应所有 NSSet 方法并返回该对象。否则，继续执行步骤 4。这个代理对象随后将它接收到的任何 NSSet 消息转换为 countOf<Key>、enumeratorOf<Key> 和 memberOf<Key> 的某种组合：消息到创建它的对象。实际上，与键值编码兼容的对象一起工作的代理对象允许底层属性表现得好像它是一个 NSSet，即使它不是。</li>
<li>如果没有找到简单的访问器方法或集合访问方法组，并且如果接收者的类方法accessInstanceVariables直接返回YES，则搜索名为_<key>、_is<Key>、<key>或is<Key>的实例变量，以该顺序。如果找到，直接获取实例变量的值并进行步骤5，否则进行步骤6。</li>
<li>如果检索到的属性值是一个对象指针，只需返回结果即可。 如果该值是 NSNumber 支持的标量类型，则将其存储在 NSNumber 实例中并返回。 如果结果是 NSNumber 不支持的标量类型，则转换为 NSValue 对象并返回。</li>
<li>如果所有其他方法都失败，请调用 valueForUndefinedKey:。默认情况下，这会引发异常，但 NSObject 的子类可能会提供特定于键的行为。</li>
</ul>
<p>其流程图如下：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21604d5aa0e64c64a2f038d4436db4f8~tplv-k3u1fbpfcp-watermark.image" alt="KVC取值过程"></p>
<h3 id="自定义实现KVC"><a href="#自定义实现KVC" class="headerlink" title="自定义实现KVC"></a>自定义实现KVC</h3><p>如果自己实现一个<code>KVC</code>可以参考上面的顺序，实现<code>valueForKey</code>和<code>setValueForKey</code>。</p>
<h4 id="设值过程"><a href="#设值过程" class="headerlink" title="设值过程"></a>设值过程</h4><ul>
<li>判断<code>key</code>是否为空，为空直接返回。</li>
<li>查找是否有 setter方法 <code>set&lt;Key&gt;:</code> ， <code>_set&lt;Key&gt;</code>, <code>setIs&lt;Key&gt;</code>，如果有则实现并返回。</li>
<li>如果没找到则判断accessInstanceVariablesDirectly的返回值是否为YES，可以则往下走，否则抛出异常。</li>
<li>查找自己的ivar列表中是否包含实例变量 <code>_&lt;key&gt;</code>, <code>_is&lt;Key&gt;</code>,<code>&lt;key&gt;</code>,<code>is&lt;Key&gt;</code>,找到就赋值。</li>
<li>如果都搜索不到，就抛出异常。</li>
</ul>
<p>实现代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">- (void)js_setValue:(nullable id)value forKey:(NSString *)key&#123;</span><br><span class="line">    &#x2F;&#x2F; 空判断</span><br><span class="line">    if (key &#x3D;&#x3D; nil || key.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 2: setter set&lt;Key&gt;: or _set&lt;Key&gt;,</span><br><span class="line">    &#x2F;&#x2F; key 要大写</span><br><span class="line">    NSString *Key &#x3D; key.capitalizedString;</span><br><span class="line">    &#x2F;&#x2F; 拼接方法</span><br><span class="line">    NSString *setKey &#x3D; [NSString stringWithFormat:@&quot;set%@:&quot;,Key];</span><br><span class="line">    NSString *_setKey &#x3D; [NSString stringWithFormat:@&quot;_set%@:&quot;,Key];</span><br><span class="line">    NSString *setIsKey &#x3D; [NSString stringWithFormat:@&quot;setIs%@:&quot;,Key];</span><br><span class="line">    </span><br><span class="line">    if ([self js_performSelectorWithMethodName:setKey value:value]) &#123;</span><br><span class="line">        NSLog(@&quot;*********%@**********&quot;,setKey);</span><br><span class="line">        return;</span><br><span class="line">    &#125;else if ([self js_performSelectorWithMethodName:_setKey value:value]) &#123;</span><br><span class="line">        NSLog(@&quot;*********%@**********&quot;,_setKey);</span><br><span class="line">        return;</span><br><span class="line">    &#125;else if ([self js_performSelectorWithMethodName:setIsKey value:value]) &#123;</span><br><span class="line">        NSLog(@&quot;*********%@**********&quot;,setIsKey);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 3: 判断是否响应 accessInstanceVariablesDirectly 返回YES NO 奔溃</span><br><span class="line">    &#x2F;&#x2F; 3:判断是否能够直接赋值实例变量</span><br><span class="line">    if (![self.class accessInstanceVariablesDirectly] ) &#123;</span><br><span class="line">        @throw [NSException exceptionWithName:@&quot;JSUnknownKeyException&quot; reason:[NSString stringWithFormat:@&quot;****[%@ valueForUndefinedKey:]: this class is not key value coding-compliant for the key name.****&quot;,self] userInfo:nil];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 4: 间接变量</span><br><span class="line">    &#x2F;&#x2F; 获取 ivar -&gt; 遍历 containsObjct -</span><br><span class="line">    &#x2F;&#x2F; 4.1 定义一个收集实例变量的可变数组</span><br><span class="line">    NSMutableArray *mArray &#x3D; [self getIvarListName];</span><br><span class="line">    &#x2F;&#x2F; _&lt;key&gt; _is&lt;Key&gt; &lt;key&gt; is&lt;Key&gt;</span><br><span class="line">    NSString *_key &#x3D; [NSString stringWithFormat:@&quot;_%@&quot;,key];</span><br><span class="line">    NSString *_isKey &#x3D; [NSString stringWithFormat:@&quot;_is%@&quot;,Key];</span><br><span class="line">    NSString *isKey &#x3D; [NSString stringWithFormat:@&quot;is%@&quot;,Key];</span><br><span class="line">    if ([mArray containsObject:_key]) &#123;</span><br><span class="line">        &#x2F;&#x2F; 4.2 获取相应的 ivar</span><br><span class="line">       Ivar ivar &#x3D; class_getInstanceVariable([self class], _key.UTF8String);</span><br><span class="line">        &#x2F;&#x2F; 4.3 对相应的 ivar 设置值</span><br><span class="line">       object_setIvar(self , ivar, value);</span><br><span class="line">       return;</span><br><span class="line">    &#125;else if ([mArray containsObject:_isKey]) &#123;</span><br><span class="line">       Ivar ivar &#x3D; class_getInstanceVariable([self class], _isKey.UTF8String);</span><br><span class="line">       object_setIvar(self , ivar, value);</span><br><span class="line">       return;</span><br><span class="line">    &#125;else if ([mArray containsObject:key]) &#123;</span><br><span class="line">       Ivar ivar &#x3D; class_getInstanceVariable([self class], key.UTF8String);</span><br><span class="line">       object_setIvar(self , ivar, value);</span><br><span class="line">       return;</span><br><span class="line">    &#125;else if ([mArray containsObject:isKey]) &#123;</span><br><span class="line">       Ivar ivar &#x3D; class_getInstanceVariable([self class], isKey.UTF8String);</span><br><span class="line">       object_setIvar(self , ivar, value);</span><br><span class="line">       return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 5:如果找不到相关实例</span><br><span class="line">    @throw [NSException exceptionWithName:@&quot;JSUnknownKeyException&quot; reason:[NSString stringWithFormat:@&quot;****[%@ %@]: this class is not key value coding-compliant for the key name.****&quot;,self,NSStringFromSelector(_cmd)] userInfo:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="取值过程"><a href="#取值过程" class="headerlink" title="取值过程"></a>取值过程</h4><ul>
<li>同样是判断key非空</li>
<li>按顺序查找方法：<code>get&lt;Key&gt;</code>、 <code>&lt;key&gt;</code>、<code>countOf&lt;Key&gt;</code>、 <code>objectIn&lt;Key&gt;AtIndex</code></li>
<li>判断accessInstanceVariablesDirectly的返回值是否为YES，可以则往下走，否则抛出异常。</li>
<li>查找自己的ivar列表中是否包含实例变量 <code>_&lt;key&gt;</code>, <code>_is&lt;Key&gt;</code>,<code>&lt;key&gt;</code>,<code>is&lt;Key&gt;</code>,找到就取值。</li>
<li>未找到抛出异常。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)js_valueForKey:(NSString *)key&#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 1:判断非空</span><br><span class="line">    if (key &#x3D;&#x3D; nil  || key.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 2:找到相关方法 get&lt;Key&gt; &lt;key&gt; countOf&lt;Key&gt;  objectIn&lt;Key&gt;AtIndex</span><br><span class="line">    &#x2F;&#x2F; key 要大写</span><br><span class="line">    NSString *Key &#x3D; key.capitalizedString;</span><br><span class="line">    &#x2F;&#x2F; 拼接方法</span><br><span class="line">    NSString *getKey &#x3D; [NSString stringWithFormat:@&quot;get%@&quot;,Key];</span><br><span class="line">    NSString *countOfKey &#x3D; [NSString stringWithFormat:@&quot;countOf%@&quot;,Key];</span><br><span class="line">    NSString *objectInKeyAtIndex &#x3D; [NSString stringWithFormat:@&quot;objectIn%@AtIndex:&quot;,Key];</span><br><span class="line">        </span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">    if ([self respondsToSelector:NSSelectorFromString(getKey)]) &#123;</span><br><span class="line">        return [self performSelector:NSSelectorFromString(getKey)];</span><br><span class="line">    &#125;else if ([self respondsToSelector:NSSelectorFromString(key)])&#123;</span><br><span class="line">        return [self performSelector:NSSelectorFromString(key)];</span><br><span class="line">    &#125;else if ([self respondsToSelector:NSSelectorFromString(countOfKey)])&#123;</span><br><span class="line">        if ([self respondsToSelector:NSSelectorFromString(objectInKeyAtIndex)]) &#123;</span><br><span class="line">            int num &#x3D; (int)[self performSelector:NSSelectorFromString(countOfKey)];</span><br><span class="line">            NSMutableArray *mArray &#x3D; [NSMutableArray arrayWithCapacity:1];</span><br><span class="line">            for (int i &#x3D; 0; i&lt;num-1; i++) &#123;</span><br><span class="line">                num &#x3D; (int)[self performSelector:NSSelectorFromString(countOfKey)];</span><br><span class="line">            &#125;</span><br><span class="line">            for (int j &#x3D; 0; j&lt;num; j++) &#123;</span><br><span class="line">                id objc &#x3D; [self performSelector:NSSelectorFromString(objectInKeyAtIndex) withObject:@(num)];</span><br><span class="line">                [mArray addObject:objc];</span><br><span class="line">            &#125;</span><br><span class="line">            return mArray;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 3:判断是否能够直接赋值实例变量</span><br><span class="line">    if (![self.class accessInstanceVariablesDirectly] ) &#123;</span><br><span class="line">        @throw [NSException exceptionWithName:@&quot;JSUnknownKeyException&quot; reason:[NSString stringWithFormat:@&quot;****[%@ valueForUndefinedKey:]: this class is not key value coding-compliant for the key name.****&quot;,self] userInfo:nil];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 4.找相关实例变量进行赋值</span><br><span class="line">    &#x2F;&#x2F; 4.1 定义一个收集实例变量的可变数组</span><br><span class="line">    NSMutableArray *mArray &#x3D; [self getIvarListName];</span><br><span class="line">    &#x2F;&#x2F; _&lt;key&gt; _is&lt;Key&gt; &lt;key&gt; is&lt;Key&gt;</span><br><span class="line">    &#x2F;&#x2F; _name -&gt; _isName -&gt; name -&gt; isName</span><br><span class="line">    NSString *_key &#x3D; [NSString stringWithFormat:@&quot;_%@&quot;,key];</span><br><span class="line">    NSString *_isKey &#x3D; [NSString stringWithFormat:@&quot;_is%@&quot;,Key];</span><br><span class="line">    NSString *isKey &#x3D; [NSString stringWithFormat:@&quot;is%@&quot;,Key];</span><br><span class="line">    if ([mArray containsObject:_key]) &#123;</span><br><span class="line">        Ivar ivar &#x3D; class_getInstanceVariable([self class], _key.UTF8String);</span><br><span class="line">        return object_getIvar(self, ivar);;</span><br><span class="line">    &#125;else if ([mArray containsObject:_isKey]) &#123;</span><br><span class="line">        Ivar ivar &#x3D; class_getInstanceVariable([self class], _isKey.UTF8String);</span><br><span class="line">        return object_getIvar(self, ivar);;</span><br><span class="line">    &#125;else if ([mArray containsObject:key]) &#123;</span><br><span class="line">        Ivar ivar &#x3D; class_getInstanceVariable([self class], key.UTF8String);</span><br><span class="line">        return object_getIvar(self, ivar);;</span><br><span class="line">    &#125;else if ([mArray containsObject:isKey]) &#123;</span><br><span class="line">        Ivar ivar &#x3D; class_getInstanceVariable([self class], isKey.UTF8String);</span><br><span class="line">        return object_getIvar(self, ivar);;</span><br><span class="line">    &#125;</span><br><span class="line">    return @&quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇我们主要探索了KVC的<code>取值</code>和<code>设值</code>的流程。设值过程<code>集合</code>类型的情况没有写，感兴趣的童鞋可以查看苹果<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107-SW1" target="_blank" rel="noopener">官方文档</a>进行探索。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/07/22/Objective-c%E5%BA%95%E5%B1%82%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/22/Objective-c%E5%BA%95%E5%B1%82%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">Objective-C底层面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-22 20:15:48" itemprop="dateCreated datePublished" datetime="2021-07-22T20:15:48+08:00">2021-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-25 11:04:14" itemprop="dateModified" datetime="2021-07-25T11:04:14+08:00">2021-07-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>oc</code>底层探索了很多了，今天主要总结一下一些相关的面试题。</p>
<h3 id="load方法什么时候调用。"><a href="#load方法什么时候调用。" class="headerlink" title="load方法什么时候调用。"></a><code>load</code>方法什么时候调用。</h3><p>这个问题很多同学应该都知道，就是<code>main</code>函数之前，但是<code>main</code>之前的哪一步执行的，可能有些同学就疑惑了，，同时还有一个方法的调用时机也会被经常问到就是<code>initialize</code>,我们分别讨论。</p>
<h4 id="load方法"><a href="#load方法" class="headerlink" title="load方法"></a><code>load</code>方法</h4><ul>
<li><code>load</code>方法是在应用程序加载过程中调用的，确实是在<code>main</code>函数之前调用。</li>
<li>具体是<code>_dyld_objc_notify_register</code>方法的第二个参数<code>load_images</code>回调的。</li>
<li>通过<code>prepare_load_methods</code>递归查找<code>load</code>方法添加到一个<code>load</code>方法的加载表<code>loadable_classes</code>里，注意父类会比子类先加入到表中，查找完类的<code>load</code>方法之后，查找分类的<code>load</code>也会添加到一个<code>loadable_categories</code>表中。</li>
<li>最后是<code>call_load_methods</code>调用<code>load</code>方法，先从<code>loadable_classes</code>表里循环调用类的<code>load</code>方法，然后从<code>loadable_categories</code>表里循环调用分类的<code>load</code>方法。</li>
<li>因为是顺序遍历表调用<code>load</code>方法的。所以<code>load</code>方法的调用次序是<code>父类</code>&gt;<code>本类</code>&gt;<code>分类</code>。</li>
<li>如果有多个分类都有<code>load</code>方法，其调用顺序会根据编译的顺序调用。编译顺序可以在<code>Compiles Sources</code>里调整。</li>
<li><code>load</code>方法过多会影响到应用的启动速度。</li>
</ul>
<h4 id="initialize方法。"><a href="#initialize方法。" class="headerlink" title="initialize方法。"></a><code>initialize</code>方法。</h4><ul>
<li><code>initialize</code>方法是在第一次<code>objc_msgSend</code>的时候调用的，它的调用时机晚于<code>load</code>。</li>
<li>分类的方法是在类<code>realize</code>之后<code>attachCategorys</code>进去的，会在类的方法前面。如果分类实现了<code>initialize</code>方法，会优先调用分类的方法。</li>
</ul>
<h3 id="Runtime是什么"><a href="#Runtime是什么" class="headerlink" title="Runtime是什么"></a><code>Runtime</code>是什么</h3><ul>
<li><code>runtime</code>是由<code>c</code>、<code>c++</code>、<code>汇编</code>实现的一套<code>API</code>,为<code>oc</code>语言加入面向对象运行时功能。</li>
<li><code>运行时</code>是指讲数据类型的确定有<code>编译时</code>推迟到了<code>运行时</code>。</li>
<li>我们写的<code>oc</code>代码，在程序运行过程中，最终都会转换成<code>runtime</code>的<code>c</code>语言代码。</li>
</ul>
<h3 id="⽅法的本质，sel是什么？IMP是什么？两者之间的关系是什么"><a href="#⽅法的本质，sel是什么？IMP是什么？两者之间的关系是什么" class="headerlink" title="⽅法的本质，sel是什么？IMP是什么？两者之间的关系是什么"></a>⽅法的本质，<code>sel</code>是什么？<code>IMP</code>是什么？两者之间的关系是什么</h3><h4 id="⽅法的本质"><a href="#⽅法的本质" class="headerlink" title="⽅法的本质"></a>⽅法的本质</h4><p>⽅法的本质是消息发送，即<code>objc_msgSend</code>,它的流程是：</p>
<ul>
<li>快速查找 （<code>objc_msgSend</code>）~ <code>cache_t</code> 缓存消息</li>
<li>慢速查找~ 递归⾃⼰或⽗类 ~ <code>lookUpImpOrForward</code></li>
<li>查找不到消息: 动态⽅法解析 ~ <code>resolveInstanceMethod</code></li>
<li>消息快速转发 ~ <code>forwardingTargetForSelector</code></li>
<li>消息慢速转发 ~ <code>methodSignatureForSelector</code> 和 <code>forwardInvocation</code></li>
</ul>
<h4 id="sel是什么"><a href="#sel是什么" class="headerlink" title="sel是什么"></a><code>sel</code>是什么</h4><p><code>sel</code>是⽅法编号，在<code>read_images</code>期间就加载进⼊了内存。它实际是<code>objc_selector</code>结构体。</p>
<h4 id="IMP是什么"><a href="#IMP是什么" class="headerlink" title="IMP是什么"></a><code>IMP</code>是什么</h4><p><code>imp</code>就是我们函数实现指针，找<code>imp</code>就是找函数实现的过程。</p>
<h4 id="sel与IMP的关系"><a href="#sel与IMP的关系" class="headerlink" title="sel与IMP的关系"></a><code>sel</code>与<code>IMP</code>的关系</h4><ul>
<li><code>sel</code>就相当于书本的⽬录<code>title</code></li>
<li><code>imp</code>就是书本的⻚码</li>
<li>方法调用的时候首先根据<code>sel</code>找到<code>imp</code>最后到具体函数的实现，完成调用。</li>
</ul>
<h3 id="能否向编译后的类中增加实例变量？能否向运⾏时创建的类中添加实例变量？"><a href="#能否向编译后的类中增加实例变量？能否向运⾏时创建的类中添加实例变量？" class="headerlink" title="能否向编译后的类中增加实例变量？能否向运⾏时创建的类中添加实例变量？"></a>能否向编译后的类中增加实例变量？能否向运⾏时创建的类中添加实例变量？</h3><ul>
<li><p>不能向编译后的得到的类中增加实例变量：</p>
<ul>
<li>我们编译好的实例变量存储的位置在<code>ro</code>（read only），⼀旦编译完成，内存结构就完全确定。</li>
<li>我们可以通过<code>分类</code>向类中添加<code>方法</code>和<code>属性</code>(通过关联对象)。</li>
</ul>
</li>
<li><p>可以向运行时创建的类中添加实例变量，只要类没有注册到内存还是可以添加。</p>
<p>这里<code>运行时创建的类</code>指的是通过<code>objc_allocateClassPair</code>方法，创建的<code>类</code>,在调用<code>objc_registerClassPair</code>方法之前是可以添加<code>实例变量</code>的。</p>
</li>
</ul>
<h3 id="self-class-和-super-class-区别"><a href="#self-class-和-super-class-区别" class="headerlink" title="[self class]和[super class]区别"></a>[self class]和[super class]区别</h3><p>先定义两个类<code>JSPerson</code>和<code>JSStudent</code>,其中<code>JSStudent</code>继承于<code>JSPerson</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@interface JSPerson : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">#import &quot;JSPerson.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation JSPerson</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface JSStudent : JSPerson</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation JSStudent</span><br><span class="line"></span><br><span class="line">- (instancetype)init&#123;</span><br><span class="line">    self &#x3D; [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        NSLog(@&quot;%@ - %@&quot;,[self class],[super class]);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>在<code>main</code>函数里实例化一个<code>JSStudent</code>对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        JSStudent *student &#x3D; [[JSStudent alloc] init];;</span><br><span class="line">        NSLog(@&quot;%@&quot;,student);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现打印结果为<code>JSStudent - JSStudent</code>。这是为什么呢，我们下面分析一下。</p>
<p>首先，<code>JSPerson</code>和<code>JSStudent</code>类都没有实现<code>class</code>方法，根据消息发送查找流程，会调用<code>NSObject</code>类的<code>class</code>方法，它的实现为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (Class)<span class="class"><span class="keyword">class</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> object_getClass(self);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据isa找到类</span></span><br><span class="line"><span class="function">Class <span class="title">object_getClass</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) <span class="keyword">return</span> obj-&gt;getIsa();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>class</code>方法的作用是返回当前的类，<code>self</code>是调用的对象也就是<code>student</code>实例。</p>
<ul>
<li><p><code>[self class]</code>打印的是<code>JSStudent</code>很好理解，因为消息接受者就是<code>JSStudent</code>的实例对象，通过<code>isa</code>找到的就是<code>JSStudent</code>类。</p>
</li>
<li><p><code>[super class]</code>打印的也是<code>JSStudent</code>就让人困惑了，我们打开<code>汇编调试</code>看一下<code>[super class]</code>的底层调用了什么</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32b236096024497cb3c8e4345f302f03~tplv-k3u1fbpfcp-watermark.image" alt="WechatIMG1246"></p>
<p><code>[super class]</code>实际调用的是<code>objc_msgSendSuper2</code>方法，我们在源码看一下这个方法的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc_msgSendSuper2() takes the current search class, not its superclass.</span></span><br><span class="line">OBJC_EXPORT id _Nullable</span><br><span class="line">objc_msgSendSuper2(struct objc_super * _Nonnull super, SEL _Nonnull op, ...)</span><br><span class="line">    OBJC_AVAILABLE(<span class="number">10.6</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br></pre></td></tr></table></figure>

<p>其实看<code>objc_msgSendSuper2</code>的注释就可以看出来，方法查找的是<code>本类</code>而不是它的<code>父类</code>。</p>
<p>继续看，<code>super</code>是方法的第一个参数，也就是<code>objc_super *</code>它的结构是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_super</span> &#123;</span></span><br><span class="line">    <span class="comment">/// Specifies an instance of a class.</span></span><br><span class="line">    __unsafe_unretained _Nonnull id receiver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Specifies the particular superclass of the instance to message. </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span></span><br><span class="line">    <span class="comment">/* For compatibility with old objc-runtime.h header */</span></span><br><span class="line">  	<span class="comment">///old结构，我们可以忽略 !__OBJC2__使用</span></span><br><span class="line">    __unsafe_unretained _Nonnull Class <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    __unsafe_unretained _Nonnull Class super_class;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* super_class is the first class to search */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>objc_super</code>的成员变量有<code>receiver</code>它是当前的调用的实例也就是<code>student</code>,<code>super_class</code>是当前实例对象的类的<code>父类</code>。所以说<code>[super class]</code>的消息接受者<code>self</code>还是<code>student</code>,所以打印的是<code>JSStudent</code>，<code>super</code>是一个关键字。</p>
<h3 id="内存平移问题"><a href="#内存平移问题" class="headerlink" title="内存平移问题"></a>内存平移问题</h3><p>案例说明:<code>JSPerson</code>类中有一个<code>saySomething</code>方法，在<code>ViewController</code>类的<code>viewDidLoad</code>通过两种方式调用，详细看代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@implementation JSPerson</span><br><span class="line">- (void)saySomething&#123;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    &#x2F;&#x2F; Do any additional setup after loading the view.</span><br><span class="line">    JSPerson *person &#x3D; [JSPerson alloc];</span><br><span class="line">    [person saySomething];</span><br><span class="line">    </span><br><span class="line">    Class cls &#x3D; [JSPerson class];</span><br><span class="line">    void  *js &#x3D; &amp;cls;</span><br><span class="line">    [(__bridge id)js saySomething];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>问题是这两个调用<code>saySomething</code>的语句是否有问题。</p>
<ul>
<li><p><code>[person saySomething]</code>：这种方式没什么疑问，正常的方法调用。它的流程是通过<code>person</code>对象的<code>isa</code>指针找到类<code>JSPerson</code>,首先通过内存平移找到<code>cache</code>里查找，如果找不到，继续平移找到<code>bits</code>查找方法列表查找，最后找到<code>imp</code>调用。</p>
</li>
<li><p><code>[(__bridge id)js saySomething]</code>:运行代码，我们这一行代码也正常执行了，原因是什么呢</p>
<p><code>void  *js = &amp;cls;</code>说明<code>js</code>是一个指向<code>JSPerson</code>类首地址的指针，它和对象的<code>isa</code>指向的是同一个地址，通过内存平移也可以找到对应的方法。</p>
</li>
</ul>
<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>在<code>saySomething</code>方法里增加属性<code>self.js_name</code> 的打印,其他不变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@interface JSPerson : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSString *js_name;</span><br><span class="line"></span><br><span class="line">- (void)saySomething;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation JSPerson</span><br><span class="line">- (void)saySomething&#123;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;%s - %@&quot;,__func__,self.js_name);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>再次运行程序发现打印结果为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-[JSPerson saySomething] - (null)</span><br><span class="line">-[JSPerson saySomething] - &lt;JSPerson: <span class="number">0x600003a00380</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>[person saySomething]</code>：因为我们没有对<code>js_name</code>赋值，<code>[person saySomething]</code>打印<code>(null)</code>正常。</p>
</li>
<li><p><code>[(__bridge id)js saySomething]</code>：这里打印了<code>&lt;JSPerson: 0x600003a00380&gt;</code>很困惑。</p>
<p>我们首先要清楚<code>self.js_name</code>是怎么找到<code>js_name</code>并打印的，它是从<code>person</code>内存地址中平移8位(<code>isa</code>是8位)找到第一个属性<code>js_name</code>。</p>
<p>类比<code>js</code>也需要平移8位找<code>js_name</code>,由于<code>js</code>是一个指针，存在<code>栈</code>上的，栈是一个<code>先进后出</code>的数据结构，每次参数传入就会压栈。</p>
<ul>
<li><p>其中<code>隐藏参数会压入栈</code>，且每个函数都会有两个隐藏参数<code>(id self，sel _cmd)</code>，这个我们前面探索过，可以通过<code>clang</code>将<code>oc</code>代码转成<code>c++</code>代码查看。</p>
</li>
<li><p><code>隐藏参数压栈</code>的过程，其地址是<code>递减</code>的，而<code>栈是从高地址-&gt;低地址 分配</code>的，即<code>在栈中，参数会从前往后一直压</code></p>
</li>
<li><p>前面还有一行<code>[super viewDidLoad];</code>,<code>super</code>调用的压栈我们也需要研究一下，其实上一题我们研究过它实际调用的是<code>objc_msgSendSuper2</code>,有两个参数<code>_objc_super</code>和<code>sel</code>。结构体的属性的压栈我们通过自定义一个结构体探索</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct js_struct&#123;</span><br><span class="line">    NSNumber *num1;</span><br><span class="line">    NSNumber *num2;</span><br><span class="line">&#125; js_struct;</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    &#x2F;&#x2F; Do any additional setup after loading the view.</span><br><span class="line">    JSPerson *person1 &#x3D; [JSPerson alloc];</span><br><span class="line">    struct js_struct jst &#x3D; &#123;@(1),@(3)&#125;;</span><br><span class="line">    JSPerson *person &#x3D; [JSPerson alloc];</span><br><span class="line">    [person saySomething];</span><br><span class="line">    </span><br><span class="line">    Class cls &#x3D; [JSPerson class];</span><br><span class="line">    void  *js &#x3D; &amp;cls;</span><br><span class="line">    [(__bridge id)js saySomething];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在图示位置添加断点调试</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/900abebd0f814bdb9251b1f21cefaf32~tplv-k3u1fbpfcp-watermark.image" alt="1627138804130"></p>
<p>使用<code>lldb</code>调试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p &amp;person1</span><br><span class="line">(JSPerson **) $<span class="number">0</span> = <span class="number">0x00007ffeed1d8118</span></span><br><span class="line">(lldb) p &amp;jst</span><br><span class="line">(js_struct *) $<span class="number">1</span> = <span class="number">0x00007ffeed1d8108</span></span><br><span class="line">(lldb) p &amp;person</span><br><span class="line">(JSPerson **) $<span class="number">2</span> = <span class="number">0x00007ffeed1d8100</span></span><br><span class="line">(lldb) p jst.num1</span><br><span class="line">(__NSCFNumber *) $<span class="number">3</span> = <span class="number">0xbab63c269bab4904</span> (<span class="keyword">int</span>)<span class="number">1</span></span><br><span class="line">(lldb) p &amp;$<span class="number">3</span></span><br><span class="line">(NSNumber **) $<span class="number">4</span> = <span class="number">0x00007ffeed1d8108</span></span><br><span class="line">(lldb) p jst.num2</span><br><span class="line">(__NSCFNumber *) $<span class="number">5</span> = <span class="number">0xbab63c269bab4924</span> (<span class="keyword">int</span>)<span class="number">3</span></span><br><span class="line">(lldb) p &amp;$<span class="number">5</span></span><br><span class="line">(NSNumber **) $<span class="number">6</span> = <span class="number">0x00007ffeed1d8110</span></span><br></pre></td></tr></table></figure>

<p>发现<code>num1</code>的地址&lt;<code>num2</code>的地址，说明<code>num2</code>先入栈。也就是<code>结构体是从后向前入栈的</code>。</p>
</li>
<li><p>总结来说题中压栈的顺序是<code>self</code>-&gt;<code>_cmd</code>-&gt;<code>superClass</code>-&gt;<code>self</code>-&gt;<code>person</code>-&gt;<code>cls</code>-&gt;<code>js</code>。地址空间是由高到低。所以这个地方<code>js</code>向高地址平移8字节找到的是<code>person</code>也就是打印是<code>&lt;JSPerson: 0x600003a00380&gt;</code>的原因。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jason</p>
  <div class="site-description" itemprop="description">个人技术博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
