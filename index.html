<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yujiusheng.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="个人技术博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Jason的博客">
<meta property="og:url" content="http://yujiusheng.com/index.html">
<meta property="og:site_name" content="Jason的博客">
<meta property="og:description" content="个人技术博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yujiusheng.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Jason的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jason的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/10/02/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-LLVM%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/02/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-LLVM%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">iOS底层探索-LLVM编译流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-02 16:48:14" itemprop="dateCreated datePublished" datetime="2021-10-02T16:48:14+08:00">2021-10-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-03 16:20:06" itemprop="dateModified" datetime="2021-10-03T16:20:06+08:00">2021-10-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们都知道iOS的编译器是<code>LLVM</code>，本篇我们就探索<code>llvm</code>的编译流程。</p>
<h3 id="解释型语言和编译型语言区别"><a href="#解释型语言和编译型语言区别" class="headerlink" title="解释型语言和编译型语言区别"></a>解释型语言和编译型语言区别</h3><h4 id="解释型语言"><a href="#解释型语言" class="headerlink" title="解释型语言"></a>解释型语言</h4><p>解释型语言的特征是：它的执行机制是使用一个<code>解释器</code>来执行，<code>解释器</code>对程序一句一句<code>翻译</code>成<code>机器语言</code>来一句一句执行。例如：<code>shell</code>、<code>python</code>等。</p>
<p>比如我们执行一段<code>pythion</code>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">///hello.py</span><br><span class="line">print(<span class="string">"hello python"</span>)</span><br></pre></td></tr></table></figure>

<p>我们执行上面的代码只需要：</p>
<p><code>python hello.py</code></p>
<h4 id="编译型语言"><a href="#编译型语言" class="headerlink" title="编译型语言"></a>编译型语言</h4><p>编译型语言的特征是：它的执行机制使用<code>编译器</code>来编译成<code>机器语言</code>,然后就可以直接执行编译后的<code>可执行文件</code>。例如：<code>c</code>、<code>java</code>等。</p>
<p>比如我们执行一段<code>c</code>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///hello.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hello c"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先要对上面的文件进行编译：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang hello.c</span><br></pre></td></tr></table></figure>

<p>执行<code>clang</code>指令后，会生成一个<code>.out</code>的可执行文件，然后执行可执行文件就可以打印出<code>hello c</code>。</p>
<h3 id="传统编译器的设计"><a href="#传统编译器的设计" class="headerlink" title="传统编译器的设计"></a>传统编译器的设计</h3><p>编译器是由三部分构成的<code>编译器前端</code>、<code>优化器</code>、<code>编译器后端</code>。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7f85b98aca04cf6a2f7ee6e5d7341f2~tplv-k3u1fbpfcp-watermark.image?" alt="传统编译流程"></p>
<h4 id="编译器前端"><a href="#编译器前端" class="headerlink" title="编译器前端"></a>编译器前端</h4><p><code>编译器前端</code>主要做词法分析，语法分析，语义分析，检查源代码是否存在错误，构建<code>抽象语法树</code>(Abstract Syntax Tree,AST),最后前端会生成<code>中间代码</code>（intermediate representation，IR）。</p>
<h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><p><code>优化器</code>主要负责中间代码的优化。改善代码运行时间，例如消除冗余的计算。</p>
<h4 id="编译器后端"><a href="#编译器后端" class="headerlink" title="编译器后端"></a>编译器后端</h4><p><code>编译器后端</code>主要是将中间代码转换成<code>机器码</code>（二进制），并且进行机器相关的代码优化。</p>
<h4 id="llvm架构编译器的设计"><a href="#llvm架构编译器的设计" class="headerlink" title="llvm架构编译器的设计"></a>llvm架构编译器的设计</h4><p>Objective C/C/C++使用的编译器前端是<code>Clang</code>,Swift的前端是<code>Swift</code>,后端是<code>LLVM</code>。示例图如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b583814a79a54188a81e97d02193ad01~tplv-k3u1fbpfcp-watermark.image?" alt="LLVM编译器"></p>
<h3 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h3><p>我们使用main.m文件进行测试查看各阶段编译的结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CUSTOM_HEIGHT 3</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">testAdd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b+CUSTOM_HEIGHT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> testAdd(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过命令我们可以打印源码的编译阶段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -ccc-<span class="built_in">print</span>-phases main.m</span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">0</span>: <span class="string">input, "main.m", objective-c</span></span><br><span class="line"><span class="attr">1</span>: <span class="string">preprocessor, &#123;0&#125;, objective-c-cpp-output </span></span><br><span class="line"><span class="attr">2</span>: <span class="string">compiler, &#123;1&#125;, ir</span></span><br><span class="line"><span class="attr">3</span>: <span class="string">backend, &#123;2&#125;, assembler</span></span><br><span class="line"><span class="attr">4</span>: <span class="string">assembler, &#123;3&#125;, object</span></span><br><span class="line"><span class="attr">5</span>: <span class="string">linker, &#123;4&#125;, image</span></span><br><span class="line"><span class="attr">6</span>: <span class="string">bind-arch, "arm64", &#123;5&#125;, image</span></span><br></pre></td></tr></table></figure>

<p>其中含义为：</p>
<p>0：输入文件：找到源文件。</p>
<p>1：预处理阶段：处理包括宏的替换，头文件的导入。</p>
<p>2：编译阶段：进行词法分析、语法分析、检查语法是否正确，最终生成IR.</p>
<p>3：后端：LLVM会通过一个一个的Pass去优化，每个Pass做一些事情，最终生成汇编代码。</p>
<p>4：生成目标文件。</p>
<p>5：链接：链接需要的动态库和静态库，生成可执行文件。</p>
<p>6：通过不同的架构，生成对应的可执行文件。</p>
<h4 id="预处理阶段"><a href="#预处理阶段" class="headerlink" title="预处理阶段"></a>预处理阶段</h4><p>执行下面命令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -E main.m</span><br></pre></td></tr></table></figure>

<p>执行完成后会看到头文件的导入和宏的替换。</p>
<h4 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h4><h5 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h5><p>预处理完成后会进行词法分析。代码会被切成一个个Token，比如大小括号、等于号、字符串等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -fmodules -fsyntax-only -Xclang -dump-tokens main.m</span><br></pre></td></tr></table></figure>

<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc5f8b52042f4568aff42dd0772cbc7d~tplv-k3u1fbpfcp-watermark.image?" alt="截屏2021-10-03 15.39.32"></p>
<h5 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h5><p>词法分析后就是语法分析，它的任务是验证语法是否正确。再次发分析的基础上将单词序列组合成各类语法短语，如”程序”，”语句”，”表达式”等，然后将所有节点组成<code>抽象语法树</code>(AST)，语法分析阶段程序判断源程序在结构上是否正确。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35d1e508411d47448c08b787a1560860~tplv-k3u1fbpfcp-watermark.image?" alt="截屏2021-10-03 15.42.36"></p>
<h4 id="生成中间代码IR-intermediate-representation"><a href="#生成中间代码IR-intermediate-representation" class="headerlink" title="生成中间代码IR(intermediate representation)"></a>生成中间代码IR(intermediate representation)</h4><p>完成上面的步骤后就开始生成中间代码IR了，代码生成器(Code Gemeration)会将语法树自定向下便利逐步翻译成LLVM IR。通过下面命令，查看IR代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -S -fobjc-arc -emit-llvm main.m</span><br></pre></td></tr></table></figure>

<p>Objective C代码这一步会进行runtime的桥接，property合成，ARC处理等。</p>
<p>这一步会生成<code>main.ll</code>文件，内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID = 'main.m'</span><br><span class="line">source_filename = <span class="string">"main.m"</span></span><br><span class="line">target datalayout = <span class="string">"e-m:o-i64:64-i128:128-n32:64-S128"</span></span><br><span class="line">target triple = <span class="string">"arm64-apple-macosx11.0.0"</span></span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind optnone ssp uwtable</span><br><span class="line">define i32 @testAdd(i32 %<span class="number">0</span>, i32 %<span class="number">1</span>) #<span class="number">0</span> &#123;</span><br><span class="line">  %<span class="number">3</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  %<span class="number">4</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  store i32 %<span class="number">0</span>, i32* %<span class="number">3</span>, align <span class="number">4</span></span><br><span class="line">  store i32 %<span class="number">1</span>, i32* %<span class="number">4</span>, align <span class="number">4</span></span><br><span class="line">  %<span class="number">5</span> = load i32, i32* %<span class="number">3</span>, align <span class="number">4</span></span><br><span class="line">  %<span class="number">6</span> = load i32, i32* %<span class="number">4</span>, align <span class="number">4</span></span><br><span class="line">  %<span class="number">7</span> = add nsw i32 %<span class="number">5</span>, %<span class="number">6</span></span><br><span class="line">  %<span class="number">8</span> = add nsw i32 %<span class="number">7</span>, <span class="number">3</span></span><br><span class="line">  ret i32 %<span class="number">8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind optnone ssp uwtable</span><br><span class="line">define i32 @main(i32 %<span class="number">0</span>, i8** %<span class="number">1</span>) #<span class="number">0</span> &#123;</span><br><span class="line">  %<span class="number">3</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  %<span class="number">4</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  %<span class="number">5</span> = alloca i8**, align <span class="number">8</span></span><br><span class="line">  store i32 <span class="number">0</span>, i32* %<span class="number">3</span>, align <span class="number">4</span></span><br><span class="line">  store i32 %<span class="number">0</span>, i32* %<span class="number">4</span>, align <span class="number">4</span></span><br><span class="line">  store i8** %<span class="number">1</span>, i8*** %<span class="number">5</span>, align <span class="number">8</span></span><br><span class="line">  %<span class="number">6</span> = call i32 @testAdd(i32 <span class="number">1</span>, i32 <span class="number">2</span>)</span><br><span class="line">  ret i32 %<span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line">attributes #<span class="number">0</span> = &#123; noinline nounwind optnone ssp uwtable <span class="string">"disable-tail-calls"</span>=<span class="string">"false"</span> <span class="string">"frame-pointer"</span>=<span class="string">"non-leaf"</span> <span class="string">"less-precise-fpmad"</span>=<span class="string">"false"</span> <span class="string">"min-legal-vector-width"</span>=<span class="string">"0"</span> <span class="string">"no-infs-fp-math"</span>=<span class="string">"false"</span> <span class="string">"no-jump-tables"</span>=<span class="string">"false"</span> <span class="string">"no-nans-fp-math"</span>=<span class="string">"false"</span> <span class="string">"no-signed-zeros-fp-math"</span>=<span class="string">"false"</span> <span class="string">"no-trapping-math"</span>=<span class="string">"true"</span> <span class="string">"probe-stack"</span>=<span class="string">"__chkstk_darwin"</span> <span class="string">"stack-protector-buffer-size"</span>=<span class="string">"8"</span> <span class="string">"target-cpu"</span>=<span class="string">"apple-m1"</span> <span class="string">"target-features"</span>=<span class="string">"+aes,+crc,+crypto,+dotprod,+fp-armv8,+fp16fml,+fullfp16,+lse,+neon,+ras,+rcpc,+rdm,+sha2,+sha3,+sm4,+v8.5a,+zcm,+zcz"</span> <span class="string">"unsafe-fp-math"</span>=<span class="string">"false"</span> <span class="string">"use-soft-float"</span>=<span class="string">"false"</span> &#125;</span><br><span class="line"></span><br><span class="line">!llvm.<span class="keyword">module</span>.flags = !&#123;!<span class="number">0</span>, !<span class="number">1</span>, !<span class="number">2</span>, !<span class="number">3</span>, !<span class="number">4</span>, !<span class="number">5</span>, !<span class="number">6</span>, !<span class="number">7</span>, !<span class="number">8</span>, !<span class="number">9</span>, !<span class="number">10</span>, !<span class="number">11</span>&#125;</span><br><span class="line">!llvm.ident = !&#123;!<span class="number">12</span>&#125;</span><br><span class="line"></span><br><span class="line">!<span class="number">0</span> = !&#123;i32 <span class="number">2</span>, !<span class="string">"SDK Version"</span>, [<span class="number">2</span> x i32] [i32 <span class="number">11</span>, i32 <span class="number">3</span>]&#125;</span><br><span class="line">!<span class="number">1</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">"Objective-C Version"</span>, i32 <span class="number">2</span>&#125;</span><br><span class="line">!<span class="number">2</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">"Objective-C Image Info Version"</span>, i32 <span class="number">0</span>&#125;</span><br><span class="line">!<span class="number">3</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">"Objective-C Image Info Section"</span>, !<span class="string">"__DATA,__objc_imageinfo,regular,no_dead_strip"</span>&#125;</span><br><span class="line">!<span class="number">4</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">"Objective-C Garbage Collection"</span>, i8 <span class="number">0</span>&#125;</span><br><span class="line">!<span class="number">5</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">"Objective-C Class Properties"</span>, i32 <span class="number">64</span>&#125;</span><br><span class="line">!<span class="number">6</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">"wchar_size"</span>, i32 <span class="number">4</span>&#125;</span><br><span class="line">!<span class="number">7</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">"branch-target-enforcement"</span>, i32 <span class="number">0</span>&#125;</span><br><span class="line">!<span class="number">8</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">"sign-return-address"</span>, i32 <span class="number">0</span>&#125;</span><br><span class="line">!<span class="number">9</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">"sign-return-address-all"</span>, i32 <span class="number">0</span>&#125;</span><br><span class="line">!<span class="number">10</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">"sign-return-address-with-bkey"</span>, i32 <span class="number">0</span>&#125;</span><br><span class="line">!<span class="number">11</span> = !&#123;i32 <span class="number">7</span>, !<span class="string">"PIC Level"</span>, i32 <span class="number">2</span>&#125;</span><br><span class="line">!<span class="number">12</span> = !&#123;!<span class="string">"Apple clang version 13.0.0 (clang-1300.0.29.3)"</span>&#125;</span><br></pre></td></tr></table></figure>

<p>IR的基本语法</p>
<blockquote>
<p>@全局标识</p>
<p>%局部标识</p>
<p>alloca开辟空间</p>
<p>align内存对齐</p>
<p>i32 32bit，4字节</p>
<p>store 写入内存</p>
<p>load 读取数据</p>
<p>call 调用函数</p>
<p>ret 返回</p>
</blockquote>
<p>IR的优化</p>
<p>LLVM的优化分别是-O0 -O1 -O2 -O3 -Os</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -Os -S -fobjc-arc -emit-llvm main.m -o main.ll</span><br></pre></td></tr></table></figure>

<p>可以看到优化后的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID = 'main.m'</span><br><span class="line">source_filename = <span class="string">"main.m"</span></span><br><span class="line">target datalayout = <span class="string">"e-m:o-i64:64-i128:128-n32:64-S128"</span></span><br><span class="line">target triple = <span class="string">"arm64-apple-macosx11.0.0"</span></span><br><span class="line"></span><br><span class="line">; Function Attrs: norecurse nounwind optsize readnone ssp uwtable willreturn</span><br><span class="line">define i32 @testAdd(i32 %<span class="number">0</span>, i32 %<span class="number">1</span>) local_unnamed_addr #<span class="number">0</span> &#123;</span><br><span class="line">  %<span class="number">3</span> = add i32 %<span class="number">0</span>, <span class="number">3</span></span><br><span class="line">  %<span class="number">4</span> = add i32 %<span class="number">3</span>, %<span class="number">1</span></span><br><span class="line">  ret i32 %<span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; Function Attrs: norecurse nounwind optsize readnone ssp uwtable willreturn</span><br><span class="line">define i32 @main(i32 %<span class="number">0</span>, i8** nocapture readnone %<span class="number">1</span>) local_unnamed_addr #<span class="number">0</span> &#123;</span><br><span class="line">  ret i32 <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">attributes #<span class="number">0</span> = &#123; norecurse nounwind optsize readnone ssp uwtable willreturn <span class="string">"disable-tail-calls"</span>=<span class="string">"false"</span> <span class="string">"frame-pointer"</span>=<span class="string">"non-leaf"</span> <span class="string">"less-precise-fpmad"</span>=<span class="string">"false"</span> <span class="string">"min-legal-vector-width"</span>=<span class="string">"0"</span> <span class="string">"no-infs-fp-math"</span>=<span class="string">"false"</span> <span class="string">"no-jump-tables"</span>=<span class="string">"false"</span> <span class="string">"no-nans-fp-math"</span>=<span class="string">"false"</span> <span class="string">"no-signed-zeros-fp-math"</span>=<span class="string">"false"</span> <span class="string">"no-trapping-math"</span>=<span class="string">"true"</span> <span class="string">"probe-stack"</span>=<span class="string">"__chkstk_darwin"</span> <span class="string">"stack-protector-buffer-size"</span>=<span class="string">"8"</span> <span class="string">"target-cpu"</span>=<span class="string">"apple-m1"</span> <span class="string">"target-features"</span>=<span class="string">"+aes,+crc,+crypto,+dotprod,+fp-armv8,+fp16fml,+fullfp16,+lse,+neon,+ras,+rcpc,+rdm,+sha2,+sha3,+sm4,+v8.5a,+zcm,+zcz"</span> <span class="string">"unsafe-fp-math"</span>=<span class="string">"false"</span> <span class="string">"use-soft-float"</span>=<span class="string">"false"</span> &#125;</span><br><span class="line"></span><br><span class="line">!llvm.<span class="keyword">module</span>.flags = !&#123;!<span class="number">0</span>, !<span class="number">1</span>, !<span class="number">2</span>, !<span class="number">3</span>, !<span class="number">4</span>, !<span class="number">5</span>, !<span class="number">6</span>, !<span class="number">7</span>, !<span class="number">8</span>, !<span class="number">9</span>, !<span class="number">10</span>, !<span class="number">11</span>&#125;</span><br><span class="line">!llvm.ident = !&#123;!<span class="number">12</span>&#125;</span><br><span class="line"></span><br><span class="line">!<span class="number">0</span> = !&#123;i32 <span class="number">2</span>, !<span class="string">"SDK Version"</span>, [<span class="number">2</span> x i32] [i32 <span class="number">11</span>, i32 <span class="number">3</span>]&#125;</span><br><span class="line">!<span class="number">1</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">"Objective-C Version"</span>, i32 <span class="number">2</span>&#125;</span><br><span class="line">!<span class="number">2</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">"Objective-C Image Info Version"</span>, i32 <span class="number">0</span>&#125;</span><br><span class="line">!<span class="number">3</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">"Objective-C Image Info Section"</span>, !<span class="string">"__DATA,__objc_imageinfo,regular,no_dead_strip"</span>&#125;</span><br><span class="line">!<span class="number">4</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">"Objective-C Garbage Collection"</span>, i8 <span class="number">0</span>&#125;</span><br><span class="line">!<span class="number">5</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">"Objective-C Class Properties"</span>, i32 <span class="number">64</span>&#125;</span><br><span class="line">!<span class="number">6</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">"wchar_size"</span>, i32 <span class="number">4</span>&#125;</span><br><span class="line">!<span class="number">7</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">"branch-target-enforcement"</span>, i32 <span class="number">0</span>&#125;</span><br><span class="line">!<span class="number">8</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">"sign-return-address"</span>, i32 <span class="number">0</span>&#125;</span><br><span class="line">!<span class="number">9</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">"sign-return-address-all"</span>, i32 <span class="number">0</span>&#125;</span><br><span class="line">!<span class="number">10</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">"sign-return-address-with-bkey"</span>, i32 <span class="number">0</span>&#125;</span><br><span class="line">!<span class="number">11</span> = !&#123;i32 <span class="number">7</span>, !<span class="string">"PIC Level"</span>, i32 <span class="number">2</span>&#125;</span><br><span class="line">!<span class="number">12</span> = !&#123;!<span class="string">"Apple clang version 13.0.0 (clang-1300.0.29.3)"</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="bitCode（非必须）"><a href="#bitCode（非必须）" class="headerlink" title="bitCode（非必须）"></a>bitCode（非必须）</h4><p>生成.bc的中间代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -emit-llvm -c main.ll -o main.bc</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line">dec0 <span class="number">170b</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1400</span> <span class="number">0000</span> <span class="number">0</span>c0b <span class="number">0000</span></span><br><span class="line">ffff ffff <span class="number">4243</span> c0de <span class="number">3514</span> <span class="number">0000</span> <span class="number">0700</span> <span class="number">0000</span></span><br><span class="line"><span class="number">620</span>c <span class="number">3024</span> <span class="number">9596</span> a6a5 f7d7 <span class="number">7f</span>7d d3b4 <span class="number">4f</span>fb</span><br><span class="line"><span class="number">76</span>ef df3f <span class="number">2</span>d44 <span class="number">0132</span> <span class="number">0500</span> <span class="number">0000</span> <span class="number">210</span>c <span class="number">0000</span></span><br><span class="line"><span class="number">7</span>c02 <span class="number">0000</span> <span class="number">0b0</span>2 <span class="number">2100</span> <span class="number">0200</span> <span class="number">0000</span> <span class="number">1600</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0781</span> <span class="number">2391</span> <span class="number">41</span>c8 <span class="number">0449</span> <span class="number">0610</span> <span class="number">3239</span> <span class="number">9201</span> <span class="number">840</span>c</span><br><span class="line"><span class="number">2505</span> <span class="number">0819</span> <span class="number">1e04</span> <span class="number">8b</span>62 <span class="number">8010</span> <span class="number">4502</span> <span class="number">4292</span> <span class="number">0b</span>42</span><br><span class="line"><span class="number">8410</span> <span class="number">3214</span> <span class="number">3808</span> <span class="number">184b</span> <span class="number">0</span>a32 <span class="number">4288</span> <span class="number">4870</span> c421</span><br><span class="line"><span class="number">2344</span> <span class="number">1287</span> <span class="number">8</span>c10 <span class="number">4192</span> <span class="number">0264</span> c808 b114 <span class="number">2043</span></span><br><span class="line"><span class="number">4688</span> <span class="number">20</span>c9 <span class="number">0132</span> <span class="number">4284</span> <span class="number">182</span>a <span class="number">282</span>a <span class="number">9031</span> <span class="number">7</span>cb0</span><br><span class="line"><span class="number">5</span>c91 <span class="number">20</span>c4 c800 <span class="number">0000</span> <span class="number">8920</span> <span class="number">0000</span> <span class="number">0e00</span> <span class="number">0000</span></span><br><span class="line"><span class="number">3222</span> <span class="number">0809</span> <span class="number">2064</span> <span class="number">8504</span> <span class="number">1322</span> a484 <span class="number">0413</span> <span class="number">22e3</span></span><br><span class="line"><span class="number">84</span>a1 <span class="number">9014</span> <span class="number">124</span>c <span class="number">888</span>c <span class="number">0b</span>84 <span class="number">844</span>c <span class="number">1034</span> <span class="number">7304</span></span><br><span class="line"><span class="number">6050</span> <span class="number">0600</span> a098 <span class="number">2340</span> <span class="number">6888</span> ca00 <span class="number">5064</span> <span class="number">0301</span></span><br><span class="line"><span class="number">2900</span> <span class="number">0423</span> <span class="number">0054</span> <span class="number">0000</span> <span class="number">5118</span> <span class="number">0000</span> b200 <span class="number">0000</span></span><br><span class="line"><span class="number">1b</span>de <span class="number">27f</span>8 ffff ffff <span class="number">0170</span> <span class="number">0009</span> <span class="number">2803</span> <span class="number">4003</span></span><br><span class="line">c280 <span class="number">2087</span> <span class="number">7498</span> <span class="number">8770</span> <span class="number">1007</span> <span class="number">7628</span> <span class="number">8736</span> a087</span><br><span class="line"><span class="number">7048</span> <span class="number">0776</span> <span class="number">6883</span> <span class="number">7108</span> <span class="number">0776</span> <span class="number">6087</span> <span class="number">7900</span> cc21</span><br><span class="line"><span class="number">1</span>cd8 <span class="number">611</span>e ca01 <span class="number">20</span>cc <span class="number">411</span>e c2a1 <span class="number">1</span>dca a10d</span><br><span class="line">e0e1 <span class="number">1</span>dd2 c11d e8a1 <span class="number">1</span>ce4 <span class="number">0170</span> <span class="number">8777</span> <span class="number">7087</span></span><br><span class="line"><span class="number">3660</span> <span class="number">8772</span> <span class="number">0807</span> <span class="number">7300</span> <span class="number">0876</span> <span class="number">2887</span> <span class="number">7998</span> <span class="number">8736</span></span><br><span class="line"><span class="number">8007</span> <span class="number">7928</span> <span class="number">8771</span> <span class="number">4887</span> <span class="number">7928</span> <span class="number">8736</span> <span class="number">3007</span> <span class="number">7868</span></span><br><span class="line"><span class="number">8770</span> <span class="number">2007</span> c01c c281 <span class="number">1</span>de6 a11c <span class="number">00</span>a2 <span class="number">1</span>dd2</span><br><span class="line">c11d da80 <span class="number">1</span>dca e11c c281 <span class="number">1</span>dda c01e ca61</span><br><span class="line"><span class="number">1</span>ce8 e11d e4a1 <span class="number">0</span>dee <span class="number">211</span>d c881 <span class="number">1</span>ed0 <span class="number">0180</span></span><br><span class="line"><span class="number">0380</span> <span class="number">7087</span> <span class="number">7768</span> <span class="number">8374</span> <span class="number">7007</span> <span class="number">7398</span> <span class="number">8736</span> <span class="number">3007</span></span><br><span class="line"><span class="number">7868</span> <span class="number">8376</span> <span class="number">0807</span> <span class="number">7</span>a40 <span class="number">07</span>c0 <span class="number">1</span>cc2 <span class="number">811</span>d e6a1</span><br><span class="line"><span class="number">1</span>c00 c21d dea1 <span class="number">0</span>dd4 a11e da01 <span class="number">1</span>eda <span class="number">801</span>e</span><br><span class="line">c241 <span class="number">1</span>cd8 a11c e601 <span class="number">3087</span> <span class="number">7060</span> <span class="number">8779</span> <span class="number">2807</span></span><br><span class="line"><span class="number">8070</span> <span class="number">8777</span> <span class="number">6803</span> <span class="number">7708</span> <span class="number">0777</span> <span class="number">9887</span> <span class="number">3630</span> <span class="number">0778</span></span><br><span class="line"><span class="number">6883</span> <span class="number">7608</span> <span class="number">077</span>a <span class="number">4007</span> c01c c281 <span class="number">1</span>de6 a11c</span><br><span class="line"><span class="number">00</span>c2 <span class="number">1</span>dde a10d e621 <span class="number">1</span>dce c11d ca81 <span class="number">1</span>cda</span><br><span class="line"><span class="number">401f</span> ca41 <span class="number">1</span>ede <span class="number">611</span>e dac0 <span class="number">1</span>ce0 a10d da21</span><br><span class="line"><span class="number">1</span>ce8 <span class="number">011</span>d <span class="number">0073</span> <span class="number">0807</span> <span class="number">7698</span> <span class="number">8772</span> <span class="number">0008</span> <span class="number">7778</span></span><br><span class="line"><span class="number">8736</span> a007 <span class="number">7908</span> <span class="number">0778</span> <span class="number">8087</span> <span class="number">7470</span> <span class="number">8773</span> <span class="number">6883</span></span><br><span class="line"><span class="number">7608</span> <span class="number">077</span>a <span class="number">4007</span> <span class="number">801</span>e e4a1 <span class="number">1</span>eca <span class="number">0120</span> e041</span><br><span class="line"><span class="number">1</span>ede <span class="number">411</span>c caa1 <span class="number">0</span>de6 <span class="number">811</span>e c261 <span class="number">1</span>cd6 <span class="number">01f</span>8</span><br><span class="line"><span class="number">855f</span> <span class="number">1807</span> <span class="number">7458</span> <span class="number">8779</span> a087 <span class="number">75f</span>8 <span class="number">0572</span> <span class="number">0807</span></span><br><span class="line"><span class="number">79b</span>8 <span class="number">8774</span> <span class="number">7007</span> <span class="number">8098</span> <span class="number">077</span>a <span class="number">0887</span> <span class="number">7158</span> <span class="number">8736</span></span><br><span class="line"><span class="number">8007</span> <span class="number">7978</span> <span class="number">077</span>a <span class="number">2887</span> <span class="number">71</span>a0 <span class="number">8777</span> <span class="number">9087</span> <span class="number">3610</span></span><br><span class="line"><span class="number">877</span>a <span class="number">3007</span> <span class="number">7328</span> <span class="number">0779</span> <span class="number">6883</span> <span class="number">7948</span> <span class="number">077</span>d <span class="number">2807</span></span><br><span class="line"><span class="number">000f</span> <span class="number">0082</span> <span class="number">1</span>ec2 <span class="number">411</span>e cea1 <span class="number">1</span>ce8 a10d c601</span><br><span class="line"><span class="number">1</span>eea <span class="number">0108</span> <span class="number">0778</span> <span class="number">8007</span> <span class="number">7628</span> <span class="number">8736</span> <span class="number">6887</span> <span class="number">3800</span></span><br><span class="line"><span class="number">087</span>a <span class="number">0807</span> <span class="number">7938</span> <span class="number">8772</span> a087 <span class="number">3630</span> <span class="number">8772</span> <span class="number">0807</span></span><br><span class="line"><span class="number">7</span>aa8 <span class="number">0779</span> <span class="number">2887</span> <span class="number">7900</span> d620 <span class="number">1</span>cca <span class="number">611</span>e d860</span><br><span class="line"><span class="number">0</span>dc6 <span class="number">411</span>e c681 <span class="number">0</span>dd6 <span class="number">601</span>c e421 <span class="number">1f</span>e0 <span class="number">811</span>e</span><br><span class="line">de81 <span class="number">0</span>dd6 <span class="number">801</span>c de81 <span class="number">1</span>ee0 <span class="number">411</span>e de81 <span class="number">1</span>cd8</span><br><span class="line"><span class="number">600</span>d cc01 <span class="number">1</span>eda <span class="number">201</span>c e4a1 <span class="number">1</span>dec <span class="number">010f</span> d860</span><br><span class="line"><span class="number">0</span>dcc <span class="number">011</span>e e2c0 <span class="number">0</span>ecc a11d d881 <span class="number">0</span>dd6 c01c</span><br><span class="line">ea81 <span class="number">1</span>dd8 c11c e021 <span class="number">0</span>eec <span class="number">800</span>d d680 <span class="number">1</span>de6</span><br><span class="line">a11c d860 <span class="number">0</span>ddc a11c dec1 <span class="number">1</span>dd8 <span class="number">600</span>d e421</span><br><span class="line"><span class="number">1</span>ce6 <span class="number">810</span>d d640 <span class="number">1</span>ec6 <span class="number">011</span>e c681 <span class="number">0</span>dd6 <span class="number">401</span>e</span><br><span class="line">c8a1 <span class="number">1</span>dd8 <span class="number">600</span>d e601 <span class="number">1</span>dc2 <span class="number">410</span>e d860 <span class="number">0</span>de6</span><br><span class="line"><span class="number">011</span>d c261 <span class="number">0</span>ed8 <span class="number">600</span>d e6a1 <span class="number">1</span>de8 <span class="number">800</span>d d6c0</span><br><span class="line"><span class="number">1</span>ef0 c00d ea20 <span class="number">1</span>cd8 <span class="number">600</span>d f461 <span class="number">1</span>cda <span class="number">810</span>d</span><br><span class="line">d640 <span class="number">1f</span>c6 <span class="number">411f</span> <span class="number">00</span>a2 <span class="number">1</span>edc <span class="number">611</span>e c2c1 <span class="number">1</span>cca</span><br><span class="line">a10d cc01 <span class="number">1</span>eda a01d c281 <span class="number">1</span>ed0 <span class="number">0130</span> <span class="number">8770</span></span><br><span class="line"><span class="number">6087</span> <span class="number">7928</span> <span class="number">0780</span> a887 <span class="number">7928</span> <span class="number">8736</span> <span class="number">9887</span> <span class="number">7730</span></span><br><span class="line"><span class="number">077</span>a <span class="number">6803</span> <span class="number">7360</span> <span class="number">8777</span> <span class="number">0807</span> <span class="number">7</span>a00 cc21 <span class="number">1</span>cd8</span><br><span class="line"><span class="number">611</span>e ca01 <span class="number">0000</span> <span class="number">0000</span> <span class="number">4918</span> <span class="number">0000</span> <span class="number">0100</span> <span class="number">0000</span></span><br><span class="line"><span class="number">1382</span> <span class="number">0000</span> <span class="number">13b</span>0 <span class="number">7090</span> <span class="number">8776</span> b003 <span class="number">3</span>a68 <span class="number">8370</span></span><br><span class="line"><span class="number">8007</span> <span class="number">7860</span> <span class="number">8772</span> <span class="number">6883</span> <span class="number">7608</span> <span class="number">8771</span> <span class="number">7887</span> <span class="number">79</span>c0</span><br><span class="line"><span class="number">8738</span> <span class="number">8803</span> <span class="number">3780</span> <span class="number">0337</span> <span class="number">8083</span> <span class="number">0</span>d61 <span class="number">500</span>e <span class="number">6</span>dd0</span><br><span class="line"><span class="number">0e7</span>a f00e <span class="number">6</span>d90 <span class="number">0e76</span> <span class="number">4007</span> <span class="number">7</span>a60 <span class="number">0774</span> d006</span><br><span class="line">e910 <span class="number">0772</span> <span class="number">8007</span> <span class="number">7</span>a10 <span class="number">0772</span> <span class="number">8007</span> <span class="number">6</span>de0 <span class="number">0e73</span></span><br><span class="line"><span class="number">2007</span> <span class="number">7</span>a60 <span class="number">0774</span> d006 b310 <span class="number">0772</span> <span class="number">8007</span> <span class="number">1</span>a21</span><br><span class="line"><span class="number">0</span>c69 <span class="number">3000</span> d2f8 cc90 <span class="number">0</span>a38 <span class="number">0200</span> <span class="number">0002</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">8003</span> <span class="number">1852</span> <span class="number">1</span>d84 <span class="number">0100</span> <span class="number">4000</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">7000</span> <span class="number">121b</span> <span class="number">048</span>a <span class="number">0</span>a0a</span><br><span class="line"><span class="number">0000</span> <span class="number">6481</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0</span>a00 <span class="number">0000</span> <span class="number">321</span>e <span class="number">9810</span></span><br><span class="line"><span class="number">1911</span> <span class="number">4</span>c90 <span class="number">8</span>c09 <span class="number">2647</span> c604 <span class="number">4382</span> <span class="number">22</span>a0 <span class="number">1</span>c4b</span><br><span class="line"><span class="number">5806</span> <span class="number">8212</span> <span class="number">1801</span> a019 <span class="number">0120</span> <span class="number">28</span>c0 <span class="number">8042</span> <span class="number">2807</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> b118 <span class="number">0000</span> <span class="number">9700</span> <span class="number">0000</span> <span class="number">3308</span> <span class="number">801</span>c</span><br><span class="line">c4e1 <span class="number">1</span>c66 <span class="number">1401</span> <span class="number">3</span>d88 <span class="number">4338</span> <span class="number">84</span>c3 <span class="number">8</span>c42 <span class="number">8007</span></span><br><span class="line"><span class="number">7978</span> <span class="number">0773</span> <span class="number">9871</span> <span class="number">0</span>ce6 <span class="number">000f</span> ed10 <span class="number">0</span>ef4 <span class="number">800</span>e</span><br><span class="line"><span class="number">330</span>c <span class="number">421</span>e c2c1 <span class="number">1</span>dce a11c <span class="number">6630</span> <span class="number">053</span>d <span class="number">8843</span></span><br><span class="line"><span class="number">3884</span> <span class="number">831b</span> cc03 <span class="number">3</span>dc8 <span class="number">433</span>d <span class="number">8</span>c03 <span class="number">3</span>dcc <span class="number">788</span>c</span><br><span class="line"><span class="number">7470</span> <span class="number">077b</span> <span class="number">0807</span> <span class="number">7948</span> <span class="number">8770</span> <span class="number">7007</span> <span class="number">7</span>a70 <span class="number">0376</span></span><br><span class="line"><span class="number">7887</span> <span class="number">7020</span> <span class="number">8719</span> cc11 <span class="number">0</span>eec <span class="number">900</span>e e130 <span class="number">0f</span>6e</span><br><span class="line"><span class="number">300f</span> e3f0 <span class="number">0</span>ef0 <span class="number">500</span>e <span class="number">3310</span> c41d de21 <span class="number">1</span>cd8</span><br><span class="line"><span class="number">211</span>d c261 <span class="number">1e66</span> <span class="number">3089</span> <span class="number">3b</span>bc <span class="number">833b</span> d043 <span class="number">39b</span>4</span><br><span class="line"><span class="number">033</span>c bc83 <span class="number">3</span>c84 <span class="number">033b</span> ccf0 <span class="number">1476</span> <span class="number">6007</span> <span class="number">7b</span>68</span><br><span class="line"><span class="number">0737</span> <span class="number">6887</span> <span class="number">7268</span> <span class="number">0737</span> <span class="number">8087</span> <span class="number">7090</span> <span class="number">8770</span> <span class="number">6007</span></span><br><span class="line"><span class="number">7628</span> <span class="number">0776</span> f805 <span class="number">7678</span> <span class="number">8777</span> <span class="number">8087</span> <span class="number">5f</span>08 <span class="number">8771</span></span><br><span class="line"><span class="number">1887</span> <span class="number">7298</span> <span class="number">8779</span> <span class="number">9881</span> <span class="number">2</span>cee f00e eee0 <span class="number">0</span>ef5</span><br><span class="line">c00e ec30 <span class="number">0362</span> c8a1 <span class="number">1</span>ce4 a11c cca1 <span class="number">1</span>ce4</span><br><span class="line">a11c dc61 <span class="number">1</span>cca <span class="number">211</span>c c481 <span class="number">1</span>dca <span class="number">6106</span> d690</span><br><span class="line"><span class="number">4339</span> c843 <span class="number">3998</span> <span class="number">4339</span> c843 <span class="number">39b</span>8 c338 <span class="number">9443</span></span><br><span class="line"><span class="number">3888</span> <span class="number">033b</span> <span class="number">94</span>c3 <span class="number">2f</span>bc <span class="number">833</span>c fc82 <span class="number">3b</span>d4 <span class="number">033b</span></span><br><span class="line">b0c3 <span class="number">0</span>cc7 <span class="number">6987</span> <span class="number">7058</span> <span class="number">8772</span> <span class="number">7083</span> <span class="number">7468</span> <span class="number">0778</span></span><br><span class="line"><span class="number">6087</span> <span class="number">7418</span> <span class="number">8774</span> a087 <span class="number">19</span>ce <span class="number">530f</span> ee00 <span class="number">0f</span>f2</span><br><span class="line"><span class="number">500</span>e e490 <span class="number">0</span>ee3 <span class="number">400f</span> e120 <span class="number">0</span>eec <span class="number">500</span>e <span class="number">3320</span></span><br><span class="line"><span class="number">281</span>d dcc1 <span class="number">1</span>ec2 <span class="number">411</span>e d221 <span class="number">1</span>cdc <span class="number">811</span>e dce0</span><br><span class="line"><span class="number">1</span>ce4 e11d ea01 <span class="number">1e66</span> <span class="number">1851</span> <span class="number">38b</span>0 <span class="number">433</span>a <span class="number">9</span>c83</span><br><span class="line"><span class="number">3b</span>cc <span class="number">5024</span> <span class="number">7660</span> <span class="number">077b</span> <span class="number">6807</span> <span class="number">3760</span> <span class="number">8777</span> <span class="number">7807</span></span><br><span class="line"><span class="number">7898</span> <span class="number">514</span>c f490 <span class="number">0f</span>f0 <span class="number">500</span>e <span class="number">331</span>e <span class="number">6</span>a1e ca61</span><br><span class="line"><span class="number">1</span>ce8 <span class="number">211</span>d dec1 <span class="number">1</span>d7e <span class="number">011</span>e e4a1 <span class="number">1</span>ccc <span class="number">211</span>d</span><br><span class="line">f061 <span class="number">0654</span> <span class="number">8583</span> <span class="number">38</span>cc c33b b043 <span class="number">3</span>dd0 <span class="number">4339</span></span><br><span class="line">fcc2 <span class="number">3</span>ce4 <span class="number">433b</span> <span class="number">88</span>c3 <span class="number">3b</span>b0 c38c c50a <span class="number">8779</span></span><br><span class="line"><span class="number">9887</span> <span class="number">7718</span> <span class="number">8774</span> <span class="number">0807</span> <span class="number">7</span>a28 <span class="number">0772</span> <span class="number">9881</span> <span class="number">5</span>ce3</span><br><span class="line"><span class="number">100</span>e ecc0 <span class="number">0</span>ee5 <span class="number">500</span>e f330 <span class="number">23</span>c1 d241 <span class="number">1</span>ee4</span><br><span class="line">e117 d8e1 <span class="number">1</span>dde <span class="number">011</span>e <span class="number">6648</span> <span class="number">193b</span> b083 <span class="number">3</span>db4</span><br><span class="line"><span class="number">831b</span> <span class="number">84</span>c3 <span class="number">388</span>c <span class="number">4339</span> ccc3 <span class="number">3</span>cb8 c139 c8c3</span><br><span class="line"><span class="number">3b</span>d4 <span class="number">033</span>c cc48 b471 <span class="number">0807</span> <span class="number">7660</span> <span class="number">0771</span> <span class="number">0887</span></span><br><span class="line"><span class="number">7158</span> <span class="number">8719</span> dbc6 <span class="number">0</span>eec <span class="number">600f</span> ede0 <span class="number">06f</span>0 <span class="number">200f</span></span><br><span class="line">e530 <span class="number">0f</span>e5 <span class="number">200f</span> f650 <span class="number">0e6</span>e <span class="number">100</span>e e330 <span class="number">0</span>ee5</span><br><span class="line"><span class="number">300f</span> f3e0 <span class="number">06e9</span> e00e e450 <span class="number">0</span>ef8 <span class="number">3023</span> e2ec</span><br><span class="line"><span class="number">611</span>c c281 <span class="number">1</span>dd8 e117 ec21 <span class="number">1</span>de6 <span class="number">211</span>d c421</span><br><span class="line"><span class="number">1</span>dd8 <span class="number">211</span>d e821 <span class="number">1f</span>66 <span class="number">209</span>d <span class="number">3b</span>bc <span class="number">433</span>d b803</span><br><span class="line"><span class="number">3994</span> <span class="number">8339</span> cc58 bc70 <span class="number">7007</span> <span class="number">7778</span> <span class="number">077</span>a <span class="number">0807</span></span><br><span class="line"><span class="number">7</span>a48 <span class="number">8777</span> <span class="number">7007</span> <span class="number">0000</span> <span class="number">7920</span> <span class="number">0000</span> <span class="number">8600</span> <span class="number">0000</span></span><br><span class="line"><span class="number">721</span>e <span class="number">4820</span> <span class="number">4388</span> <span class="number">0</span>c19 <span class="number">0972</span> <span class="number">3248</span> <span class="number">2023</span> <span class="number">818</span>c</span><br><span class="line"><span class="number">9191</span> d144 a010 <span class="number">2864</span> <span class="number">3</span>c31 <span class="number">3242</span> <span class="number">8e90</span> <span class="number">21</span>a3</span><br><span class="line">e830 ee02 cbe4 <span class="number">796</span>d e071 <span class="number">4</span>a36 <span class="number">5</span>d5d e206</span><br><span class="line"><span class="number">5344</span> <span class="number">4b</span>20 <span class="number">5665</span> <span class="number">7273</span> <span class="number">696f</span> <span class="number">6e4</span>f <span class="number">626</span>a <span class="number">6563</span></span><br><span class="line"><span class="number">7469</span> <span class="number">7665</span> <span class="number">2</span>d43 <span class="number">2056</span> <span class="number">6572</span> <span class="number">7369</span> <span class="number">6f</span>6e <span class="number">4f</span>62</span><br><span class="line"><span class="number">6</span>a65 <span class="number">6374</span> <span class="number">6976</span> <span class="number">652</span>d <span class="number">4320</span> <span class="number">496</span>d <span class="number">6167</span> <span class="number">6520</span></span><br><span class="line"><span class="number">496</span>e <span class="number">666f</span> <span class="number">2056</span> <span class="number">6572</span> <span class="number">7369</span> <span class="number">6f</span>6e <span class="number">4f</span>62 <span class="number">6</span>a65</span><br><span class="line"><span class="number">6374</span> <span class="number">6976</span> <span class="number">652</span>d <span class="number">4320</span> <span class="number">496</span>d <span class="number">6167</span> <span class="number">6520</span> <span class="number">496</span>e</span><br><span class="line"><span class="number">666f</span> <span class="number">2053</span> <span class="number">6563</span> <span class="number">7469</span> <span class="number">6f</span>6e <span class="number">5f</span>5f <span class="number">4441</span> <span class="number">5441</span></span><br><span class="line"><span class="number">2</span>c5f <span class="number">5f</span>6f <span class="number">626</span>a <span class="number">635f</span> <span class="number">696</span>d <span class="number">6167</span> <span class="number">6569</span> <span class="number">6e66</span></span><br><span class="line"><span class="number">6f</span>2c <span class="number">7265</span> <span class="number">6775</span> <span class="number">6</span>c61 <span class="number">722</span>c <span class="number">6e6</span>f <span class="number">5f</span>64 <span class="number">6561</span></span><br><span class="line"><span class="number">645f</span> <span class="number">7374</span> <span class="number">7269</span> <span class="number">704f</span> <span class="number">626</span>a <span class="number">6563</span> <span class="number">7469</span> <span class="number">7665</span></span><br><span class="line"><span class="number">2</span>d43 <span class="number">2047</span> <span class="number">6172</span> <span class="number">6261</span> <span class="number">6765</span> <span class="number">2043</span> <span class="number">6f</span>6c <span class="number">6</span>c65</span><br><span class="line"><span class="number">6374</span> <span class="number">696f</span> <span class="number">6e4</span>f <span class="number">626</span>a <span class="number">6563</span> <span class="number">7469</span> <span class="number">7665</span> <span class="number">2</span>d43</span><br><span class="line"><span class="number">2043</span> <span class="number">6</span>c61 <span class="number">7373</span> <span class="number">2050</span> <span class="number">726f</span> <span class="number">7065</span> <span class="number">7274</span> <span class="number">6965</span></span><br><span class="line"><span class="number">7377</span> <span class="number">6368</span> <span class="number">6172</span> <span class="number">5f</span>73 <span class="number">697</span>a <span class="number">6562</span> <span class="number">7261</span> <span class="number">6e63</span></span><br><span class="line"><span class="number">682</span>d <span class="number">7461</span> <span class="number">7267</span> <span class="number">6574</span> <span class="number">2</span>d65 <span class="number">6e66</span> <span class="number">6f</span>72 <span class="number">6365</span></span><br><span class="line"><span class="number">6</span>d65 <span class="number">6e74</span> <span class="number">7369</span> <span class="number">676</span>e <span class="number">2</span>d72 <span class="number">6574</span> <span class="number">7572</span> <span class="number">6e2</span>d</span><br><span class="line"><span class="number">6164</span> <span class="number">6472</span> <span class="number">6573</span> <span class="number">7373</span> <span class="number">6967</span> <span class="number">6e2</span>d <span class="number">7265</span> <span class="number">7475</span></span><br><span class="line"><span class="number">726</span>e <span class="number">2</span>d61 <span class="number">6464</span> <span class="number">7265</span> <span class="number">7373</span> <span class="number">2</span>d61 <span class="number">6</span>c6c <span class="number">7369</span></span><br><span class="line"><span class="number">676</span>e <span class="number">2</span>d72 <span class="number">6574</span> <span class="number">7572</span> <span class="number">6e2</span>d <span class="number">6164</span> <span class="number">6472</span> <span class="number">6573</span></span><br><span class="line"><span class="number">732</span>d <span class="number">7769</span> <span class="number">7468</span> <span class="number">2</span>d62 <span class="number">6b</span>65 <span class="number">7950</span> <span class="number">4943</span> <span class="number">204</span>c</span><br><span class="line"><span class="number">6576</span> <span class="number">656</span>c <span class="number">4170</span> <span class="number">706</span>c <span class="number">6520</span> <span class="number">636</span>c <span class="number">616</span>e <span class="number">6720</span></span><br><span class="line"><span class="number">7665</span> <span class="number">7273</span> <span class="number">696f</span> <span class="number">6e20</span> <span class="number">3133</span> <span class="number">2e30</span> <span class="number">2e30</span> <span class="number">2028</span></span><br><span class="line"><span class="number">636</span>c <span class="number">616</span>e <span class="number">672</span>d <span class="number">3133</span> <span class="number">3030</span> <span class="number">2e30</span> <span class="number">2e32</span> <span class="number">392</span>e</span><br><span class="line"><span class="number">3329</span> <span class="number">0000</span> <span class="number">2308</span> <span class="number">8030</span> <span class="number">8290</span> <span class="number">0</span>c23 <span class="number">0800</span> <span class="number">3182</span></span><br><span class="line"><span class="number">0014</span> <span class="number">2308</span> <span class="number">8331</span> <span class="number">8200</span> <span class="number">1</span>c23 <span class="number">0800</span> <span class="number">3282</span> <span class="number">0024</span></span><br><span class="line"><span class="number">330</span>c <span class="number">4f</span>00 cd30 <span class="number">44</span>c2 <span class="number">33</span>c3 <span class="number">100</span>d d20c <span class="number">4344</span></span><br><span class="line"><span class="number">1433</span> <span class="number">0</span>c91 <span class="number">31</span>cd <span class="number">3044</span> <span class="number">0735</span> c310 <span class="number">21</span>d5 <span class="number">0</span>c43</span><br><span class="line"><span class="number">9448</span> <span class="number">330</span>c <span class="number">9122</span> cd30 <span class="number">448b</span> <span class="number">34</span>c3 <span class="number">1031</span> d20c</span><br><span class="line"><span class="number">83</span>d5 <span class="number">3</span>c33 <span class="number">048</span>e <span class="number">8</span>c04 <span class="number">2628</span> <span class="number">2336</span> <span class="number">36b</span>b <span class="number">3697</span></span><br><span class="line">b637 b23a b632 <span class="number">1733</span> b6b0 b3b9 <span class="number">5118</span> ebc2</span><br><span class="line"><span class="number">326</span>d e33a ef03 <span class="number">8330</span> <span class="number">4885</span> <span class="number">8</span>dcd aecd <span class="number">258</span>d</span><br><span class="line">accc <span class="number">8</span>d6e <span class="number">9440</span> <span class="number">0</span>c00 a918 <span class="number">0000</span> <span class="number">1</span>c00 <span class="number">0000</span></span><br><span class="line"><span class="number">0b0</span>a <span class="number">7228</span> <span class="number">8777</span> <span class="number">8007</span> <span class="number">7</span>a58 <span class="number">7098</span> <span class="number">433</span>d b8c3</span><br><span class="line"><span class="number">38b</span>0 <span class="number">4339</span> d0c3 <span class="number">82e6</span> <span class="number">1</span>cc6 a10d e841 <span class="number">1</span>ec2</span><br><span class="line">c11d e621 <span class="number">1</span>de8 <span class="number">211</span>d dec1 <span class="number">1</span>d16 <span class="number">34e3</span> <span class="number">600</span>e</span><br><span class="line">e750 <span class="number">0f</span>e1 <span class="number">200f</span> e440 <span class="number">0f</span>e1 <span class="number">200f</span> e750 <span class="number">0</span>ef4</span><br><span class="line">b080 <span class="number">8107</span> <span class="number">7928</span> <span class="number">8770</span> <span class="number">6007</span> <span class="number">7678</span> <span class="number">8771</span> <span class="number">0807</span></span><br><span class="line"><span class="number">7</span>a28 <span class="number">0772</span> <span class="number">5870</span> <span class="number">9</span>cc3 <span class="number">38b</span>4 <span class="number">013b</span> a483 <span class="number">3</span>d94</span><br><span class="line">c382 <span class="number">031</span>e e841 <span class="number">1</span>ec2 a11e e801 <span class="number">1</span>d00 <span class="number">0000</span></span><br><span class="line">d110 <span class="number">0000</span> <span class="number">0600</span> <span class="number">0000</span> <span class="number">07</span>cc <span class="number">3</span>ca4 <span class="number">833b</span> <span class="number">9</span>c03</span><br><span class="line"><span class="number">3b</span>94 <span class="number">033</span>d a083 <span class="number">3</span>c94 <span class="number">4338</span> <span class="number">90</span>c3 <span class="number">0100</span> <span class="number">0000</span></span><br><span class="line"><span class="number">6120</span> <span class="number">0000</span> <span class="number">0e00</span> <span class="number">0000</span> <span class="number">1304</span> <span class="number">412</span>c <span class="number">1000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0100</span> <span class="number">0000</span> <span class="number">0465</span> <span class="number">0000</span> <span class="number">3311</span> <span class="number">0040</span> <span class="number">8</span>cc2 <span class="number">4</span>c04</span><br><span class="line"><span class="number">0010</span> a330 <span class="number">6</span>c40 <span class="number">08</span>c5 <span class="number">000</span>c <span class="number">1b</span>10 <span class="number">0131</span> <span class="number">0024</span></span><br><span class="line">c020 <span class="number">0106</span> <span class="number">0</span>a01 <span class="number">0860</span> <span class="number">6080</span> c006 <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">6120</span> <span class="number">0000</span> <span class="number">0</span>d00 <span class="number">0000</span> <span class="number">1304</span> c14c <span class="number">0400</span> <span class="number">10</span>a3</span><br><span class="line"><span class="number">3013</span> <span class="number">0100</span> c428 cc44 <span class="number">1400</span> <span class="number">410</span>a c306 c4a0</span><br><span class="line"><span class="number">0</span>cc0 b001 <span class="number">2114</span> <span class="number">0330</span> <span class="number">6</span>c40 <span class="number">0404</span> <span class="number">018</span>c <span class="number">1818</span></span><br><span class="line"><span class="number">0008</span> <span class="number">8241</span> f02c cd06 <span class="number">0000</span> <span class="number">0000</span> <span class="number">7120</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0300</span> <span class="number">0000</span> <span class="number">320</span>e <span class="number">1022</span> <span class="number">8400</span> e304 <span class="number">1830</span> <span class="number">4f</span>00</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">650</span>c <span class="number">0000</span> <span class="number">2500</span> <span class="number">0000</span> <span class="number">1203</span> <span class="number">9428</span></span><br><span class="line"><span class="number">0100</span> <span class="number">0000</span> <span class="number">0200</span> <span class="number">0000</span> <span class="number">0b00</span> <span class="number">0000</span> <span class="number">0600</span> <span class="number">0000</span></span><br><span class="line"><span class="number">4</span>c00 <span class="number">0000</span> <span class="number">0100</span> <span class="number">0000</span> <span class="number">5800</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">5800</span> <span class="number">0000</span> <span class="number">0200</span> <span class="number">0000</span> <span class="number">8800</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">1100</span> <span class="number">0000</span> <span class="number">1800</span> <span class="number">0000</span> <span class="number">2900</span> <span class="number">0000</span> <span class="number">0600</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0700</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">8800</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0200</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">2f</span>00 <span class="number">0000</span></span><br><span class="line"><span class="number">0800</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0700</span> <span class="number">0000</span> ffff ffff</span><br><span class="line"><span class="number">0024</span> <span class="number">0000</span> <span class="number">3700</span> <span class="number">0000</span> <span class="number">0500</span> <span class="number">0000</span> <span class="number">0700</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0400</span> <span class="number">0000</span> ffff ffff <span class="number">0024</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">5</span>d0c <span class="number">0000</span> <span class="number">1200</span> <span class="number">0000</span> <span class="number">1203</span> <span class="number">947</span>c <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">7465</span> <span class="number">7374</span> <span class="number">4164</span> <span class="number">646</span>d <span class="number">6169</span> <span class="number">6e31</span> <span class="number">332</span>e <span class="number">302</span>e</span><br><span class="line"><span class="number">3061</span> <span class="number">726</span>d <span class="number">3634</span> <span class="number">2</span>d61 <span class="number">7070</span> <span class="number">6</span>c65 <span class="number">2</span>d6d <span class="number">6163</span></span><br><span class="line"><span class="number">6f</span>73 <span class="number">7831</span> <span class="number">312</span>e <span class="number">302</span>e <span class="number">306</span>d <span class="number">6169</span> <span class="number">6e2</span>e <span class="number">6</span>d5f</span><br><span class="line"><span class="number">7465</span> <span class="number">7374</span> <span class="number">4164</span> <span class="number">645f</span> <span class="number">6</span>d61 <span class="number">696</span>e <span class="number">0000</span> <span class="number">0000</span></span><br></pre></td></tr></table></figure>

<h4 id="生成汇编代码"><a href="#生成汇编代码" class="headerlink" title="生成汇编代码"></a>生成汇编代码</h4><p>我们通过最终的.bc或.ll代码生成汇编代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang -S -fobjc-arc main.bc -o main.s</span><br><span class="line">clang -S -fobjc-arc main.ll -o main.s</span><br></pre></td></tr></table></figure>

<p>生成的汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">	.section	__TEXT,__text,regular,pure_instructions</span><br><span class="line">	.build_version macos, 11, 0	sdk_version 11, 3</span><br><span class="line">	.globl	_testAdd                        ; -- Begin function testAdd</span><br><span class="line">	.p2align	2</span><br><span class="line">_testAdd:                               ; @testAdd</span><br><span class="line">	.cfi_startproc</span><br><span class="line">; %bb.0:</span><br><span class="line">	sub	sp, sp, #16                     ; &#x3D;16</span><br><span class="line">	.cfi_def_cfa_offset 16</span><br><span class="line">	str	w0, [sp, #12]</span><br><span class="line">	str	w1, [sp, #8]</span><br><span class="line">	ldr	w8, [sp, #12]</span><br><span class="line">	ldr	w9, [sp, #8]</span><br><span class="line">	add	w8, w8, w9</span><br><span class="line">	add	w0, w8, #3                      ; &#x3D;3</span><br><span class="line">	add	sp, sp, #16                     ; &#x3D;16</span><br><span class="line">	ret</span><br><span class="line">	.cfi_endproc</span><br><span class="line">                                        ; -- End function</span><br><span class="line">	.globl	_main                           ; -- Begin function main</span><br><span class="line">	.p2align	2</span><br><span class="line">_main:                                  ; @main</span><br><span class="line">	.cfi_startproc</span><br><span class="line">; %bb.0:</span><br><span class="line">	sub	sp, sp, #32                     ; &#x3D;32</span><br><span class="line">	stp	x29, x30, [sp, #16]             ; 16-byte Folded Spill</span><br><span class="line">	add	x29, sp, #16                    ; &#x3D;16</span><br><span class="line">	.cfi_def_cfa w29, 16</span><br><span class="line">	.cfi_offset w30, -8</span><br><span class="line">	.cfi_offset w29, -16</span><br><span class="line">	stur	wzr, [x29, #-4]</span><br><span class="line">	str	w0, [sp, #8]</span><br><span class="line">	str	x1, [sp]</span><br><span class="line">	mov	w0, #1</span><br><span class="line">	mov	w1, #2</span><br><span class="line">	bl	_testAdd</span><br><span class="line">	ldp	x29, x30, [sp, #16]             ; 16-byte Folded Reload</span><br><span class="line">	add	sp, sp, #32                     ; &#x3D;32</span><br><span class="line">	ret</span><br><span class="line">	.cfi_endproc</span><br><span class="line">                                        ; -- End function</span><br><span class="line">	.section	__DATA,__objc_imageinfo,regular,no_dead_strip</span><br><span class="line">L_OBJC_IMAGE_INFO:</span><br><span class="line">	.long	0</span><br><span class="line">	.long	64</span><br><span class="line"></span><br><span class="line">.subsections_via_symbols</span><br></pre></td></tr></table></figure>

<p>汇编代码也可以优化，参数和IR相同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -Os -S -fobjc-arc main.m -o main.s</span><br></pre></td></tr></table></figure>

<p>优化后的汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">	.section	__TEXT,__text,regular,pure_instructions</span><br><span class="line">	.build_version macos, 11, 0	sdk_version 11, 3</span><br><span class="line">	.globl	_testAdd                        ; -- Begin function testAdd</span><br><span class="line">	.p2align	2</span><br><span class="line">_testAdd:                               ; @testAdd</span><br><span class="line">	.cfi_startproc</span><br><span class="line">; %bb.0:</span><br><span class="line">	add	w8, w0, w1</span><br><span class="line">	add	w0, w8, #3                      ; &#x3D;3</span><br><span class="line">	ret</span><br><span class="line">	.cfi_endproc</span><br><span class="line">                                        ; -- End function</span><br><span class="line">	.globl	_main                           ; -- Begin function main</span><br><span class="line">	.p2align	2</span><br><span class="line">_main:                                  ; @main</span><br><span class="line">	.cfi_startproc</span><br><span class="line">; %bb.0:</span><br><span class="line">	mov	w0, #6</span><br><span class="line">	ret</span><br><span class="line">	.cfi_endproc</span><br><span class="line">                                        ; -- End function</span><br><span class="line">	.section	__DATA,__objc_imageinfo,regular,no_dead_strip</span><br><span class="line">L_OBJC_IMAGE_INFO:</span><br><span class="line">	.long	0</span><br><span class="line">	.long	64</span><br><span class="line"></span><br><span class="line">.subsections_via_symbols</span><br></pre></td></tr></table></figure>

<h4 id="生成目标文件"><a href="#生成目标文件" class="headerlink" title="生成目标文件"></a>生成目标文件</h4><p>目标文件生成，汇编器以汇编代码作为输出，将汇编代码转为机器代码，最后输出目标文件(object file)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -fmodules -c main.s -o main.o</span><br></pre></td></tr></table></figure>

<p>.o文件的内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">cffa edfe <span class="number">0</span>c00 <span class="number">0001</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0100</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0400</span> <span class="number">0000</span> b801 <span class="number">0000</span> <span class="number">0020</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">1900</span> <span class="number">0000</span> <span class="number">3801</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line">a000 <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> d801 <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line">a000 <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0700</span> <span class="number">0000</span> <span class="number">0700</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0300</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">5f</span>5f <span class="number">7465</span> <span class="number">7874</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">5f</span>5f <span class="number">5445</span> <span class="number">5854</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">5400</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> d801 <span class="number">0000</span> <span class="number">0200</span> <span class="number">0000</span></span><br><span class="line"><span class="number">7802</span> <span class="number">0000</span> <span class="number">0100</span> <span class="number">0000</span> <span class="number">0004</span> <span class="number">0080</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">5f</span>5f <span class="number">6f</span>62 <span class="number">6</span>a63 <span class="number">5f</span>69</span><br><span class="line"><span class="number">6</span>d61 <span class="number">6765</span> <span class="number">696</span>e <span class="number">666f</span> <span class="number">5f</span>5f <span class="number">4441</span> <span class="number">5441</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">5400</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0800</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">2</span>c02 <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0010</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">5f</span>5f <span class="number">636f</span> <span class="number">6</span>d70 <span class="number">6163</span></span><br><span class="line"><span class="number">745f</span> <span class="number">756</span>e <span class="number">7769</span> <span class="number">6e64</span> <span class="number">5f</span>5f <span class="number">4</span>c44 <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">6000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">4000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">3802</span> <span class="number">0000</span> <span class="number">0300</span> <span class="number">0000</span></span><br><span class="line"><span class="number">8002</span> <span class="number">0000</span> <span class="number">0200</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0002</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">3200</span> <span class="number">0000</span> <span class="number">1800</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0100</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0b00</span> <span class="number">0003</span> <span class="number">0b00</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0200</span> <span class="number">0000</span> <span class="number">1800</span> <span class="number">0000</span> <span class="number">9002</span> <span class="number">0000</span> <span class="number">0500</span> <span class="number">0000</span></span><br><span class="line">e002 <span class="number">0000</span> <span class="number">2800</span> <span class="number">0000</span> <span class="number">0b00</span> <span class="number">0000</span> <span class="number">5000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0300</span> <span class="number">0000</span> <span class="number">0300</span> <span class="number">0000</span> <span class="number">0200</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0500</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> ff43 <span class="number">00</span>d1 e00f <span class="number">00b</span>9</span><br><span class="line">e10b <span class="number">00b</span>9 e80f <span class="number">40b</span>9 e90b <span class="number">40b</span>9 <span class="number">0801</span> <span class="number">090b</span></span><br><span class="line"><span class="number">000</span>d <span class="number">0011</span> ff43 <span class="number">0091</span> c003 <span class="number">5f</span>d6 ff83 <span class="number">00</span>d1</span><br><span class="line">fd7b <span class="number">01</span>a9 fd43 <span class="number">0091</span> bfc3 <span class="number">1f</span>b8 e00b <span class="number">00b</span>9</span><br><span class="line">e103 <span class="number">00f</span>9 <span class="number">2000</span> <span class="number">8052</span> <span class="number">4100</span> <span class="number">8052</span> <span class="number">0000</span> <span class="number">0094</span></span><br><span class="line">fd7b <span class="number">41</span>a9 ff83 <span class="number">0091</span> c003 <span class="number">5f</span>d6 <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">4000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">2400</span> <span class="number">0000</span> <span class="number">0010</span> <span class="number">0002</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">2400</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">3000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0004</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">4400</span> <span class="number">0000</span> <span class="number">0400</span> <span class="number">002</span>d</span><br><span class="line"><span class="number">2000</span> <span class="number">0000</span> <span class="number">0100</span> <span class="number">0006</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0100</span> <span class="number">0006</span></span><br><span class="line"><span class="number">1</span>c00 <span class="number">0000</span> <span class="number">0e01</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">1600</span> <span class="number">0000</span> <span class="number">0e02</span> <span class="number">0000</span> <span class="number">5400</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">1000</span> <span class="number">0000</span> <span class="number">0e03</span> <span class="number">0000</span> <span class="number">6000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0100</span> <span class="number">0000</span> <span class="number">0f</span>01 <span class="number">0000</span> <span class="number">2400</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0700</span> <span class="number">0000</span> <span class="number">0f</span>01 <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">005f</span> <span class="number">6</span>d61 <span class="number">696</span>e <span class="number">005f</span> <span class="number">7465</span> <span class="number">7374</span> <span class="number">4164</span> <span class="number">6400</span></span><br><span class="line"><span class="number">6</span>c74 <span class="number">6</span>d70 <span class="number">3200</span> <span class="number">6</span>c74 <span class="number">6</span>d70 <span class="number">3100</span> <span class="number">6</span>c74 <span class="number">6</span>d70</span><br><span class="line"><span class="number">3000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br></pre></td></tr></table></figure>

<h4 id="生成可执行文件（链接）"><a href="#生成可执行文件（链接）" class="headerlink" title="生成可执行文件（链接）"></a>生成可执行文件（链接）</h4><p>链接器把编译产生的.o文件和.dylib/.a文件，生成一个mach-o文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang main.o -o main</span><br></pre></td></tr></table></figure>

<p><img src="/Users/yyhl/Documents/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6.jpg" alt="可执行文件"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇我们主要研究了编译器的编译流程，从<code>源代码</code>到<code>可执行文件</code></p>
<ul>
<li>预处理：处理包括宏的替换，头文件的导入等。</li>
<li>词法分析：根据一些标识符对源文件进行切割，词法分析产生的记号一般可以分为如下几类：关键字、标识符、字面量和特殊符号。注意这一步是不会检查代码是否有错误。</li>
<li>语法分析：语法分析器对词法分析后的记号进行语法分析，产生抽象语法树(AST),这一步会检查语法是否正确</li>
<li>生成中间代码（IR）：将上面生成的语法树转换成中间代码。中间代码使得编译器可以范围内前端和后端。编译器的前端负责产生机器无关的中间代码，编译器后端将中间代码转换成目标机器代码。</li>
<li>生成汇编代码：将中间代码准换成汇编。</li>
<li>生成目标文件（.o）:将汇编语言转换成目标文件。</li>
<li>链接目标文件，生成可执行文件：这一步主要是处理多个库依赖的情况。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/10/01/iOS%E5%8C%85%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96-Flutter%E5%8C%85%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/01/iOS%E5%8C%85%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96-Flutter%E5%8C%85%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">iOS包体积优化-Flutter包优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-10-01 11:02:41 / 修改时间：11:03:45" itemprop="dateCreated datePublished" datetime="2021-10-01T11:02:41+08:00">2021-10-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/08/24/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-Block/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/24/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-Block/" class="post-title-link" itemprop="url">iOS底层探索 - Block</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-24 19:42:22" itemprop="dateCreated datePublished" datetime="2021-08-24T19:42:22+08:00">2021-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-27 22:41:00" itemprop="dateModified" datetime="2021-08-27T22:41:00+08:00">2021-08-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>block是我们开发经常遇到的一个结构，本篇我们就来探索一下它的结构。</p>
<h3 id="block的分类"><a href="#block的分类" class="headerlink" title="block的分类"></a>block的分类</h3><p>block的分类相信大家已经很清楚了，分为全局block、堆block和栈block。我们来个例子看看它们的区别</p>
<ul>
<li><p>全局block</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void (^block)(void) &#x3D; ^&#123;</span><br><span class="line">&#125;;</span><br><span class="line">NSLog(@&quot;%@&quot;,block);</span><br><span class="line">&#x2F;&#x2F;&#x2F;打印结果</span><br><span class="line">&lt;__NSGlobalBlock__: 0x1072d4100&gt;</span><br></pre></td></tr></table></figure>

<p>全局block是指不捕获任何外部变量的block，只会使用静态变量和全局变量，存储于内存的<code>全局区</code>。</p>
</li>
<li><p>堆block</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 10;</span><br><span class="line">void (^block)(void) &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;Cooci - %d&quot;,a);</span><br><span class="line">&#125;;</span><br><span class="line">NSLog(@&quot;%@&quot;,block);</span><br><span class="line">&#x2F;&#x2F;&#x2F;打印结果</span><br><span class="line">&lt;__NSMallocBlock__: 0x60000130c4b0&gt;</span><br></pre></td></tr></table></figure>

<p>堆block会捕获外部变量，存储于内存的<code>堆区</code>。</p>
</li>
<li><p>栈block</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 10;</span><br><span class="line">void (^__weak block)(void) &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;Cooci - %d&quot;,a);</span><br><span class="line">&#125;;</span><br><span class="line">NSLog(@&quot;%@&quot;,block);</span><br><span class="line">&#x2F;&#x2F;&#x2F;打印结果</span><br><span class="line">&lt;__NSStackBlock__: 0x7ffee06ac4d8&gt;</span><br></pre></td></tr></table></figure>

<p>栈block也会捕获外部变量，和堆block的区别是需要加<code>__weak</code>修饰，它存储于内存的<code>栈区</code></p>
</li>
</ul>
<h3 id="block的循环引用"><a href="#block的循环引用" class="headerlink" title="block的循环引用"></a>block的循环引用</h3><h4 id="block引起循环引用的原因"><a href="#block引起循环引用的原因" class="headerlink" title="block引起循环引用的原因"></a>block引起循环引用的原因</h4><p>A、B相互持有，所以导致A无法调用dealloc方法给B发送release信号，而B也无法接收到release信号。所以A、B此时都无法释放。如图所示</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ff0b44dcab44114828396a67d202ca5~tplv-k3u1fbpfcp-watermark.image" alt="循环引用"></p>
<h4 id="解决循环引用"><a href="#解决循环引用" class="headerlink" title="解决循环引用"></a>解决循环引用</h4><p>我们看一段循环引用的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSString *name &#x3D; @&quot;JS&quot;;</span><br><span class="line">self.block &#x3D; ^(void)&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,self.name);</span><br><span class="line">&#125;;</span><br><span class="line">self.block();</span><br></pre></td></tr></table></figure>

<p>这段代码出现了循环引用，因为在<code>block</code>内部使用了<code>外部变量name</code>，导致<code>block持有了self</code>，而<code>self原本是持有block</code>的，所以导致了<code>self和block的相互持有</code>。</p>
<p>解决方法：</p>
<ul>
<li><p>__weak和__strong组合使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^JSBlock)(void);</span><br><span class="line"></span><br><span class="line">@property(nonatomic, copy) JSBlock jslBlock;</span><br><span class="line"></span><br><span class="line">__weak typeof(self) weakSelf &#x3D; self;</span><br><span class="line">self.jslBlock &#x3D; ^(void)&#123;</span><br><span class="line">			__strong typeof(weakSelf) strongSelf &#x3D; weakSelf;</span><br><span class="line">     NSLog(@&quot;%@&quot;,weakSelf.name);</span><br><span class="line">&#125;</span><br><span class="line">self.jslBlock();</span><br></pre></td></tr></table></figure>

<p>这是我们最容易想到的方式，使用__weak打破强引用，__strong的作用的方式self提前释放，而block执行的时候因为self已经释放而拿不到值。</p>
</li>
<li><p>__block定义一个临时变量指向self。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__block ViewController *vc &#x3D; self;</span><br><span class="line">self.jslBlock &#x3D; ^(void)&#123;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,vc.name);</span><br><span class="line">        vc &#x3D; nil;&#x2F;&#x2F;需手动释放</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">self.jslBlock();</span><br></pre></td></tr></table></figure>

<p>这种方式是在方法外部定义一个指向self的变量，block内部捕获临时变量，使用结束后将临时变量置为nil，加__block的原因是需要在block内存对其进行置空操作。</p>
</li>
<li><p>block加一个参数，使用参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^JSBlock)(ViewController *);</span><br><span class="line">@property(nonatomic, copy) JSBlock jslBlock;</span><br><span class="line">self.jslBlock &#x3D; ^(ViewController *vc)&#123;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,vc.name);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">self.jslBlock(self);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Block的底层分析"><a href="#Block的底层分析" class="headerlink" title="Block的底层分析"></a>Block的底层分析</h3><p>我们主要通过clang和断点调试的方式分析。</p>
<h4 id="xcrun编译分析"><a href="#xcrun编译分析" class="headerlink" title="xcrun编译分析"></a>xcrun编译分析</h4><p>我们首先自定义一个<code>block.c</code>文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">void</span>(^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"js - %d"</span>,a);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>xcrun</code>命令讲<code>block.c</code>编译成<code>block.cpp</code>。<code>xcrun -sdk iphonesimulator clang -arch x86_64 -rewrite-objc block.c</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> a = __cself-&gt;a; <span class="comment">// bound by copy</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"js - %d"</span>,a);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">void</span>(*block)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a));</span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们把类型强转的代码去掉：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">void</span>(*block)(<span class="keyword">void</span>) = __main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, a));</span><br><span class="line">    block-&gt;FuncPtr(block);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简化之后我们看到<code>block</code>代码块是一个<code>__main_block_impl_0</code>，<code>__main_block_impl_0</code>的结构是一个结构体,它的<code>impl</code>也是一个结构体</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> _a, <span class="keyword">int</span> flags=<span class="number">0</span>) : a(_a) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意：在结构体内部捕获到了外部变量<code>a</code>，且在结构体内部生成了一个成员变量<code>a</code>与其对应。</p>
<p>我们对代码做一下修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    __block int a &#x3D; 18;</span><br><span class="line">    void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">        a++;</span><br><span class="line">        printf(&quot;js - %d&quot;,a);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新<code>xcrun</code>一下看看结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __Block_byref_a_0 *a; <span class="comment">// by ref</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, <span class="keyword">int</span> flags=<span class="number">0</span>) : a(_a-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>可以看到，现在的<code>a</code>和之前的<code>a</code>不同的是加了<code>__Block_byref_a_0 *</code>修饰，这样就可以对捕获到的变量进行修改，传给block是a的地址，所以block内部可以修改。</p>
</li>
<li><p><code>impl.isa = &amp;_NSConcreteStackBlock</code>说明现在<code>栈类型</code>根据我们前面的分析这里应该是<code>堆block</code>，为什么不同呢。</p>
</li>
<li><p>fp是一个函数式保存，如果不调用不会执行。</p>
</li>
</ul>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>我们首先用汇编，查看源码在哪个库中，我们打断点</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43a7f94029c64667a1de4d787d11d80f~tplv-k3u1fbpfcp-watermark.image" alt="断点"></p>
<p>然后看汇编代码，<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf9c4a24e15d42babeb4c0cb6b706af8~tplv-k3u1fbpfcp-watermark.image" alt="源码定位"></p>
<p>我们添加符号断点<code>objc_retainBlock</code>:</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24c28d4e308c4869a1c3aea6e4627459~tplv-k3u1fbpfcp-watermark.image" alt="1629984483869"></p>
<p>所以我们去<code>libobjc</code>去搜索<code>objc_retainBlock</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id <span class="title">objc_retainBlock</span><span class="params">(id x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (id)_Block_copy(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际调用了<code>_Block_copy</code>,在<code>libobjc</code>库中并没有找到方法的实现，我们继续打符号断点：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/973b28fba97a4952bb24470da47023fb~tplv-k3u1fbpfcp-watermark.image" alt="1629984996709"></p>
<p><code>_Block_copy</code>函数的实现在<code>libsystem</code>库中，这个库没有开源，我们找一个替换的库<code>libclosure</code>的源码分析。我们在<code>libclosure</code>源码中搜索<code>_Block_copy</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy, or bump refcount, of a block.  If really copying, call the copy helper if present.</span></span><br><span class="line"><span class="keyword">void</span> *_Block_copy(<span class="keyword">const</span> <span class="keyword">void</span> *arg) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_layout</span> *<span class="title">aBlock</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!arg) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// The following would be better done as a switch statement</span></span><br><span class="line">    aBlock = (struct Block_layout *)arg;</span><br><span class="line">    <span class="keyword">if</span> (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) &#123;</span><br><span class="line">        <span class="comment">// latches on high</span></span><br><span class="line">        latching_incr_int(&amp;aBlock-&gt;flags);</span><br><span class="line">        <span class="keyword">return</span> aBlock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) &#123;</span><br><span class="line">        <span class="keyword">return</span> aBlock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 栈 - 堆 运行时拷贝到堆上</span></span><br><span class="line">        <span class="comment">// Its a stack block.  Make a copy.</span></span><br><span class="line">        <span class="keyword">size_t</span> <span class="built_in">size</span> = Block_size(aBlock);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Block_layout</span> *<span class="title">result</span> = (<span class="title">struct</span> <span class="title">Block_layout</span> *)<span class="title">malloc</span>(<span class="title">size</span>);</span></span><br><span class="line">        <span class="keyword">if</span> (!result) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        memmove(result, aBlock, <span class="built_in">size</span>); <span class="comment">// bitcopy first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(ptrauth_calls)</span></span><br><span class="line">        <span class="comment">// Resign the invoke pointer as it uses address authentication.</span></span><br><span class="line">        result-&gt;invoke = aBlock-&gt;invoke;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(ptrauth_signed_block_descriptors)</span></span><br><span class="line">        <span class="keyword">if</span> (aBlock-&gt;flags &amp; BLOCK_SMALL_DESCRIPTOR) &#123;</span><br><span class="line">            <span class="keyword">uintptr_t</span> oldDesc = ptrauth_blend_discriminator(</span><br><span class="line">                    &amp;aBlock-&gt;descriptor,</span><br><span class="line">                    _Block_descriptor_ptrauth_discriminator);</span><br><span class="line">            <span class="keyword">uintptr_t</span> newDesc = ptrauth_blend_discriminator(</span><br><span class="line">                    &amp;result-&gt;descriptor,</span><br><span class="line">                    _Block_descriptor_ptrauth_discriminator);</span><br><span class="line"></span><br><span class="line">            result-&gt;descriptor =</span><br><span class="line">                    ptrauth_auth_and_resign(aBlock-&gt;descriptor,</span><br><span class="line">                                            ptrauth_key_asda, oldDesc,</span><br><span class="line">                                            ptrauth_key_asda, newDesc);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">// reset refcount</span></span><br><span class="line">        result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK|BLOCK_DEALLOCATING);    <span class="comment">// XXX not needed</span></span><br><span class="line">        result-&gt;flags |= BLOCK_NEEDS_FREE | <span class="number">2</span>;  <span class="comment">// logical refcount 1</span></span><br><span class="line">        _Block_call_copy_helper(result, aBlock);</span><br><span class="line">        <span class="comment">// Set isa last so memory analysis tools see a fully-initialized object.</span></span><br><span class="line">        result-&gt;isa = _NSConcreteMallocBlock;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>Block_layout</code>结构体的结构是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block_layout</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> * __ptrauth_objc_isa_pointer isa;<span class="comment">//isa 标识是栈、堆block类型</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span> flags; <span class="comment">// contains ref count 引用计数</span></span><br><span class="line">    <span class="keyword">int32_t</span> reserved;<span class="comment">//流程数据</span></span><br><span class="line">    BlockInvokeFunction invoke;<span class="comment">//调用函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_descriptor_1</span> *<span class="title">descriptor</span>;</span><span class="comment">//相关描述</span></span><br><span class="line">    <span class="comment">// imported variables</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对结构有个简单了解之后，我们打符号断点，看运行中<code>block</code>的结构。</p>
<ul>
<li><p><code>objc_retainBlock</code></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fca99172b35b4a35a130f9bb0ea423dd~tplv-k3u1fbpfcp-watermark.image" alt="1629986289286"></p>
<p>发现此时的block类型还是<code>StackBlock</code>。</p>
</li>
<li><p>在<code>_Block_copy</code>最后打一个断点：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cb0fd0a0551400ab250a8d6ad9142f6~tplv-k3u1fbpfcp-watermark.image" alt="1629986567227"></p>
<p>此时<code>block</code>的类型就是<code>__NSMallocBlock__</code>类型了。</p>
</li>
</ul>
<h5 id="blockLayout结构"><a href="#blockLayout结构" class="headerlink" title="blockLayout结构"></a>blockLayout结构</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block_layout</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> * __ptrauth_objc_isa_pointer isa;<span class="comment">//isa 标识是栈、堆block类型</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span> flags; <span class="comment">// contains ref count 引用计数</span></span><br><span class="line">    <span class="keyword">int32_t</span> reserved;<span class="comment">//流程数据</span></span><br><span class="line">    BlockInvokeFunction invoke;<span class="comment">//调用函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_descriptor_1</span> *<span class="title">descriptor</span>;</span><span class="comment">//相关描述</span></span><br><span class="line">    <span class="comment">// imported variables</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们看<code>Block_descriptor_1</code>的结构，发现并没有上面调试打印的<code>signature</code>信息。</p>
<p>我们看源码发现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCK_DESCRIPTOR_2 1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block_descriptor_2</span> &#123;</span></span><br><span class="line">    <span class="comment">// requires BLOCK_HAS_COPY_DISPOSE</span></span><br><span class="line">    BlockCopyFunction copy;<span class="comment">//拷贝函数指针</span></span><br><span class="line">    BlockDisposeFunction dispose;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCK_DESCRIPTOR_3 1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block_descriptor_3</span> &#123;</span></span><br><span class="line">    <span class="comment">// requires BLOCK_HAS_SIGNATURE</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *signature;<span class="comment">//签名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *layout;     <span class="comment">// contents depend on BLOCK_HAS_EXTENDED_LAYOUT 布局</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Block_descriptor_2</code>和<code>Block_descriptor_3</code>是可选的，它们是通过<code>Block_descriptor_1</code>内存平移得到的。</p>
<h5 id="捕获变量的copy"><a href="#捕获变量的copy" class="headerlink" title="捕获变量的copy"></a>捕获变量的copy</h5><h6 id="Block-copy"><a href="#Block-copy" class="headerlink" title="_Block_copy"></a>_Block_copy</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy, or bump refcount, of a block.  If really copying, call the copy helper if present.</span></span><br><span class="line"><span class="comment">//  栈Block -&gt; 堆Block</span></span><br><span class="line"><span class="keyword">void</span> *_Block_copy(<span class="keyword">const</span> <span class="keyword">void</span> *arg) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_layout</span> *<span class="title">aBlock</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!arg) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The following would be better done as a switch statement</span></span><br><span class="line">    aBlock = (struct Block_layout *)arg;<span class="comment">//强转为Block_layout类型对象，防止对外界造成影响</span></span><br><span class="line">    <span class="keyword">if</span> (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) &#123;<span class="comment">//是否需要释放</span></span><br><span class="line">        <span class="comment">// latches on high</span></span><br><span class="line">        latching_incr_int(&amp;aBlock-&gt;flags);</span><br><span class="line">        <span class="keyword">return</span> aBlock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) &#123;<span class="comment">//如果是全局block，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> aBlock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//为栈block 或者 堆block，由于堆区需要申请内存，所以只可能是栈区</span></span><br><span class="line">        <span class="comment">// Its a stack block.  Make a copy. 它是一个堆栈块block，拷贝。</span></span><br><span class="line">        struct Block_layout *result =</span><br><span class="line">            (struct Block_layout *)<span class="built_in">malloc</span>(aBlock-&gt;descriptor-&gt;<span class="built_in">size</span>);<span class="comment">//申请空间并接收</span></span><br><span class="line">        <span class="keyword">if</span> (!result) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//通过memmove内存拷贝，将 aBlock 拷贝至result</span></span><br><span class="line">        memmove(result, aBlock, aBlock-&gt;descriptor-&gt;<span class="built_in">size</span>); <span class="comment">// bitcopy first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(ptrauth_calls)</span></span><br><span class="line">        <span class="comment">// Resign the invoke pointer as it uses address authentication.</span></span><br><span class="line">        result-&gt;invoke = aBlock-&gt;invoke;<span class="comment">//可以直接调起invoke</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">// reset refcount</span></span><br><span class="line">        result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK|BLOCK_DEALLOCATING);    <span class="comment">// XXX not needed 告知可释放</span></span><br><span class="line">        result-&gt;flags |= BLOCK_NEEDS_FREE | <span class="number">2</span>;  <span class="comment">// logical refcount 1</span></span><br><span class="line">        _Block_call_copy_helper(result, aBlock);</span><br><span class="line">        <span class="comment">// Set isa last so memory analysis tools see a fully-initialized object.</span></span><br><span class="line">        result-&gt;isa = _NSConcreteMallocBlock;<span class="comment">//设置block对象类型为堆区block</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_Block_copy</code>主要是将block从栈区拷贝到堆区</p>
<ul>
<li>如果需要释放，则直接释放</li>
<li>如果是<code>globalBlock</code>不需要copy，返回</li>
<li>剩下两种情况：堆区block和栈区block。由于堆区block需要申请内存，这里到这里只能是栈block。<ul>
<li>通过<code>malloc</code>申请内存空间用于接收block</li>
<li>通过remove将block拷贝至新申请的内存中</li>
<li>设置block对象的类型为堆区block。将<code>isa</code>指向<code>__NSConcreteMallocBlock</code></li>
</ul>
</li>
</ul>
<h6 id="Block-object-assign"><a href="#Block-object-assign" class="headerlink" title="_Block_object_assign"></a>_Block_object_assign</h6><p>先看一个枚举的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Block 捕获的外界变量的种类</span></span><br><span class="line"><span class="comment">// Runtime support functions used by compiler when generating copy/dispose helpers</span></span><br><span class="line"><span class="comment">// Values for _Block_object_assign() and _Block_object_dispose() parameters</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    <span class="comment">// see function implementation for a more complete description of these fields and combinations</span></span><br><span class="line">    <span class="comment">//普通对象，即没有其他的引用类型</span></span><br><span class="line">    BLOCK_FIELD_IS_OBJECT   =  <span class="number">3</span>,  <span class="comment">// id, NSObject, __attribute__((NSObject)), block, ...</span></span><br><span class="line">    <span class="comment">//block类型作为变量</span></span><br><span class="line">    BLOCK_FIELD_IS_BLOCK    =  <span class="number">7</span>,  <span class="comment">// a block variable</span></span><br><span class="line">    <span class="comment">//经过__block修饰的变量</span></span><br><span class="line">    BLOCK_FIELD_IS_BYREF    =  <span class="number">8</span>,  <span class="comment">// the on stack structure holding the __block variable</span></span><br><span class="line">    <span class="comment">//weak 弱引用变量</span></span><br><span class="line">    BLOCK_FIELD_IS_WEAK     = <span class="number">16</span>,  <span class="comment">// declared __weak, only used in byref copy helpers</span></span><br><span class="line">    <span class="comment">//返回的调用对象 - 处理block_byref内部对象内存会加的一个额外标记，配合flags一起使用</span></span><br><span class="line">    BLOCK_BYREF_CALLER      = <span class="number">128</span>, <span class="comment">// called from __block (byref) copy/dispose support routines.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中用的最多的是<code>BLOCK_FIELD_IS_OBJECT</code>和<code>BLOCK_FIELD_IS_BYREF</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref</span> *_<span class="title">Block_byref_copy</span>(<span class="title">const</span> <span class="title">void</span> *<span class="title">arg</span>) &#123;</span></span><br><span class="line">    <span class="comment">//强转为Block_byref结构体类型，保存一份</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref</span> *<span class="title">src</span> = (<span class="title">struct</span> <span class="title">Block_byref</span> *)<span class="title">arg</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((src-&gt;forwarding-&gt;flags &amp; BLOCK_REFCOUNT_MASK) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// src points to stack 申请内存</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref</span> *<span class="title">copy</span> = (<span class="title">struct</span> <span class="title">Block_byref</span> *)<span class="title">malloc</span>(<span class="title">src</span>-&gt;<span class="title">size</span>);</span></span><br><span class="line">        copy-&gt;isa = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// byref value 4 is logical refcount of 2: one for caller, one for stack</span></span><br><span class="line">        copy-&gt;flags = src-&gt;flags | BLOCK_BYREF_NEEDS_FREE | <span class="number">4</span>;</span><br><span class="line">        <span class="comment">//block内部持有的Block_byref 和 外界的Block_byref 所持有的对象是同一个，这也是为什么__block修饰的变量具有修改能力</span></span><br><span class="line">        <span class="comment">//copy 和 scr 的地址指针达到了完美的同一份拷贝，目前只有持有能力</span></span><br><span class="line">        copy-&gt;forwarding = copy; <span class="comment">// patch heap copy to point to itself</span></span><br><span class="line">        src-&gt;forwarding = copy;  <span class="comment">// patch stack to point to heap copy</span></span><br><span class="line">        copy-&gt;<span class="built_in">size</span> = src-&gt;<span class="built_in">size</span>;</span><br><span class="line">        <span class="comment">//如果有copy能力</span></span><br><span class="line">        <span class="keyword">if</span> (src-&gt;flags &amp; BLOCK_BYREF_HAS_COPY_DISPOSE) &#123;</span><br><span class="line">            <span class="comment">// Trust copy helper to copy everything of interest</span></span><br><span class="line">            <span class="comment">// If more than one field shows up in a byref block this is wrong XXX</span></span><br><span class="line">            <span class="comment">//Block_byref_2是结构体，__block修饰的可能是对象，对象通过byref_keep保存，在合适的时机进行调用</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref_2</span> *<span class="title">src2</span> = (<span class="title">struct</span> <span class="title">Block_byref_2</span> *)(<span class="title">src</span>+1);</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref_2</span> *<span class="title">copy2</span> = (<span class="title">struct</span> <span class="title">Block_byref_2</span> *)(<span class="title">copy</span>+1);</span></span><br><span class="line">            copy2-&gt;byref_keep = src2-&gt;byref_keep;</span><br><span class="line">            copy2-&gt;byref_destroy = src2-&gt;byref_destroy;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (src-&gt;flags &amp; BLOCK_BYREF_LAYOUT_EXTENDED) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref_3</span> *<span class="title">src3</span> = (<span class="title">struct</span> <span class="title">Block_byref_3</span> *)(<span class="title">src2</span>+1);</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref_3</span> *<span class="title">copy3</span> = (<span class="title">struct</span> <span class="title">Block_byref_3</span>*)(<span class="title">copy2</span>+1);</span></span><br><span class="line">                copy3-&gt;layout = src3-&gt;layout;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//等价于 __Block_byref_id_object_copy</span></span><br><span class="line">            (*src2-&gt;byref_keep)(copy, src);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Bitwise copy.</span></span><br><span class="line">            <span class="comment">// This copy includes Block_byref_3, if any.</span></span><br><span class="line">            memmove(copy+<span class="number">1</span>, src+<span class="number">1</span>, src-&gt;<span class="built_in">size</span> - <span class="keyword">sizeof</span>(*src));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// already copied to heap</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((src-&gt;forwarding-&gt;flags &amp; BLOCK_BYREF_NEEDS_FREE) == BLOCK_BYREF_NEEDS_FREE) &#123;</span><br><span class="line">        latching_incr_int(&amp;src-&gt;forwarding-&gt;flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> src-&gt;forwarding;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_Block_object_assign</code>是在底层编译代码中，外部变量拷贝时调用的方法就是它。</p>
<ul>
<li>如果是普通对象，交给系统arc处理，拷贝对象指针，引用技术+1，外界变量不能释放。</li>
<li>如果是block类型的变量，通过_Block_copy操作，将block从栈区拷贝到堆区。</li>
<li>如果是<code>__block</code>修饰的变量，调用<code>_Block_byref_copy</code>函数，进行内存拷贝以及常规处理。</li>
</ul>
<h6 id="Block-byref-copy"><a href="#Block-byref-copy" class="headerlink" title="_Block_byref_copy"></a>_Block_byref_copy</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref</span> *_<span class="title">Block_byref_copy</span>(<span class="title">const</span> <span class="title">void</span> *<span class="title">arg</span>) &#123;</span></span><br><span class="line">    <span class="comment">//强转为Block_byref结构体类型，保存一份</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref</span> *<span class="title">src</span> = (<span class="title">struct</span> <span class="title">Block_byref</span> *)<span class="title">arg</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((src-&gt;forwarding-&gt;flags &amp; BLOCK_REFCOUNT_MASK) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// src points to stack 申请内存</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref</span> *<span class="title">copy</span> = (<span class="title">struct</span> <span class="title">Block_byref</span> *)<span class="title">malloc</span>(<span class="title">src</span>-&gt;<span class="title">size</span>);</span></span><br><span class="line">        copy-&gt;isa = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// byref value 4 is logical refcount of 2: one for caller, one for stack</span></span><br><span class="line">        copy-&gt;flags = src-&gt;flags | BLOCK_BYREF_NEEDS_FREE | <span class="number">4</span>;</span><br><span class="line">        <span class="comment">//block内部持有的Block_byref 和 外界的Block_byref 所持有的对象是同一个，这也是为什么__block修饰的变量具有修改能力</span></span><br><span class="line">        <span class="comment">//copy 和 scr 的地址指针达到了完美的同一份拷贝，目前只有持有能力</span></span><br><span class="line">        copy-&gt;forwarding = copy; <span class="comment">// patch heap copy to point to itself</span></span><br><span class="line">        src-&gt;forwarding = copy;  <span class="comment">// patch stack to point to heap copy</span></span><br><span class="line">        copy-&gt;<span class="built_in">size</span> = src-&gt;<span class="built_in">size</span>;</span><br><span class="line">        <span class="comment">//如果有copy能力</span></span><br><span class="line">        <span class="keyword">if</span> (src-&gt;flags &amp; BLOCK_BYREF_HAS_COPY_DISPOSE) &#123;</span><br><span class="line">            <span class="comment">// Trust copy helper to copy everything of interest</span></span><br><span class="line">            <span class="comment">// If more than one field shows up in a byref block this is wrong XXX</span></span><br><span class="line">            <span class="comment">//Block_byref_2是结构体，__block修饰的可能是对象，对象通过byref_keep保存，在合适的时机进行调用</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref_2</span> *<span class="title">src2</span> = (<span class="title">struct</span> <span class="title">Block_byref_2</span> *)(<span class="title">src</span>+1);</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref_2</span> *<span class="title">copy2</span> = (<span class="title">struct</span> <span class="title">Block_byref_2</span> *)(<span class="title">copy</span>+1);</span></span><br><span class="line">            copy2-&gt;byref_keep = src2-&gt;byref_keep;</span><br><span class="line">            copy2-&gt;byref_destroy = src2-&gt;byref_destroy;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (src-&gt;flags &amp; BLOCK_BYREF_LAYOUT_EXTENDED) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref_3</span> *<span class="title">src3</span> = (<span class="title">struct</span> <span class="title">Block_byref_3</span> *)(<span class="title">src2</span>+1);</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref_3</span> *<span class="title">copy3</span> = (<span class="title">struct</span> <span class="title">Block_byref_3</span>*)(<span class="title">copy2</span>+1);</span></span><br><span class="line">                copy3-&gt;layout = src3-&gt;layout;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//等价于 __Block_byref_id_object_copy</span></span><br><span class="line">            (*src2-&gt;byref_keep)(copy, src);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Bitwise copy.</span></span><br><span class="line">            <span class="comment">// This copy includes Block_byref_3, if any.</span></span><br><span class="line">            memmove(copy+<span class="number">1</span>, src+<span class="number">1</span>, src-&gt;<span class="built_in">size</span> - <span class="keyword">sizeof</span>(*src));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// already copied to heap</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((src-&gt;forwarding-&gt;flags &amp; BLOCK_BYREF_NEEDS_FREE) == BLOCK_BYREF_NEEDS_FREE) &#123;</span><br><span class="line">        latching_incr_int(&amp;src-&gt;forwarding-&gt;flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> src-&gt;forwarding;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将传入的对象，强转为<code>Block_byref</code>结构体类型对象。保存</li>
<li>如果没有将变量拷贝到堆上，就申请内存进行拷贝</li>
<li>如果已经拷贝，则进行处理并返回</li>
<li>其中copy和src的forwarding指针都是指向同一片内存。这就是为什么<code>__block</code>修饰的对象具有修改的能力。</li>
</ul>
<h4 id="三层copy小结"><a href="#三层copy小结" class="headerlink" title="三层copy小结"></a>三层copy小结</h4><ul>
<li>第一层：通过<code>_Block_copy</code>实现对象的<code>自身拷贝</code>,从栈区拷贝至堆区</li>
<li>第二层：通过<code>_Block_byref_copy</code>方法，将对象拷贝为<code>Block_byref</code>结构体类型</li>
<li>第三次：调用<code>_Block_object_assign</code>方法，对<code>__block</code>修饰的<code>当前变量的拷贝</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/08/23/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/23/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%94%81/" class="post-title-link" itemprop="url">iOS多线程-锁</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-23 23:29:44" itemprop="dateCreated datePublished" datetime="2021-08-23T23:29:44+08:00">2021-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-27 22:05:07" itemprop="dateModified" datetime="2021-08-27T22:05:07+08:00">2021-08-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前面几篇我们探索了<code>iOS</code>使用频率很高的多线程技术<code>GCD</code>，本篇我们探索多线程中一个重要的概念<code>锁</code>。</p>
<h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><p>锁主要分为两大类<code>自旋锁</code>和<code>互斥锁</code>。</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>在自旋锁中，<code>线程会反复检查变量是否可用</code>。由于线程这个过程中一致保持执行，所以是一种<code>忙等待</code>。 一旦获取了自旋锁，线程就<code>会一直保持该锁</code>，直到显式释放自旋锁。自旋锁避免了进程上下文的调度开销，因此对于<code>线程只会阻塞很短时间的场合</code>是<code>有效</code>的。对于iOS属性的修饰符<code>atomic</code>，自带一把自旋锁</p>
<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p><code>互斥锁</code>是一种用于<code>多线程编程</code>中，<code>防止两条线程同时对同一公共资源（例如全局变量）进行读写的机制</code>，该目的是通过<code>将代码切成一个个临界区</code>而达成。</p>
<h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>读写锁实际是一种特殊的互斥锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源 进行读访问，写者则需要对共享资源进行写操作。这种锁相对于自旋锁而言，能提高并发性，因为在多处理器系统中，它允许同时有多个读者来访问共享资源，最大可能的读者数为实际的逻辑CPU 数。写者是排他性的，一个读写锁同时只能有一个写者或多个读者(与CPU数相关)，但不能同时既有读者又有写者。在读写锁保持期间也是抢占失效的。</p>
<p>如果读写锁当前没有读者，也没有写者，那么写者可以立刻获得读写锁，否则它必须自旋在那里， 直到没有任何写者或读者。如果读写锁没有写者，那么读者可以立即获得该读写锁，否则读者必须自旋在那里，直到写者释放该读写锁。</p>
<p>当读写锁是写加锁状态时, 在这个锁被解锁之前, 所有试图对这个锁加锁的线程都会被阻塞.当读写锁在读加锁状态时, 所有试图以读模式对它进行加锁的线程都可以得到访问权, 但是如果线程希望以写模式对此锁进行加锁, 它必须直到所有的线程释放锁.通常, 当读写锁处于读模式锁住状态时, 如果有另外线程试图以写模式加锁, 读写锁通常会阻塞随后的读模式锁请求, 这样可以避免读模式锁⻓期占用, 而等待的写模式锁请求⻓期阻塞.读写锁适合于对数据结构的读次数比写次数多得多的情况. 因为, 读模式锁定时可以共享, 以写模式锁住时意味着独占, 所以读写锁又叫共享-独占锁.</p>
<h3 id="几种锁的性能对比"><a href="#几种锁的性能对比" class="headerlink" title="几种锁的性能对比"></a>几种锁的性能对比</h3><p>我们通过代码打印的方式比较各种锁性能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">int js_runTimes &#x3D; 100000;</span><br><span class="line">&#x2F;** OSSpinLock 性能 *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">    OSSpinLock js_spinlock &#x3D; OS_SPINLOCK_INIT;</span><br><span class="line">    double_t js_beginTime &#x3D; CFAbsoluteTimeGetCurrent();</span><br><span class="line">    for (int i&#x3D;0 ; i &lt; js_runTimes; i++) &#123;</span><br><span class="line">        OSSpinLockLock(&amp;js_spinlock);          &#x2F;&#x2F;解锁</span><br><span class="line">        OSSpinLockUnlock(&amp;js_spinlock);</span><br><span class="line">    &#125;</span><br><span class="line">    double_t js_endTime &#x3D; CFAbsoluteTimeGetCurrent() ;</span><br><span class="line">    JSLog(@&quot;OSSpinLock: %f ms&quot;,(js_endTime - js_beginTime)*1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** dispatch_semaphore_t 性能 *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_semaphore_t js_sem &#x3D; dispatch_semaphore_create(1);</span><br><span class="line">    double_t js_beginTime &#x3D; CFAbsoluteTimeGetCurrent();</span><br><span class="line">    for (int i&#x3D;0 ; i &lt; js_runTimes; i++) &#123;</span><br><span class="line">        dispatch_semaphore_wait(js_sem, DISPATCH_TIME_FOREVER);</span><br><span class="line">        dispatch_semaphore_signal(js_sem);</span><br><span class="line">    &#125;</span><br><span class="line">    double_t js_endTime &#x3D; CFAbsoluteTimeGetCurrent() ;</span><br><span class="line">    JSLog(@&quot;dispatch_semaphore_t: %f ms&quot;,(js_endTime - js_beginTime)*1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** os_unfair_lock_lock 性能 *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">    os_unfair_lock js_unfairlock &#x3D; OS_UNFAIR_LOCK_INIT;</span><br><span class="line">    double_t js_beginTime &#x3D; CFAbsoluteTimeGetCurrent();</span><br><span class="line">    for (int i&#x3D;0 ; i &lt; js_runTimes; i++) &#123;</span><br><span class="line">        os_unfair_lock_lock(&amp;js_unfairlock);</span><br><span class="line">        os_unfair_lock_unlock(&amp;js_unfairlock);</span><br><span class="line">    &#125;</span><br><span class="line">    double_t js_endTime &#x3D; CFAbsoluteTimeGetCurrent() ;</span><br><span class="line">    JSLog(@&quot;os_unfair_lock_lock: %f ms&quot;,(js_endTime - js_beginTime)*1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;** pthread_mutex_t 性能 *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_t js_metext &#x3D; PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">  </span><br><span class="line">    double_t js_beginTime &#x3D; CFAbsoluteTimeGetCurrent();</span><br><span class="line">    for (int i&#x3D;0 ; i &lt; js_runTimes; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;js_metext);</span><br><span class="line">        pthread_mutex_unlock(&amp;js_metext);</span><br><span class="line">    &#125;</span><br><span class="line">    double_t js_endTime &#x3D; CFAbsoluteTimeGetCurrent() ;</span><br><span class="line">    JSLog(@&quot;pthread_mutex_t: %f ms&quot;,(js_endTime - js_beginTime)*1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;** NSlock 性能 *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">    NSLock *js_lock &#x3D; [NSLock new];</span><br><span class="line">    double_t js_beginTime &#x3D; CFAbsoluteTimeGetCurrent();</span><br><span class="line">    for (int i&#x3D;0 ; i &lt; js_runTimes; i++) &#123;</span><br><span class="line">        [js_lock lock];</span><br><span class="line">        [js_lock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">    double_t js_endTime &#x3D; CFAbsoluteTimeGetCurrent() ;</span><br><span class="line">    JSLog(@&quot;NSlock: %f ms&quot;,(js_endTime - js_beginTime)*1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** NSCondition 性能 *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">    NSCondition *js_condition &#x3D; [NSCondition new];</span><br><span class="line">    double_t js_beginTime &#x3D; CFAbsoluteTimeGetCurrent();</span><br><span class="line">    for (int i&#x3D;0 ; i &lt; js_runTimes; i++) &#123;</span><br><span class="line">        [js_condition lock];</span><br><span class="line">        [js_condition unlock];</span><br><span class="line">    &#125;</span><br><span class="line">    double_t js_endTime &#x3D; CFAbsoluteTimeGetCurrent() ;</span><br><span class="line">    JSLog(@&quot;NSCondition: %f ms&quot;,(js_endTime - js_beginTime)*1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** PTHREAD_MUTEX_RECURSIVE 性能 *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_t js_metext_recurive;</span><br><span class="line">    pthread_mutexattr_t attr;</span><br><span class="line">    pthread_mutexattr_init (&amp;attr);</span><br><span class="line">    pthread_mutexattr_settype (&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">    pthread_mutex_init (&amp;js_metext_recurive, &amp;attr);</span><br><span class="line">    </span><br><span class="line">    double_t js_beginTime &#x3D; CFAbsoluteTimeGetCurrent();</span><br><span class="line">    for (int i&#x3D;0 ; i &lt; js_runTimes; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;js_metext_recurive);</span><br><span class="line">        pthread_mutex_unlock(&amp;js_metext_recurive);</span><br><span class="line">    &#125;</span><br><span class="line">    double_t js_endTime &#x3D; CFAbsoluteTimeGetCurrent() ;</span><br><span class="line">    JSLog(@&quot;PTHREAD_MUTEX_RECURSIVE: %f ms&quot;,(js_endTime - js_beginTime)*1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** NSRecursiveLock 性能 *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">    NSRecursiveLock *js_recursiveLock &#x3D; [NSRecursiveLock new];</span><br><span class="line">    double_t js_beginTime &#x3D; CFAbsoluteTimeGetCurrent();</span><br><span class="line">    for (int i&#x3D;0 ; i &lt; js_runTimes; i++) &#123;</span><br><span class="line">        [js_recursiveLock lock];</span><br><span class="line">        [js_recursiveLock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">    double_t js_endTime &#x3D; CFAbsoluteTimeGetCurrent() ;</span><br><span class="line">    JSLog(@&quot;NSRecursiveLock: %f ms&quot;,(js_endTime - js_beginTime)*1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;** NSConditionLock 性能 *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">    NSConditionLock *js_conditionLock &#x3D; [NSConditionLock new];</span><br><span class="line">    double_t js_beginTime &#x3D; CFAbsoluteTimeGetCurrent();</span><br><span class="line">    for (int i&#x3D;0 ; i &lt; js_runTimes; i++) &#123;</span><br><span class="line">        [js_conditionLock lock];</span><br><span class="line">        [js_conditionLock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">    double_t js_endTime &#x3D; CFAbsoluteTimeGetCurrent() ;</span><br><span class="line">    JSLog(@&quot;NSConditionLock: %f ms&quot;,(js_endTime - js_beginTime)*1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** @synchronized 性能 *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">    double_t js_beginTime &#x3D; CFAbsoluteTimeGetCurrent();</span><br><span class="line">    for (int i&#x3D;0 ; i &lt; js_runTimes; i++) &#123;</span><br><span class="line">        @synchronized(self) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    double_t js_endTime &#x3D; CFAbsoluteTimeGetCurrent() ;</span><br><span class="line">    JSLog(@&quot;@synchronized: %f ms&quot;,(js_endTime - js_beginTime)*1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在iPhone 12pro模拟器打印的结果为：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e27af26dedf46ff9c3bc053105c7f1d~tplv-k3u1fbpfcp-watermark.image" alt="模拟器锁性能"></p>
<p>在iPhone12 mini真机的结果如下：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c6345a8d4df4656a9edb72697e8c6e9~tplv-k3u1fbpfcp-watermark.image" alt="12mini锁的性能"></p>
<p>可以看到模拟器上<strong>@synchronized</strong>锁性能是比较差的，但12系列(xr经过测试并没提高)手机的性能有很大提升，我们项目中会比较常见，我们就从<strong>@synchronized</strong>开始探索。</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a><strong>@synchronized</strong></h3><h4 id="xcrun分析"><a href="#xcrun分析" class="headerlink" title="xcrun分析"></a>xcrun分析</h4><p>我们在<code>main.m</code>文件里写一个锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    NSString * appDelegateClassName;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        &#x2F;&#x2F; Setup code that might create autoreleased objects goes here.</span><br><span class="line">        appDelegateClassName &#x3D; NSStringFromClass([AppDelegate class]);</span><br><span class="line">        @synchronized (appDelegateClassName) &#123;</span><br><span class="line">       </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return UIApplicationMain(argc, argv, nil, appDelegateClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>xcrun</code>命令将其编译成<code>.cpp</code>文件</p>
<p><code>xcrun -sdk iphoneos clang -arch arm64e -rewrite-objc main.m</code></p>
<p>在<code>main.cpp</code>文件最下方找到<code>main</code>函数的实习，定位到<code>@synchronized</code>代码块</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db699552afd14951b6c3695a353a7d51~tplv-k3u1fbpfcp-watermark.image" alt="xcrunsyn"></p>
<p>将代码排版之后：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  id _rethrow = <span class="number">0</span>; </span><br><span class="line">  id _sync_obj = (id)appDelegateClassName; </span><br><span class="line">  objc_sync_enter(_sync_obj);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">SYNC_EXIT</span> &#123;</span></span><br><span class="line">         _SYNC_EXIT(id arg) : sync_exit(arg) &#123;&#125;</span><br><span class="line">       ~_SYNC_EXIT() &#123;objc_sync_exit(sync_exit);&#125;</span><br><span class="line">        id sync_exit;</span><br><span class="line">    &#125; </span><br><span class="line">    _sync_exit(_sync_obj);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (id e) &#123;_rethrow = e;&#125;</span><br><span class="line">  &#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">FIN</span> &#123;</span> _FIN(id reth) : rethrow(reth) &#123;&#125;</span><br><span class="line">  ~_FIN() &#123; <span class="keyword">if</span> (rethrow) objc_exception_throw(rethrow); &#125;</span><br><span class="line">  id rethrow;</span><br><span class="line">&#125; _fin_force_rethow(_rethrow);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加锁成功的情况我们只需要关注<code>try</code>代码块及以上的代码。经过我们的简化后的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id _sync_obj = (id)appDelegateClassName; </span><br><span class="line">objc_sync_enter(_sync_obj);</span><br><span class="line">objc_sync_exit(sync_exit);</span><br></pre></td></tr></table></figure>

<p>可以看到主要就是执行了两个函数<code>objc_sync_enter</code>和<code>objc_sync_exit</code>。</p>
<h4 id="libobjc源码分析"><a href="#libobjc源码分析" class="headerlink" title="libobjc源码分析"></a>libobjc源码分析</h4><p>通过打符号断点<code>objc_sync_enter</code>,我们可以知道<code>objc_sync_enter</code>在<code>libobjc</code>源码中。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/852b8ac50ca64cb6aa06a11eb15f9546~tplv-k3u1fbpfcp-watermark.image" alt="libobjc_enter"></p>
<p>接下来我们在<code>libobjc</code>源码中全局搜索<code>objc_sync_enter</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">objc_sync_enter</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;<span class="comment">///重要代码</span></span><br><span class="line">        SyncData* data = id2data(obj, ACQUIRE);</span><br><span class="line">        ASSERT(data);</span><br><span class="line">        data-&gt;mutex.lock();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">        <span class="keyword">if</span> (DebugNilSync) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        objc_sync_nil();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果传入<code>obj</code>为<code>nil</code>,会什么也不做。主要看<code>if</code>代码块的代码，可以看到加锁是通过<code>data-&gt;mutex.lock()</code>,也就是<code>SyncData</code>的实例，所以我们先探究一下<code>SyncData</code>类型的结构：</p>
<h5 id="SyncData"><a href="#SyncData" class="headerlink" title="SyncData"></a>SyncData</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> struct <span class="title">alignas</span><span class="params">(CacheLineSize)</span> SyncData </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SyncData</span>* <span class="title">nextData</span>;</span></span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; object;</span><br><span class="line">    <span class="keyword">int32_t</span> threadCount;  <span class="comment">// number of THREADS using this block</span></span><br><span class="line">    <span class="keyword">recursive_mutex_t</span> mutex;</span><br><span class="line">&#125; SyncData;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>nextData</code>：链表结构下一个节点</li>
<li><code>object</code>：参照关联对象的结构，哈希表</li>
<li><code>threadCount</code>：使用block的线程数量</li>
<li><code>mutex</code>：递归锁（单用多线程会出现问题）</li>
</ul>
<p>在初始化<code>SyncData</code>实例的时候使用的是<code>id2data</code>函数，我们接下来探索这个函数。</p>
<h5 id="id2data函数"><a href="#id2data函数" class="headerlink" title="id2data函数"></a>id2data函数</h5><p><code>id2data</code>函数有150+行，我们先隐藏代码块，总览一下结构：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02d33a39e653474f9471c6e0e1ef2994~tplv-k3u1fbpfcp-watermark.image" alt="id2data"></p>
<p>函数的最开始两行有两个宏，它们的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_FOR_OBJ(obj) sDataLists[obj].lock</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_FOR_OBJ(obj) sDataLists[obj].data</span></span><br><span class="line"><span class="keyword">static</span> StripedMap&lt;SyncList&gt; sDataLists;</span><br></pre></td></tr></table></figure>

<p><code>sDataLists</code>是一个静态哈希表结构，我们使用<code>lldb</code>查看它的数据结构：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/328a178a46ec4d4cb286a8360e332ddc~tplv-k3u1fbpfcp-watermark.image" alt="sData"></p>
<p>经过断点调试，第一次进来执行的代码是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">posix_memalign((<span class="keyword">void</span> **)&amp;result, <span class="keyword">alignof</span>(SyncData), <span class="keyword">sizeof</span>(SyncData));</span><br><span class="line">result-&gt;object = (objc_object *)object;</span><br><span class="line">result-&gt;threadCount = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">new</span> (&amp;result-&gt;mutex) <span class="keyword">recursive_mutex_t</span>(fork_unsafe_lock);</span><br><span class="line">result-&gt;nextData = *listp;<span class="comment">//头插法 添加近链表</span></span><br><span class="line">*listp = result;</span><br></pre></td></tr></table></figure>

<p>这里有个细节就是<code>listp</code>使用的<code>头插法</code>将新的元素添加到链表，它的可递归性的实现依赖了这种数据结构的使用。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>synchronized的数据结构是哈希表，采用的拉链法处理哈希冲突</li>
<li>sDataLists arrary key是和对象相关的，拉链链表里的元素是同一个对象的锁。</li>
<li>objc_sync_enter和objc_sync_exit是对称的，它是一把递归锁。</li>
<li>会有两种存储结构：tls和catch</li>
<li>第一次访问syncData采用的是头插法链表结构 标记threadCount = 1</li>
<li>后续访问，会判断是不是同一个对象，同一对象lockcount++,不是同一个对象threadCount++1。</li>
<li>synchronized是一种可重入、递归的多线程锁，原因<ul>
<li>tls保障 threadCount 可以有多个线程对这个锁对象加锁</li>
<li>lock++会记录总共锁了多少次。</li>
</ul>
</li>
</ul>
<h3 id="NSLock和NSRecursiveLock使用"><a href="#NSLock和NSRecursiveLock使用" class="headerlink" title="NSLock和NSRecursiveLock使用"></a>NSLock和NSRecursiveLock使用</h3><p>我们以一个实例分析这两种锁的区别：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">void</span> (^testMethod)(<span class="keyword">int</span>);</span><br><span class="line">        testMethod = ^(<span class="keyword">int</span> value)&#123;</span><br><span class="line">        <span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"current value = %d"</span>,value);</span><br><span class="line">            testMethod(value - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        testMethod(<span class="number">10</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个代码有多线程冲突的问题，打印的结果无序，不是我们想要的结果</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e83ec7588234014956e787a0991f1ba~tplv-k3u1fbpfcp-watermark.image" alt="没有锁无序"></p>
<h4 id="使用NSLock解决问题"><a href="#使用NSLock解决问题" class="headerlink" title="使用NSLock解决问题"></a>使用<code>NSLock</code>解决问题</h4><p>使用<code>NSLock</code>解决的方法其实很简单，就是在我们调用方法<code>testMethod</code>前后加锁。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a874305ec494450ab33acfb02f644768~tplv-k3u1fbpfcp-watermark.image" alt="nslock"></p>
<p>我们再看打印结果就正常了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/467c7996864941688b3ca24a63d15e0a~tplv-k3u1fbpfcp-watermark.image" alt="nslock打印结果"></p>
<p><code>NSLock</code>适用的是在最外层加锁，如果我们能写的代码只能在<code>testMethod</code>操作，这个时候加<code>NSLock</code>就不会正常工作了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a4425ac2c0541c3af2d506802ebf03c~tplv-k3u1fbpfcp-watermark.image" alt="nslock加在业务代码"></p>
<h4 id="使用NSRecursiveLock"><a href="#使用NSRecursiveLock" class="headerlink" title="使用NSRecursiveLock"></a>使用NSRecursiveLock</h4><p>上面我们知道<code>NSLock</code>在<code>testMethod</code>无法解决问题，我们尝试用<code>NSRecursiveLock</code>解决。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e05a791f9e0e4be78679301542fd64aa~tplv-k3u1fbpfcp-watermark.image" alt="nsrecrusiveLock"></p>
<p>发现<code>NSRecursiveLock</code>并不能解决问题，而且还会偶现崩溃。<code>NSRecursiveLock</code>是一把递归锁，但是它并不支持多线程递归。</p>
<h4 id="使用-synchronized"><a href="#使用-synchronized" class="headerlink" title="使用@synchronized"></a>使用@synchronized</h4><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5223b33727034d4eaf5490d7d8a08fdf~tplv-k3u1fbpfcp-watermark.image" alt="sychorsize解决问题"></p>
<p>使用@synchronized解决了业务代码里的问题，说明@synchronized是一把支持多线程的递归锁。</p>
<h3 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h3><p><strong>NSCondition</strong> 的对象实际上作为一个锁和一个线程检查器:锁主要 为了当检测条件时保护数据源，执行条件引发的任务;线程检查器 主要是根据条件决定是否继续运行线程，即线程是否被阻塞。它主要有四个方法</p>
<ul>
<li><strong>[condition lock]</strong>：一般用于多线程同时访问、修改同一个数据源，保证在同一 时间内数据源只被访问、修改一次，其他线程的命令需要在<strong>lock</strong> 外等待，只到 <strong>unlock</strong> ，才可访问</li>
<li><strong>[condition unlock];//</strong>与<strong>lock</strong> 同时使用</li>
<li><strong>[condition wait];//</strong>让当前线程处于等待状态</li>
<li><strong>[condition signal];//CPU</strong>发信号告诉线程不用在等待，可以继续执行</li>
</ul>
<p>它的一个应用场景之一就是<code>生产者-消费者</code>模型。也就是通过多线程进行生产和销售产品，当产品数量为0的时候就只能等待，具体代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)js_testConditon&#123;</span><br><span class="line">    _testCondition = [[<span class="built_in">NSCondition</span> alloc] init];</span><br><span class="line">    <span class="comment">//创建生产-消费者</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> js_producer];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> js_consumer];</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> js_consumer];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> js_producer];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)js_producer&#123;</span><br><span class="line">    [_testCondition lock]; <span class="comment">// 操作的多线程影响</span></span><br><span class="line">    <span class="keyword">self</span>.ticketCount = <span class="keyword">self</span>.ticketCount + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"生产一个 现有 count %zd"</span>,<span class="keyword">self</span>.ticketCount);</span><br><span class="line">    [_testCondition signal]; <span class="comment">// 信号</span></span><br><span class="line">    [_testCondition unlock];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)js_consumer&#123;</span><br><span class="line">     [_testCondition lock];  <span class="comment">// 操作的多线程影响</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.ticketCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"等待 count %zd"</span>,<span class="keyword">self</span>.ticketCount);</span><br><span class="line">        [_testCondition wait];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意消费行为，要在等待条件判断之后</span></span><br><span class="line">    <span class="keyword">self</span>.ticketCount -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"消费一个 还剩 count %zd "</span>,<span class="keyword">self</span>.ticketCount);</span><br><span class="line">     [_testCondition unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Foundation源码看锁的封装"><a href="#Foundation源码看锁的封装" class="headerlink" title="Foundation源码看锁的封装"></a>Foundation源码看锁的封装</h3><p>我们在<code>swift-corelibs-foundation</code>源码中探索。</p>
<p>通过源码我们看到，<code>NSLock</code>等锁都实现了一个协议就是<code>NSLocking</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">NSLocking</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它们都是对<code>pthread</code>的封装</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/582cb7845b854b7e97338ddb9618d7a0~tplv-k3u1fbpfcp-watermark.image" alt="锁的源码"></p>
<p>NSRecursiveLock，也类似，它和<code>NSLock</code>的区别是<code>pthread_mutexattr_settype(attrs, Int32(PTHREAD_MUTEX_RECURSIVE))</code></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30104e8b0ae74ff8a0c3d7123644dc6c~tplv-k3u1fbpfcp-watermark.image" alt="nsrecursivelock源码"></p>
<h3 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a>NSConditionLock</h3><ul>
<li><strong>NSConditionLock</strong> 是锁，一旦一个线程获得锁，其他线程一定等待</li>
<li>lock函数：表示 对象期待获得锁，如果没有其他线程获得锁(不需要判断内部的 <strong>condition)</strong> 那它能执行此行以下代码，如果已经有其他线程获得锁(可能是条件锁，或者无条件 锁)，则等待，直至其他线程解锁</li>
<li>[xx <strong>lockWhenCondition</strong>：<strong>:A</strong>条件]方法：表示如果没有其他线程获得该锁，但是该锁内部的 <strong>condition</strong>不等于<strong>A</strong>条件，它依然不能获得锁，仍然等待。如果内部的<strong>condition</strong>等于<strong>A</strong>条件，并且 没有其他线程获得该锁，则进入代码区，同时设置它获得该锁，其他任何线程都将等待它代码的 完成，直至它解锁。</li>
<li><strong>[xxx unlockWithCondition:A</strong>条件<strong>];</strong> 表示释放锁，同时把内部的<strong>condition</strong>设置为<strong>A</strong>条件</li>
<li><strong>return = [xxx lockWhenCondition:A</strong>条件 <strong>beforeDate:A</strong>时间<strong>];</strong> 表示如果被锁定(没获得 锁)，并超过该时间则不再阻塞线程。但是注意:返回的值是<strong>NO,</strong>它没有改变锁的状态，这个函 数的目的在于可以实现两种状态下的处理。</li>
</ul>
<h3 id="栅栏函数实现读写锁"><a href="#栅栏函数实现读写锁" class="headerlink" title="栅栏函数实现读写锁"></a>栅栏函数实现读写锁</h3><p>读写锁主要要实现以下功能：</p>
<ul>
<li>多读单写功能。</li>
<li>写入和写入互斥。</li>
<li>读和写入互斥。</li>
<li>写入不能阻塞主线程任务执行。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">dispatch_queue_t</span> js_currentQueue;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *mDict;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.js_currentQueue = dispatch_queue_create(<span class="string">"jscurrent"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    <span class="keyword">self</span>.mDict = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line">    [<span class="keyword">self</span> js_safeSetter:<span class="string">@"123"</span> time:<span class="number">10</span>];</span><br><span class="line">    [<span class="keyword">self</span> js_safeSetter:<span class="string">@"456"</span> time:<span class="number">5</span>];</span><br><span class="line">    [<span class="keyword">self</span> js_safeSetter:<span class="string">@"789"</span> time:<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"读取，name = %@ thread---%@"</span>,[<span class="keyword">self</span> js_safeGetter],[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)js_safeSetter:(<span class="built_in">NSString</span> *)name time:(<span class="keyword">int</span>)time&#123;</span><br><span class="line">    dispatch_barrier_async(<span class="keyword">self</span>.js_currentQueue, ^&#123;</span><br><span class="line">        sleep(time);</span><br><span class="line">        [<span class="keyword">self</span>.mDict setValue:name forKey:<span class="string">@"name"</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"写入，name = %@ thread---%@"</span>,name,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)js_safeGetter&#123;</span><br><span class="line">    __block <span class="built_in">NSString</span> *result;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.js_currentQueue, ^&#123;</span><br><span class="line">        result = <span class="keyword">self</span>.mDict[<span class="string">@"name"</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>程序运行我们就开始点击屏幕(读操作)，最后看打印结果：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2b276d04dd04fd88e2f06568a9d8546~tplv-k3u1fbpfcp-watermark.image" alt="读写锁"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/08/21/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-GCD-%E4%B8%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/21/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-GCD-%E4%B8%89/" class="post-title-link" itemprop="url">iOS多线程 - GCD(三)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-21 17:38:29" itemprop="dateCreated datePublished" datetime="2021-08-21T17:38:29+08:00">2021-08-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-23 23:19:34" itemprop="dateModified" datetime="2021-08-23T23:19:34+08:00">2021-08-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前两篇我们主要探索了<code>GCD</code>的函数和队列的调度及死锁和单例，本篇我们开始探索<code>GCD</code>的其他函数。</p>
<h3 id="栅栏函数"><a href="#栅栏函数" class="headerlink" title="栅栏函数"></a>栅栏函数</h3><p>栅栏函数最直接的作用是：控制任务执行顺序，同步</p>
<ul>
<li>dispatch_battier_async 前面的任务执行完毕才会来到这里。</li>
<li>dispatch_battier_sync 作用相同，但是会阻塞线程，影响后面的任务执行。 </li>
<li>栅栏函数只能控制同一并发队列。</li>
</ul>
<h4 id="栅栏函数的使用"><a href="#栅栏函数的使用" class="headerlink" title="栅栏函数的使用"></a>栅栏函数的使用</h4><p>我们一般会如下使用栅栏函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t concurrentQueue &#x3D; dispatch_queue_create(&quot;jason&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;123&quot;);</span><br><span class="line">&#125;); </span><br><span class="line">dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">    sleep(1);</span><br><span class="line">    NSLog(@&quot;456&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_barrier_async(concurrentQueue1, ^&#123;</span><br><span class="line">    NSLog(@&quot;----%@-----&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;789&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;10 11 12&quot;);</span><br></pre></td></tr></table></figure>

<p>我们打印结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">10</span> <span class="number">11</span> <span class="number">12</span></span><br><span class="line"><span class="number">456</span></span><br><span class="line">----&lt;NSThread: <span class="number">0x6000012ca180</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125;-----</span><br><span class="line"><span class="number">789</span></span><br></pre></td></tr></table></figure>

<p>可以看到栅栏函数阻塞了自己的<code>block</code>和后续异步函数的执行，也就是必须前面的函数执行之后才会执行后续操作。</p>
<p>我们换成同步栅栏函数再执行一次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_barrier_sync(concurrentQueue1, ^&#123;</span><br><span class="line">    NSLog(@&quot;----%@-----&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">456</span><br><span class="line">----&lt;NSThread: 0x6000025a4140&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;-----</span><br><span class="line">10 11 12</span><br><span class="line">789</span><br></pre></td></tr></table></figure>

<p>可以看到<code>dispatch_battier_sync</code>阻塞了<code>NSLog(@&quot;10 11 12&quot;);</code>代码的执行。</p>
<p>注意：还有一个点需要注意就是<code>栅栏函数</code>不能阻塞<code>全局并发队列</code>。</p>
<p>接下来我们从源码层面看<code>栅栏函数</code>的实现以及为什么全局并发队列不能被<code>栅栏函数</code>阻塞。</p>
<h4 id="栅栏函数底层原理"><a href="#栅栏函数底层原理" class="headerlink" title="栅栏函数底层原理"></a>栅栏函数底层原理</h4><p>我们还是以同步函数<code>dispatch_barrier_sync</code>为例探索</p>
<p>调试代码如图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fccfb4fa9b1f495aacd0d7731e726902~tplv-k3u1fbpfcp-watermark.image" alt="1629551309944"></p>
<p>调试代码有个点就是<code>sleep(30)</code>方便调试等待前面方法执行完成之前的调用。</p>
<p>我们从<code>libdispatch</code>源码中搜索<code>dispatch_barrier_sync</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_barrier_sync(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_block_t</span> work)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uintptr_t</span> dc_flags = DC_FLAG_BARRIER | DC_FLAG_BLOCK;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(_dispatch_block_has_private_data(work))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_block_with_privdata(dq, work, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_barrier_sync_f(dq, work, _dispatch_Block_invoke(work), dc_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了<code>_dispatch_barrier_sync_f</code>函数，继续跟进去：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_barrier_sync_f(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	_dispatch_barrier_sync_f_inline(dq, ctxt, func, dc_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>_dispatch_barrier_sync_f_inline</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_barrier_sync_f_inline(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_tid tid = _dispatch_tid_self();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(dx_metatype(dq) != _DISPATCH_LANE_TYPE)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(<span class="number">0</span>, <span class="string">"Queue type doesn't support dispatch_sync"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">dispatch_lane_t</span> dl = upcast(dq)._dl;</span><br><span class="line">	<span class="comment">// The more correct thing to do would be to merge the qos of the thread</span></span><br><span class="line">	<span class="comment">// that just acquired the barrier lock into the queue state.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// However this is too expensive for the fast path, so skip doing it.</span></span><br><span class="line">	<span class="comment">// The chosen tradeoff is that if an enqueue on a lower priority thread</span></span><br><span class="line">	<span class="comment">// contends with this fast path, this thread may receive a useless override.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Global concurrent queues and queues bound to non-dispatch threads</span></span><br><span class="line">	<span class="comment">// always fall into the slow case, see DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!_dispatch_queue_try_acquire_barrier_sync(dl, tid))) &#123;</span><br><span class="line">    <span class="comment">//经过断点调试执行了这里</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_f_slow(dl, ctxt, func, DC_FLAG_BARRIER, dl,</span><br><span class="line">				DC_FLAG_BARRIER | dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(dl-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_recurse(dl, ctxt, func,</span><br><span class="line">				DC_FLAG_BARRIER | dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_introspection_sync_begin(dl);</span><br><span class="line">	_dispatch_lane_barrier_sync_invoke_and_complete(dl, ctxt, func</span><br><span class="line">			DISPATCH_TRACE_ARG(_dispatch_trace_item_sync_push_pop(</span><br><span class="line">					dq, ctxt, func, dc_flags | DC_FLAG_BARRIER)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们加两个符号断点调试一下看看执行的是<code>_dispatch_sync_f_slow</code>还是<code>_dispatch_sync_recurse</code>,经过添加符号断点实际调用了<code>_dispatch_sync_f_slow</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_f_slow(<span class="keyword">dispatch_queue_class_t</span> top_dqu, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func, <span class="keyword">uintptr_t</span> top_dc_flags,</span><br><span class="line">		<span class="keyword">dispatch_queue_class_t</span> dqu, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> top_dq = top_dqu._dq;</span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> dq = dqu._dq;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!dq-&gt;do_targetq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_function_invoke(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pthread_priority_t</span> pp = _dispatch_get_priority();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_sync_context_s</span> <span class="title">dsc</span> = &#123;</span></span><br><span class="line">		.dc_flags    = DC_FLAG_SYNC_WAITER | dc_flags,</span><br><span class="line">		.dc_func     = _dispatch_async_and_wait_invoke,</span><br><span class="line">		.dc_ctxt     = &amp;dsc,</span><br><span class="line">		.dc_other    = top_dq,</span><br><span class="line">		.dc_priority = pp | _PTHREAD_PRIORITY_ENFORCE_FLAG,</span><br><span class="line">		.dc_voucher  = _voucher_get(),</span><br><span class="line">		.dsc_func    = func,</span><br><span class="line">		.dsc_ctxt    = ctxt,</span><br><span class="line">		.dsc_waiter  = _dispatch_tid_self(),</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	_dispatch_trace_item_push(top_dq, &amp;dsc);</span><br><span class="line">	__DISPATCH_WAIT_FOR_QUEUE__(&amp;dsc, dq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dsc.dsc_func == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">// dsc_func being cleared means that the block ran on another thread ie.</span></span><br><span class="line">		<span class="comment">// case (2) as listed in _dispatch_async_and_wait_f_slow.</span></span><br><span class="line">		<span class="keyword">dispatch_queue_t</span> stop_dq = dsc.dc_other;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_complete_recurse(top_dq, stop_dq, top_dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_introspection_sync_begin(top_dq);</span><br><span class="line">	_dispatch_trace_item_pop(top_dq, &amp;dsc);</span><br><span class="line">	_dispatch_sync_invoke_and_complete_recurse(top_dq, ctxt, func,top_dc_flags</span><br><span class="line">			DISPATCH_TRACE_ARG(&amp;dsc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_dispatch_sync_f_slow</code>函数我们比较熟悉了，在上一篇探索过，我们继续添加符号断点，</p>
<p><strong>这里有个细节</strong>，就是会先调用<code>__DISPATCH_WAIT_FOR_QUEUE__</code>等待<code>sleep(300);</code>的调用结束说明等待的过程是<code>__DISPATCH_WAIT_FOR_QUEUE__</code>处理，接着会调用到<code>dq_push</code>及<code>_dispatch_lane_concurrent_push</code>函数-&gt;<code>_dispatch_lane_push</code>-&gt;<code>_dispatch_lane_push_waiter</code>也就是阻塞了当前队列。</p>
<ul>
<li>自定义并发队列会执行<code>_dispatch_lane_wakeup</code>会有等待<code>barrier</code>的判断。</li>
<li>全局并发队列会执行<code>_dispatch_root_queue_wakeup</code>方法，所以不会有等待的方法,所以不会阻塞</li>
</ul>
<p>等待执行的队列完成之后会调用<code>_dispatch_lane_class_barrier_complete</code>函数-&gt;<code>dx_wakeup</code>-&gt;<code>_dispatch_lane_wakeup</code>-&gt;<code>_dispatch_queue_wakeup</code>。</p>
<p>这里会调用<code>_dispatch_client_callout</code>函数，然后同步函数就接着被执行了。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><h4 id="信号量的使用"><a href="#信号量的使用" class="headerlink" title="信号量的使用"></a>信号量的使用</h4><p>先看使用代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">dispatch_semaphore_t sem &#x3D; dispatch_semaphore_create(0);</span><br><span class="line"> &#x2F;&#x2F;任务1</span><br><span class="line"> dispatch_async(queue, ^&#123;</span><br><span class="line">     dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER); &#x2F;&#x2F; sem开始为0 需要等待等待</span><br><span class="line">     NSLog(@&quot;执行任务1&quot;);</span><br><span class="line">     NSLog(@&quot;任务1完成&quot;);</span><br><span class="line"> &#125;);</span><br><span class="line"> &#x2F;&#x2F;任务2</span><br><span class="line"> dispatch_async(queue, ^&#123;</span><br><span class="line">     sleep(2);</span><br><span class="line">     NSLog(@&quot;执行任务2&quot;);</span><br><span class="line">     NSLog(@&quot;任务2完成&quot;);</span><br><span class="line">     dispatch_semaphore_signal(sem); &#x2F;&#x2F; 发信号 sem+1</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<p>信号量主要有三个函数：</p>
<ul>
<li>dispatch_semaphore_create：创建信号量</li>
<li>dispatch_semaphore_wait：等待信号量</li>
<li>dispatch_semaphore_signal：信号量释放</li>
</ul>
<p>它可以控制<code>GCD</code>的最大并发数。</p>
<h4 id="信号量的底层原理"><a href="#信号量的底层原理" class="headerlink" title="信号量的底层原理"></a>信号量的底层原理</h4><p>底层原理其实就是三个方法的探索，我们依次探索</p>
<h5 id="dispatch-semaphore-wait"><a href="#dispatch-semaphore-wait" class="headerlink" title="dispatch_semaphore_wait"></a>dispatch_semaphore_wait</h5><p>全局搜索<code>dispatch_semaphore_wait</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">intptr_t</span></span><br><span class="line">dispatch_semaphore_wait(<span class="keyword">dispatch_semaphore_t</span> dsema, <span class="keyword">dispatch_time_t</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//--1</span></span><br><span class="line">	<span class="keyword">long</span> value = os_atomic_dec2o(dsema, dsema_value, acquire);</span><br><span class="line">	<span class="keyword">if</span> (likely(value &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_semaphore_wait_slow(dsema, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面的例子我们创建的信号量为0，经过–操作&lt;0，会执行<code>_dispatch_semaphore_wait_slow</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">intptr_t</span></span><br><span class="line">_dispatch_semaphore_wait_slow(<span class="keyword">dispatch_semaphore_t</span> dsema,</span><br><span class="line">		<span class="keyword">dispatch_time_t</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">long</span> orig;</span><br><span class="line"></span><br><span class="line">	_dispatch_sema4_create(&amp;dsema-&gt;dsema_sema, _DSEMA4_POLICY_FIFO);</span><br><span class="line">	<span class="keyword">switch</span> (timeout) &#123;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">if</span> (!_dispatch_sema4_timedwait(&amp;dsema-&gt;dsema_sema, timeout)) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Fall through and try to undo what the fast path did to</span></span><br><span class="line">		<span class="comment">// dsema-&gt;dsema_value</span></span><br><span class="line">	<span class="keyword">case</span> DISPATCH_TIME_NOW:</span><br><span class="line">    <span class="comment">//超时操作</span></span><br><span class="line">		orig = dsema-&gt;dsema_value;</span><br><span class="line">		<span class="keyword">while</span> (orig &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (os_atomic_cmpxchgv2o(dsema, dsema_value, orig, orig + <span class="number">1</span>,</span><br><span class="line">					&amp;orig, relaxed)) &#123;</span><br><span class="line">				<span class="keyword">return</span> _DSEMA4_TIMEOUT();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Another thread called semaphore_signal().</span></span><br><span class="line">		<span class="comment">// Fall through and drain the wakeup.</span></span><br><span class="line">	<span class="keyword">case</span> DISPATCH_TIME_FOREVER:</span><br><span class="line">     <span class="comment">//一直等待</span></span><br><span class="line">		_dispatch_sema4_wait(&amp;dsema-&gt;dsema_sema);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见等待的函数是<code>_dispatch_sema4_wait</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_sema4_wait(<span class="keyword">_dispatch_sema4_t</span> *sema)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		ret = sem_wait(sema);</span><br><span class="line">	&#125; <span class="keyword">while</span> (ret == <span class="number">-1</span> &amp;&amp; errno == EINTR);</span><br><span class="line">	DISPATCH_SEMAPHORE_VERIFY_RET(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sem_wait</code>是c语言的方法，这里是一个do-while循环事宜等待信号量的值满足条件。</p>
<p>#####dispatch_semaphore_signal</p>
<p>全局搜索<code>dispatch_semaphore_signal</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">intptr_t</span></span><br><span class="line">dispatch_semaphore_signal(<span class="keyword">dispatch_semaphore_t</span> dsema)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//++1</span></span><br><span class="line">	<span class="keyword">long</span> value = os_atomic_inc2o(dsema, dsema_value, <span class="built_in">release</span>);</span><br><span class="line">	<span class="keyword">if</span> (likely(value &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(value == LONG_MIN)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(value,</span><br><span class="line">				<span class="string">"Unbalanced call to dispatch_semaphore_signal()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_semaphore_signal_slow(dsema);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里信号量++一次，如果信号量&gt;0就可以正常执行了，如果信号量还是&lt;=0,会进入函数<code>_dispatch_semaphore_signal_slow</code>,它是异常的处理一直++信号量的值，直到返回的值为正值。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li><code>dispatch_semaphore_create</code>:初始化信号量。</li>
<li><code>dispatch_semaphore_wait</code>：对信号量的value–</li>
<li><code>dispatch_semaphore_signal</code>对信号量的value++</li>
</ul>
<h3 id="调度组"><a href="#调度组" class="headerlink" title="调度组"></a>调度组</h3><p>####调度组的使用</p>
<p>有时候我们可能需要等待多个接口都返回数据才能进行下一步的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group &#x3D; dispatch_group_create();</span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">      &#x2F;&#x2F;下载任务1</span><br><span class="line">      sleep(2);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">      &#x2F;&#x2F;下载任务2</span><br><span class="line">      sleep(2);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line"> 			&#x2F;&#x2F;组里任务都执行之后，下一步的操作。	</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group &#x3D; dispatch_group_create();</span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">      &#x2F;&#x2F;下载任务1</span><br><span class="line">      sleep(2);</span><br><span class="line">      dispatch_group_leave(group);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">      &#x2F;&#x2F;下载任务2</span><br><span class="line">      sleep(2);</span><br><span class="line">      dispatch_group_leave(group);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line"> 			&#x2F;&#x2F;组里任务都执行之后，下一步的操作。	</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="调度组底层原理"><a href="#调度组底层原理" class="headerlink" title="调度组底层原理"></a>调度组底层原理</h4><p>我们从三个方面分析，组是如何控制同步的、<code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>的搭配、<code>dispatch_group_async</code>的原理。</p>
<h5 id="dispatch-group-create函数"><a href="#dispatch-group-create函数" class="headerlink" title="dispatch_group_create函数"></a>dispatch_group_create函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t</span><br><span class="line">dispatch_group_create(void)</span><br><span class="line">&#123;</span><br><span class="line">	return _dispatch_group_create_with_count(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是创建了一个组的数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_group_t</span></span><br><span class="line">_dispatch_group_create_with_count(<span class="keyword">uint32_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">dispatch_group_t</span> dg = _dispatch_object_alloc(DISPATCH_VTABLE(group),</span><br><span class="line">			<span class="keyword">sizeof</span>(struct dispatch_group_s));</span><br><span class="line">	dg-&gt;do_next = DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">	dg-&gt;do_targetq = _dispatch_get_default_queue(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (n) &#123;</span><br><span class="line">		os_atomic_store2o(dg, dg_bits,</span><br><span class="line">				(<span class="keyword">uint32_t</span>)-n * DISPATCH_GROUP_VALUE_INTERVAL, relaxed);</span><br><span class="line">		os_atomic_store2o(dg, do_ref_cnt, <span class="number">1</span>, relaxed); <span class="comment">// &lt;rdar://22318411&gt;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="dispatch-group-enter函数"><a href="#dispatch-group-enter函数" class="headerlink" title="dispatch_group_enter函数"></a>dispatch_group_enter函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_enter(<span class="keyword">dispatch_group_t</span> dg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// The value is decremented on a 32bits wide atomic so that the carry</span></span><br><span class="line">	<span class="comment">// for the 0 -&gt; -1 transition is not propagated to the upper 32bits.</span></span><br><span class="line">  <span class="comment">/// --操作</span></span><br><span class="line">	<span class="keyword">uint32_t</span> old_bits = os_atomic_sub_orig2o(dg, dg_bits,</span><br><span class="line">			DISPATCH_GROUP_VALUE_INTERVAL, acquire);</span><br><span class="line">	<span class="keyword">uint32_t</span> old_value = old_bits &amp; DISPATCH_GROUP_VALUE_MASK;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(old_value == <span class="number">0</span>)) &#123;</span><br><span class="line">		_dispatch_retain(dg); <span class="comment">// &lt;rdar://problem/22318411&gt;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(old_value == DISPATCH_GROUP_VALUE_MAX)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(old_bits,</span><br><span class="line">				<span class="string">"Too many nested calls to dispatch_group_enter()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开始count == 0，进行–操作，变为-1， </p>
<h5 id="dispatch-group-leave函数"><a href="#dispatch-group-leave函数" class="headerlink" title="dispatch_group_leave函数"></a>dispatch_group_leave函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_leave(<span class="keyword">dispatch_group_t</span> dg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// The value is incremented on a 64bits wide atomic so that the carry for</span></span><br><span class="line">	<span class="comment">// the -1 -&gt; 0 transition increments the generation atomically.</span></span><br><span class="line">	<span class="keyword">uint64_t</span> new_state, old_state = os_atomic_add_orig2o(dg, dg_state,</span><br><span class="line">			DISPATCH_GROUP_VALUE_INTERVAL, <span class="built_in">release</span>);</span><br><span class="line">	<span class="keyword">uint32_t</span> old_value = (<span class="keyword">uint32_t</span>)(old_state &amp; DISPATCH_GROUP_VALUE_MASK);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(old_value == DISPATCH_GROUP_VALUE_1)) &#123;<span class="comment">//old_state == -1</span></span><br><span class="line">		old_state += DISPATCH_GROUP_VALUE_INTERVAL;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			new_state = old_state;</span><br><span class="line">			<span class="keyword">if</span> ((old_state &amp; DISPATCH_GROUP_VALUE_MASK) == <span class="number">0</span>) &#123;</span><br><span class="line">				new_state &amp;= ~DISPATCH_GROUP_HAS_WAITERS;</span><br><span class="line">				new_state &amp;= ~DISPATCH_GROUP_HAS_NOTIFS;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// If the group was entered again since the atomic_add above,</span></span><br><span class="line">				<span class="comment">// we can't clear the waiters bit anymore as we don't know for</span></span><br><span class="line">				<span class="comment">// which generation the waiters are for</span></span><br><span class="line">				new_state &amp;= ~DISPATCH_GROUP_HAS_NOTIFS;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (old_state == new_state) <span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">while</span> (unlikely(!os_atomic_cmpxchgv2o(dg, dg_state,</span><br><span class="line">				old_state, new_state, &amp;old_state, relaxed)));</span><br><span class="line">		<span class="keyword">return</span> _dispatch_group_wake(dg, old_state, <span class="literal">true</span>);<span class="comment">///唤醒 notify</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(old_value == <span class="number">0</span>)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH((<span class="keyword">uintptr_t</span>)old_value,</span><br><span class="line">				<span class="string">"Unbalanced call to dispatch_group_leave()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>count由-1变为0，可以看出<code>old_state != new_state</code>时会一直<code>while</code>循环，当相等是执行<code>_dispatch_group_wake</code>唤醒阻塞的函数。</p>
<p>#####dispatch_group_notify</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_group_notify(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq,</span><br><span class="line">		<span class="keyword">dispatch_continuation_t</span> dsn)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> old_state, new_state;</span><br><span class="line">	<span class="keyword">dispatch_continuation_t</span> prev;</span><br><span class="line"></span><br><span class="line">	dsn-&gt;dc_data = dq;</span><br><span class="line">	_dispatch_retain(dq);</span><br><span class="line"></span><br><span class="line">	prev = os_mpsc_push_update_tail(os_mpsc(dg, dg_notify), dsn, do_next);</span><br><span class="line">	<span class="keyword">if</span> (os_mpsc_push_was_empty(prev)) _dispatch_retain(dg);</span><br><span class="line">	os_mpsc_push_update_prev(os_mpsc(dg, dg_notify), prev, dsn, do_next);</span><br><span class="line">	<span class="keyword">if</span> (os_mpsc_push_was_empty(prev)) &#123;</span><br><span class="line">		os_atomic_rmw_loop2o(dg, dg_state, old_state, new_state, <span class="built_in">release</span>, &#123;</span><br><span class="line">			new_state = old_state | DISPATCH_GROUP_HAS_NOTIFS;</span><br><span class="line">			<span class="keyword">if</span> ((<span class="keyword">uint32_t</span>)old_state == <span class="number">0</span>) &#123;</span><br><span class="line">				os_atomic_rmw_loop_give_up(&#123;<span class="comment">/// block callout函数</span></span><br><span class="line">					<span class="keyword">return</span> _dispatch_group_wake(dg, new_state, <span class="literal">false</span>);</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 可以看到<code>old_state == 0</code>的时候才会执行block，也就是<code>dispatch_group_leave</code>执行完成。</p>
<h5 id="dispatch-group-async"><a href="#dispatch-group-async" class="headerlink" title="dispatch_group_async"></a>dispatch_group_async</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_async(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq,</span><br><span class="line">		<span class="keyword">dispatch_block_t</span> db)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//任务封装</span></span><br><span class="line">	<span class="keyword">dispatch_continuation_t</span> dc = _dispatch_continuation_alloc();</span><br><span class="line">	<span class="keyword">uintptr_t</span> dc_flags = DC_FLAG_CONSUME | DC_FLAG_GROUP_ASYNC;</span><br><span class="line">	<span class="keyword">dispatch_qos_t</span> qos;</span><br><span class="line">	qos = _dispatch_continuation_init(dc, dq, db, <span class="number">0</span>, dc_flags);</span><br><span class="line">	_dispatch_continuation_group_async(dg, dq, dc, qos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_continuation_group_async(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq,</span><br><span class="line">		<span class="keyword">dispatch_continuation_t</span> dc, <span class="keyword">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_group_enter(dg);<span class="comment">//执行了enter</span></span><br><span class="line">	dc-&gt;dc_data = dg;</span><br><span class="line">	_dispatch_continuation_async(dq, dc, qos, dc-&gt;dc_flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_continuation_async(<span class="keyword">dispatch_queue_class_t</span> dqu,</span><br><span class="line">		<span class="keyword">dispatch_continuation_t</span> dc, <span class="keyword">dispatch_qos_t</span> qos, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_INTROSPECTION</span></span><br><span class="line">	<span class="keyword">if</span> (!(dc_flags &amp; DC_FLAG_NO_INTROSPECTION)) &#123;</span><br><span class="line">		_dispatch_trace_item_push(dqu, dc);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	(<span class="keyword">void</span>)dc_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> dx_push(dqu._dq, dc, qos);<span class="comment">//调用的函数 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里在<code>_dispatch_continuation_group_async</code>函数调用了<code>dispatch_group_enter</code>函数，然后再<code>dx_push</code>之后也就是callout函数之后执行了<code>dispatch_group_leave</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_continuation_with_group_invoke(<span class="keyword">dispatch_continuation_t</span> dc)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">dou</span> = <span class="title">dc</span>-&gt;<span class="title">dc_data</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> type = dx_type(dou);</span><br><span class="line">	<span class="keyword">if</span> (type == DISPATCH_GROUP_TYPE) &#123;</span><br><span class="line">		_dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);</span><br><span class="line">		_dispatch_trace_item_complete(dc);</span><br><span class="line">    <span class="comment">///执行了leave方法</span></span><br><span class="line">		dispatch_group_leave((<span class="keyword">dispatch_group_t</span>)dou);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		DISPATCH_INTERNAL_CRASH(dx_type(dou), <span class="string">"Unexpected object type"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul>
<li><code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>成对出现</li>
<li><code>dispatch_group_enter</code>底层对group的value做–操作（0-&gt;1）</li>
<li><code>dispatch_group_leave</code>底层对group的value做++操作（-1-&gt;0）</li>
<li><code>dispatch_group_notify</code>底层判断group的state是否为0，为0就通知执行block。</li>
<li>任务唤醒有两种方式：1、<code>dispatch_group_leave</code>2、<code>dispatch_group_notify</code></li>
<li><code>dispatch_group_async</code>等同于 <code>enter+leave</code>，底层实现包含一对enter+leave。</li>
</ul>
<p>###dispatch_source</p>
<p>dispatch_source我们平时会使用到的场景是一个计时器(倒计时)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (void)timeDone&#123;</span><br><span class="line">    &#x2F;&#x2F;倒计时时间</span><br><span class="line">    __block int timeout &#x3D; 3;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;创建队列</span><br><span class="line">    dispatch_queue_t globalQueue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;创建timer</span><br><span class="line">    dispatch_source_t timer &#x3D; dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, globalQueue);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;设置1s触发一次，0s的误差</span><br><span class="line">    &#x2F;*</span><br><span class="line">     - source 分派源</span><br><span class="line">     - start 数控制计时器第一次触发的时刻。参数类型是 dispatch_time_t，这是一个opaque类型，我们不能直接操作它。我们得需要 dispatch_time 和 dispatch_walltime 函数来创建它们。另外，常量 DISPATCH_TIME_NOW 和 DISPATCH_TIME_FOREVER 通常很有用。</span><br><span class="line">     - interval 间隔时间</span><br><span class="line">     - leeway 计时器触发的精准程度</span><br><span class="line">     *&#x2F;</span><br><span class="line">    dispatch_source_set_timer(timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0);</span><br><span class="line">    </span><br><span class="line">     &#x2F;&#x2F;触发的事件</span><br><span class="line">    dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">        &#x2F;&#x2F;倒计时结束，关闭</span><br><span class="line">        if (timeout &lt;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F;取消dispatch源</span><br><span class="line">            dispatch_source_cancel(timer);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            timeout--;</span><br><span class="line">            </span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                &#x2F;&#x2F;更新主界面的操作</span><br><span class="line">                NSLog(@&quot;倒计时 - %d&quot;, timeout);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F;开始执行dispatch源</span><br><span class="line">    dispatch_resume(timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/08/14/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-GCD-%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/14/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-GCD-%E4%BA%8C/" class="post-title-link" itemprop="url">iOS多线程-GCD(二)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-14 19:29:50" itemprop="dateCreated datePublished" datetime="2021-08-14T19:29:50+08:00">2021-08-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-23 23:16:42" itemprop="dateModified" datetime="2021-08-23T23:16:42+08:00">2021-08-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一篇我们主要探索了GCD的主队列及<code>串行队列</code>与<code>并发队列</code>在源码上的区分，以及同步函数的调用时机。本节我们主要探索同步函数与异步函数的区别：</p>
<ul>
<li>同步函数死锁分析</li>
<li>任务回调是否具有同步性、异步性</li>
<li><code>dispatch_once</code>底层的分析</li>
</ul>
<p>我们先从同步函数开始探索。</p>
<h3 id="同步函数死锁分析"><a href="#同步函数死锁分析" class="headerlink" title="同步函数死锁分析"></a>同步函数死锁分析</h3><p><code>libdispatch</code>源码中全局搜索<code>dispatch_sync</code>,找到方法的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_sync(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_block_t</span> work)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uintptr_t</span> dc_flags = DC_FLAG_BLOCK;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(_dispatch_block_has_private_data(work))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_block_with_privdata(dq, work, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_sync_f(dq, work, _dispatch_Block_invoke(work), dc_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟进方法<code>_dispatch_sync_f</code>实际调用<code>_dispatch_sync_f_inline</code>方法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_f_inline(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (likely(dq-&gt;dq_width == <span class="number">1</span>)) &#123;<span class="comment">//串行队列</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_barrier_sync_f(dq, ctxt, func, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(dx_metatype(dq) != _DISPATCH_LANE_TYPE)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(<span class="number">0</span>, <span class="string">"Queue type doesn't support dispatch_sync"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">dispatch_lane_t</span> dl = upcast(dq)._dl;</span><br><span class="line">	<span class="comment">// Global concurrent queues and queues bound to non-dispatch threads</span></span><br><span class="line">	<span class="comment">// always fall into the slow case, see DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!_dispatch_queue_try_reserve_sync_width(dl))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_f_slow(dl, ctxt, func, <span class="number">0</span>, dl, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_recurse(dl, ctxt, func, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_introspection_sync_begin(dl);</span><br><span class="line">	_dispatch_sync_invoke_and_complete(dl, ctxt, func DISPATCH_TRACE_ARG(</span><br><span class="line">			_dispatch_trace_item_sync_push_pop(dq, ctxt, func, dc_flags)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>串行队列调用了<code>_dispatch_barrier_sync_f</code>方法，最终调用到<code>_dispatch_barrier_sync_f_inline</code>方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_barrier_sync_f_inline(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_tid tid = _dispatch_tid_self();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(dx_metatype(dq) != _DISPATCH_LANE_TYPE)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(<span class="number">0</span>, <span class="string">"Queue type doesn't support dispatch_sync"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">dispatch_lane_t</span> dl = upcast(dq)._dl;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!_dispatch_queue_try_acquire_barrier_sync(dl, tid))) &#123;</span><br><span class="line">    <span class="comment">//死锁的是否会有_dispatch_sync_f_slow异常</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_f_slow(dl, ctxt, func, DC_FLAG_BARRIER, dl,</span><br><span class="line">				DC_FLAG_BARRIER | dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(dl-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_recurse(dl, ctxt, func,</span><br><span class="line">				DC_FLAG_BARRIER | dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_introspection_sync_begin(dl);</span><br><span class="line">	_dispatch_lane_barrier_sync_invoke_and_complete(dl, ctxt, func</span><br><span class="line">			DISPATCH_TRACE_ARG(_dispatch_trace_item_sync_push_pop(</span><br><span class="line">					dq, ctxt, func, dc_flags | DC_FLAG_BARRIER)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有多个调用的方法，我们自定义一种死锁的情况看调用堆栈的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;jason&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">  NSLog(@&quot;1&quot;);</span><br><span class="line">  dispatch_async(queue, ^&#123;</span><br><span class="line">      NSLog(@&quot;2&quot;);</span><br><span class="line">      dispatch_sync(queue, ^&#123;</span><br><span class="line">          NSLog(@&quot;3&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">      NSLog(@&quot;4&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;5&quot;);</span><br></pre></td></tr></table></figure>

<p>执行代码查看调用栈：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2597a32d39214293867da9b9fdf34478~tplv-k3u1fbpfcp-watermark.image" alt="死锁"></p>
<p>可以看到调用了<code>_dispatch_sync_f_slow</code>方法，然后调用了<code>__DISPATCH_WAIT_FOR_QUEUE__</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">__DISPATCH_WAIT_FOR_QUEUE__(<span class="keyword">dispatch_sync_context_t</span> dsc, <span class="keyword">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> dq_state = _dispatch_wait_prepare(dq);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(_dq_state_drain_locked_by(dq_state, dsc-&gt;dsc_waiter))) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH((<span class="keyword">uintptr_t</span>)dq_state,</span><br><span class="line">				<span class="string">"dispatch_sync called on queue "</span></span><br><span class="line">				<span class="string">"already owned by current thread"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">///省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里的crash信息和我们写的例子中最终的错误是一致的</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc3fa6cbe00e413dad18c53505a064e2~tplv-k3u1fbpfcp-watermark.image" alt="死锁2"></p>
<p>说明<code>_dq_state_drain_locked_by</code>判断的条件是产生死锁的原因，这个函数调用了<code>_dispatch_lock_is_locked_by</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">_dispatch_lock_is_locked_by(dispatch_lock lock_value, dispatch_tid tid)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// equivalent to _dispatch_lock_owner(lock_value) == tid</span></span><br><span class="line">	<span class="keyword">return</span> ((lock_value ^ tid) &amp; DLOCK_OWNER_MASK) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLOCK_OWNER_MASK			((dispatch_lock)0xfffffffc)</span></span><br></pre></td></tr></table></figure>

<p><code>DLOCK_OWNER_MASK</code>是一个很大的值，说明<code>lock_value ^ tid</code>为0，也就是<code>tid=lock_value</code>，看上面的注释也是这个意思，即当前的等待的线程与现在执行的线程是同一个。</p>
<h3 id="同步函数的回调"><a href="#同步函数的回调" class="headerlink" title="同步函数的回调"></a>同步函数的回调</h3><p>我们建立一个全局并发队列探索</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t concurrentQueue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">dispatch_sync(concurrentQueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;函数调用了....&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们回到<code>_dispatch_sync_f_inline</code>函数，然后打符号断点看执行了哪个方法</p>
<ul>
<li>_dispatch_sync_f_slow</li>
<li>_dispatch_sync_recurse</li>
<li>_dispatch_introspection_sync_begin</li>
<li>_dispatch_sync_invoke_and_complete</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf76ebde132c467e97f7c64de9a78302~tplv-k3u1fbpfcp-watermark.image" alt="同步函数并发队列探索"></p>
<p>断点调用到了<code>_dispatch_sync_f_slow</code>函数，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_f_slow(<span class="keyword">dispatch_queue_class_t</span> top_dqu, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func, <span class="keyword">uintptr_t</span> top_dc_flags,</span><br><span class="line">		<span class="keyword">dispatch_queue_class_t</span> dqu, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> top_dq = top_dqu._dq;</span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> dq = dqu._dq;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!dq-&gt;do_targetq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_function_invoke(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pthread_priority_t</span> pp = _dispatch_get_priority();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_sync_context_s</span> <span class="title">dsc</span> = &#123;</span></span><br><span class="line">		.dc_flags    = DC_FLAG_SYNC_WAITER | dc_flags,</span><br><span class="line">		.dc_func     = _dispatch_async_and_wait_invoke,</span><br><span class="line">		.dc_ctxt     = &amp;dsc,</span><br><span class="line">		.dc_other    = top_dq,</span><br><span class="line">		.dc_priority = pp | _PTHREAD_PRIORITY_ENFORCE_FLAG,</span><br><span class="line">		.dc_voucher  = _voucher_get(),</span><br><span class="line">		.dsc_func    = func,</span><br><span class="line">		.dsc_ctxt    = ctxt,</span><br><span class="line">		.dsc_waiter  = _dispatch_tid_self(),</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	_dispatch_trace_item_push(top_dq, &amp;dsc);</span><br><span class="line">	__DISPATCH_WAIT_FOR_QUEUE__(&amp;dsc, dq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dsc.dsc_func == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">// dsc_func being cleared means that the block ran on another thread ie.</span></span><br><span class="line">		<span class="comment">// case (2) as listed in _dispatch_async_and_wait_f_slow.</span></span><br><span class="line">		<span class="keyword">dispatch_queue_t</span> stop_dq = dsc.dc_other;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_complete_recurse(top_dq, stop_dq, top_dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_introspection_sync_begin(top_dq);</span><br><span class="line">	_dispatch_trace_item_pop(top_dq, &amp;dsc);</span><br><span class="line">	_dispatch_sync_invoke_and_complete_recurse(top_dq, ctxt, func,top_dc_flags</span><br><span class="line">			DISPATCH_TRACE_ARG(&amp;dsc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们继续加符号断点跟踪<code>_dispatch_trace_item_push</code>、<code>_dispatch_sync_complete_recurse</code>、<code>_dispatch_trace_item_pop</code>、<code>_dispatch_sync_invoke_and_complete_recurse</code>、<code>_dispatch_sync_function_invoke</code></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2ab368e89ac49a18c4d3c5f42865c88~tplv-k3u1fbpfcp-watermark.image" alt="同步函数并发队列"></p>
<p>说明执行了<code>_dispatch_sync_function_invoke</code>函数，注意<code>dq-&gt;do_targetq</code>系统队列为空，因为我们使用的是全局并发队列，所以执行到了这里。</p>
<p>继续看<code>_dispatch_sync_function_invoke</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_function_invoke(<span class="keyword">dispatch_queue_class_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">	_dispatch_sync_function_invoke_inline(dq, ctxt, func);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_function_invoke_inline(<span class="keyword">dispatch_queue_class_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_thread_frame_s dtf;</span><br><span class="line">	_dispatch_thread_frame_push(&amp;dtf, dq);</span><br><span class="line">	_dispatch_client_callout(ctxt, func);</span><br><span class="line">	_dispatch_perfmon_workitem_inc();</span><br><span class="line">	_dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里执行了<code>_dispatch_client_callout</code>函数，也就调用了<code>回调函数</code>。</p>
<h3 id="异步函数回调"><a href="#异步函数回调" class="headerlink" title="异步函数回调"></a>异步函数回调</h3><p>同样，我们也用符号断点的方式探究：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t concurrentQueue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;函数调用了....&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>全局搜索<code>dispatch_async</code>其调用了<code>_dispatch_continuation_async</code>函数，然后调用<code>dx_push</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_push(x, y, z) dx_vtable(x)-&gt;dq_push(x, y, z)</span></span><br></pre></td></tr></table></figure>

<p>最后调用了<code>dq_push</code>,<code>dq_push</code>根据队列类型的不同而调用，我们看并发队列的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_concurrent, lane,</span><br><span class="line">	.do_type        = DISPATCH_QUEUE_CONCURRENT_TYPE,</span><br><span class="line">	.do_dispose     = _dispatch_lane_dispose,</span><br><span class="line">	.do_debug       = _dispatch_queue_debug,</span><br><span class="line">	.do_invoke      = _dispatch_lane_invoke,</span><br><span class="line"></span><br><span class="line">	.dq_activate    = _dispatch_lane_activate,</span><br><span class="line">	.dq_wakeup      = _dispatch_lane_wakeup,</span><br><span class="line">	.dq_push        = _dispatch_lane_concurrent_push,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>搜索<code>_dispatch_lane_concurrent_push</code>的实现实际调用了<code>_dispatch_lane_push</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_lane_push(<span class="keyword">dispatch_lane_t</span> dq, <span class="keyword">dispatch_object_t</span> dou,</span><br><span class="line">		<span class="keyword">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">dispatch_wakeup_flags_t</span> flags = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(_dispatch_object_is_waiter(dou))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_lane_push_waiter(dq, dou._dsc, qos);</span><br><span class="line">	&#125;</span><br><span class="line">	dispatch_assert(!_dispatch_object_is_global(dq));</span><br><span class="line">	qos = _dispatch_queue_push_qos(dq, qos);</span><br><span class="line"></span><br><span class="line">	prev = os_mpsc_push_update_tail(os_mpsc(dq, dq_items), dou._do, do_next);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(os_mpsc_push_was_empty(prev))) &#123;</span><br><span class="line">		_dispatch_retain_2_unsafe(dq);</span><br><span class="line">		flags = DISPATCH_WAKEUP_CONSUME_2 | DISPATCH_WAKEUP_MAKE_DIRTY;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(_dispatch_queue_need_override(dq, qos))) &#123;</span><br><span class="line">		_dispatch_retain_2_unsafe(dq);</span><br><span class="line">		flags = DISPATCH_WAKEUP_CONSUME_2;</span><br><span class="line">	&#125;</span><br><span class="line">	os_mpsc_push_update_prev(os_mpsc(dq, dq_items), prev, dou._do, do_next);</span><br><span class="line">	<span class="keyword">if</span> (flags) &#123;</span><br><span class="line">		<span class="keyword">return</span> dx_wakeup(dq, qos, flags);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们添加符号断点<code>_dispatch_lane_push_waiter</code>、<code>_dispatch_queue_push_qos</code>、<code>os_mpsc_push_update_prev</code>、<code>dx_wakeup</code>。调用的是<code>dx_wakeup</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_wakeup(x, y, z) dx_vtable(x)-&gt;dq_wakeup(x, y, z)</span></span><br></pre></td></tr></table></figure>

<p>实际是对<code>dq_wakeup</code>的封装，依然我们找并发队列：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_concurrent, lane,</span><br><span class="line">	.do_type        = DISPATCH_QUEUE_CONCURRENT_TYPE,</span><br><span class="line">	.do_dispose     = _dispatch_lane_dispose,</span><br><span class="line">	.do_debug       = _dispatch_queue_debug,</span><br><span class="line">	.do_invoke      = _dispatch_lane_invoke,</span><br><span class="line"></span><br><span class="line">	.dq_activate    = _dispatch_lane_activate,</span><br><span class="line">	.dq_wakeup      = _dispatch_lane_wakeup,</span><br><span class="line">	.dq_push        = _dispatch_lane_concurrent_push,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><code>_dispatch_lane_wakeup</code>调用的<code>_dispatch_queue_wakeup</code>,同样也是把<code>_dispatch_queue_wakeup</code>调用的<code>return</code>的方法添加符号断点，会调用<code>_dispatch_queue_wakeup</code>-&gt;<code>_dispatch_lane_push</code>,执行到<code>_dispatch_root_queue_drain</code></p>
<h3 id="dispatch-once函数底层实现"><a href="#dispatch-once函数底层实现" class="headerlink" title="dispatch_once函数底层实现"></a>dispatch_once函数底层实现</h3><p>我们平时定义一个单例对象的时候一般都会使用<code>dispatch_once</code>函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    NSLog(@&quot;once&quot;)  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们在<code>libdispatch</code>中搜索<code>dispatch_once</code>看其底层实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_once(<span class="keyword">dispatch_once_t</span> *val, <span class="keyword">dispatch_block_t</span> block)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_once_f(val, block, _dispatch_Block_invoke(block));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>val</code>是<code>dispatch_once_t</code>类型。继续跟进<code>dispatch_once_f</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_once_f(<span class="keyword">dispatch_once_t</span> *val, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//gate</span></span><br><span class="line">	<span class="keyword">dispatch_once_gate_t</span> l = (<span class="keyword">dispatch_once_gate_t</span>)val;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !DISPATCH_ONCE_INLINE_FASTPATH || DISPATCH_ONCE_USE_QUIESCENT_COUNTER</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> v = os_atomic_load(&amp;l-&gt;dgo_once, acquire);</span><br><span class="line">	<span class="keyword">if</span> (likely(v == DLOCK_ONCE_DONE)) &#123;<span class="comment">//第一次会标示为done return</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_ONCE_USE_QUIESCENT_COUNTER</span></span><br><span class="line">	<span class="keyword">if</span> (likely(DISPATCH_ONCE_IS_GEN(v))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_once_mark_done_if_quiesced(l, v);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="comment">///第一次调用</span></span><br><span class="line">	<span class="keyword">if</span> (_dispatch_once_gate_tryenter(l)) &#123;<span class="comment">//锁 说明单例是线程安全的</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_once_callout(l, ctxt, func);<span class="comment">//执行任务</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_once_wait(l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">_dispatch_once_gate_tryenter(<span class="keyword">dispatch_once_gate_t</span> l)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> os_atomic_cmpxchg(&amp;l-&gt;dgo_once, DLOCK_ONCE_UNLOCKED,</span><br><span class="line">			(<span class="keyword">uintptr_t</span>)_dispatch_lock_value_for_self(), relaxed);</span><br><span class="line">&#125;</span><br><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_once_callout(<span class="keyword">dispatch_once_gate_t</span> l, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">///执行任务</span></span><br><span class="line">	_dispatch_client_callout(ctxt, func);</span><br><span class="line">  <span class="comment">///广播关门处理</span></span><br><span class="line">	_dispatch_once_gate_broadcast(l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_once_gate_broadcast(<span class="keyword">dispatch_once_gate_t</span> l)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_lock value_self = _dispatch_lock_value_for_self();</span><br><span class="line">	<span class="keyword">uintptr_t</span> v;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_ONCE_USE_QUIESCENT_COUNTER</span></span><br><span class="line">	v = _dispatch_once_mark_quiescing(l);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	v = _dispatch_once_mark_done(l);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (likely((dispatch_lock)v == value_self)) <span class="keyword">return</span>;</span><br><span class="line">	_dispatch_gate_broadcast_slow(&amp;l-&gt;dgo_gate, (dispatch_lock)v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li><p>只执行一次原理：<code>onceToken</code>是静态变量，具有唯一性，在底层被封装成了<code>dispatch_once_gate_t</code>类型的<code>变量l</code>，<code>l</code>主要是用来获取底层原子封装性的关联，即<code>变量v</code>，通过v来查询任务的状态，如果此时v等于<code>DLOCK_ONCE_DONE</code>，说明任务已经处理过一次了，直接`return</p>
</li>
<li><p>block调用的时机：如果此时任务没有执行过，将<code>任务进行加锁</code>，即任务状态置为<code>DLOCK_ONCE_UNLOCK</code>，目的是为了<code>保证当前任务执行的唯一性</code>，防止在其他地方有多次定义。加锁之后<code>进行block回调函数的执行</code>，执行完成后，将<code>当前任务解锁</code>，将当前的<code>任务状态置为DLOCK_ONCE_DONE</code>，在下次进来时，就不会在执行，会直接返回</p>
</li>
<li><p>如果在当前任务执行期间，有其他任务进来，会进入无限次等待，原因是当前任务已经获取了锁，进行了加锁，其他任务是无法获取锁的</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/08/05/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-GCD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/05/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-GCD/" class="post-title-link" itemprop="url">iOS多线程-GCD上</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-05 20:15:37" itemprop="dateCreated datePublished" datetime="2021-08-05T20:15:37+08:00">2021-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-10 20:47:31" itemprop="dateModified" datetime="2021-08-10T20:47:31+08:00">2021-08-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一篇我们介绍了多线程的一些概念，本篇我们主要探究iOS开发中经常会使用到的多线程技术<code>GCD</code>。</p>
<h3 id="GCD的概念"><a href="#GCD的概念" class="headerlink" title="GCD的概念"></a>GCD的概念</h3><p><code>GCD</code>的全称是 Grand Central Dispatch。它是由纯 C 语言实现，提供了非常多强大的函数。它有如下优势：</p>
<ul>
<li>GCD 是苹果公司为多核的并行运算提出的解决方案</li>
<li>GCD 会自动利用更多的CPU内核(比如双核、四核)</li>
<li>GCD 会自动管理线程的生命周期(创建线程、调度任务、销毁线程)</li>
<li>程序员只需要告诉 GCD 想要执行什么任务，不需要编写任何线程管理代码。</li>
</ul>
<p>总结来说GCD就是将任务添加到队列，并指定任务执行的函数。</p>
<h3 id="GCD的基本使用"><a href="#GCD的基本使用" class="headerlink" title="GCD的基本使用"></a>GCD的基本使用</h3><p>一般情况下我们会这样使用GCD</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建任务block</span><br><span class="line">dispatch_block_t block &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;这是任务&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;创建串行队列</span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;com.lg.cn&quot;, NULL);</span><br><span class="line">&#x2F;&#x2F;执行任务</span><br><span class="line">dispatch_async(queue, block);</span><br></pre></td></tr></table></figure>

<p>总结来看就是三部：</p>
<ul>
<li>创建任务块<code>dispatch_block_t</code></li>
<li>创建队列<code>dispatch_queue_t</code></li>
<li>将任务添加到队列并执行任务函数<code>dispatch_async</code>或<code>dispatch_sync</code></li>
</ul>
<p>还有两个概念其实我们也很熟悉了就是<code>函数</code>和<code>队列</code>。</p>
<ul>
<li>函数包括<code>同步函数（dispatch_sync）</code>和<code>异步函数（dispatch_async）</code>。</li>
<li>队列包括<code>串行队列（DISPATCH_QUEUE_SERIAL）</code>和<code>并行队列（DISPATCH_QUEUE_CONCURRENT）</code></li>
</ul>
<h3 id="主队列"><a href="#主队列" class="headerlink" title="主队列"></a>主队列</h3><p>主队列（<code>dispatch_queue_main_t</code>）是我们运行程序就会启动的一个队列，它是主线程所在的队列，会贯穿我们应用运行的始终。通过我们<code>dispatch_get_main_queue</code>函数的注释我们看到主队列是一个串行队列，这也不难理解，因为串行队列里的任务会逐个顺序执行，而我们主线程上的任务也符合这一特性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面这行注释说明它是一个串行队列，但不完全是一个标准的串行队列。  </span></span><br><span class="line">* Because the main <span class="built_in">queue</span> doesn<span class="number">'</span>t behave entirely like a regular serial <span class="built_in">queue</span>,</span><br><span class="line"> * it may have unwanted side-effects when used in processes that are <span class="keyword">not</span> UI apps</span><br><span class="line"> * (daemons). For such processes, the main <span class="built_in">queue</span> should be avoided.</span><br><span class="line"> *</span><br><span class="line"> * @see <span class="keyword">dispatch_queue_main_t</span></span><br><span class="line"> *</span><br><span class="line"> * @result</span><br><span class="line"> * Returns the main <span class="built_in">queue</span>. This <span class="built_in">queue</span> is created automatically on behalf of</span><br><span class="line"> * the main thread before main() is called.</span><br><span class="line"> */</span><br><span class="line">DISPATCH_INLINE DISPATCH_ALWAYS_INLINE DISPATCH_CONST DISPATCH_NOTHROW</span><br><span class="line"><span class="keyword">dispatch_queue_main_t</span></span><br><span class="line">dispatch_get_main_queue(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> DISPATCH_GLOBAL_OBJECT(<span class="keyword">dispatch_queue_main_t</span>, _dispatch_main_q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们下载<code>libdispatch</code>的源码，看一下<code>dispatch_get_main_queue</code>的源码，调用的是<code>DISPATCH_GLOBAL_OBJECT(dispatch_queue_main_t, _dispatch_main_q)</code>,它是一个<code>宏</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_GLOBAL_OBJECT(type, object) (static_cast<span class="meta-string">&lt;type&gt;(&amp;(object)))</span></span></span><br></pre></td></tr></table></figure>

<p>可以看到第一个参数<code>type</code>是类型，第二个参数<code>object</code>参数真正的参数也就是<code>_dispatch_main_q</code>,我们全局搜索<code>_dispatch_main_q =</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_static_s</span> _<span class="title">dispatch_main_q</span> = &#123;</span></span><br><span class="line">	DISPATCH_GLOBAL_OBJECT_HEADER(queue_main),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !DISPATCH_USE_RESOLVERS</span></span><br><span class="line">	.do_targetq = _dispatch_get_default_queue(<span class="literal">true</span>),</span><br><span class="line">#endif</span><br><span class="line">	.dq_state = DISPATCH_QUEUE_STATE_INIT_VALUE(<span class="number">1</span>) |</span><br><span class="line">			DISPATCH_QUEUE_ROLE_BASE_ANON,</span><br><span class="line">	.dq_label = <span class="string">"com.apple.main-thread"</span>,</span><br><span class="line">	.dq_atomic_flags = DQF_THREAD_BOUND | DQF_WIDTH(<span class="number">1</span>),</span><br><span class="line">	.dq_serialnum = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>发现<code>_dispatch_main_q</code>是一个结构体。可以看到<code>dispatch_queue_main_t</code>是一个结构体<code>dispatch_queue_static_s</code>。</p>
<h3 id="串行队列和并发队列源码上的区分"><a href="#串行队列和并发队列源码上的区分" class="headerlink" title="串行队列和并发队列源码上的区分"></a>串行队列和并发队列源码上的区分</h3><p>上面我们已经知道，gcd的队列的本质是<code>dispatch_queue_static_s</code>结构体，结构体中那个成员标示的是串行还是并行队列呢？我们源码中找答案。我们的队列是通过<code>dispatch_queue_create</code>函数创建的，它的第二个参数传入的是队列的类型，我们源码中找<code>dispatch_queue_create</code>函数的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span></span><br><span class="line">dispatch_queue_create(<span class="keyword">const</span> <span class="keyword">char</span> *label, <span class="keyword">dispatch_queue_attr_t</span> attr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_lane_create_with_target(label, attr,</span><br><span class="line">			DISPATCH_TARGET_QUEUE_DEFAULT, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟着调用继续查找<code>_dispatch_lane_create_with_target</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">dispatch_queue_t</span></span><br><span class="line">_dispatch_lane_create_with_target(<span class="keyword">const</span> <span class="keyword">char</span> *label, <span class="keyword">dispatch_queue_attr_t</span> dqa,</span><br><span class="line">		<span class="keyword">dispatch_queue_t</span> tq, <span class="keyword">bool</span> legacy)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">dispatch_queue_attr_info_t</span> dqai = _dispatch_queue_attr_to_info(dqa);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Step 1: Normalize arguments (qos, overcommit, tq)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">dispatch_qos_t</span> qos = dqai.dqai_qos;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !HAVE_PTHREAD_WORKQUEUE_QOS</span></span><br><span class="line">	<span class="keyword">if</span> (qos == DISPATCH_QOS_USER_INTERACTIVE) &#123;</span><br><span class="line">		dqai.dqai_qos = qos = DISPATCH_QOS_USER_INITIATED;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (qos == DISPATCH_QOS_MAINTENANCE) &#123;</span><br><span class="line">		dqai.dqai_qos = qos = DISPATCH_QOS_BACKGROUND;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !HAVE_PTHREAD_WORKQUEUE_QOS</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">_dispatch_queue_attr_overcommit_t</span> overcommit = dqai.dqai_overcommit;</span><br><span class="line">	<span class="keyword">if</span> (overcommit != _dispatch_queue_attr_overcommit_unspecified &amp;&amp; tq) &#123;</span><br><span class="line">		<span class="keyword">if</span> (tq-&gt;do_targetq) &#123;</span><br><span class="line">			DISPATCH_CLIENT_CRASH(tq, <span class="string">"Cannot specify both overcommit and "</span></span><br><span class="line">					<span class="string">"a non-global target queue"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tq &amp;&amp; dx_type(tq) == DISPATCH_QUEUE_GLOBAL_ROOT_TYPE) &#123;</span><br><span class="line">		<span class="comment">// Handle discrepancies between attr and target queue, attributes win</span></span><br><span class="line">		<span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_unspecified) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tq-&gt;dq_priority &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT) &#123;</span><br><span class="line">				overcommit = _dispatch_queue_attr_overcommit_enabled;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				overcommit = _dispatch_queue_attr_overcommit_disabled;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (qos == DISPATCH_QOS_UNSPECIFIED) &#123;</span><br><span class="line">			qos = _dispatch_priority_qos(tq-&gt;dq_priority);</span><br><span class="line">		&#125;</span><br><span class="line">		tq = <span class="literal">NULL</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tq &amp;&amp; !tq-&gt;do_targetq) &#123;</span><br><span class="line">		<span class="comment">// target is a pthread or runloop root queue, setting QoS or overcommit</span></span><br><span class="line">		<span class="comment">// is disallowed</span></span><br><span class="line">		<span class="keyword">if</span> (overcommit != _dispatch_queue_attr_overcommit_unspecified) &#123;</span><br><span class="line">			DISPATCH_CLIENT_CRASH(tq, <span class="string">"Cannot specify an overcommit attribute "</span></span><br><span class="line">					<span class="string">"and use this kind of target queue"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_unspecified) &#123;</span><br><span class="line">			<span class="comment">// Serial queues default to overcommit!</span></span><br><span class="line">			overcommit = dqai.dqai_concurrent ?</span><br><span class="line">					_dispatch_queue_attr_overcommit_disabled :</span><br><span class="line">					_dispatch_queue_attr_overcommit_enabled;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!tq) &#123;</span><br><span class="line">		tq = _dispatch_get_root_queue(</span><br><span class="line">				qos == DISPATCH_QOS_UNSPECIFIED ? DISPATCH_QOS_DEFAULT : qos,</span><br><span class="line">				overcommit == _dispatch_queue_attr_overcommit_enabled)-&gt;_as_dq;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!tq)) &#123;</span><br><span class="line">			DISPATCH_CLIENT_CRASH(qos, <span class="string">"Invalid queue attribute"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Step 2: Initialize the queue</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (legacy) &#123;</span><br><span class="line">		<span class="comment">// if any of these attributes is specified, use non legacy classes</span></span><br><span class="line">		<span class="keyword">if</span> (dqai.dqai_inactive || dqai.dqai_autorelease_frequency) &#123;</span><br><span class="line">			legacy = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">void</span> *vtable;</span><br><span class="line">	<span class="keyword">dispatch_queue_flags_t</span> dqf = legacy ? DQF_MUTABLE : <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (dqai.dqai_concurrent) &#123;</span><br><span class="line">		vtable = DISPATCH_VTABLE(queue_concurrent);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		vtable = DISPATCH_VTABLE(queue_serial);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> (dqai.dqai_autorelease_frequency) &#123;</span><br><span class="line">	<span class="keyword">case</span> DISPATCH_AUTORELEASE_FREQUENCY_NEVER:</span><br><span class="line">		dqf |= DQF_AUTORELEASE_NEVER;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM:</span><br><span class="line">		dqf |= DQF_AUTORELEASE_ALWAYS;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (label) &#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span> *tmp = _dispatch_strdup_if_mutable(label);</span><br><span class="line">		<span class="keyword">if</span> (tmp != label) &#123;</span><br><span class="line">			dqf |= DQF_LABEL_NEEDS_FREE;</span><br><span class="line">			label = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">dispatch_lane_t</span> dq = _dispatch_object_alloc(vtable,</span><br><span class="line">			<span class="keyword">sizeof</span>(struct dispatch_lane_s));</span><br><span class="line">	_dispatch_queue_init(dq, dqf, dqai.dqai_concurrent ?</span><br><span class="line">			DISPATCH_QUEUE_WIDTH_MAX : <span class="number">1</span>, DISPATCH_QUEUE_ROLE_INNER |</span><br><span class="line">			(dqai.dqai_inactive ? DISPATCH_QUEUE_INACTIVE : <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	dq-&gt;dq_label = label;</span><br><span class="line">	dq-&gt;dq_priority = _dispatch_priority_make((<span class="keyword">dispatch_qos_t</span>)dqai.dqai_qos,</span><br><span class="line">			dqai.dqai_relpri);</span><br><span class="line">	<span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_enabled) &#123;</span><br><span class="line">		dq-&gt;dq_priority |= DISPATCH_PRIORITY_FLAG_OVERCOMMIT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!dqai.dqai_inactive) &#123;</span><br><span class="line">		_dispatch_queue_priority_inherit_from_target(dq, tq);</span><br><span class="line">		_dispatch_lane_inherit_wlh_from_target(dq, tq);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_retain(tq);</span><br><span class="line">	dq-&gt;do_targetq = tq;</span><br><span class="line">	_dispatch_object_debug(dq, <span class="string">"%s"</span>, __func__);</span><br><span class="line">	<span class="keyword">return</span> _dispatch_trace_queue_create(dq)._dq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数比较长，按照管理我们还是先看返回值<code>_dispatch_trace_queue_create(dq)._dq</code>。重点看<code>dq</code>怎么创建的。所以我们主要<code>dq</code>的创建及成员赋值的过程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_lane_t</span> dq = _dispatch_object_alloc(vtable,</span><br><span class="line">			<span class="keyword">sizeof</span>(struct dispatch_lane_s));</span><br><span class="line">	_dispatch_queue_init(dq, dqf, dqai.dqai_concurrent ?</span><br><span class="line">			DISPATCH_QUEUE_WIDTH_MAX : <span class="number">1</span>, DISPATCH_QUEUE_ROLE_INNER |</span><br><span class="line">			(dqai.dqai_inactive ? DISPATCH_QUEUE_INACTIVE : <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>发现<code>_dispatch_queue_init</code>的实参有<code>dqai.dqai_concurrent</code>还是并行队列的判断。我们定位到<code>_dispatch_queue_init</code>的第三个参数，看看其赋值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_queue_class_t</span></span><br><span class="line">_dispatch_queue_init(<span class="keyword">dispatch_queue_class_t</span> dqu, <span class="keyword">dispatch_queue_flags_t</span> dqf,</span><br><span class="line">		<span class="keyword">uint16_t</span> <span class="built_in">width</span>, <span class="keyword">uint64_t</span> initial_state_bits)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> dq_state = DISPATCH_QUEUE_STATE_INIT_VALUE(<span class="built_in">width</span>);</span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> dq = dqu._dq;</span><br><span class="line"></span><br><span class="line">	dispatch_assert((initial_state_bits &amp; ~(DISPATCH_QUEUE_ROLE_MASK |</span><br><span class="line">			DISPATCH_QUEUE_INACTIVE)) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (initial_state_bits &amp; DISPATCH_QUEUE_INACTIVE) &#123;</span><br><span class="line">		dq-&gt;do_ref_cnt += <span class="number">2</span>; <span class="comment">// rdar://8181908 see _dispatch_lane_resume</span></span><br><span class="line">		<span class="keyword">if</span> (dx_metatype(dq) == _DISPATCH_SOURCE_TYPE) &#123;</span><br><span class="line">			dq-&gt;do_ref_cnt++; <span class="comment">// released when DSF_DELETED is set</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dq_state |= initial_state_bits;</span><br><span class="line">	dq-&gt;do_next = DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">	dqf |= DQF_WIDTH(<span class="built_in">width</span>);</span><br><span class="line">	os_atomic_store2o(dq, dq_atomic_flags, dqf, relaxed);</span><br><span class="line">	dq-&gt;dq_state = dq_state;</span><br><span class="line">	dq-&gt;dq_serialnum =</span><br><span class="line">			os_atomic_inc_orig(&amp;_dispatch_queue_serial_numbers, relaxed);</span><br><span class="line">	<span class="keyword">return</span> dqu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到第三个参数<code>width</code>复制的地方是<code>dqf |= DQF_WIDTH(width);</code>即：</p>
<ul>
<li><p>width = 1表示串行队列</p>
</li>
<li><p>width =  DISPATCH_QUEUE_WIDTH_MAX表示并行队列，其中<code>DISPATCH_QUEUE_WIDTH_MAX</code>的定义如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_QUEUE_WIDTH_FULL			0x1000ull</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_QUEUE_WIDTH_MAX  (DISPATCH_QUEUE_WIDTH_FULL - 2)</span></span><br></pre></td></tr></table></figure>

<h3 id="dispatch-queue-t的继承链"><a href="#dispatch-queue-t的继承链" class="headerlink" title="dispatch_queue_t的继承链"></a>dispatch_queue_t的继承链</h3></li>
</ul>
<p><code>dispatch_queue_t</code>的继承链是什么样子呢，我们在代码中按<code>cmd</code>+<code>dispatch_queue_t</code>会跳转到<code>DISPATCH_DECL(dispatch_queue);</code>代码，它是<code>dispatch_queue_t</code>的定义。我们在libdispatch源码中搜索<code>DISPATCH_DECL(</code>找定义的地方，根据上下文<code>if</code>判断下面这行是<code>oc</code>情况下的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_DECL(name) \</span></span><br><span class="line">		<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">name</span>##_<span class="title">s</span> :</span> <span class="keyword">public</span> dispatch_object_s &#123;&#125; *name##<span class="keyword">_t</span></span><br><span class="line"><span class="comment">///dispatch_queue_t -&gt; dispatch_queue_s -&gt; dispatch_object_s</span></span><br></pre></td></tr></table></figure>

<p>可以看到继承链为<code>dispatch_queue_t -&gt; dispatch_queue_s -&gt; dispatch_object_s</code></p>
<p>我们观察一下的机构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> &#123;</span></span><br><span class="line">	DISPATCH_QUEUE_CLASS_HEADER(<span class="built_in">queue</span>, <span class="keyword">void</span> *__dq_opaque1);</span><br><span class="line">	<span class="comment">/* 32bit hole on LP64 */</span></span><br><span class="line">&#125; DISPATCH_ATOMIC64_ALIGN;</span><br></pre></td></tr></table></figure>

<p>继续看<code>DISPATCH_QUEUE_CLASS_HEADER</code>结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DISPATCH_QUEUE_CLASS_HEADER(x, __pointer_sized_field__) \</span></span><br><span class="line">	DISPATCH_OBJECT_HEADER(x); \</span><br><span class="line">	__pointer_sized_field__; \</span><br><span class="line">	DISPATCH_UNION_LE(<span class="keyword">uint64_t</span> <span class="keyword">volatile</span> dq_state, \</span><br><span class="line">			dispatch_lock dq_state_lock, \</span><br><span class="line">			<span class="keyword">uint32_t</span> dq_state_bits \</span><br><span class="line">	)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>继承于<code>DISPATCH_OBJECT_HEADER</code>继续搜索：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DISPATCH_OBJECT_HEADER(x) \</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">os_object_s</span> _<span class="title">as_os_obj</span>[0];</span> \</span><br><span class="line">	OS_OBJECT_STRUCT_HEADER(dispatch_##x); \</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_</span>##<span class="title">x</span>##_<span class="title">s</span> *<span class="title">volatile</span> <span class="title">do_next</span>;</span> \</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *<span class="title">do_targetq</span>;</span> \</span><br><span class="line">	<span class="keyword">void</span> *do_ctxt; \</span><br><span class="line">	<span class="keyword">union</span> &#123; \</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> DISPATCH_FUNCTION_POINTER do_finalizer; \</span><br><span class="line">		<span class="keyword">void</span> *do_introspection_ctxt; \</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>最后继承的是<code>_os_object_s</code>,所以完整继承链就是</p>
<p>dispatch_queue_t -&gt; dispatch_queue_s -&gt; dispatch_object_s -&gt; _os_object_s</p>
<h3 id="函数的调用时机"><a href="#函数的调用时机" class="headerlink" title="函数的调用时机"></a>函数的调用时机</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_sync(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">    NSLog(@&quot;函数调用了&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们本小节探究函数的<code>block</code>参数是什么时候调用的，我们以同步函数为例，全局搜索<code>dispatch_sync</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_sync(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_block_t</span> work)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uintptr_t</span> dc_flags = DC_FLAG_BLOCK;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(_dispatch_block_has_private_data(work))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_block_with_privdata(dq, work, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_sync_f(dq, work, _dispatch_Block_invoke(work), dc_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>work</code>为我们传入的<code>block</code>，所以我们看和<code>work</code>参数相关的代码</p>
<p><code>_dispatch_Block_invoke</code>函数的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _dispatch_Block_invoke(bb) \</span></span><br><span class="line">		((<span class="keyword">dispatch_function_t</span>)((struct Block_layout *)bb)-&gt;invoke)</span><br></pre></td></tr></table></figure>

<p>可以看到_dispatch_Block_invoke函数主要是调用了<code>work</code>的<code>invoke</code>方法。</p>
<p>我们再看<code>_dispatch_sync_f</code>的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_f(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func,</span><br><span class="line">		<span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	_dispatch_sync_f_inline(dq, ctxt, func, dc_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟踪<code>_dispatch_sync_f_inline</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_f_inline(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (likely(dq-&gt;dq_width == <span class="number">1</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_barrier_sync_f(dq, ctxt, func, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(dx_metatype(dq) != _DISPATCH_LANE_TYPE)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(<span class="number">0</span>, <span class="string">"Queue type doesn't support dispatch_sync"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">dispatch_lane_t</span> dl = upcast(dq)._dl;</span><br><span class="line">	<span class="comment">// Global concurrent queues and queues bound to non-dispatch threads</span></span><br><span class="line">	<span class="comment">// always fall into the slow case, see DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!_dispatch_queue_try_reserve_sync_width(dl))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_f_slow(dl, ctxt, func, <span class="number">0</span>, dl, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_recurse(dl, ctxt, func, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_introspection_sync_begin(dl);</span><br><span class="line">	_dispatch_sync_invoke_and_complete(dl, ctxt, func DISPATCH_TRACE_ARG(</span><br><span class="line">			_dispatch_trace_item_sync_push_pop(dq, ctxt, func, dc_flags)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_dispatch_sync_f_inline</code>函数的<code>ctxt</code>和<code>func</code>参数是和block相关的参数，调用的地方比较多，我们在demo工程打一个符号断点看一下，到底执行了哪个方法：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5efc9820ecdd40359b417a0786b63a45~tplv-k3u1fbpfcp-watermark.image" alt="1628264358531"></p>
<p>我们发现实际调用的是<code>_dispatch_sync_f_slow</code>函数</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/036607d53d484d3a964806f0557747d9~tplv-k3u1fbpfcp-watermark.image" alt="1628264502620"></p>
<p>所以我们继续看<code>_dispatch_sync_f_slow</code>的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_f_slow(<span class="keyword">dispatch_queue_class_t</span> top_dqu, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func, <span class="keyword">uintptr_t</span> top_dc_flags,</span><br><span class="line">		<span class="keyword">dispatch_queue_class_t</span> dqu, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> top_dq = top_dqu._dq;</span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> dq = dqu._dq;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!dq-&gt;do_targetq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_function_invoke(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pthread_priority_t</span> pp = _dispatch_get_priority();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_sync_context_s</span> <span class="title">dsc</span> = &#123;</span></span><br><span class="line">		.dc_flags    = DC_FLAG_SYNC_WAITER | dc_flags,</span><br><span class="line">		.dc_func     = _dispatch_async_and_wait_invoke,</span><br><span class="line">		.dc_ctxt     = &amp;dsc,</span><br><span class="line">		.dc_other    = top_dq,</span><br><span class="line">		.dc_priority = pp | _PTHREAD_PRIORITY_ENFORCE_FLAG,</span><br><span class="line">		.dc_voucher  = _voucher_get(),</span><br><span class="line">		.dsc_func    = func,</span><br><span class="line">		.dsc_ctxt    = ctxt,</span><br><span class="line">		.dsc_waiter  = _dispatch_tid_self(),</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	_dispatch_trace_item_push(top_dq, &amp;dsc);</span><br><span class="line">	__DISPATCH_WAIT_FOR_QUEUE__(&amp;dsc, dq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dsc.dsc_func == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">// dsc_func being cleared means that the block ran on another thread ie.</span></span><br><span class="line">		<span class="comment">// case (2) as listed in _dispatch_async_and_wait_f_slow.</span></span><br><span class="line">		<span class="keyword">dispatch_queue_t</span> stop_dq = dsc.dc_other;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_complete_recurse(top_dq, stop_dq, top_dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_dispatch_introspection_sync_begin(top_dq);</span><br><span class="line">	_dispatch_trace_item_pop(top_dq, &amp;dsc);</span><br><span class="line">	_dispatch_sync_invoke_and_complete_recurse(top_dq, ctxt, func,top_dc_flags</span><br><span class="line">			DISPATCH_TRACE_ARG(&amp;dsc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关注的参数依然是<code>ctxt</code>和<code>func</code>，和上一步骤类似，我们继续打符号断点<code>_dispatch_sync_invoke_and_complete_recurse</code>和<code>_dispatch_sync_function_invoke</code>来看具体执行的代码。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/553b2e78bcb545a7811d664a66dd90cf~tplv-k3u1fbpfcp-watermark.image" alt="1628264995211"></p>
<p>实际调用了<code>_dispatch_sync_function_invoke</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_function_invoke(<span class="keyword">dispatch_queue_class_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">	_dispatch_sync_function_invoke_inline(dq, ctxt, func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟进<code>_dispatch_sync_function_invoke_inline</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_function_invoke_inline(<span class="keyword">dispatch_queue_class_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_thread_frame_s dtf;</span><br><span class="line">	_dispatch_thread_frame_push(&amp;dtf, dq);</span><br><span class="line">	_dispatch_client_callout(ctxt, func);</span><br><span class="line">	_dispatch_perfmon_workitem_inc();</span><br><span class="line">	_dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ctxt</code>和<code>func</code>的调用在<code>_dispatch_client_callout</code>函数，有多个实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_client_callout(<span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> f)</span><br><span class="line">&#123;</span><br><span class="line">	_dispatch_get_tsd_base();</span><br><span class="line">	<span class="keyword">void</span> *u = _dispatch_get_unwind_tsd();</span><br><span class="line">	<span class="keyword">if</span> (likely(!u)) <span class="keyword">return</span> f(ctxt);</span><br><span class="line">	_dispatch_set_unwind_tsd(<span class="literal">NULL</span>);</span><br><span class="line">	f(ctxt);</span><br><span class="line">	_dispatch_free_unwind_tsd();</span><br><span class="line">	_dispatch_set_unwind_tsd(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> _dispatch_client_callout</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_client_callout(<span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> f)</span><br><span class="line">&#123;</span><br><span class="line">	@<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> f(ctxt);</span><br><span class="line">	&#125;</span><br><span class="line">	@<span class="keyword">catch</span> (...) &#123;</span><br><span class="line">		objc_terminate();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然多处实现，但是调用<code>block</code>的代码都是<code>f(ctxt)</code>。</p>
<p>所以<code>block</code>的调用链是：<code>dispatch_sync</code>-&gt;<code>_dispatch_sync_f</code>-&gt;<code>_dispatch_sync_f_inline</code>-&gt;<code>_dispatch_sync_f_slow</code>-&gt;<code>_dispatch_sync_function_invoke</code>-&gt;<code>_dispatch_client_callout</code>-&gt;<code>f(ctxt)</code>。</p>
<p>同理异步函数<code>dispatch_async</code>用相同的方法也能探究出一个调用链，最后调用的也是<code>f(ctxt)</code>,感兴趣的童鞋可以探究一下。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/08/01/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/01/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">iOS多线程-多线程原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-01 17:05:50 / 修改时间：21:23:57" itemprop="dateCreated datePublished" datetime="2021-08-01T17:05:50+08:00">2021-08-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本节我们主要了解一些多线程的理论知识。</p>
<h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><ul>
<li>进程是指在系统中正在运行的一个应用程序。</li>
<li>每个进程之间是独立的，每个进程均运行在其专用的且受保护的内存空间内。</li>
<li>通过“活动监视器”可以查看 Mac 系统中所开启的进程。</li>
</ul>
<h5 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h5><ul>
<li>线程是进程的基本执行单元，一个进程的所有任务都在线程中执行。</li>
<li>进程要想执行任务，必须得有线程，进程至少要有一条线程。</li>
<li>程序启动会默认开启一条线程，这条线程被称为主线程或 UI 线程。</li>
</ul>
<h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><ul>
<li>地址空间:同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。</li>
<li>资源拥有:同一进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的 资源是独立的。</li>
</ul>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><ol>
<li>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</li>
<li>进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进 程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程 </li>
<li>执行过程:每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口。但是 线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li>
<li>线程是处理器调度的基本单位，但是进程不是。</li>
<li>线程没有地址空间,线程包含在进程地址空间中。</li>
</ol>
<h3 id="多线程原理"><a href="#多线程原理" class="headerlink" title="多线程原理"></a>多线程原理</h3><ul>
<li>对于<code>单核CPU</code>，<code>同一时间，CPU只能处理一条线程</code>，即只有一条线程在工作，</li>
<li>iOS中的<code>多线程同时执行</code>的本质是CPU在多个任务直接进行快速的切换，由于CPU调度线程的时间足够快，就造成了多线程的“同时”执行的效果。其中切换的时间间隔就是<code>时间片</code>。</li>
</ul>
<h4 id="多线程的优点"><a href="#多线程的优点" class="headerlink" title="多线程的优点"></a>多线程的优点</h4><ul>
<li>能适当提高程序的执行效率</li>
<li>能适当提高资源的利用率(CPU，内存)</li>
<li>线程上的任务执行完成后，线程会自动销毁</li>
</ul>
<h4 id="多线程的缺点"><a href="#多线程的缺点" class="headerlink" title="多线程的缺点"></a>多线程的缺点</h4><ul>
<li>开启线程需要占用一定的内存空间(默认情况下，每一个线程都占 512 KB，90ms的时间)。</li>
<li>如果开启大量的线程，会占用大量的内存空间，降低程序的性能。</li>
<li>线程越多，CPU 在调用线程上的开销就越大。</li>
<li>程序设计更加复杂，比如线程间的通信，多线程的数据共享。</li>
</ul>
<h3 id="多线程生命周期"><a href="#多线程生命周期" class="headerlink" title="多线程生命周期"></a>多线程生命周期</h3><p>多线程的生命周期主要分为5部分：新建 - 就绪 - 运行 - 阻塞 - 死亡，如下图所示</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5c1d80cb9754ab98612a71b7f3ea3ec~tplv-k3u1fbpfcp-watermark.image" alt="多线程生命周期"></p>
<ul>
<li><code>新建</code>：主要是实例化线程对象</li>
<li><code>就绪</code>：线程对象调用start方法，将线程对象加入可调度线程池，等待CPU的调用，即调用start方法，并不会立即执行，进入<code>就绪状态</code>，需要等待一段时间，经CPU时间片调度后再执行，也就是从就绪状态进入<code>运行状态</code>。</li>
<li><code>阻塞</code>：当满足某个预定条件时，可以<code>使用休眠，即sleep，或者同步锁</code>，阻塞线程执行。当进入sleep时，会重新将<code>线程加入就绪</code>中。</li>
<li><code>死亡</code>：分为两种情况，<ol>
<li><code>正常死亡</code>，即线程执行完毕</li>
<li><code>非正常死亡</code>，即当满足某个条件后，在线程内部（或者主线程中）终止执行（调用exit方法等退出）</li>
</ol>
</li>
<li><code>运行</code>：就是线程执行，处于<code>运行中的线程</code>拥有一段可以执行的时间(<code>时间片</code>)。<ol>
<li>如果<code>时间片用尽</code>，线程就会进入<code>就绪状态队列</code></li>
<li>如果<code>时间片没有用尽</code>，且需要开始<code>等待某事件</code>，就会进入<code>阻塞状态队列</code></li>
<li>等待事件发生后，线程又会重新进入<code>就绪状态队列</code></li>
<li>每当一个<code>线程离开运行</code>，即执行完毕或者强制退出后，会重新从就绪状态队列中选择一个线程继续执行</li>
</ol>
</li>
</ul>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池流程图如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86ba007efda84d878b9551594a95d4b4~tplv-k3u1fbpfcp-watermark.image" alt="线程池"></p>
<ol>
<li>判断核心线程池是否都正在执行任务<ul>
<li>返回NO，创建新的工作线程去执行</li>
<li>返回YES，进入2</li>
</ul>
</li>
<li>判断线程池工作队列是否已经饱满<ul>
<li>返回NO，将任务存储到工作队列，等待CPU调度</li>
<li>返回YES，进入3</li>
</ul>
</li>
<li>判断线程池中的线程是否都处于执行状态<ul>
<li>返回NO，安排可调度线程池中空闲的线程去执行任务</li>
<li>返回YES，进入4</li>
</ul>
</li>
<li>交给饱和策略去执行。饱和策略有一下四种：<ul>
<li><code>AbortPolicy</code>：直接抛出RejectedExecutionExeception异常来阻止系统正常运行</li>
<li><code>CallerRunsPolicy</code>：将任务回退到调用者</li>
<li><code>DisOldestPolicy</code>：丢掉等待最久的任务</li>
<li><code>DisCardPolicy</code>：直接丢弃任务</li>
<li>这四种拒绝策略均实现的RejectedExecutionHandler接口</li>
</ul>
</li>
</ol>
<h3 id="互斥锁与自旋锁"><a href="#互斥锁与自旋锁" class="headerlink" title="互斥锁与自旋锁"></a>互斥锁与自旋锁</h3><p>锁是用户保护临界区，确保同一时间，只有一条线程能够访问临界区。</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><ul>
<li>自旋锁在获取到资源之前一直处于忙等。</li>
<li>自旋锁的使用场景：锁持有时间短，且线程不希望在重新调用上花太多成本。<code>OC</code>属性的关键字<code>atomic</code>就是使用了自旋锁。</li>
<li>使用自旋锁，当心线程访问代码时，如果发现其他线程转给你在锁定代码，新线程会用死循环的方法，一直等待锁定的代码执行完成，比较消耗性能。</li>
</ul>
<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><ul>
<li><p>互斥锁在获取到资源之前是休眠状态，释放资源后会被唤醒。</p>
</li>
<li><p>如果代码中<code>只有一个地方需要加锁，大多都使用 self</code>，这样可以避免单独再创建一个锁对象</p>
</li>
<li><p>互斥锁的<code>锁定范围，应该尽量小</code>，锁定范围越大，效率越差</p>
</li>
<li><p>能够<code>加锁的任意 NSObject 对象</code></p>
</li>
<li><p>锁对象一定要保证所有的线程都能够访问</p>
<h3 id="几个多线程题目"><a href="#几个多线程题目" class="headerlink" title="几个多线程题目"></a>几个多线程题目</h3></li>
</ul>
<h4 id="任务执行的影响因素"><a href="#任务执行的影响因素" class="headerlink" title="任务执行的影响因素"></a>任务执行的影响因素</h4><ul>
<li>cpu的调度</li>
<li>执行任务的复杂度</li>
<li>任务的优先级</li>
<li>线程的状态</li>
</ul>
<h4 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h4><p>两种线程：IO密集型、CPU密集型</p>
<ul>
<li>IO密集型，频繁等待的线程。更容易得到优先级提升。</li>
<li>CPU密集型，很少等待的线程。</li>
<li>IO密集型线程容易饿死。</li>
<li>cpu调度来提升等待线程的优先级</li>
</ul>
<h4 id="优先级的影响因素"><a href="#优先级的影响因素" class="headerlink" title="优先级的影响因素"></a>优先级的影响因素</h4><ul>
<li>用户指定。</li>
<li>等待的频繁度。</li>
<li>长时间不执行。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/07/27/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-KVO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/27/iOS%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-KVO/" class="post-title-link" itemprop="url">iOS底层探索-KVO</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-27 20:30:04" itemprop="dateCreated datePublished" datetime="2021-07-27T20:30:04+08:00">2021-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-31 15:58:49" itemprop="dateModified" datetime="2021-07-31T15:58:49+08:00">2021-07-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>KVO</code>是一种机制，它允许对象在其他对象的指定属性发生更改时收到通知。它最常用的一个场景就是<code>viewconroller</code>中监听<code>model</code>属性的变化从而刷新页面展示。</p>
<h3 id="KVO使用过程的细节"><a href="#KVO使用过程的细节" class="headerlink" title="KVO使用过程的细节"></a><code>KVO</code>使用过程的细节</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p><code>KVO</code>的基本使用就是三部曲：</p>
<ul>
<li><p>注册观察者 <code>addObserver:forKeyPath:options:context</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.person addObserver:self forKeyPath:@&quot;nickname&quot; options:NSKeyValueObservingOptionNew context:NULL];</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现<code>KVO</code>的回调<code>observeValueForKeyPath:ofObject:change:context</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    if ([keyPath isEqualToString:@&quot;nickname&quot;]) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,change);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>移除观察者<code>removeObserver:forKeyPath:context</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.person removeObserver:self forKeyPath:@&quot;nickname&quot; context:NULL];</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="context参数的使用"><a href="#context参数的使用" class="headerlink" title="context参数的使用"></a>context参数的使用</h4><p>基本使用的过程中我们经常会给<code>context</code>传<code>NULL</code>作为实参，<code>context</code>参数的作用很容易被我们忽略。苹果官方文档对<code>context</code>有详细的说明</p>
<blockquote>
<p>The context pointer in the <code>addObserver:forKeyPath:options:context:</code> message contains arbitrary data that will be passed back to the observer in the corresponding change notifications. You may specify <code>NULL</code> and rely entirely on the key path string to determine the origin of a change notification, but this approach may cause problems for an object whose superclass is also observing the same key path for different reasons.</p>
<p>A safer and more extensible approach is to use the context to ensure notifications you receive are destined for your observer and not a superclass.</p>
</blockquote>
<p>大体意思就是：<code>addObserver：forKeyPath：options：context：</code>方法中的<code>context</code>指针包含任意数据，这些数据将在相应的更改通知中传递回观察者。可以通过<code>指定context为NULL</code>，从而<code>依靠keyPath</code>即<code>键路径字符串</code>传来确定更改通知的来源，但是这种方法可能会导致对象的父类由于不同的原因也观察到相同的键路径而导致问题。所以可以为每个观察到的keyPath创建一个不同的context，从而<code>完全不需要进行字符串比较</code>，从而可以更有效地进行通知解析。</p>
<p><code>context</code>主要是用于区分不同对象的同名属性，从而在KVO回调方法中可以直接使用<code>context</code>进行区分，可以大大提升性能，以及代码的可读性。</p>
<ul>
<li><p>不使用context时，我们通过字符串判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[self.person addObserver:self forKeyPath:@&quot;nickname&quot; options:NSKeyValueObservingOptionNew context:NULL];</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    if ([keyPath isEqualToString:@&quot;nickname&quot;]) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,change);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用context时，我们通过<code>context</code>判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;context定义</span><br><span class="line">static void *PersonNickNameContext &#x3D; &amp;PersonNickNameContext;</span><br><span class="line">static void *PersonNameContext &#x3D; &amp;PersonNameContext;</span><br><span class="line">&#x2F;&#x2F;注册观察者</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;nick&quot; options:NSKeyValueObservingOptionNew context:PersonNickNameContext];</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:PersonNameContext];</span><br><span class="line">&#x2F;&#x2F;KVO的回调</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    if (context &#x3D;&#x3D; PersonNickNameContext) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,change);</span><br><span class="line">    &#125;else if (context &#x3D;&#x3D; PersonNameContext)&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,change);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="是否有必要移除KVOobserver"><a href="#是否有必要移除KVOobserver" class="headerlink" title="是否有必要移除KVOobserver"></a>是否有必要移除<code>KVO</code>observer</h4><p>官方文档对<code>removeObserver</code>也有说明：</p>
<blockquote>
<p>When removing an observer, keep several points in mind:</p>
<ul>
<li>Asking to be removed as an observer if not already registered as one results in an <code>NSRangeException</code>. You either call <code>removeObserver:forKeyPath:context:</code> exactly once for the corresponding call to <code>addObserver:forKeyPath:options:context:</code>, or if that is not feasible in your app, place the <code>removeObserver:forKeyPath:context:</code> call inside a try/catch block to process the potential exception.</li>
<li>An observer does not automatically remove itself when deallocated. The observed object continues to send notifications, oblivious to the state of the observer. However, a change notification, like any other message, sent to a released object, triggers a memory access exception. You therefore ensure that observers remove themselves before disappearing from memory.</li>
<li>The protocol offers no way to ask an object if it is an observer or being observed. Construct your code to avoid release related errors. A typical pattern is to register as an observer during the observer’s initialization (for example in <code>init</code> or <code>viewDidLoad</code>) and unregister during deallocation (usually in <code>dealloc</code>), ensuring properly paired and ordered add and remove messages, and that the observer is unregistered before it is freed from memory.</li>
</ul>
</blockquote>
<p>翻译过来就是，移除观察者时，注意以下几点：</p>
<ul>
<li>如果未注册为观察者，在移除观察者的时候会导致<code>NSRangeException</code>异常。<code>removeObserver</code>必须和<code>addObserver</code>对应，且只能调用一次。如果项目中不能保证，就需要在使用的时候使用<code>try/catch</code>来处理异常。</li>
<li>观察者在对象销毁的时候不会自动移除观察者。被观察者会继续发送通知，对观察者来说这个状态是感知不到的。但是，向一个已经释放的对象发送通知会引起内存访问异常。所以，我们要保证观察者在内存释放之前移除观察。</li>
<li>这个协议没有方法可以判断他是一个观察者还是被观察者，写代码是要避免释放内存相关的错误。一个典型的规范就是在观察者初始画的时候注册观察，在<code>dealloc</code>的时候移除观察，以确保成对和有序地添加和删除消息，并确保观察者在注册之前被取消注册，从内存中释放出来。</li>
</ul>
<p>所以，总的来说，<code>KVO注册观察者 和移除观察者是需要成对出现的</code>，如果只注册，不移除，会出现<code>野指针的崩溃</code>。</p>
<h4 id="自动触发与手动触发"><a href="#自动触发与手动触发" class="headerlink" title="自动触发与手动触发"></a>自动触发与手动触发</h4><p>KVO观察的自动和手动两种方式</p>
<ul>
<li><p>自动开关，<code>automaticallyNotifiesObserversForKey</code>返回<code>YES</code>的时候标示自动监听，如果是<code>NO</code>表示我们需要手动监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 自动开关</span><br><span class="line">+ (BOOL) automaticallyNotifiesObserversForKey:(NSString *)key&#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果是手动，我们需要通过<code>手动开关</code>监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)setNickName:(NSString *)nickName&#123;</span><br><span class="line">    &#x2F;&#x2F;手动开关</span><br><span class="line">    [self willChangeValueForKey:@&quot;nickName&quot;];</span><br><span class="line">    _nickName &#x3D; namenickName</span><br><span class="line">    [self didChangeValueForKey:@&quot;nickName&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="观察多个属性变化"><a href="#观察多个属性变化" class="headerlink" title="观察多个属性变化"></a>观察多个属性变化</h4><p>我们以观察两个属性为例，例如我们需要根据速度<code>speed</code>和时间<code>time</code>，取得当前的路程<code>distance</code>。我们用两种方式。</p>
<ul>
<li><p>第一种就是分别观察速度<code>speed</code>和时间<code>time</code>两个属性，当其中一个发生变化计算 当前路程<code>distance</code>。</p>
</li>
<li><p>第二种方式就是，通过<code>keyPathsForValuesAffectingValueForKey</code>方法，将两个观察合为一个观察，即观察当前路程<code>distance</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1、合二为一的观察方法</span><br><span class="line">+ (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key&#123;</span><br><span class="line">    NSSet *keyPaths &#x3D; [super keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line">    if ([key isEqualToString:@&quot;distance&quot;]) &#123;</span><br><span class="line">        NSArray *affectingKeys &#x3D; @[@&quot;speed&quot;, @&quot;time&quot;];</span><br><span class="line">        keyPaths &#x3D; [keyPaths setByAddingObjectsFromArray:affectingKeys];</span><br><span class="line">    &#125;</span><br><span class="line">    return keyPaths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2、注册KVO观察</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;distance&quot; options:(NSKeyValueObservingOptionNew) context:NULL];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3、触发属性值变化</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    self.person.speed +&#x3D; 10;</span><br><span class="line">    self.person.time  +&#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;4、移除观察者</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">    [self.person removeObserver:self forKeyPath:@&quot;distance&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="可变数组的观察"><a href="#可变数组的观察" class="headerlink" title="可变数组的观察"></a>可变数组的观察</h4><p>KVO是基于KVC基础之上的，所以可变数组如果直接添加数据，是不会调用setter方法的，所有对<code>可变数组</code>的KVO观察下面这种方式<code>不生效</code>的,即直接通过<code>[self.person.dateArray addObject:@&quot;1&quot;];</code>向数组添加元素，是不会触发kvo通知回调的，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1、注册可变数组KVO观察者</span><br><span class="line">self.person.dateArray &#x3D; [NSMutableArray arrayWithCapacity:1];</span><br><span class="line">    [self.person addObserver:self forKeyPath:@&quot;dateArray&quot; options:(NSKeyValueObservingOptionNew) context:NULL];</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;2、KVO回调</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,change);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3、移除观察者</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line"> [self.person removeObserver:self forKeyPath:@&quot;dateArray&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;4、触发数组添加数据</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    [self.person.dateArray addObject:@&quot;1&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在KVC官方文档中，针对<code>可变数组的集合</code>类型，有如下说明，即访问集合对象需要需要通过<code>mutableArrayValueForKey</code>方法，这样才能<code>将元素添加到可变数组</code>中</p>
<blockquote>
<p>The protocol defines three different proxy methods for collection object access, each with a key and a key path variant:</p>
<ul>
<li><p><code>mutableArrayValueForKey:</code> and <code>mutableArrayValueForKeyPath:</code></p>
<p>These return a proxy object that behaves like an <code>NSMutableArray</code> object.</p>
</li>
<li><p><code>mutableSetValueForKey:</code> and <code>mutableSetValueForKeyPath:</code></p>
<p>These return a proxy object that behaves like an <code>NSMutableSet</code> object.</p>
</li>
<li><p><code>mutableOrderedSetValueForKey:</code> and <code>mutableOrderedSetValueForKeyPath:</code></p>
<p>These return a proxy object that behaves like an <code>NSMutableOrderedSet</code> object.</p>
</li>
</ul>
</blockquote>
<p>我们代码这样修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    &#x2F;&#x2F; KVC 集合 array</span><br><span class="line">    [[self.person mutableArrayValueForKey:@&quot;dateArray&quot;] addObject:@&quot;1&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在可变数组就可以监听到了。</p>
<h3 id="KVO底层探索"><a href="#KVO底层探索" class="headerlink" title="KVO底层探索"></a>KVO底层探索</h3><p>苹果官方文档在<code>Key-Value Observing Implementation Details</code>里有提到<code>KVO</code>的实现：</p>
<blockquote>
<p>Automatic key-value observing is implemented using a technique called <em>isa-swizzling</em>.</p>
<p>The <code>isa</code> pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.</p>
<p>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</p>
<p>You should never rely on the <code>isa</code> pointer to determine class membership. Instead, you should use the <code>class</code> method to determine the class of an object instance.</p>
</blockquote>
<p>大概意思就是<code>KVO</code>的实现使用了<code>isa</code>的交换。当我们添加一个<code>observer</code>的时候<code>isa</code>的指向会发生改变，是一个<code>中间类</code>而不是<code>真正的类</code>。我们不能根据<code>isa</code>指针确定类的成员身份，而是用哪个<code>class</code>方法确定。</p>
<h4 id="中间类是什么"><a href="#中间类是什么" class="headerlink" title="中间类是什么"></a><code>中间类</code>是什么</h4><p>看苹果官网文档我们了解了，<code>KVO</code>的实现时通过修改<code>isa</code>指针指向了一个<code>中间类</code>实现的，我们使用<code>lldb</code>探究一下<code>中间类</code>是什么。</p>
<ul>
<li><p>添加观察者之前，我们打印实例对象<code>person</code>的方法是<code>JSPerson</code>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) <span class="function">po <span class="title">object_getClassName</span><span class="params">(self.person)</span></span></span><br><span class="line">"JSPerson"</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加观察者之后，我们打印实例对象<code>person</code>的方法是<code>NSKVONotifying_JSPerson</code>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) <span class="function">po <span class="title">object_getClassName</span><span class="params">(self.person)</span></span></span><br><span class="line">"NSKVONotifying_JSPerson"</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>通过上面的调试，我们看到添加观察者值<code>isa</code>指向了一个名为<code>&quot;NSKVONotifying_JSPerson</code>的中间类。关于这个<code>中间类</code>我们有几个点需要研究一下。</p>
<ol>
<li><p><code>中间类</code>和之前的类是父子类关系吗</p>
<p>我们通过一个方法来判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 遍历类以及子类</span><br><span class="line">- (void)printClasses:(Class)cls&#123;</span><br><span class="line">    &#x2F;&#x2F; 注册类的总数</span><br><span class="line">    int count &#x3D; objc_getClassList(NULL, 0);</span><br><span class="line">    &#x2F;&#x2F; 创建一个数组， 其中包含给定对象</span><br><span class="line">    NSMutableArray *mArray &#x3D; [NSMutableArray arrayWithObject:cls];</span><br><span class="line">    &#x2F;&#x2F; 获取所有已注册的类</span><br><span class="line">    Class* classes &#x3D; (Class*)malloc(sizeof(Class)*count);</span><br><span class="line">    objc_getClassList(classes, count);</span><br><span class="line">    for (int i &#x3D; 0; i&lt;count; i++) &#123;</span><br><span class="line">        if (cls &#x3D;&#x3D; class_getSuperclass(classes[i])) &#123;</span><br><span class="line">            [mArray addObject:classes[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(classes);</span><br><span class="line">    NSLog(@&quot;classes &#x3D; %@&quot;, mArray);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;********以下为调用********</span><br><span class="line">[self printClasses:[JSPerson class]];</span><br></pre></td></tr></table></figure>

<p>打印结果为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">classes = (</span><br><span class="line">    JSPerson,</span><br><span class="line">    <span class="string">"NSKVONotifying_JSPerson"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>通过打印结果我们可以判断中间类<code>NSKVONotifying_JSPerson</code>是<code>JSPerson</code>的子类。</p>
</li>
<li><p>中间类里有什么方法。</p>
<p>同样，我们定义一个方法获取<code>NSKVONotifying_JSPerson</code>的所有方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 遍历方法-ivar-property</span><br><span class="line">- (void)printClassAllMethod:(Class)cls&#123;</span><br><span class="line">    unsigned int count &#x3D; 0;</span><br><span class="line">    Method *methodList &#x3D; class_copyMethodList(cls, &amp;count);</span><br><span class="line">    for (int i &#x3D; 0; i&lt;count; i++) &#123;</span><br><span class="line">        Method method &#x3D; methodList[i];</span><br><span class="line">        SEL sel &#x3D; method_getName(method);</span><br><span class="line">        IMP imp &#x3D; class_getMethodImplementation(cls, sel);</span><br><span class="line">        NSLog(@&quot;%@-%p&quot;,NSStringFromSelector(sel),imp);</span><br><span class="line">    &#125;</span><br><span class="line">    free(methodList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;********以下为调用********</span><br><span class="line">[self printClassAllMethod:objc_getClass(&quot;NSKVONotifying_JSPerson&quot;)];</span><br></pre></td></tr></table></figure>

<p>打印结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setNickName:<span class="number">-0x7fff207bbb57</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>-0<span class="title">x7fff207ba662</span></span></span><br><span class="line"><span class="class"><span class="title">dealloc</span>-0<span class="title">x7fff207ba40b</span></span></span><br><span class="line"><span class="class">_<span class="title">isKVOA</span>-0<span class="title">x7fff207ba403</span></span></span><br></pre></td></tr></table></figure>

<p>我们看到一共有四个方法</p>
<ul>
<li>重写了父类的<code>setNickName</code>方法</li>
<li>重写了根类的<code>class</code>、<code>dealloc</code>方法</li>
<li><code>_isKVO</code>方法，用来判断是否是<code>kvo</code>类</li>
</ul>
</li>
<li><p>dealloc中移除观察者后，isa会指回来吗</p>
<ul>
<li><p>移除观察者之前，我们用<code>lldb</code>打印</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) <span class="function">po <span class="title">object_getClassName</span><span class="params">(self.person)</span></span></span><br><span class="line">"NSKVONotifying_JSPerson"</span><br></pre></td></tr></table></figure>
</li>
<li><p>移除观察者之后，我们重新打印</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) <span class="function">po <span class="title">object_getClassName</span><span class="params">(self.person)</span></span></span><br><span class="line">"JSPerson"</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>说明的确是在移除观察的时候将<code>isa</code>指回来的。</p>
</li>
<li><p>移除观察后中间类会销毁吗</p>
<p>我们返回前一个页面，此时添加观察者的VC已经销毁，我们打印<code>JSPerson</code>的子类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self printClasses:[JSPerson class]];</span><br></pre></td></tr></table></figure>

<p>打印结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">classes = (</span><br><span class="line">    JSPerson,</span><br><span class="line">    <span class="string">"NSKVONotifying_JSPerson"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>发现子类并不会被销毁。</p>
</li>
</ol>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>实例对象<code>isa</code>的指向<code>在添加KVO观察者之后</code>，由<code>原有类</code>更改为<code>指向中间类</code></li>
<li><code>中间类</code>重写了观察<code>属性的setter方法</code>、<code>class</code>、<code>dealloc</code>、<code>_isKVOA</code>方法</li>
<li><code>dealloc</code>方法中，移除KVO观察者之后，实例对象<code>isa</code>指向由<code>中间类</code>更改为<code>原有类</code></li>
<li><code>中间类</code>从创建后，就一直<code>存在内存中，不会被销毁</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yujiusheng.com/2021/07/26/Flutter-IneritedWidget/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="个人技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/26/Flutter-IneritedWidget/" class="post-title-link" itemprop="url">Flutter-InheritedWidget</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-26 10:41:49" itemprop="dateCreated datePublished" datetime="2021-07-26T10:41:49+08:00">2021-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-30 15:06:34" itemprop="dateModified" datetime="2021-07-30T15:06:34+08:00">2021-07-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jason</p>
  <div class="site-description" itemprop="description">个人技术博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
